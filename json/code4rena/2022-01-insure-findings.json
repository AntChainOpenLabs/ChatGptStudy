[
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "CDSTemplate.sol",
            "PoolTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "setKeeper()",
                    "keeper",
                    "address(",
                    "utilize()",
                    "controller",
                    "safeTransfer()"
                ],
                "Type": " Tokens can be burned with no access control",
                "Description": "\n\nThe Vault.sol contract has two address state variables, the keeper variable and the controller variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance totalDebt) by sending these tokens to the zero address with the unprotected utilitize() function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.\n\n\nThe problematic utilize() function is found here(https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur:\n\n1.  The keeper state variable is only changed by the setKeeper() function found here(https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses the only access control for the utilize function(https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344).\n2.  There is a comment here on line 69(https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.\n\nIf both address variables are left at their defaults of address(0), then the safeTransfer() call on line 348(https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).\n\n",
                "Repair": "\nAdd the following line to the very beginning of the utilize() function:\nrequire(address(controller) != address(0))\n\nThis check is already found in many other functions in Vault.sol, including the _unutilize() function.\n\noishun1112 (Insure) confirmed and resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/158):\n  https://github.com/InsureDAO/pool-contracts/blob/audit/code4rena/contracts/Vault.sol#L382\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @title Parameters\n * @author @InsureDAO\n * @notice This contract manages parameters of markets.\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPremiumModel.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Parameters is IParameters {\n    event VaultSet(address indexed token, address vault);\n    event FeeRateSet(address indexed target, uint256 rate);\n    event PremiumSet(address indexed target, address model);\n    event UpperSlack(address indexed target, uint256 rate);\n    event LowerSlack(address indexed target, uint256 rate);\n    event LockupSet(address indexed target, uint256 span);\n    event GraceSet(address indexed target, uint256 span);\n    event MinDateSet(address indexed target, uint256 span);\n    event WithdrawableSet(address indexed target, uint256 span);\n    event ConditionSet(bytes32 indexed ref, bytes32 condition);\n    event MaxListSet(address target, uint256 max);\n\n    address public ownership;\n\n    mapping(address => address) private _vaults; //address of the vault contract for each token\n    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6)\n    mapping(address => address) private _premium; //address for each premium model contract\n    mapping(address => uint256) private _lowerSlack; //lower slack range before adjustAlloc for index\n    mapping(address => uint256) private _upperSlack; //upper slack range before adjustAlloc for index\n    mapping(address => uint256) private _grace; //grace before an insurance policy expires\n    mapping(address => uint256) private _lockup; //funds lock up period after user requested to withdraw liquidity\n    mapping(address => uint256) private _min; //minimum period to purchase an insurance policy\n    mapping(address => uint256) private _maxList; //maximum number of pools one index can allocate\n    mapping(address => uint256) private _withdawable; //a certain period a user can withdraw after lock up ends\n    mapping(bytes32 => bytes32) private _conditions; //condition mapping for future use cases\n\n    constructor(address _ownership) {\n        ownership = _ownership;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            IOwnership(ownership).owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    /**\n     * @notice set the vault address corresponding to the token address\n     * @param _token address of token\n     * @param _vault vault for token\n     */\n    function setVault(address _token, address _vault)\n        external\n        override\n        onlyOwner\n    {\n        require(_vaults[_token] == address(0), \"dev: already initialized\");\n        require(_vault != address(0), \"dev: zero address\");\n        _vaults[_token] = _vault;\n        emit VaultSet(_token, _vault);\n    }\n\n    /**\n     * @notice set lock up periods in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setLockup(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _lockup[_address] = _target;\n        emit LockupSet(_address, _target);\n    }\n\n    /**\n     * @notice set grace period length in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setGrace(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _grace[_address] = _target;\n        emit GraceSet(_address, _target);\n    }\n\n    /**\n     * @notice set min length in unix timestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setMinDate(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _min[_address] = _target;\n        emit MinDateSet(_address, _target);\n    }\n\n    /**\n     * @notice set slack rate of leverage before adjustAlloc\n     * @param _address address to set the parameter\n     * @param _target parameter (slack rate 100% = 1000\n     */\n    function setUpperSlack(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _upperSlack[_address] = _target;\n        emit UpperSlack(_address, _target);\n    }\n\n    /**\n     * @notice set slack rate of leverage before adjustAlloc\n     * @param _address address to set the parameter\n     * @param _target parameter (slack rate 100% = 1000\n     */\n    function setLowerSlack(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _lowerSlack[_address] = _target;\n        emit LowerSlack(_address, _target);\n    }\n\n    /**\n     * @notice set withdrawable period in unixtimestamp length (1 day = 86400)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setWithdrawable(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _withdawable[_address] = _target;\n        emit WithdrawableSet(_address, _target);\n    }\n\n    /**\n     * @notice set the contract address of premium model\n     * @param _address address to set the premium model\n     * @param _target premium model contract address\n     */\n    function setPremiumModel(address _address, address _target)\n        external\n        override\n        onlyOwner\n    {\n        require(_target != address(0), \"dev: zero address\");\n        _premium[_address] = _target;\n        emit PremiumSet(_address, _target);\n    }\n\n    /**\n     * @notice set the contract address of fee model\n     * @param _address address to set the fee model\n     * @param _target fee rate\n     */\n    function setFeeRate(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _fee[_address] = _target;\n        emit FeeRateSet(_address, _target);\n    }\n\n    /**\n     * @notice set the max list number (e.g. 10)\n     * @param _address address to set the parameter\n     * @param _target parameter\n     */\n    function setMaxList(address _address, uint256 _target)\n        external\n        override\n        onlyOwner\n    {\n        _maxList[_address] = _target;\n        emit MaxListSet(_address, _target);\n    }\n\n    /**\n     * @notice set the condition in bytes32 corresponding to bytes32\n     * @param _reference bytes32 value to refer the parameter\n     * @param _target parameter\n     */\n    function setCondition(bytes32 _reference, bytes32 _target)\n        external\n        override\n        onlyOwner\n    {\n        _conditions[_reference] = _target;\n        emit ConditionSet(_reference, _target);\n    }\n\n    /**\n     * @notice Get the address of the owner\n     * @return owner's address\n     */\n    function getOwner() public view override returns (address) {\n        return IOwnership(ownership).owner();\n    }\n\n    /**\n     * @notice get the address of the vault contract\n     * @param _token token address\n     * @return vault address\n     */\n    function getVault(address _token) external view override returns (address) {\n        return _vaults[_token];\n    }\n\n    /**\n     * @notice get premium amount for the specified conditions\n     * @param _amount amount to get insured\n     * @param _term term length\n     * @param _totalLiquidity liquidity of the target contract's pool\n     * @param _lockedAmount locked amount of the total liquidity\n     * @param _target address of insurance market\n     * @return premium amount\n     */\n    function getPremium(\n        uint256 _amount,\n        uint256 _term,\n        uint256 _totalLiquidity,\n        uint256 _lockedAmount,\n        address _target\n    ) external view override returns (uint256) {\n        if (_premium[_target] == address(0)) {\n            return\n                IPremiumModel(_premium[address(0)]).getPremium(\n                    _amount,\n                    _term,\n                    _totalLiquidity,\n                    _lockedAmount\n                );\n        } else {\n            return\n                IPremiumModel(_premium[_target]).getPremium(\n                    _amount,\n                    _term,\n                    _totalLiquidity,\n                    _lockedAmount\n                );\n        }\n    }\n\n    /**\n     * @notice get fee rate for the specified conditions\n     * @param _target address of insurance market\n     * @return fee rate\n     */\n    function getFeeRate(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_fee[_target] == 0) {\n            return _fee[address(0)];\n        } else {\n            return _fee[_target];\n        }\n    }\n\n    /**\n     * @notice get slack rate of leverage before adjustAlloc\n     * @param _target target contract's address\n     * @return upper slack(slack above target)\n     */\n    function getUpperSlack(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_upperSlack[_target] == 0) {\n            return _upperSlack[address(0)];\n        } else {\n            return _upperSlack[_target];\n        }\n    }\n\n    /**\n     * @notice get slack rate of leverage before adjustAlloc\n     * @param _target target contract's address\n     * @return lower slack(slack below target)\n     */\n    function getLowerSlack(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_lowerSlack[_target] == 0) {\n            return _lowerSlack[address(0)];\n        } else {\n            return _lowerSlack[_target];\n        }\n    }\n\n    /**\n     * @notice get lock up period length\n     * @param _target target contract's address\n     * @return lock up period\n     */\n    function getLockup(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_lockup[_target] == 0) {\n            return _lockup[address(0)];\n        } else {\n            return _lockup[_target];\n        }\n    }\n\n    /**\n     * @notice get withdrawable period length\n     * @param _target target contract's address\n     * @return withdrawable period\n     */\n    function getWithdrawable(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_withdawable[_target] == 0) {\n            return _withdawable[address(0)];\n        } else {\n            return _withdawable[_target];\n        }\n    }\n\n    /**\n     * @notice get grace period length\n     * @param _target target contract's address\n     * @return grace period\n     */\n    function getGrace(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_grace[_target] == 0) {\n            return _grace[address(0)];\n        } else {\n            return _grace[_target];\n        }\n    }\n\n    /**\n     * @notice get minimum period length for an insurance policy\n     * @param _target target contract's address\n     * @return minimum lenght of policy\n     */\n    function getMinDate(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_min[_target] == 0) {\n            return _min[address(0)];\n        } else {\n            return _min[_target];\n        }\n    }\n\n    /**\n     * @notice get max number of pools for an index\n     * @param _target target contract's address\n     * @return maximum number of pools\n     */\n    function getMaxList(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_maxList[_target] == 0) {\n            return _maxList[address(0)];\n        } else {\n            return _maxList[_target];\n        }\n    }\n\n    /**\n     * @notice get conditions for the corresponding reference parameter in bytes32\n     * @param _reference reference address\n     * @return condition parameter\n     */\n    function getCondition(bytes32 _reference)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return _conditions[_reference];\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol",
            "Parameters.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "unlock()",
                    "false",
                    "lockedAmount"
                ],
                "Type": " Typo in PoolTemplate unlock function results in user being able to unlock multiple times",
                "Description": "\nThe function unlock() in PoolTemplate has a typo where it compares insurances[_id].status to false rather than setting it to false. If the conditions are met to unlock the funds for an id, the user should be able to call the unlock() function once for that id as insurances[_id].amount is subtracted from lockedAmount. However, since insurances[_id].status does not get set to false, a user can call unlock() multiple times for the same id, resulting in lockedAmount being way smaller than it should be since insurances[_id].amount is subtracted multiple times.\n\n\nlockedAmount is used to calculate the amount of underlying tokens available for withdrawals. If lockedAmount is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.\n\n\nTypo in unlock():\n\n*   <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362\n\nCalculation of underlying tokens available for withdrawal:\n\n*   <https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836\n\n",
                "Repair": "\nChange insurances[_id].status == false; to insurances[_id].status = false;\n\noishun1112 (Insure) confirmed and resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/192):\n  https://github.com/InsureDAO/pool-contracts/blob/audit/code4rena/contracts/PoolTemplate.sol#L375\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/192#issuecomment-1023658102):\n  upgrading to sev-3 based on assets being compromised. \n\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nrequire(\n    MerkleProof.verify(\n        _merkleProof,\n        _targets,\n        keccak256(\n            abi.encodePacked(_insurance.target, _insurance.insured)\n        )\n    ) ||\n        MerkleProof.verify(\n            _merkleProof,\n            _targets,\n            keccak256(abi.encodePacked(_insurance.target, address(0)))\n        ),\n    \"ERROR: INSURANCE_EXEMPTED\"\n);\n"
                ],
                "Type": " Signature replay",
                "Description": "\nSignature replay in PoolTemplate.\n\n\nThe redeem method of PoolTemplate verifies the data stored in incident, and the verification logic of this process is performed as following:\nsolidity\nrequire(\n    MerkleProof.verify(\n        _merkleProof,\n        _targets,\n        keccak256(\n            abi.encodePacked(_insurance.target, _insurance.insured)\n        )\n    ) ||\n        MerkleProof.verify(\n            _merkleProof,\n            _targets,\n            keccak256(abi.encodePacked(_insurance.target, address(0)))\n        ),\n    \"ERROR: INSURANCE_EXEMPTED\"\n);\n\n\nAs can be seen, the only data related to the _insurance are  target  and insured, so as the incident has no relation with the  Insurance , apparently nothing prevents a user to call insure with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an _incidentTimestamp from the past.\n\nSo if an owner create a incident from the future it's possible to create a new insure that could be reused by the same affected address.\n\nAnother lack of input verification that could facilitate this attack is the _span=0 in the insure method.\n\n\n",
                "Repair": "\nIt is mandatory to add a check in applyCover that  _incidentTimestamp  is less than the current date and the span argument is greater than 0 in the  insure  method.\n\noishun1112 (Insure) confirmed and resolved, but disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/184):\n  agree on the _incidentTimestamp check.\n disagree on span check since there already is\n \n require(\n             parameters.getMinDate(msg.sender) <= _span,\n             \"ERROR: INSURE_SPAN_BELOW_MIN\"\n         );\n \n we are going to set default value of 1week for everyone\n\noishun1112 (Insure) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1015081369):\n  we assume ownership control works fine.\n this can lose money in-proper way, but not at risk since onlyOwner modifier applied.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1023674000):\n  going to leave this as 2 \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n The external requirement here would be an incorrect timestamp from the owner which would cause assets to be at risk from the replay. \n\noishun1112 (Insure) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/184#issuecomment-1027599600):\n  there is\n \n _span = getMinDate() \n \n so we don't implement _span  0\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n/**\n * @title Factory\n * @author @InsureDAO\n * @notice This contract is the functory contract that manages functions related to market creation activities.\n * SPDX-License-Identifier: GPL-3.0\n */\n\npragma solidity 0.8.7;\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen; //true if the market allows anyone to create a market\n        bool approval; //true if the template exists\n        bool allowDuplicate; //true if the market with same ID is allowed\n    }\n    mapping(address => Template) public templates;\n    //mapping of authorized market template address\n\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    //Authorized reference(address) list for market market template\n    //Each template has different set of references\n    //true if that address is authorized within the template\n    // Example reference list for pool template v1\n    // references[0] = target governance token address\n    // references[1] = underlying token address\n    // references[2] = registry\n    // references[3] = parameter\n\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    //Authorized condition(uint256) list for market temaplate\n    //Each template has different set of conditions\n    //true if that address is authorized within the template\n    // Example condition list for pool template v1\n    // conditions[0] = minimim deposit amount\n\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice A function to approve or disapprove templates.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _approval true if a market is allowed to create based on the template\n     * @param _isOpen true if anyone can create a market based on the template\n     * @param _duplicate true if a market with duplicate target id is allowed\n     */\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within reference array\n     * @param _target the reference  address\n     * @param _approval true if the reference is approved\n     */\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within condition array\n     * @param _target the condition uint\n     */\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n\n    /**\n     * @notice A function to create markets.\n     * This function is market model agnostic.\n     * @param _template template address, which must be registered\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     * @return created market address\n     */\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    /**\n     * @notice Template Code for the create clone method:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n     */\n    function _createClone(address target) internal returns (address result) {\n        // convert address to bytes20 for assembly use\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            // allocate clone memory\n            let clone := mload(0x40)\n            // store initial portion of the delegation contract code in bytes form\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            // store the provided address\n            mstore(add(clone, 0x14), targetBytes)\n            // store the remaining delegation contract code\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            // create the actual delegate contract reference and return its address\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol",
            "Factory.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction createMarket(\n    IUniversalMarket _template,\n    string memory _metaData,\n    uint256[] memory _conditions,\n    address[] memory _references\n) public override returns (address) {\n    //check eligibility\n    require(\n        templates[address(_template)].approval == true,\n        \"ERROR: UNAUTHORIZED_TEMPLATE\"\n    );\n    if (templates[address(_template)].isOpen == false) {\n        require(\n            ownership.owner() == msg.sender,\n            \"ERROR: UNAUTHORIZED_SENDER\"\n        );\n    }\n    if (_references.length  0) {\n        for (uint256 i = 0; i < _references.length; i++) {\n            require(\n                reflist[address(_template)][i][_references[i]] == true ||\n                    reflist[address(_template)][i][address(0)] == true,\n                \"ERROR: UNAUTHORIZED_REFERENCE\"\n            );\n        }\n    }\n\n    if (_conditions.length  0) {\n        for (uint256 i = 0; i < _conditions.length; i++) {\n            if (conditionlist[address(_template)][i]  0) {\n                _conditions[i] = conditionlist[address(_template)][i];\n            }\n        }\n    }\n\n    if (\n        IRegistry(registry).confirmExistence(\n            address(_template),\n            _references[0]\n        ) == false\n    ) {\n        IRegistry(registry).setExistence(\n            address(_template),\n            _references[0]\n        );\n    } else {\n        if (templates[address(_template)].allowDuplicate == false) {\n            revert(\"ERROR: DUPLICATE_MARKET\");\n        }\n    }\n\n    //create market\n    IUniversalMarket market = IUniversalMarket(\n        _createClone(address(_template))\n    );\n\n    IRegistry(registry).supportMarket(address(market));\n    \n    markets.push(address(market));\n\n\n    //initialize\n    market.initialize(_metaData, _conditions, _references);\n\n    emit MarketCreated(\n        address(market),\n        address(_template),\n        _metaData,\n        _conditions,\n        _references\n    );\n\n    return address(market);\n}\n",
                    "//solidity\nfunction initialize(\n    string calldata _metaData,\n    uint256[] calldata _conditions,\n    address[] calldata _references\n) external override {\n    require(\n        initialized == false &&\n            bytes(_metaData).length  0 &&\n            _references[0] != address(0) &&\n            _references[1] != address(0) &&\n            _references[2] != address(0) &&\n            _references[3] != address(0) &&\n            _references[4] != address(0) &&\n            _conditions[0] <= _conditions[1],\n        \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n    );\n    initialized = true;\n\n    string memory _name = string(\n        abi.encodePacked(\n            \"InsureDAO-\",\n            IERC20Metadata(_references[1]).name(),\n            \"-PoolInsurance\"\n        )\n    );\n    string memory _symbol = string(\n        abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n    );\n    uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n    initializeToken(_name, _symbol, _decimals);\n\n    registry = IRegistry(_references[2]);\n    parameters = IParameters(_references[3]);\n    vault = IVault(parameters.getVault(_references[1]));\n\n    metadata = _metaData;\n\n    marketStatus = MarketStatus.Trading;\n\n    if (_conditions[1]  0) {\n        _depositFrom(_conditions[1], _references[4]);\n    }\n}\n"
                ],
                "Type": " Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts",
                "Description": "\nThe current method of market creation involves calling Factory.createMarket() with a list of approved _conditions and _references accounts. If a registered template address has templates[address(_template)].isOpen == true, then any user is able to call createMarket() using this template. If the template points to PoolTemplate.sol, then a malicious market creator can abuse PoolTemplate.initialize() as it makes a vault deposit from an account that they control. The vulnerable internal function, _depositFrom(), makes a vault deposit from the _references[4] address (arbitrarily set to an approved reference address upon market creation).\n\nHence, if approved _references accounts have set an unlimited approval amount for Vault.sol before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.\n\nThis issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to Vault.sol was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow.\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231\nsolidity\nfunction createMarket(\n    IUniversalMarket _template,\n    string memory _metaData,\n    uint256[] memory _conditions,\n    address[] memory _references\n) public override returns (address) {\n    //check eligibility\n    require(\n        templates[address(_template)].approval == true,\n        \"ERROR: UNAUTHORIZED_TEMPLATE\"\n    );\n    if (templates[address(_template)].isOpen == false) {\n        require(\n            ownership.owner() == msg.sender,\n            \"ERROR: UNAUTHORIZED_SENDER\"\n        );\n    }\n    if (_references.length  0) {\n        for (uint256 i = 0; i < _references.length; i++) {\n            require(\n                reflist[address(_template)][i][_references[i]] == true ||\n                    reflist[address(_template)][i][address(0)] == true,\n                \"ERROR: UNAUTHORIZED_REFERENCE\"\n            );\n        }\n    }\n\n    if (_conditions.length  0) {\n        for (uint256 i = 0; i < _conditions.length; i++) {\n            if (conditionlist[address(_template)][i]  0) {\n                _conditions[i] = conditionlist[address(_template)][i];\n            }\n        }\n    }\n\n    if (\n        IRegistry(registry).confirmExistence(\n            address(_template),\n            _references[0]\n        ) == false\n    ) {\n        IRegistry(registry).setExistence(\n            address(_template),\n            _references[0]\n        );\n    } else {\n        if (templates[address(_template)].allowDuplicate == false) {\n            revert(\"ERROR: DUPLICATE_MARKET\");\n        }\n    }\n\n    //create market\n    IUniversalMarket market = IUniversalMarket(\n        _createClone(address(_template))\n    );\n\n    IRegistry(registry).supportMarket(address(market));\n    \n    markets.push(address(market));\n\n\n    //initialize\n    market.initialize(_metaData, _conditions, _references);\n\n    emit MarketCreated(\n        address(market),\n        address(_template),\n        _metaData,\n        _conditions,\n        _references\n    );\n\n    return address(market);\n}\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221\nsolidity\nfunction initialize(\n    string calldata _metaData,\n    uint256[] calldata _conditions,\n    address[] calldata _references\n) external override {\n    require(\n        initialized == false &&\n            bytes(_metaData).length  0 &&\n            _references[0] != address(0) &&\n            _references[1] != address(0) &&\n            _references[2] != address(0) &&\n            _references[3] != address(0) &&\n            _references[4] != address(0) &&\n            _conditions[0] <= _conditions[1],\n        \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n    );\n    initialized = true;\n\n    string memory _name = string(\n        abi.encodePacked(\n            \"InsureDAO-\",\n            IERC20Metadata(_references[1]).name(),\n            \"-PoolInsurance\"\n        )\n    );\n    string memory _symbol = string(\n        abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n    );\n    uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n    initializeToken(_name, _symbol, _decimals);\n\n    registry = IRegistry(_references[2]);\n    parameters = IParameters(_references[3]);\n    vault = IVault(parameters.getVault(_references[1]));\n\n    metadata = _metaData;\n\n    marketStatus = MarketStatus.Trading;\n\n    if (_conditions[1]  0) {\n        _depositFrom(_conditions[1], _references[4]);\n    }\n}\n\n\n\nManual code review.\nDiscussions with kohshiba.\n\n",
                "Repair": "\nAfter discussions with the sponsor, they have opted to parse a _creator address to PoolTemplate.sol which will act as the depositor and be set to msg.sender in Factory.createMarket(). This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in Factory.sol and have also approved Vault.sol to make transfers on their behalf.\n\n\noishun1112 (Insure) confirmed(https://github.com/code-423n4/2022-01-insure-findings/issues/224):\n  https://github.com/code-423n4/2022-01-insure-findings/issues/250\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract InsureDAOERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    bool tokenInitialized;\n    string private _name = \"InsureDAO LP Token\";\n    string private _symbol = \"iLP\";\n    uint8 private _decimals = 18;\n\n    constructor() {}\n\n    function initializeToken(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        /***\n         *@notice initialize token. Only called internally.\n         *\n         */\n        assert(!tokenInitialized);\n        tokenInitialized = true;\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        _balances[sender] = senderBalance - amount;\n\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n/**\n * @title Factory\n * @author @InsureDAO\n * @notice This contract is the functory contract that manages functions related to market creation activities.\n * SPDX-License-Identifier: GPL-3.0\n */\n\npragma solidity 0.8.7;\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen; //true if the market allows anyone to create a market\n        bool approval; //true if the template exists\n        bool allowDuplicate; //true if the market with same ID is allowed\n    }\n    mapping(address => Template) public templates;\n    //mapping of authorized market template address\n\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    //Authorized reference(address) list for market market template\n    //Each template has different set of references\n    //true if that address is authorized within the template\n    // Example reference list for pool template v1\n    // references[0] = target governance token address\n    // references[1] = underlying token address\n    // references[2] = registry\n    // references[3] = parameter\n\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    //Authorized condition(uint256) list for market temaplate\n    //Each template has different set of conditions\n    //true if that address is authorized within the template\n    // Example condition list for pool template v1\n    // conditions[0] = minimim deposit amount\n\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice A function to approve or disapprove templates.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _approval true if a market is allowed to create based on the template\n     * @param _isOpen true if anyone can create a market based on the template\n     * @param _duplicate true if a market with duplicate target id is allowed\n     */\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within reference array\n     * @param _target the reference  address\n     * @param _approval true if the reference is approved\n     */\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within condition array\n     * @param _target the condition uint\n     */\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n\n    /**\n     * @notice A function to create markets.\n     * This function is market model agnostic.\n     * @param _template template address, which must be registered\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     * @return created market address\n     */\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    /**\n     * @notice Template Code for the create clone method:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n     */\n    function _createClone(address target) internal returns (address result) {\n        // convert address to bytes20 for assembly use\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            // allocate clone memory\n            let clone := mload(0x40)\n            // store initial portion of the delegation contract code in bytes form\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            // store the provided address\n            mstore(add(clone, 0x14), targetBytes)\n            // store the remaining delegation contract code\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            // create the actual delegate contract reference and return its address\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "InsureDAOERC20.sol",
            "PoolTemplate.sol",
            "Factory.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n// PoolTemplate\nfunction initialize(\n     string calldata _metaData,\n     uint256[] calldata _conditions,\n     address[] calldata _references\n) external override {\n     // ...\n\n     if (_conditions[1]  0) {\n          // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])\n          _depositFrom(_conditions[1], _references[4]);\n     }\n}\n\nfunction _depositFrom(uint256 _amount, address _from)\n     internal\n     returns (uint256 _mintAmount)\n{\n     require(\n          marketStatus == MarketStatus.Trading && paused == false,\n          \"ERROR: DEPOSIT_DISABLED\"\n     );\n     require(_amount  0, \"ERROR: DEPOSIT_ZERO\");\n\n     _mintAmount = worth(_amount);\n     // @audit vault calls asset.transferFrom(_from, vault, _amount)\n     vault.addValue(_amount, _from, address(this));\n\n     emit Deposit(_from, _amount, _mintAmount);\n\n     //mint iToken\n     _mint(_from, _mintAmount);\n}\n"
                ],
                "Type": " Initial pool deposit can be stolen",
                "Description": "\nNote that the PoolTemplate.initialize function, called when creating a market with Factory.createMarket, calls a vault function to transfer an initial deposit amount (conditions[1]) *from* the initial depositor (_references[4]):\n\nsolidity\n// PoolTemplate\nfunction initialize(\n     string calldata _metaData,\n     uint256[] calldata _conditions,\n     address[] calldata _references\n) external override {\n     // ...\n\n     if (_conditions[1]  0) {\n          // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])\n          _depositFrom(_conditions[1], _references[4]);\n     }\n}\n\nfunction _depositFrom(uint256 _amount, address _from)\n     internal\n     returns (uint256 _mintAmount)\n{\n     require(\n          marketStatus == MarketStatus.Trading && paused == false,\n          \"ERROR: DEPOSIT_DISABLED\"\n     );\n     require(_amount  0, \"ERROR: DEPOSIT_ZERO\");\n\n     _mintAmount = worth(_amount);\n     // @audit vault calls asset.transferFrom(_from, vault, _amount)\n     vault.addValue(_amount, _from, address(this));\n\n     emit Deposit(_from, _amount, _mintAmount);\n\n     //mint iToken\n     _mint(_from, _mintAmount);\n}\n\n\nThe initial depositor needs to first approve the vault contract for the transferFrom to succeed.\n\nAn attacker can then frontrun the Factory.createMarket transaction with their own market creation (it does not have access restrictions) and create a market *with different parameters* but still passing in _conditions[1]=amount and _references[4]=victim.\n\nA market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.\n\n",
                "Repair": "\nCan the initial depositor be set to Factory.createMarket's msg.sender, instead of being able to pick a whitelisted one as _references[4]?\n\noishun1112 (Insure) confirmed(https://github.com/code-423n4/2022-01-insure-findings/issues/250):\n  https://github.com/code-423n4/2022-01-insure-findings/issues/224\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token) &&\n          balance < IERC20(token).balanceOf(address(this))\n     ) {\n          uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n               balance;\n          IERC20(token).safeTransfer(_to, _redundant);\n     } else if (IERC20(_token).balanceOf(address(this))  0) {\n          // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) = first if false = transfers out everything\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n"
                ],
                "Type": " backdoor in  withdrawRedundant ",
                "Description": "\nThe Vault.withdrawRedundant has wrong logic that allows the admins to steal the underlying vault token.\n\nsolidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token) &&\n          balance < IERC20(token).balanceOf(address(this))\n     ) {\n          uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n               balance;\n          IERC20(token).safeTransfer(_to, _redundant);\n     } else if (IERC20(_token).balanceOf(address(this))  0) {\n          // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) = first if false = transfers out everything\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n\n\n\n*   Vault deposits increase as Vault.addValue is called and the balance increases by _amount as well as the actual IERC20(token).balanceOf(this). Note that balance == IERC20(token).balanceOf(this)\n*   Admins call vault.withdrawRedundant(vault.token(), attacker) which goes into the else if branch due to the balance inequality condition being false. It will transfer out all vault.token() amounts to the attacker.\n\n\nThere's a backdoor in the withdrawRedundant that allows admins to steal all user deposits.\n\n",
                "Repair": "\nI think the devs wanted this logic from the code instead:\n\nsolidity\nfunction withdrawRedundant(address _token, address _to)\n     external\n     override\n     onlyOwner\n{\n     if (\n          _token == address(token)\n     ) {\n          if (balance < IERC20(token).balanceOf(address(this))) {\n               uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                    balance;\n               IERC20(token).safeTransfer(_to, _redundant);\n          }\n     } else if (IERC20(_token).balanceOf(address(this))  0) {\n          IERC20(_token).safeTransfer(\n               _to,\n               IERC20(_token).balanceOf(address(this))\n          );\n     }\n}\n\n\noishun1112 (Insure) confirmed(https://github.com/code-423n4/2022-01-insure-findings/issues/252):\n  similar to PVE03 (Peckshield audit)\n  We will create a PR and merge after we merge both audit/code4rena and audit/peckshield branches in the InsureDAO repository.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "transferAttribution"
                ],
                "Type": " the first depositor to a pool can drain all users",
                "Description": "\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L807\nif there is no liquidity in the pool, the first deposit determines the total liquidity, if the amount is too small the minted liquidity for the next liquidity providers will round down to zero.\n\n\nAn attacker can steal all money from liquidity providers.\n\n\nconsider the following scenario:\na pool is created.\nthe attacker is the first one to deposit, they deposit with _amount == 1, the smallest amount possible. meaning the total liquidity is 1.\nthen they join another pool in order to get attributions in the vault.\nthey transfer the attributions to the pool using transferAttribution.\nfor example, they transferred 1M dollar worth of attributions.\nthe next person deposits in the index, for example, 500,000 dollars.\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L803\nthe amount they will get is:\n\n    _amount = (_value * _supply) / _originalLiquidity;\n\nas we know:\n_amount = 500,000 dollar\n_supply = 1\n_totalLiquidity = 1,000,000 dollar (the attacker transferred directly)\nthe investor will get (500,000 dollar * 1) / (1,000,000 dollar) = 0\nand they will pay 500,000\nthis money will go to the index, and the attacker holds all of the shares, so they can withdraw it and get 1,500,000 stealing 500,000 dollars from the second investor.\n\n\noishun1112 (Insure) acknowledged and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/263):\n  yes. Every address that has attributions can call transferAttribution(), however, the address has to call addValue() to earn attributions. addValue() has onlyMarket modifier.\n To pass onlyMarket modifier, ownership has to be stolen, in short.\n Since we assume ownership control is driven safely, we don't take this as an issue.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/263#issuecomment-1023330012):\n  Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n \n Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-02",
                "Location": [
                    "applyCover",
                    "Trading",
                    "MarketStatusChanged"
                ],
                "Type": " Owner can call  applyCover  multiple times in  PoolTemplate.sol ",
                "Description": "\nThe owner could potentially extend the insurance period indefinitely in the applyCover function without ever allowing the market to resume. This is because there is no check in applyCover to ensure that the market is in a Trading state.\n\nThis can also allow the owner to emit fraudulent MarketStatusChanged events.\n\n",
                "Repair": "\nRequire that the market be in a Trading state to allow another applyCover call.\n\noishun1112 (Insure) confirmed and resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/160):\n  this behaviour is not intended, so confirmed.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/160#issuecomment-1023710961):\n  upgrading to medium severity since it alters the function of the protocol \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\n/**\n * @title Factory\n * @author @InsureDAO\n * @notice This contract is the functory contract that manages functions related to market creation activities.\n * SPDX-License-Identifier: GPL-3.0\n */\n\npragma solidity 0.8.7;\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen; //true if the market allows anyone to create a market\n        bool approval; //true if the template exists\n        bool allowDuplicate; //true if the market with same ID is allowed\n    }\n    mapping(address => Template) public templates;\n    //mapping of authorized market template address\n\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    //Authorized reference(address) list for market market template\n    //Each template has different set of references\n    //true if that address is authorized within the template\n    // Example reference list for pool template v1\n    // references[0] = target governance token address\n    // references[1] = underlying token address\n    // references[2] = registry\n    // references[3] = parameter\n\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    //Authorized condition(uint256) list for market temaplate\n    //Each template has different set of conditions\n    //true if that address is authorized within the template\n    // Example condition list for pool template v1\n    // conditions[0] = minimim deposit amount\n\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice A function to approve or disapprove templates.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _approval true if a market is allowed to create based on the template\n     * @param _isOpen true if anyone can create a market based on the template\n     * @param _duplicate true if a market with duplicate target id is allowed\n     */\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within reference array\n     * @param _target the reference  address\n     * @param _approval true if the reference is approved\n     */\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within condition array\n     * @param _target the condition uint\n     */\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n\n    /**\n     * @notice A function to create markets.\n     * This function is market model agnostic.\n     * @param _template template address, which must be registered\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     * @return created market address\n     */\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    /**\n     * @notice Template Code for the create clone method:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n     */\n    function _createClone(address target) internal returns (address result) {\n        // convert address to bytes20 for assembly use\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            // allocate clone memory\n            let clone := mload(0x40)\n            // store initial portion of the delegation contract code in bytes form\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            // store the provided address\n            mstore(add(clone, 0x14), targetBytes)\n            // store the remaining delegation contract code\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            // create the actual delegate contract reference and return its address\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "Factory.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "//solidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n",
                    "//solidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n",
                    "//solidity\nfunction supportMarket(address _market) external override {\n    require(!markets[_market], \"ERROR: ALREADY_REGISTERED\");\n    require(\n        msg.sender == factory || msg.sender == ownership.owner(),\n        \"ERROR: UNAUTHORIZED_CALLER\"\n    );\n    require(_market != address(0), \"ERROR: ZERO_ADDRESS\");\n\n    allMarkets.push(_market);\n    markets[_market] = true;\n    emit NewMarketRegistered(_market);\n}\n"
                ],
                "Type": " Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances",
                "Description": "\nThe current design/implementation allows a market address (registered on registry) to call Vault#addValue() and transfer tokens from an arbitrary address to a specified _beneficiary up the approved amount at any time, and the _beneficiary can withdraw the funds by calling Vault#withdrawAllAttribution() immediately.\n\nThis poses a very dangerous risk to all the users that approved their tokens to the Vault contracts (each one holds all users' allowances for that token).\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L52-L58\n\nsolidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140\n\nsolidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n\n\nRegistry owner can call Registry#supportMarket() and mark an arbitrary address as a market.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L49-L60\n\nsolidity\nfunction supportMarket(address _market) external override {\n    require(!markets[_market], \"ERROR: ALREADY_REGISTERED\");\n    require(\n        msg.sender == factory || msg.sender == ownership.owner(),\n        \"ERROR: UNAUTHORIZED_CALLER\"\n    );\n    require(_market != address(0), \"ERROR: ZERO_ADDRESS\");\n\n    allMarkets.push(_market);\n    markets[_market] = true;\n    emit NewMarketRegistered(_market);\n}\n\n\nOr, the owner of the Factory can call createMarket() to add a malicous market contract via a custom template contract to the markets list.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216\n\n\nA malicious/compromised Registry owner can:\n\n1.  Call Registry#supportMarket() and set markets[attackerAddress] to true;\n2.  Call Vault#addValue(token.balanceOf(victimAddress), victimAddress, attackerAddress) and transferring all the balanceOf victim's wallet to the vault, owned by attackerAddress.\n3.  Call Vault#withdrawAllAttribution(attackerAddress) and retrive the funds.\n\nThe malicious/compromised Registry owner can repeat the steps above for all the users who approved the Vault contract for all the Vault contracts.\n\nAs a result, the attacker can steal all the wallet balances of the tokens approved to the protocol.\n\n\nImproper access control for using users' allowances.\n\n",
                "Repair": "\nConsider changing the design/implementation to make sure that the allowances approved by the users can only be used by themselves.\n\n\noishun1112 (Insure) acknowledged and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/266):\n  this is an issue only when ownership control has fail. This architecture is necessary to achieve simplicity of the code.\n We assume ownership control works fine.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/266#issuecomment-1023323992):\n  Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds. \n \n Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path. \n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol",
            "IndexTemplate.sol",
            "CDSTemplate.sol",
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\nuint256 _shortage;\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = _value + _cds;\n}\nvault.offsetDebt(_compensated, msg.sender);\n"
                ],
                "Type": "  IndexTemplate.sol#compensate()  will most certainly fail",
                "Description": "\nPrecision loss while converting between the amount of shares and the amount of underlying tokens back and forth is not handled properly.\n\n*\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447\n\nsolidity\nuint256 _shortage;\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = _value + _cds;\n}\nvault.offsetDebt(_compensated, msg.sender);\n\n\nIn the current implementation, when someone tries to resume the market after a pending period ends by calling PoolTemplate.sol#resume(), IndexTemplate.sol#compensate() will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.\n\nHowever, while CDSTemplate.sol#compensate() takes a parameter for the amount of underlying tokens, it uses vault.transferValue() to transfer corresponding _attributions (shares) instead of underlying tokens.\n\nDue to precision loss, the _attributions transferred in the terms of underlying tokens will most certainly be less than the shortage.\n\nAt L444, the contract believes that it's been compensated for _value + _cds, which is lower than the actual value, due to precision loss.\n\nAt L446, when it calls vault.offsetDebt(_compensated, msg.sender), the tx will revert at require(underlyingValue(msg.sender) = _amount).\n\nAs a result, resume() can not be done, and the debt can't be repaid.\n\n\nGiven:\n\n*   vault.underlyingValue = 10,000\n*   vault.valueAll = 30,000\n*   totalAttributions = 2,000,000\n*   _amount = 1,010,000\n\n0.  _shortage = _amount vault.underlyingValue = 1,000,000\n1.  _attributions = (_amount * totalAttributions) / valueAll = 67,333,333\n2.  actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999\n\nExpected results: actualValueTransfered = _shortage;\n\nActual results: actualValueTransfered < _shortage.\n\n\nThe precision loss isn't just happening on special numbers, but will most certainly always revert the txs.\n\nThis will malfunction the contract as the index pool can not compensate(), therefore the pool can not resume(). Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.\n\n",
                "Repair": "\nChange to:\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446\n\nsolidity\nif (totalLiquidity() < _amount) {\n    //Insolvency case\n    _shortage = _amount _value;\n    uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n        .compensate(_shortage);\n    _compensated = vault.underlyingValue(address(this));\n}\nvault.offsetDebt(_compensated, msg.sender);\n\n\noishun1112 (Insure) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/269) \n\noishun1112 (Insure) resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/269)\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nfunction setController(address _controller) public override onlyOwner {\n    require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n    if (address(controller) != address(0)) {\n        controller.migrate(address(_controller));\n        controller = IController(_controller);\n    } else {\n        controller = IController(_controller);\n    }\n\n    emit ControllerSet(_controller);\n}\n",
                    "//solidity\nfunction utilize() external override returns (uint256 _amount) {\n    if (keeper != address(0)) {\n        require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n    }\n    _amount = available(); //balance\n    if (_amount  0) {\n        IERC20(token).safeTransfer(address(controller), _amount);\n        balance -= _amount;\n        controller.earn(address(token), _amount);\n    }\n}\n"
                ],
                "Type": "  Vault#setController()  owner of the Vault contracts can drain funds from the Vault",
                "Description": "\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496\n\nsolidity\nfunction setController(address _controller) public override onlyOwner {\n    require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n    if (address(controller) != address(0)) {\n        controller.migrate(address(_controller));\n        controller = IController(_controller);\n    } else {\n        controller = IController(_controller);\n    }\n\n    emit ControllerSet(_controller);\n}\n\n\nThe owner of the Vault contract can set an arbitrary address as the controller.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352\n\nsolidity\nfunction utilize() external override returns (uint256 _amount) {\n    if (keeper != address(0)) {\n        require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n    }\n    _amount = available(); //balance\n    if (_amount  0) {\n        IERC20(token).safeTransfer(address(controller), _amount);\n        balance -= _amount;\n        controller.earn(address(token), _amount);\n    }\n}\n\n\nA malicious controller contract can transfer funds from the Vault to the attacker.\n\n\nA malicious/compromised can:\n\n1.  Call Vault#setController() and set controller to a malicious contract;\n    *   L489 the old controller will transfer funds to the new, malicious controller.\n2.  Call Vault#utilize() to deposit all the balance in the Vault contract into the malicious controller contract.\n3.  Withdraw all the funds from the malicious controller contract.\n\n",
                "Repair": "\nConsider disallowing Vault#setController() to set a new address if a controller is existing, which terminates the possibility of migrating funds to a specified address provided by the owner. Or, putting a timelock to this function at least.\n\n\noishun1112 (Insure) acknowledged and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/271):\n  we assume ownership control is driven safely\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/271#issuecomment-1023326594):\n  Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n \n Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "repayDebt()",
                    "debts[_target]",
                    "totalDebt"
                ],
                "Type": " repayDebt in Vault.sol could DOS functionality for markets",
                "Description": "\nAny user can pay the debt for any borrower in Vault.sol, by using repayDebt(). This function allows anyone to repay any amount of borrowed value, up-to and including the totalDebt value; it works by setting the debts[_target] to zero, and decreasing totalDebt by the given amount, up to zero. However, all debts of the other borrowers are left untouched.\n\nIf a malicious (but generous) user were to repay the debt for all the borrowers, markets functionality regarding borrowing would be DOSed: the vault would try to decrease the debt of the market, successfully, but would fail to decrease totalDebt as it would result in an underflow\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L257\n\n\n",
                "Repair": "\nMake repayDebt() accept an amount up-to and including the value of the debt for the given borrower\n\noishun1112 (Insure) confirmed(https://github.com/code-423n4/2022-01-insure-findings/issues/126):\n  this needs to be specified how in more detail.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n",
                    "//solidity\nfunction borrowValue(uint256 _amount, address _to) external onlyMarket override {\n    debts[msg.sender] += _amount;\n    totalDebt += _amount;\n\n    IERC20(token).safeTransfer(_to, _amount);\n}\n"
                ],
                "Type": " A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts",
                "Description": "\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L52-L58\n\nsolidity\nmodifier onlyMarket() {\n    require(\n        IRegistry(registry).isListed(msg.sender),\n        \"ERROR_ONLY_MARKET\"\n    );\n    _;\n}\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206\n\nsolidity\nfunction borrowValue(uint256 _amount, address _to) external onlyMarket override {\n    debts[msg.sender] += _amount;\n    totalDebt += _amount;\n\n    IERC20(token).safeTransfer(_to, _amount);\n}\n\n\nThe current design/implementation allows a market address (registered on the registry) to call Vault#borrowValue() and transfer tokens to an arbitrary address.\n\n\nSee the PoC section on [WP-H24].\n\n",
                "Repair": "\n1.  Consider adding constrains (eg. timelock) to Registry#supportMarket().\n2.  Consdier adding constrains (upper bound for each pool, and index pool for example) to Vault#borrowValue().\n\noishun1112 (Insure) acknowledged and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/272):\n  Ownership has to be stolen to drain funds using this method and we assume ownership control driven safely, so we don't treat this as issue\n\n0xean (judge) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/272#issuecomment-1023327233):\n  Agree with warden that the privilege addresses should not be able to use approvals in a way that rugs users funds.\n \n Based on the fact that we have seen many rug pulls in the space based on compromised \"owner\" keys, this is a valid attack path.\n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nif (_value = _amount) {\n    ...\n    _compensated = _amount;\n} else {\n    ...\n    if (totalLiquidity() < _amount) {\n        ...\n        _compensated = _value + _cds;\n    }\n    vault.offsetDebt(_compensated, msg.sender);\n}\n"
                ],
                "Type": " Index compensate is 0 when totalLiquidity() is enough to cover the whole amount",
                "Description": "\nIn IndexTemplate, function compensate, When _amount  _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0:\n\nsolidity\nif (_value = _amount) {\n    ...\n    _compensated = _amount;\n} else {\n    ...\n    if (totalLiquidity() < _amount) {\n        ...\n        _compensated = _value + _cds;\n    }\n    vault.offsetDebt(_compensated, msg.sender);\n}\n\n\nBut nevertheless, in both cases, it calls vault.offsetDebt, even when the_compensated is 0 (no else block).\n\n",
                "Repair": "\nI think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.\n\n\noishun1112 (Insure) confirmed and resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/354):\n  Right.\n totalLiquidity = underlyingValue + pendingPremium.\n \n I will discuss how to fix this issue with my team\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "requestWithdraw"
                ],
                "Type": "  requestWithdraw  without obligation to withdraw allow underwriter to avoid payout",
                "Description": "\nTo prevent withdrawal front-running, a lockup period is set between withdrawal request and withdrawal. However, there are no obligation to withdraw after the lockup period and the capital will keep earning premium during lockup. A strategy for underwriter is to keep requesting withdrawal every lockup period to keep their average lockup to lockup period/2.\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L279\n\nAssuming\n\n1.  Reporting DAO vote last for 24 hours (according to docs) plus there will be delay between the hack and vote creation\n2.  the lockup period is set to 86400 (24 hours) in the supplied test cases\n\nIt is very likely an underwriter can avoid payout by such strategy since their effective lockup would be 12 hours only. They will continue to earn yield in the pool and only require some extra gas cost for the requestWithdraw every 24 hours.\n\n",
                "Repair": "\nExtend the lockup period at least by a factor of 2 or force underwriter to withdraw after lockup period.\n\n\noishun1112 (Insure) acknowledged(https://github.com/code-423n4/2022-01-insure-findings/issues/295):\n  Yes, lock up period is going to be like a week~2week in production.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol",
            "IndexTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "//solidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit  0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n",
                    "\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n// _deductionFromIndex = 10,000 * 106 * 1018;\n\n",
                    "//solidity\n\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 200000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 25,000 * 1018;\n",
                    "//solidity\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 300000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 16666666666666666666667 (~ 16,666 * 1018)\n",
                    "//solidity\nuint256 _shortage = _deductionFromIndex /\n    MAGIC_SCALE_1E6 -\n    _actualDeduction;\n"
                ],
                "Type": "  PoolTemplate.sol#resume()  Wrong implementation of  resume()  will compensate overmuch redeem amount from index pools",
                "Description": "\nWrong arithmetic.\n\n*\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717\n\nsolidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit  0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n\n\n\n*   totalLiquidity = 200,000* 10**18;\n\n*   totalCredit = 100,000 * 10**18;\n\n*   debt = 10,000 * 10**18;\n\n*   [Index Pool 1] Credit = 20,000 * 10**18;\n\n*   [Index Pool 2] Credit = 30,000 * 10**18;\n\n\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n// _deductionFromIndex = 10,000 * 106 * 1018;\n\n\n\nIndex Pool 1]:\nsolidity\n\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 200000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 25,000 * 1018;\n\nIndex Pool 2]:\nsolidity\nuint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;  \n//  _shareOfIndex = 300000\n\nuint256 _redeemAmount = _divCeil(\n    _deductionFromIndex,\n    _shareOfIndex\n);\n\n// _redeemAmount = 16666666666666666666667 (~ 16,666 * 1018)\n\nIn most cases, the transaction will revet on underflow at:\nsolidity\nuint256 _shortage = _deductionFromIndex /\n    MAGIC_SCALE_1E6 -\n    _actualDeduction;\n\nIn some cases, specific pools will be liable for unfair compensation:\n\nIf the CSD is empty, Index Pool 1 only have 6,000 * 1018 and Index Pool 2 only have 4,000 * 1018, the _actualDeduction will be 10,000 * 1018, _deductionFromPool will be 0.\n\nIndex Pool 1 should only pay 1,000 * 1018, but actually paid 6,000 * 1018, the LPs of Index Pool 1 now suffer funds loss.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nuint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity();\nuint256 _actualDeduction;\nfor (uint256 i = 0; i < indexList.length; i++) {\n    address _index = indexList[i];\n    uint256 _credit = indicies[_index].credit;\n    if (_credit  0) {\n        uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n            _totalCredit;\n        uint256 _redeemAmount = _divCeil(\n            _deductionFromIndex * _shareOfIndex,\n            MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6\n        );\n        _actualDeduction += IIndexTemplate(_index).compensate(\n            _redeemAmount\n        );\n    }\n}\n\n\noishun1112 (Insure) confirmed and resolved(https://github.com/code-423n4/2022-01-insure-findings/issues/283)\n\n\n\n"
            },
            {
                "Name": "H-13",
                "Location": [
                    "withdrawCredit()",
                    "rewardPerCredit",
                    "resume()",
                    "totalCredit",
                    "credit",
                    "applyCover()",
                    "pendingEnd"
                ],
                "Type": " Admin of the index pool can  withdrawCredit()  after  applyCover()  to avoid taking loss for the compensation paid for a certain pool",
                "Description": "\nIn the current implementation, when an incident is reported for a certain pool, the index pool can still withdrawCredit() from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.\n\nThis allows the index pool to escape from the responsibility for the risks of invested pools.\n\nMaking the LPs of the pool take an unfair share of the responsibility.\n\n\n*   Pool A totalCredit = 10,000\n*   Pool A rewardPerCredit = 1\n\n1.  [Index Pool 1] allocates 1,000 credits to Pool A:\n\n*   totalCredit = 11,000\n*   indicies[Index Pool 1] = 1,000\n\n2.  After a while, Pool A rewardPerCredit has grown to 1.1, and applyCover() has been called, [Index Pool 1] call withdrawCredit() get 100 premium\n\n*   totalCredit = 10,000\n*   indicies[Index Pool 1] = 0\n\n3.  After pendingEnd, the pool resume(),[ Index Pool 1] will not be paying for the compensation since credit is 0.\n\nIn our case, [Index Pool 1] earned premium without paying for a part of the compensation.\n\n",
                "Repair": "\nChange to:\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421\n\nsolidity\nfunction withdrawCredit(uint256 _credit)\n    external\n    override\n    returns (uint256 _pending)\n{\n    require(\n        marketStatus == MarketStatus.Trading,\n        \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n    );\n    IndexInfo storage _index = indicies[msg.sender];\n\n\noishun1112 (Insure) confirmed and disagreed with severity(https://github.com/code-423n4/2022-01-insure-findings/issues/281):\n  to call PoolTemplate: withdrawCredit(), someone has to call IndexTemplate: withdraw(), set(), and adjustAlloc().\n \n set() is onlyOwner, so we assume it's fine()\n adjustAlloc() is public. this clean up and flatten the credit distribution.\n withdraw() is public. this reduce totalCredit to distribute. when exceed upperSlack, call adjustAlloc().\n \n  We should lock the credit control when pool is in payout status.\n This implementation, still allows small amount of withdraw, for users who were requested Withdraw.\n\noishun1112 (Insure) commented(https://github.com/code-423n4/2022-01-insure-findings/issues/281#issuecomment-1027721179):\n  We have fixed with PVE02 (Peckshield audit) issue together.\n\n \n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "IndexTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-12",
                "Location": [
                    "//solidity\nfunction resume() external override {\n    uint256 _poolLength = poolList.length;\n\n    for (uint256 i = 0; i < _poolLength; i++) {\n        require(\n            IPoolTemplate(poolList[i]).paused() == false,\n            \"ERROR: POOL_IS_PAUSED\"\n        );\n    }\n\n    locked = false;\n    emit Resumed();\n}\n"
                ],
                "Type": "  IndexTemplate.sol  Wrong implementation allows lp of the index pool to resume a locked  PayingOut  pool and escape the responsibility for the compensation",
                "Description": "\nBased on the context, the system intends to lock all the lps during PayingOut period.\n\nHowever, the current implementation allows anyone, including LPs to call resume() and unlock the index pool.\n\nIt allows a malicious LP to escape the responsibility for the compensation, at the expense of other LPs paying more than expected.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L459-L471\n\nsolidity\nfunction resume() external override {\n    uint256 _poolLength = poolList.length;\n\n    for (uint256 i = 0; i < _poolLength; i++) {\n        require(\n            IPoolTemplate(poolList[i]).paused() == false,\n            \"ERROR: POOL_IS_PAUSED\"\n        );\n    }\n\n    locked = false;\n    emit Resumed();\n}\n\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction resume() external override {\n   uint256 _poolLength = poolList.length;\n\n   for (uint256 i = 0; i < _poolLength; i++) {\n       require(\n           IPoolTemplate(poolList[i]).marketStatus() == MarketStatus.Trading,\n           \"ERROR: POOL_IS_PAYINGOUT\"\n       );\n   }\n\n   locked = false;\n   emit Resumed();\n}\n\n\noishun1112 (Insure) confirmed(https://github.com/code-423n4/2022-01-insure-findings/issues/278)\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol",
            "IndexTemplate.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction resume() external {\n    require(\n        marketStatus == MarketStatus.Payingout &&\n            pendingEnd < block.timestamp,\n        \"ERROR: UNABLE_TO_RESUME\"\n    );\n\n    uint256 _debt = vault.debts(address(this));\n    uint256 _totalCredit = totalCredit;\n    uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n        totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit  0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n\n    uint256 _deductionFromPool = _debt -\n        _deductionFromIndex /\n        MAGIC_SCALE_1E6;\n    uint256 _shortage = _deductionFromIndex /\n        MAGIC_SCALE_1E6 -\n        _actualDeduction;\n\n    if (_deductionFromPool  0) {\n        vault.offsetDebt(_deductionFromPool, address(this));\n    }\n\n    vault.transferDebt(_shortage);\n\n    marketStatus = MarketStatus.Trading;\n    emit MarketStatusChanged(MarketStatus.Trading);\n}\n"
                ],
                "Type": " System Debt Is Not Handled When Insurance Pools Become Insolvent",
                "Description": "\nIf an incident has occurred where an insurance policy is to be redeemed. The market is put into the MarketStatus.Payingout mode where the _insurance.insured account is allowed to redeem their cover and receive a payout amount. Upon paying out the insurance cover, any user is able to resume the market by calling PoolTemplate.resume(). This function will compensate the insurance pool if it is insolvent by querying IndexTemplate.compensate() which in turn queries CDSTemplate.compensate() to cover any shortage.\n\nIn the event none of these entities are able to cover the shortage in debt, the system accrues the debt. However, there is currently no mechanism to ensure when transferDebt() is called in PoolTemplate.resume(), the accrued system debt is paid off. Therefore, the system may incorrectly handle insolvency on an extreme edge case, generating system instability.\n\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L691-L734\nsolidity\nfunction resume() external {\n    require(\n        marketStatus == MarketStatus.Payingout &&\n            pendingEnd < block.timestamp,\n        \"ERROR: UNABLE_TO_RESUME\"\n    );\n\n    uint256 _debt = vault.debts(address(this));\n    uint256 _totalCredit = totalCredit;\n    uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n        totalLiquidity();\n    uint256 _actualDeduction;\n    for (uint256 i = 0; i < indexList.length; i++) {\n        address _index = indexList[i];\n        uint256 _credit = indicies[_index].credit;\n        if (_credit  0) {\n            uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                _totalCredit;\n            uint256 _redeemAmount = _divCeil(\n                _deductionFromIndex,\n                _shareOfIndex\n            );\n            _actualDeduction += IIndexTemplate(_index).compensate(\n                _redeemAmount\n            );\n        }\n    }\n\n    uint256 _deductionFromPool = _debt -\n        _deductionFromIndex /\n        MAGIC_SCALE_1E6;\n    uint256 _shortage = _deductionFromIndex /\n        MAGIC_SCALE_1E6 -\n        _actualDeduction;\n\n    if (_deductionFromPool  0) {\n        vault.offsetDebt(_deductionFromPool, address(this));\n    }\n\n    vault.transferDebt(_shortage);\n\n    marketStatus = MarketStatus.Trading;\n    emit MarketStatusChanged(MarketStatus.Trading);\n}\n\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L421-L450\n<https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L248-L277\n\n\n",
                "Repair": "\nConsider devising a mechanism to ensure system debt is properly handled. After discussions with the sponsor, it seems that they will be implementing a way to mint INSURE tokens which will be used to cover the shortfall.\n\noishun1112 (Insure) acknowledged(https://github.com/code-423n4/2022-01-insure-findings/issues/228)\n  yes, PoolTemplate calls transferDebt() to make his debt to the system debt in case all Index and CDS layers couldn't cover the shortage.\n In this case, we have to repay the system debt somehow since this is the situation that we over-lose money. One way is that someone calls repayDebt() and pay for it (not realistic at all). As we implement the way to payback, we are considering minting INSURE token or, other better mechanism.\n \n  This is not developed yet, and acknowledged.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract InsureDAOERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    bool tokenInitialized;\n    string private _name = \"InsureDAO LP Token\";\n    string private _symbol = \"iLP\";\n    uint8 private _decimals = 18;\n\n    constructor() {}\n\n    function initializeToken(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        /***\n         *@notice initialize token. Only called internally.\n         *\n         */\n        assert(!tokenInitialized);\n        tokenInitialized = true;\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        _balances[sender] = senderBalance - amount;\n\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO CDS template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\ncontract CDSTemplate is InsureDAOERC20, ICDSTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event Fund(address indexed depositor, uint256 amount, uint256 attribution);\n    event Defund(\n        address indexed depositor,\n        uint256 amount,\n        uint256 attribution\n    );\n\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n    uint256 public surplusPool;\n    uint256 public crowdPool;\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"ERROR: ONLY_OWNER\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override{\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-CDS\";\n        string memory _symbol = \"iCDS\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool initeractions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function deposit(uint256 _amount) external returns (uint256 _mintAmount) {\n        require(paused == false, \"ERROR: PAUSED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        //deposit and pay fees\n        uint256 _liquidity = vault.attributionValue(crowdPool); //get USDC balance with crowdPool's attribution\n        uint256 _supply = totalSupply();\n\n        crowdPool += vault.addValue(_amount, msg.sender, address(this)); //increase attribution\n        \n        if (_supply > 0 && _liquidity > 0) {\n            _mintAmount = (_amount * _supply) / _liquidity;\n        } else if (_supply > 0 && _liquidity == 0) {\n            //when vault lose all underwritten asset = \n            _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.\n        } else {\n            //when _supply == 0,\n            _mintAmount = _amount;\n        }\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider supplies collatral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     */\n    function fund(uint256 _amount) external {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        //deposit and pay fees\n        uint256 _attribution = vault.addValue(\n            _amount,\n            msg.sender,\n            address(this)\n        );\n\n        surplusPool += _attribution;\n\n        emit Fund(msg.sender, _amount, _attribution);\n    }\n\n    function defund(uint256 _amount) external override onlyOwner {\n        require(paused == false, \"ERROR: PAUSED\");\n\n        uint256 _attribution = vault.withdrawValue(_amount, msg.sender);\n        surplusPool -= _attribution;\n\n        emit Defund(msg.sender, _amount, _attribution);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collatral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        Withdrawal memory request = withdrawalReq[msg.sender];\n\n        require(paused == false, \"ERROR: PAUSED\");\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            request.timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            request.amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        //Calculate underlying value\n        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply();\n\n\n        //reduce requested amount\n        request.amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        crowdPool -= vault.withdrawValue(_retVal, msg.sender);\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Compensate the shortage if an index is insolvent\n     * @param _amount amount of underlier token to compensate shortage within index\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(registry.isListed(msg.sender));\n        \n        uint256 _available = vault.underlyingValue(address(this));\n        uint256 _crowdAttribution = crowdPool;\n        uint256 _surplusAttribution = surplusPool;\n        uint256 _attributionLoss;\n\n        if (_available >= _amount) {\n            _compensated = _amount;\n            _attributionLoss = vault.transferValue(_amount, msg.sender);\n            emit Compensated(msg.sender, _amount);\n        } else {\n            //when CDS cannot afford, pay as much as possible\n            _compensated = _available;\n            _attributionLoss = vault.transferValue(_available, msg.sender);\n            emit Compensated(msg.sender, _available);\n        }\n\n        uint256 _crowdPoolLoss = \n            (_crowdAttribution * _attributionLoss) /\n            (_crowdAttribution + _surplusAttribution);\n\n        crowdPool -= _crowdPoolLoss;\n        surplusPool -= (_attributionLoss - _crowdPoolLoss);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance available liquidity of this pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this));\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6, if MAGIC_SCALE_1E6, the value of iToken vs underlier is 1:1)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return\n                (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /\n                totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return\n                _balance * vault.attributionValue(crowdPool) / totalSupply();\n        }\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "InsureDAOERC20.sol",
            "Vault.sol",
            "CDSTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n"
                ],
                "Type": "  Vault.sol  Tokens with fee on transfer are not supported",
                "Description": "\nThere are ERC20 tokens that charge fee for every transfer() / transferFrom().\n\nVault.sol#addValue() assumes that the received amount is the same as the transfer amount, and uses it to calculate attributions, balance amounts, etc. While the actual transferred amount can be lower for those tokens.\n\n<https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L124-L140\n\nsolidity\nfunction addValue(\n    uint256 _amount,\n    address _from,\n    address _beneficiary\n) external override onlyMarket returns (uint256 _attributions) {\n\n    if (totalAttributions == 0) {\n        _attributions = _amount;\n    } else {\n        uint256 _pool = valueAll();\n        _attributions = (_amount * totalAttributions) / _pool;\n    }\n    IERC20(token).safeTransferFrom(_from, address(this), _amount);\n    balance += _amount;\n    totalAttributions += _attributions;\n    attributions[_beneficiary] += _attributions;\n}\n\n\n",
                "Repair": "\nConsider comparing before and after balance to get the actual transferred amount.\n\noishun1112 (Insure) acknowledged(https://github.com/code-423n4/2022-01-insure-findings/issues/236):\n  only USDC can be underwriting asset. We are trying to make it multi currency. \n We won't implement this now due to the gas consumption, but we will when we develop new type of Vault\n\n\n\n"
            }
        ]
    }
]