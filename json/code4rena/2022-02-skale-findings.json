[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfor (uint256 i = 0; i < messages.length; i++) {\n    // @audit re-entrant, can submit same postIncomingMessages again\n    _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);\n}\nconnectedChains[fromChainHash].incomingMessageCounter += messages.length;\n"
                ],
                "Type": " Reentrancy in  MessageProxyForSchain  leads to replay attacks",
                "Description": "\nThe postIncomingMessages function calls _callReceiverContract(fromChainHash, messages[i], startingCounter + 1) which gives control to a contract that is potentially attacker controlled *before* updating the incomingMessageCounter.\n\nsolidity\nfor (uint256 i = 0; i < messages.length; i++) {\n    // @audit re-entrant, can submit same postIncomingMessages again\n    _callReceiverContract(fromChainHash, messages[i], startingCounter + 1);\n}\nconnectedChains[fromChainHash].incomingMessageCounter += messages.length;\n\n\nThe attacker can re-enter into the postIncomingMessages function and submit the same messages again, creating a replay attack.\nNote that the startingCounter is the way how messages are prevented from replay attacks here, there are no further nonces.\n\n\nAttacker can submit two cross-chain messages to be executed:\n\n1.  Transfer 1000 USDC\n2.  A call to their attacker-controlled contract, could be masked as a token contract that allows re-entrance on transfer.\n\nSome node submits the postIncomingMessages(params) transaction, transfers 1000 USDC, then calls the attackers contract, who can themself call postIncomingMessages(params) again, receive 1000 USDC a second time, and stop the recursion.\n\n",
                "Repair": "\nAdd a messageInProgressLocker modifier to postIncomingMessages as was done in MessageProxyForMainnet.\n\ncstrangedk (SKALE) resolved:\n\nResolved via https://github.com/skalenetwork/IMA/pull/1054\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal gasleft() + additionalGasPerMessage;\n            }\n        }\n",
                    "//solidity\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount  _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas amount) / tx.gasprice;\n    }\n"
                ],
                "Type": " Gas pricing can be used to extort funds from users of SChain owner",
                "Description": "\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L82-L112\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/MessageProxyForMainnet.sol#L235-L250\n\n\nThe function refundGasByUser() can be exploited by the message sender to drain nodes and SChain owners of their balances when processing incoming messages.\n\nWhen a node collates a set of exits from an SChain to Ethereum, they are submitted on-chain via MessageProxyForMainnet.sol.  For each message to a registered contract the user is required to pay for the refund via CommunityPool.refundGasByUser().\n\nThe issue occurs in CommunityPool.refundGasByUser()  as the amount to be refunded is calculated as uint amount = tx.gasprice * gas;, where gas is the gas used by the message. Since tx.gasprice is set by the node and there is no upper bounds on the price. Since EIP1559 the gas price is BaseFee + Tip and although Base is predetermined Tip is any arbitrary non-zero integer.\n\nThe attack is for a node to set an excessively high tx.gasprice which will be refunded out of the balance of the user who initiated the outgoing transaction or if that user has insufficient balance then from the SChain owner.  Since the node submitting the transaction is refunded for their gas they do not lose from setting a higher gas price.\n\nThe impact of the attack is that the user requesting the exit and/or the SChain owner may have their ETH balances depleted to refund the submitter. The impact is worsened as if the user has insufficient balance a message will be sent to the SChain preventing them from making further exits until they have sufficient balance.\n\nNote a similar issue may be seen in IWallets.refundGasBySchain() depending on how the gas calculations are performed (they are not in scope but the TestWallet also uses tx.gasprice in the same manner).\n\n\nProcessing incoming messages in MessageProxyForMainnet.sol\n\nsolidity\n        for (uint256 i = 0; i < messages.length; i++) {\n            gasTotal = gasleft();\n            if (isContractRegistered(bytes32(0), messages[i].destinationContract)) {\n                address receiver = _getGasPayer(fromSchainHash, messages[i], startingCounter + i);\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += communityPool.refundGasByUser(\n                    fromSchainHash,\n                    payable(msg.sender),\n                    receiver,\n                    gasTotal gasleft() + additionalGasPerMessage\n                );\n            } else {\n                _callReceiverContract(fromSchainHash, messages[i], startingCounter + i);\n                notReimbursedGas += gasTotal gasleft() + additionalGasPerMessage;\n            }\n        }\n\n\nRefunding gas in CommunityPool.sol\n\nsolidity\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount  _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas amount) / tx.gasprice;\n    }\n\n\n",
                "Repair": "\nOne solution to avoid excessive over refunding of gas fees is to use a gas price oracle rather than tx.gasprice.\n\nAn alternate solution is to set a maximum gas price and have some incentives for the node submitting at a gas price below the maximum.\n\ncstrangedk (SKALE) resolved(https://github.com/code-423n4/2022-02-skale-findings/issues/28#issuecomment-1176670089):\n  Resolved via https://github.com/skalenetwork/IMA/pull/1165/\n*\n\n \n\n"
            }
        ]
    }
]