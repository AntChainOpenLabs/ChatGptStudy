[
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    /// @notice An address to receive swap fees. The 0 address prevents fee\n    ///         withdrawal.\n    address payable public feeRecipient;\n    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted\n    ///         from the proceeds of each swap.\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    /// @param owner_ A new contract owner, expected to implement\n    ///               TimelockGovernorWithEmergencyGovernance.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal, and can be set later by\n    ///        governance.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee\n    ///                 ratio charged for each swap.\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the fee taken from each swap's proceeds.\n    /// @dev Only timelocked governance can set the swap fee.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.\n    function setSwapFee(uint256 swapFee_) external onlyTimelock {\n        require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::setSwapFee: Swap fee must not exceed 100%\");\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the address permitted to receive swap fees.\n    /// @dev Only timelocked governance can set the fee recipient.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal.\n    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n    }\n\n    /// @notice Swap by filling a 0x quote.\n    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.\n    ///      Charges a governable swap fee that comes out of the bought asset,\n    ///      be it token or ETH. Unfortunately, the fee is also charged on any\n    ///      refunded ETH from 0x protocol fees due to an implementation oddity.\n    ///      This behavior shouldn't impact most users.\n    ///\n    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api\n    /// @param zrxSellTokenAddress The contract address of the token to be sold,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling\n    ///        unwrapped ETH included via msg.value, this should be address(0)\n    /// @param amountToSell Amount of token to sell, with the same precision as\n    ///        zrxSellTokenAddress. This information is also encoded in zrxData.\n    ///        If selling unwrapped ETH via msg.value, this should be 0.\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy\n    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    /// @param minimumAmountReceived The minimum amount expected to be received\n    ///        from filling the quote, before the swap fee is deducted, in\n    ///        zrxBuyTokenAddress. Reverts if not met\n    /// @param zrxAllowanceTarget Contract address that needs to be approved for\n    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API\n    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH\n    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param zrxData Data encoding the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param deadline Timestamp after which the swap will be reverted.\n    function swapByQuote(\n        address zrxSellTokenAddress,\n        uint256 amountToSell,\n        address zrxBuyTokenAddress,\n        uint256 minimumAmountReceived,\n        address zrxAllowanceTarget,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 deadline\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            block.timestamp <= deadline,\n            \"Swap::swapByQuote: Deadline exceeded\"\n        );\n        require(\n            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,\n            \"Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value\"\n        );\n\n        // if zrxAllowanceTarget is 0, this is an ETH sale\n        if (zrxAllowanceTarget != address(0)) {\n            // transfer tokens to this contract\n            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);\n            // approve token transfer to 0x contracts\n            // TODO (handle approval special cases like USDT, KNC, etc)\n            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);\n        }\n\n        // execute 0x quote\n        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(\n            IERC20(zrxBuyTokenAddress),\n            zrxTo,\n            zrxData,\n            msg.value\n        );\n\n        require(\n            (\n                !signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtERC20Amount >= minimumAmountReceived\n            ) ||\n            (\n                signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtETHAmount >= minimumAmountReceived\n            ),\n            \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n        );\n        if (boughtERC20Amount > 0) {\n            // take the swap fee from the ERC20 proceeds and return the rest\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n            // return any refunded ETH\n            payable(msg.sender).transfer(boughtETHAmount);\n\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtERC20Amount,\n                boughtERC20Amount.sub(toTransfer)\n            );\n        } else {\n\n            // take the swap fee from the ETH proceeds and return the rest. Note\n            // that if any 0x protocol fee is refunded in ETH, it also suffers\n            // the swap fee tax\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n            payable(msg.sender).transfer(toTransfer);\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtETHAmount,\n                boughtETHAmount.sub(toTransfer)\n            );\n        }\n        if (zrxAllowanceTarget != address(0)) {\n            // remove any dangling token allowance\n            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);\n        }\n    }\n\n    /// @notice Fill a 0x quote as provided by the API, and return any ETH or\n    ///         ERC20 proceeds.\n    /// @dev Learn more at https://0x.org/docs/api\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    ///        signifies the user is buying unwrapped ETH.\n    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API\n    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API\n    /// @param ethAmount The amount of ETH required to fill the quote, including\n    ///        any ETH being traded as well as protocol fees\n    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well\n    ///         as any positive ETH balance change\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    /// @notice Test whether an address is zero, or the magic address the 0x\n    ///         platform uses to signify \"unwrapped ETH\" rather than an ERC20.\n    /// @param tokenAddress An address that might point toward an ERC-20.\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established\n    ///         fee recipient address.\n    /// @dev Fees are tracked based on the contract's balances, rather than\n    ///      using any additional bookkeeping. If there are bugs in swap\n    ///      accounting, this function could jeopardize funds.\n    /// @param tokens An array of ERC20 contracts to withdraw token fees\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// test input data from the 0x API\n// 0xd9627aa4000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000008430000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee869584cd0000000000000000000000001000000000000000000000000000000000000011000000000000000000000000000000000000000000000052beeb861f60df6a37\n\ncontract MockZrxExchangeProxy {\n    // well behaved function that takes 1000 * 1e18 _1[0] tokens and returns 1000e18\n    // _1[1] tokens if possible.\n    //\n    // function selector: 0xd9627aa4 (real selector in use on mainnet)\n    function sellToUniswap(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        require(_1.length > 1, \"tokens\");\n        IERC20 tokenToSell = IERC20(_1[0]);\n        IERC20 tokenToBuy = IERC20(_1[1]);\n        tokenToSell.transferFrom(msg.sender, address(this), 1000 ether);\n        tokenToBuy.transfer(msg.sender, 1000 ether);\n    }\n\n    // well behaved function that takes 1000 * 1e18 _1[0] tokens and returns 1 ETH,\n    // if possible.\n    //\n    // function selector: 0x22170963\n    function sellToUniswap1(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        require(_1.length > 0, \"tokens\");\n        IERC20 tokenToSell = IERC20(_1[0]);\n        IERC20 tokenToBuy = IERC20(_1[1]);\n        tokenToSell.transferFrom(msg.sender, address(this), 1000 ether);\n        payable(address(msg.sender)).transfer(1 ether);\n    }\n\n    // well behaved function that takes 1 ETH and returns 1000 * 1e18 _1[1]\n    // tokens, if possible.\n    //\n    // function selector: 0x02af0bb5\n    function sellToUniswap2(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        require(msg.value == 1 ether, \"mispaid\");\n        require(_1.length > 1, \"tokens\");\n        IERC20(_1[1]).transfer(msg.sender, 1000 ether);\n    }\n\n    // function that reverts\n    //\n    // function selector: 0x9b1d1f41\n    function sellToUniswap3(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        revert(\"Sorry fren\");\n    }\n\n    // malicious function that takes all ETH and returns nothing\n    //\n    // function selector: 0xb88ce71e\n    function sellToUniswap4(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        // yep that's it :)\n    }\n\n    // malicious function that takes all approved _1[0] tokens and returns a\n    // small amount of ETH\n    //\n    // function selector: 0x1f9b9985\n    function sellToUniswap5(address[] calldata _1, uint256 _2, uint256 _3, bool _4) external payable {\n        if(_1.length > 0) {\n            IERC20 token = IERC20(_1[0]);\n            uint256 allowance = token.allowance(msg.sender, address(this));\n            IERC20(_1[0]).transferFrom(msg.sender, address(this), allowance);\n            payable(address(msg.sender)).transfer(0.1 ether);\n            // see you later sucker!\n        }\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Swap.sol",
            "MockZrxExchangeProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n",
                    "//solidity\nTallySwap.swapByQuote(\n    address(WETH),\n    0,\n    address(WETH),\n    0,\n    address(0),\n    address(WETH),\n    abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        address(Alice),\n        address(this),\n        1000 ether\n    )\n)\n"
                ],
                "Type": " Arbitrary contract call allows attackers to steal ERC20 from users' wallets",
                "Description": "\nSwap.sol L200-L212(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212)\n\nsolidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n\n\nA call to an arbitrary contract with custom calldata is made in fillZrxQuote(), which means the contract can be an ERC20 token, and the calldata can be transferFrom a previously approved user.\n\nThe wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.\n\nGiven:\n\n*   Alice has approved 1000 WETH to Swap.sol;\n\nThe attacker can:\nsolidity\nTallySwap.swapByQuote(\n    address(WETH),\n    0,\n    address(WETH),\n    0,\n    address(0),\n    address(WETH),\n    abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        address(Alice),\n        address(this),\n        1000 ether\n    )\n)\n\n\nAs a result, 1000 WETH will be stolen from Alice and sent to the attacker.\n\nThis PoC has been tested on a forking network.\n\n",
                "Repair": "Consider adding a whitelist for zrxTo addresses.\n\n\nShadowfiend (Tally) confirmed(https://github.com/code-423n4/2021-10-tally-findings/issues/37)\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    /// @notice An address to receive swap fees. The 0 address prevents fee\n    ///         withdrawal.\n    address payable public feeRecipient;\n    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted\n    ///         from the proceeds of each swap.\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    /// @param owner_ A new contract owner, expected to implement\n    ///               TimelockGovernorWithEmergencyGovernance.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal, and can be set later by\n    ///        governance.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee\n    ///                 ratio charged for each swap.\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the fee taken from each swap's proceeds.\n    /// @dev Only timelocked governance can set the swap fee.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.\n    function setSwapFee(uint256 swapFee_) external onlyTimelock {\n        require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::setSwapFee: Swap fee must not exceed 100%\");\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the address permitted to receive swap fees.\n    /// @dev Only timelocked governance can set the fee recipient.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal.\n    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n    }\n\n    /// @notice Swap by filling a 0x quote.\n    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.\n    ///      Charges a governable swap fee that comes out of the bought asset,\n    ///      be it token or ETH. Unfortunately, the fee is also charged on any\n    ///      refunded ETH from 0x protocol fees due to an implementation oddity.\n    ///      This behavior shouldn't impact most users.\n    ///\n    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api\n    /// @param zrxSellTokenAddress The contract address of the token to be sold,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling\n    ///        unwrapped ETH included via msg.value, this should be address(0)\n    /// @param amountToSell Amount of token to sell, with the same precision as\n    ///        zrxSellTokenAddress. This information is also encoded in zrxData.\n    ///        If selling unwrapped ETH via msg.value, this should be 0.\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy\n    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    /// @param minimumAmountReceived The minimum amount expected to be received\n    ///        from filling the quote, before the swap fee is deducted, in\n    ///        zrxBuyTokenAddress. Reverts if not met\n    /// @param zrxAllowanceTarget Contract address that needs to be approved for\n    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API\n    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH\n    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param zrxData Data encoding the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param deadline Timestamp after which the swap will be reverted.\n    function swapByQuote(\n        address zrxSellTokenAddress,\n        uint256 amountToSell,\n        address zrxBuyTokenAddress,\n        uint256 minimumAmountReceived,\n        address zrxAllowanceTarget,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 deadline\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            block.timestamp <= deadline,\n            \"Swap::swapByQuote: Deadline exceeded\"\n        );\n        require(\n            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,\n            \"Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value\"\n        );\n\n        // if zrxAllowanceTarget is 0, this is an ETH sale\n        if (zrxAllowanceTarget != address(0)) {\n            // transfer tokens to this contract\n            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);\n            // approve token transfer to 0x contracts\n            // TODO (handle approval special cases like USDT, KNC, etc)\n            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);\n        }\n\n        // execute 0x quote\n        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(\n            IERC20(zrxBuyTokenAddress),\n            zrxTo,\n            zrxData,\n            msg.value\n        );\n\n        require(\n            (\n                !signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtERC20Amount >= minimumAmountReceived\n            ) ||\n            (\n                signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtETHAmount >= minimumAmountReceived\n            ),\n            \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n        );\n        if (boughtERC20Amount > 0) {\n            // take the swap fee from the ERC20 proceeds and return the rest\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n            // return any refunded ETH\n            payable(msg.sender).transfer(boughtETHAmount);\n\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtERC20Amount,\n                boughtERC20Amount.sub(toTransfer)\n            );\n        } else {\n\n            // take the swap fee from the ETH proceeds and return the rest. Note\n            // that if any 0x protocol fee is refunded in ETH, it also suffers\n            // the swap fee tax\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n            payable(msg.sender).transfer(toTransfer);\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtETHAmount,\n                boughtETHAmount.sub(toTransfer)\n            );\n        }\n        if (zrxAllowanceTarget != address(0)) {\n            // remove any dangling token allowance\n            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);\n        }\n    }\n\n    /// @notice Fill a 0x quote as provided by the API, and return any ETH or\n    ///         ERC20 proceeds.\n    /// @dev Learn more at https://0x.org/docs/api\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    ///        signifies the user is buying unwrapped ETH.\n    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API\n    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API\n    /// @param ethAmount The amount of ETH required to fill the quote, including\n    ///        any ETH being traded as well as protocol fees\n    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well\n    ///         as any positive ETH balance change\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    /// @notice Test whether an address is zero, or the magic address the 0x\n    ///         platform uses to signify \"unwrapped ETH\" rather than an ERC20.\n    /// @param tokenAddress An address that might point toward an ERC-20.\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established\n    ///         fee recipient address.\n    /// @dev Fees are tracked based on the contract's balances, rather than\n    ///      using any additional bookkeeping. If there are bugs in swap\n    ///      accounting, this function could jeopardize funds.\n    /// @param tokens An array of ERC20 contracts to withdraw token fees\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Swap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n    require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n    uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n    uint256 erc20Delta;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n        require(erc20Delta  0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n    } else {\n        require(ethDelta  0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n    }\n\n    return (erc20Delta, ethDelta);\n}\n"
                ],
                "Type": " Wrong calculation of  erc20Delta  and  ethDelta ",
                "Description": "\nSwap.sol L200-L225(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225)\n\nsolidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n    require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n    uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n    uint256 erc20Delta;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n        require(erc20Delta  0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n    } else {\n        require(ethDelta  0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n    }\n\n    return (erc20Delta, ethDelta);\n}\n\n\nWhen a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, ethDelta will always be 0.\n\nThat's because originalETHBalance already includes the msg.value sent by the caller.\n\nLet's say the ETH balance of the contract is 1 ETH before the swap.\n\n*   A user swaps 10 ETH to USDC;\n*   originalETHBalance will be 11 ETH;\n*   If there is 1 ETH of refund;\n*   ethDelta will be 0 as the new balance is 2 ETH and subOrZero(2, 11) is 0.\n\nSimilarly, erc20Delta is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from WBTC to WBTC, the originalERC20Balance already includes the input amount, erc20Delta will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from 1 WBTC to 1.1 WBTC, the ethDelta will be 0.1 WBTC while it should be 1.1 WBTC.\n\n*   User can not get ETH refund for swaps from ETH to ERC20 tokens;\n*   Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.\n\n",
                "Repair": "Consider subtracting the input amount from the originalBalance.\n\nShadowfiend (Tally) confirmed(https://github.com/code-423n4/2021-10-tally-findings/issues/34#issuecomment-961228745):\n  This doesn't allow explicit stealing by an attacker, but does leak value. We would suggest a (2) severity on this.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-10-tally-findings/issues/34#issuecomment-962285115):\n  This results in a user losing assets that they will never be able to recover. Per documentation\n\n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n Lost assets are a high sev.\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "swapByQuote()",
                    "zrxBuyTokenAddress",
                    "boughtERC",
                    "fillZrxQuote"
                ],
                "Type": " Users can avoid paying fees for ETH swaps",
                "Description": "\nUsers can call Swap.swapByQuote() to execute an ETH swap (where they receive ETH) without paying swap fee for the gained ETH. They can trick the system by setting zrxBuyTokenAddress to an address of a malicious contract and making it think they have executed an ERC20 swap when they have actually executed an ETH swap. In this case, the system will give them the ETH they got from the swap (boughtETHAmount) without charging any swap fees for it, because the systems consideres this ETH as \"refunded ETH\" that wasn't part of the \"ERC20\" swap.\n\nUsers can execute ETH swap without paying swap fees for the ETH the got from the swap.\n\nThe steps of the attack are:\n\n1.  Deploy a malicious contract (denoted by M), that will be used for zrxBuyTokenAddress.\n2.  Call Swap.swapByQuote() with zrxBuyTokenAddress=M and minimumAmountReceived=0. The rest of the arguments should specify our ETH swap, nothing special here.\n3.  Define M to return 0 and 1 at the first and second times when fillZrxQuote calls zrxBuyTokenAddress.balanceOf(address(this)), respectively.\n4.  As a result, boughtERC20Amount now equals 1 and the function will \"return any refunded ETH\" to the caller, without charging any swap fees on it. This ETH is actually the output of that ETH swap.\n\nManual code review.\n\n",
                "Repair": "Charge swap fees for the \"refunded ETH\" on ERC20 swaps (when boughtERC20Amount  0), or require boughtETHAmount == 0.\n\nShadowfiend (Tally) acknowledged(https://github.com/code-423n4/2021-10-tally-findings/issues/68#issuecomment-961245894):\n  Still working through whether this is an issue we're truly worried about; in particular, if you want to do this, you probably might as well use the 0x API to swap directly.\n\n Nonetheless, it's overshadowed by #37, which will likely lead to changes that will make this impractical as well.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-10-tally-findings/issues/68#issuecomment-962451293):\n  Downgrading to severity 2 as this would lead to \"leaked value\" as only the fees are lost by the protocol in this attack vector and customer assets aren't being stolen.\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    /// @notice An address to receive swap fees. The 0 address prevents fee\n    ///         withdrawal.\n    address payable public feeRecipient;\n    /// @notice divide by the SWAP_FEE_DIVISOR to get the fee ratio, deducted\n    ///         from the proceeds of each swap.\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    /// @param owner_ A new contract owner, expected to implement\n    ///               TimelockGovernorWithEmergencyGovernance.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal, and can be set later by\n    ///        governance.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee\n    ///                 ratio charged for each swap.\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the fee taken from each swap's proceeds.\n    /// @dev Only timelocked governance can set the swap fee.\n    /// @param swapFee_ A fee, which divided by SWAP_FEE_DIVISOR sets the fee ratio.\n    function setSwapFee(uint256 swapFee_) external onlyTimelock {\n        require(swapFee_ < SWAP_FEE_DIVISOR, \"Swap::setSwapFee: Swap fee must not exceed 100%\");\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    /// @notice Set the address permitted to receive swap fees.\n    /// @dev Only timelocked governance can set the fee recipient.\n    /// @param feeRecipient_ A payable address to receive swap fees. Setting the\n    ///        0 address prevents fee withdrawal.\n    function setFeeRecipient(address payable feeRecipient_) external onlyTimelock {\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n    }\n\n    /// @notice Swap by filling a 0x quote.\n    /// @dev Execute a swap by filling a 0x quote, as provided by the 0x API.\n    ///      Charges a governable swap fee that comes out of the bought asset,\n    ///      be it token or ETH. Unfortunately, the fee is also charged on any\n    ///      refunded ETH from 0x protocol fees due to an implementation oddity.\n    ///      This behavior shouldn't impact most users.\n    ///\n    ///      Learn more about the 0x API and quotes at https://0x.org/docs/api\n    /// @param zrxSellTokenAddress The contract address of the token to be sold,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. If selling\n    ///        unwrapped ETH included via msg.value, this should be address(0)\n    /// @param amountToSell Amount of token to sell, with the same precision as\n    ///        zrxSellTokenAddress. This information is also encoded in zrxData.\n    ///        If selling unwrapped ETH via msg.value, this should be 0.\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as returned by the 0x `/swap/v1/quote` API endpoint. To buy\n    ///        unwrapped ETH, use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    /// @param minimumAmountReceived The minimum amount expected to be received\n    ///        from filling the quote, before the swap fee is deducted, in\n    ///        zrxBuyTokenAddress. Reverts if not met\n    /// @param zrxAllowanceTarget Contract address that needs to be approved for\n    ///        zrxSellTokenAddress, as returned by the 0x `/swap/v1/quote` API\n    ///        endpoint. Should be address(0) for purchases uses unwrapped ETH\n    /// @param zrxTo Contract to fill the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param zrxData Data encoding the 0x quote, as returned by the 0x\n    ///        `/swap/v1/quote` API endpoint\n    /// @param deadline Timestamp after which the swap will be reverted.\n    function swapByQuote(\n        address zrxSellTokenAddress,\n        uint256 amountToSell,\n        address zrxBuyTokenAddress,\n        uint256 minimumAmountReceived,\n        address zrxAllowanceTarget,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 deadline\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            block.timestamp <= deadline,\n            \"Swap::swapByQuote: Deadline exceeded\"\n        );\n        require(\n            !signifiesETHOrZero(zrxSellTokenAddress) || msg.value > 0,\n            \"Swap::swapByQuote: Unwrapped ETH must be swapped via msg.value\"\n        );\n\n        // if zrxAllowanceTarget is 0, this is an ETH sale\n        if (zrxAllowanceTarget != address(0)) {\n            // transfer tokens to this contract\n            IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell);\n            // approve token transfer to 0x contracts\n            // TODO (handle approval special cases like USDT, KNC, etc)\n            IERC20(zrxSellTokenAddress).safeIncreaseAllowance(zrxAllowanceTarget, amountToSell);\n        }\n\n        // execute 0x quote\n        (uint256 boughtERC20Amount, uint256 boughtETHAmount) = fillZrxQuote(\n            IERC20(zrxBuyTokenAddress),\n            zrxTo,\n            zrxData,\n            msg.value\n        );\n\n        require(\n            (\n                !signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtERC20Amount >= minimumAmountReceived\n            ) ||\n            (\n                signifiesETHOrZero(zrxBuyTokenAddress) &&\n                boughtETHAmount >= minimumAmountReceived\n            ),\n            \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n        );\n        if (boughtERC20Amount > 0) {\n            // take the swap fee from the ERC20 proceeds and return the rest\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n            IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n            // return any refunded ETH\n            payable(msg.sender).transfer(boughtETHAmount);\n\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtERC20Amount,\n                boughtERC20Amount.sub(toTransfer)\n            );\n        } else {\n\n            // take the swap fee from the ETH proceeds and return the rest. Note\n            // that if any 0x protocol fee is refunded in ETH, it also suffers\n            // the swap fee tax\n            uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n            payable(msg.sender).transfer(toTransfer);\n            emit SwappedTokens(\n                zrxSellTokenAddress,\n                zrxBuyTokenAddress,\n                amountToSell,\n                boughtETHAmount,\n                boughtETHAmount.sub(toTransfer)\n            );\n        }\n        if (zrxAllowanceTarget != address(0)) {\n            // remove any dangling token allowance\n            IERC20(zrxSellTokenAddress).safeApprove(zrxAllowanceTarget, 0);\n        }\n    }\n\n    /// @notice Fill a 0x quote as provided by the API, and return any ETH or\n    ///         ERC20 proceeds.\n    /// @dev Learn more at https://0x.org/docs/api\n    /// @param zrxBuyTokenAddress The contract address of the token to be bought,\n    ///        as provided by the 0x API. `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n    ///        signifies the user is buying unwrapped ETH.\n    /// @param zrxTo Contract to fill the 0x quote, as provided by the 0x API\n    /// @param zrxData Data encoding the 0x quote, as provided by the 0x API\n    /// @param ethAmount The amount of ETH required to fill the quote, including\n    ///        any ETH being traded as well as protocol fees\n    /// @return any positive `zrxBuyTokenAddress` ERC20 balance change, as well\n    ///         as any positive ETH balance change\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    /// @notice Test whether an address is zero, or the magic address the 0x\n    ///         platform uses to signify \"unwrapped ETH\" rather than an ERC20.\n    /// @param tokenAddress An address that might point toward an ERC-20.\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    /// @notice Sweeps accrued ETH and ERC20 swap fees to the pre-established\n    ///         fee recipient address.\n    /// @dev Fees are tracked based on the contract's balances, rather than\n    ///      using any additional bookkeeping. If there are bugs in swap\n    ///      accounting, this function could jeopardize funds.\n    /// @param tokens An array of ERC20 contracts to withdraw token fees\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @dev Base for contracts with actions that should be emergency-governable.\n///      Implies Ownable, and assumes the owner is a\n///      TimelockGovernorWithEmergencyGovernance. Provides the\n///      onlyTimelockOrEmergencyGovernance modifier, which allows the system\n///      governor's timelock OR the system governor's emergency governance\n///      address to make a change.\ncontract EmergencyGovernable is Ownable {\n    /// @dev Casts the owner to the expected\n    ///      TimelockGovernorWithEmergencyGovernance interface.\n    function governor()\n        internal\n        view\n        returns (TimelockGovernorWithEmergencyGovernance)\n    {\n        return TimelockGovernorWithEmergencyGovernance(owner());\n    }\n\n    /// @dev Assumes this contract's owner is a governor implementing\n    ///      TimelockGovernorWithEmergencyGovernance, and only allows\n    ///      the modified function to be invoked from that governor's\n    ///      timelock.\n    ///\n    ///      Note that applying this modifier means that transferring ownership\n    ///      to a contract or EOA that does _not_ implement the\n    ///      TimelockGovernorWithEmergencyGovernance interface will prevent\n    ///      the modified function from being called. The governor is _not_\n    ///      permitted to call the modified function directly.\n    modifier onlyTimelock {\n        require(\n            msg.sender == governor().timelock(),\n            \"Only governor may call this function.\"\n        );\n        _;\n    }\n\n    /// @dev Assumes this contract's owner is a governor implementing\n    ///      TimelockGovernorWithEmergencyGovernance, and only allows\n    ///      the modified function to be invoked from either that governor's\n    ///      timelock or its emergency governance address.\n    ///\n    ///      Note that applying this modifier means that transferring ownership\n    ///      to a contract or EOA that does _not_ implement the\n    ///      TimelockGovernorWithEmergencyGovernance interface will prevent\n    ///      the modified function from being called. The governor is _not_\n    ///      permitted to call the modified function directly.\n    modifier onlyTimelockOrEmergencyGovernance {\n        require(\n            msg.sender == governor().emergencyGovernance() ||\n                msg.sender == governor().timelock(),\n            \"Only emergency governor or governor may call this function.\"\n        );\n        _;\n    }\n}\n\ninterface TimelockGovernorWithEmergencyGovernance {\n    function timelock() external returns (address);\n\n    function emergencyGovernance() external returns (address);\n}\n\n\n",
        "CodeNames": [
            "Swap.sol",
            "EmergencyGovernable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "feeRecipient",
                    "transfer()"
                ],
                "Type": " Swap.sol implements potentially dangerous transfer ",
                "Description": "\nThe use of transfer()  in  Swap.sol   may have unintended outcomes on the eth being sent to the receiver. Eth may be irretrievable or undelivered if the msg.sender   or feeRecipient   is a smart contract. Funds can potentially be lost if;\n\n1.  The smart contract fails to implement the payable fallback function\n2.  The fallback function uses more than 2300 gas units\n\nThe latter situation may occur in the instance of gas cost changes. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.\n\nThis issue directly impacts the following lines of code:\nL257(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L257)\nL173(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L173)\nL158(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L158)\n\nExamples of similar issues ranked as medium can be found here(https://github.com/code-423n4/2021-08-notional-findings/issues/15) and here, just search for 'M04'(https://blog.openzeppelin.com/opyn-gamma-protocol-audit/). A detailed explanation of why relying on payable().transfer() may result in unexpected loss of eth can be found here(https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)\n\nManual review\n\n",
                "Repair": "Re-entrancy has been accounted for in all functions that reference  Solidity's     transfer()   . This has been done by using a re-entrancy guard, therefore, we can rely on   msg.sender.call.value(amount)  or using the OpenZeppelin Address.sendValue library(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63)\n\nShadowfiend (Tally) acknowledged(https://github.com/code-423n4/2021-10-tally-findings/issues/20)\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nif (boughtERC20Amount  0) {\n    // take the swap fee from the ERC20 proceeds and return the rest\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n    IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n    // return any refunded ETH\n    payable(msg.sender).transfer(boughtETHAmount);\n\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtERC20Amount,\n        boughtERC20Amount.sub(toTransfer)\n    );\n} else {\n\n    // take the swap fee from the ETH proceeds and return the rest. Note\n    // that if any 0x protocol fee is refunded in ETH, it also suffers\n    // the swap fee tax\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n    payable(msg.sender).transfer(toTransfer);\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtETHAmount,\n        boughtETHAmount.sub(toTransfer)\n    );\n}\n"
                ],
                "Type": " Unused ERC20 tokens are not refunded",
                "Description": "\nBased on the context and comments in the code, we assume that it's possible that there will be some leftover sell tokens, not only when users are selling unwrapped ETH but also for ERC20 tokens.\n\nHowever, in the current implementation, only refunded ETH is returned (L158).\n\nBecause of this, the leftover tkoens may be left in the contract unintentionally.\n\nSwap.sol L153-L181(https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L153-L181)\n\nsolidity\nif (boughtERC20Amount  0) {\n    // take the swap fee from the ERC20 proceeds and return the rest\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n    IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n    // return any refunded ETH\n    payable(msg.sender).transfer(boughtETHAmount);\n\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtERC20Amount,\n        boughtERC20Amount.sub(toTransfer)\n    );\n} else {\n\n    // take the swap fee from the ETH proceeds and return the rest. Note\n    // that if any 0x protocol fee is refunded in ETH, it also suffers\n    // the swap fee tax\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n    payable(msg.sender).transfer(toTransfer);\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtETHAmount,\n        boughtETHAmount.sub(toTransfer)\n    );\n}\n\n\nShadowfiend (Tally) acknowledged(https://github.com/code-423n4/2021-10-tally-findings/issues/36#issuecomment-960119681):\n  I believe the 0x API does in fact guarantee that we won't have any sell tokens left over, particularly since we intend to use RFQ-T for these quotes, but if not we will fix this... And we may make the change regardless to future-proof.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-10-tally-findings/issues/36#issuecomment-962450934):\n  Downgrading to sev 2\n\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n As I believe this to be a \"leak value\" scenario.\n\n\n",
                "Repair": ""
            }
        ]
    }
]