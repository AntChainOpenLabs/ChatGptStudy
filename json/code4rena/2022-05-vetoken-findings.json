[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract ExtraRewardStashV1 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant WEEK = 7 * 86400;\n    uint256 private constant maxRewards = 8;\n\n    uint256 public pid;\n    address public operator;\n    address public staker;\n    address public gauge;\n    address public rewardFactory;\n\n    uint256 public historicalRewards = 0;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n        uint256 lastActiveTime;\n    }\n    TokenInfo public tokenInfo;\n\n    constructor(\n        uint256 _pid,\n        address _operator,\n        address _staker,\n        address _gauge,\n        address _rFactory\n    ) {\n        pid = _pid;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV1\";\n    }\n\n    function setToken() internal {\n        address token = IGauge(gauge).rewarded_token();\n\n        if (token != address(0)) {\n            //set token address\n            tokenInfo.token = token;\n\n            //create new reward contract\n            (, , , address mainRewardContract, , ) = IDeposit(operator).poolInfo(pid);\n            address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                token,\n                mainRewardContract\n            );\n            tokenInfo.rewardAddress = rewardContract;\n            tokenInfo.lastActiveTime = block.timestamp;\n        }\n    }\n\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n        //first time init\n        if (tokenInfo.token == address(0)) {\n            setToken();\n        }\n\n        if (tokenInfo.token != address(0)) {\n            uint256 before = IERC20(tokenInfo.token).balanceOf(staker);\n            IDeposit(operator).claimRewards(pid, gauge);\n            uint256 newbalance = IERC20(tokenInfo.token).balanceOf(staker);\n            if (newbalance > before) {\n                IStaker(staker).withdraw(tokenInfo.token);\n                tokenInfo.lastActiveTime = block.timestamp;\n\n                //make sure this pool is in active list,\n                IRewardFactory(rewardFactory).addActiveReward(tokenInfo.token, pid);\n\n                //check if other stashes are also active, and if so, send to arbitrator\n                //do this here because processStash will have tokens from the arbitrator\n                uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(\n                    tokenInfo.token\n                );\n                if (activeCount > 1) {\n                    //send to arbitrator\n                    address arb = IDeposit(operator).rewardArbitrator();\n                    if (arb != address(0)) {\n                        IERC20(tokenInfo.token).safeTransfer(arb, newbalance);\n                    }\n                }\n            } else {\n                //check if this reward has been inactive too long\n                if (block.timestamp > tokenInfo.lastActiveTime + WEEK) {\n                    //set as inactive\n                    IRewardFactory(rewardFactory).removeActiveReward(tokenInfo.token, pid);\n                } else {\n                    //edge case around reward ending periods\n                    if (newbalance > 0) {\n                        // - recently active pool\n                        // - rewards claimed to staker contract via someone manually calling claim_rewards() on the gauge\n                        // - rewards ended before the above call, which claimed the last available tokens\n                        // - thus claimRewards doesnt see any new rewards, but there are rewards on the staker contract\n                        // - i think its safe to assume claim will be called within the timeframe, or else these rewards\n                        //     will be unretrievable until some pool starts rewards again\n\n                        //claim the tokens\n                        IStaker(staker).withdraw(tokenInfo.token);\n\n                        uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(\n                            tokenInfo.token\n                        );\n                        if (activeCount > 1) {\n                            //send to arbitrator\n                            address arb = IDeposit(operator).rewardArbitrator();\n                            if (arb != address(0)) {\n                                IERC20(tokenInfo.token).safeTransfer(arb, newbalance);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external pure returns (bool) {\n        //stashRewards() is also called on deposit\n        //so dont need to try withdrawing here for v1\n        // -> move withdraw() call to processStash() which is only called during reward claiming\n        return true;\n    }\n\n    //send all extra rewards to their reward contracts\n    function processStash() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        address token = tokenInfo.token;\n        if (token == address(0)) return true;\n\n        //send to rewards\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if (amount > 0) {\n            historicalRewards = historicalRewards.add(amount);\n            //add to reward contract\n            address rewards = tokenInfo.rewardAddress;\n            if (rewards == address(0)) return true;\n            IERC20(token).safeTransfer(rewards, amount);\n            IRewards(rewards).queueNewRewards(amount);\n        }\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/IDeposit.sol\";\n\ncontract BaseRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n    uint256 constant BLOCKS_PER_DAY = 6450;\n    uint256 constant BLOCKS_PER_YEAR = BLOCKS_PER_DAY * 365;\n    uint256 constant EXTRA_REWARD_POOLS = 3;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event ExtraRewardAdded(address indexed reward);\n    event ExtraRewardCleared();\n    event RewardUpdated(\n        address indexed user,\n        uint256 reward,\n        uint256 rewardPerTokenStored,\n        uint256 lastUpdateTime\n    );\n    event Donated(uint256 queuedRewards);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0), \"!reward setting\");\n        require(extraRewards.length < EXTRA_REWARD_POOLS, \"!extra reward pools exceed\");\n\n        extraRewards.push(_reward);\n        emit ExtraRewardAdded(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n        emit ExtraRewardCleared();\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        emit RewardUpdated(account, rewards[account], rewardPerTokenStored, lastUpdateTime);\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(\n                    totalSupply()\n                )\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(uint256 amount, bool claim) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns (bool)\n    {\n        //also withdraw from linked rewards\n        for (uint256 i = 0; i < extraRewards.length; i++) {\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid, amount, msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(address _account, bool _claimExtras)\n        public\n        updateReward(_account)\n        returns (bool)\n    {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint256 i = 0; i < extraRewards.length; i++) {\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external {\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n        emit Donated(queuedRewards);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    function getAPY() external view returns (uint256) {\n        return rewardRate.mul(BLOCKS_PER_YEAR).mul(1e18).div(totalSupply());\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/ITokenFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IRewards.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\nimport \"./Interfaces/IStash.sol\";\nimport \"./Interfaces/IStashFactory.sol\";\n\ncontract Booster {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // ve3Token reward pool\n    uint256 public lockIncentive = 1000; //incentive to veAsset stakers\n    // veToken reward pool\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    // veToken locking reward pool xVE3D\n    uint256 public stakerLockIncentive;\n    // caller reward\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    // platoform fee\n    uint256 public platformFee; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    uint256 public lockFeesIncentive = 10000; //ve3Token veVeAsset fees percentage\n    uint256 public stakerLockFeesIncentive; //xVE3D veVeAsset fees percentage\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public immutable veAsset;\n    address public immutable feeDistro;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //vetoken rewards\n    address public stakerLockRewards; // veToken lock rewards xVE3D\n    address public lockRewards; //ve3Token rewards(veAsset)\n    address public lockFees; //ve3Token veVeAsset fees\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address veAssetRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n    event OwnerUpdated(address indexed owner);\n    event FeeManagerUpdated(address indexed feeM);\n    event PoolManagerUpdated(address indexed poolM);\n    event FactoriesUpdated(address indexed rfactory, address indexed tfactory);\n    event ArbitratorUpdated(address indexed arb);\n    event VoteDelegateUpdated(address indexed voteDelegate);\n    event RewardContractsUpdated(\n        address indexed rewards,\n        address indexed stakerRewards,\n        address indexed stakerLockRewards\n    );\n    event FeesUpdated(\n        uint256 lockFees,\n        uint256 stakerFees,\n        uint256 stakerLockFee,\n        uint256 callerFees,\n        uint256 platform\n    );\n    event TreasuryUpdated(address indexed treasury);\n    event PoolAdded(\n        address indexed lptoken,\n        address indexed gauge,\n        address indexed token,\n        address rewardPool\n    );\n    event PoolShuttedDown(uint256 indexed pid);\n    event SystemShuttedDown();\n    event Voted(uint256 indexed voteId, address indexed votingAddress, bool support);\n\n    constructor(\n        address _staker,\n        address _minter,\n        address _veAsset,\n        address _feeDistro\n    ) {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        minter = _minter;\n        veAsset = _veAsset;\n        feeDistro = _feeDistro;\n    }\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n        emit OwnerUpdated(_owner);\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    function setFactories(\n        address _rfactory,\n        address _sfactory,\n        address _tfactory\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if (rewardFactory == address(0)) {\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n            emit FactoriesUpdated(_rfactory, _tfactory);\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender == owner, \"!auth\");\n        rewardArbitrator = _arb;\n        emit ArbitratorUpdated(_arb);\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender == voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    function setRewardContracts(\n        address _rewards,\n        address _stakerRewards,\n        address _stakerLockRewards\n    ) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if (lockRewards == address(0)) {\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            stakerLockRewards = _stakerLockRewards;\n        }\n\n        emit RewardContractsUpdated(_rewards, _stakerRewards, _stakerLockRewards);\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        lockFeesIncentive = _lockFeesIncentive;\n        stakerLockFeesIncentive = _stakerLockFeesIncentive;\n\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if (feeToken != _feeToken) {\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards);\n\n            if (_feeToken != veAsset) {\n                IRewards(stakerLockRewards).addReward(\n                    _feeToken,\n                    address(0),\n                    address(0),\n                    address(0),\n                    address(this),\n                    false\n                );\n            }\n\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(\n        uint256 _lockFees,\n        uint256 _stakerFees,\n        uint256 _stakerLockIncentiveFee,\n        uint256 _callerFees,\n        uint256 _platform\n    ) external {\n        require(msg.sender == feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform).add(\n            _stakerLockIncentiveFee\n        );\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        stakerLockIncentive = _stakerLockIncentiveFee;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n        emit FeesUpdated(_lockFees, _stakerFees, _stakerLockIncentiveFee, _callerFees, _platform);\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == feeManager, \"!auth\");\n        treasury = _treasury;\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool) {\n        require(msg.sender == poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0), \"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for veAsset rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateVeAssetRewards(pid, token);\n\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(\n            pid,\n            veAsset,\n            _gauge,\n            staker,\n            _stashVersion\n        );\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                veAssetRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if (stash != address(0)) {\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash, true);\n            IRewardFactory(rewardFactory).setAccess(stash, true);\n        }\n        emit PoolAdded(_lptoken, _gauge, token, newRewardPool);\n\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns (bool) {\n        require(msg.sender == poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken, pool.gauge) {} catch {}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n\n        emit PoolShuttedDown(_pid);\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external {\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token, gauge) {\n                pool.shutdown = true;\n            } catch {}\n        }\n        emit SystemShuttedDown();\n    }\n\n    //deposit lp tokens and stake\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) public returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0), \"!gauge setting\");\n        IStaker(staker).deposit(lptoken, gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this), _amount);\n            address rewardContract = pool.veAssetRewards;\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewards(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender, _amount);\n        }\n\n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns (bool) {\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid, balance, _stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from, _amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken, gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if (stash != address(0) && !isShutdown && !pool.shutdown) {\n            IStash(stash).stashRewards();\n        }\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns (bool) {\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract, \"!auth\");\n\n        _withdraw(_pid, _amount, msg.sender, _to);\n        return true;\n    }\n\n    /**\n     * @notice set valid vote hash on VoterProxy\n     */\n    function setVote(bytes32 _hash, bool valid) external returns (bool) {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).setVote(_hash, valid);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        IStaker(staker).voteGaugeWeight(_gauge, _weight);\n\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool) {\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash, \"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(keccak256(\"set_rewards_receiver(address)\")),\n            stash\n        );\n        IStaker(staker).execute(gauge, uint256(0), data);\n        return true;\n    }\n\n    //claim veAsset and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //veAsset balance\n        uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\n        if (veAssetBal > 0) {\n            uint256 _lockIncentive = veAssetBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = veAssetBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerLockIncentive = veAssetBal.mul(stakerLockIncentive).div(\n                FEE_DENOMINATOR\n            );\n            uint256 _callIncentive = veAssetBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n\n            //send treasury\n            if (treasury != address(0) && treasury != address(this) && platformFee > 0) {\n                //only subtract after address condition check\n                uint256 _platform = veAssetBal.mul(platformFee).div(FEE_DENOMINATOR);\n                veAssetBal = veAssetBal.sub(_platform);\n                IERC20(veAsset).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            veAssetBal = veAssetBal\n                .sub(_lockIncentive)\n                .sub(_callIncentive)\n                .sub(_stakerIncentive)\n                .sub(_stakerLockIncentive);\n\n            //send incentives for calling\n            if (_callIncentive > 0) {\n                IERC20(veAsset).safeTransfer(msg.sender, _callIncentive);\n            }\n\n            //send veAsset to lp provider reward contract\n            address rewardContract = pool.veAssetRewards;\n            IERC20(veAsset).safeTransfer(rewardContract, veAssetBal);\n            IRewards(rewardContract).queueNewRewards(veAssetBal);\n\n            //send lockers' share of veAsset to reward contract\n            if (_lockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(lockRewards, _lockIncentive);\n                IRewards(lockRewards).queueNewRewards(_lockIncentive);\n            }\n            //send stakers's share of veAsset to VE3D reward contract\n            if (_stakerIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerRewards, _stakerIncentive);\n                IRewards(stakerRewards).queueNewRewards(veAsset, _stakerIncentive);\n            }\n\n            //send stakers's lock share of veAsset to VE3D locker reward contract\n            if (_stakerLockIncentive > 0) {\n                IERC20(veAsset).safeTransfer(stakerLockRewards, _stakerLockIncentive);\n                IRewards(stakerLockRewards).queueNewRewards(veAsset, _stakerLockIncentive);\n            }\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from fee distro contract, put in lockers' reward contract\n    function earmarkFees() external returns (bool) {\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n\n        uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);\n        uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(\n            FEE_DENOMINATOR\n        );\n        if (_lockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);\n            IRewards(lockFees).queueNewRewards(_lockFeesIncentive);\n        }\n        if (_stakerLockFeesIncentive > 0) {\n            IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);\n            IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);\n        }\n        return true;\n    }\n\n    //callback from reward contract when veAsset is received.\n    function rewardClaimed(\n        uint256 _pid,\n        address _address,\n        uint256 _amount\n    ) external returns (bool) {\n        address rewardContract = poolInfo[_pid].veAssetRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n        ITokenMinter veTokenMinter = ITokenMinter(minter);\n        //calc the amount of veAssetEarned\n        uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(\n            veTokenMinter.totalWeight()\n        );\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address, _veAssetEarned);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IVoteEscrow.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IFeeDistro.sol\";\nimport \"./Interfaces/IVoting.sol\";\nimport \"./Interfaces/ITokenMinter.sol\";\n\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable veAsset;\n    address public immutable escrow;\n    address public immutable gaugeProxy;\n\n    address public immutable minter;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    string public name;\n    IVoteEscrow.EscrowModle public escrowModle;\n\n    mapping(address => bool) private protectedTokens;\n    mapping(address => bool) private stashPool;\n    mapping(bytes32 => bool) private votes;\n\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    constructor(\n        string memory _name,\n        address _veAsset,\n        address _escrow,\n        address _gaugeProxy,\n        address _minter,\n        IVoteEscrow.EscrowModle _escrowModle\n    ) {\n        name = _name;\n        veAsset = _veAsset;\n        escrow = _escrow;\n        gaugeProxy = _gaugeProxy;\n        owner = msg.sender;\n        minter = _minter;\n        escrowModle = _escrowModle;\n    }\n\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(\n            operator == address(0) || IDeposit(operator).isShutdown() == true,\n            \"needs shutdown\"\n        );\n\n        operator = _operator;\n    }\n\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (_stash != address(0)) {\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    function deposit(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        if (protectedTokens[_token] == false) {\n            protectedTokens[_token] = true;\n        }\n        if (protectedTokens[_gauge] == false) {\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            IGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    //stash only function for pulling extra incentive reward tokens out\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(stashPool[msg.sender] == true, \"!auth\");\n\n        //check protection\n        if (protectedTokens[address(_asset)] == true) {\n            return 0;\n        }\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(msg.sender, balance);\n        return balance;\n    }\n\n    // Withdraw partial funds\n    function withdraw(\n        address _token,\n        address _gauge,\n        uint256 _amount\n    ) public returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    function withdrawAll(address _token, address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        IGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n\n    function increaseAmount(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(veAsset).safeApprove(escrow, 0);\n        IERC20(veAsset).safeApprove(escrow, _value);\n        IVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    function increaseTime(uint256 _value) external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    function release() external returns (bool) {\n        require(msg.sender == depositor, \"!auth\");\n        IVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if\n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value\n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if (votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function voteGaugeWeight(address[] calldata _tokenVote, uint256[] calldata _weight)\n        external\n        returns (bool)\n    {\n        require(msg.sender == operator, \"!auth\");\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            //vote\n            IVoting(gaugeProxy).vote(_tokenVote, _weight);\n        } else {\n            for (uint256 i = 0; i < _tokenVote.length; i++) {\n                IVoting(gaugeProxy).vote_for_gauge_weights(_tokenVote[i], _weight[i]);\n            }\n        }\n        return true;\n    }\n\n    function claimVeAsset(address _gauge) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n\n        uint256 _balance = 0;\n\n        if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n            try IGauge(_gauge).getReward() {} catch {\n                return _balance;\n            }\n        } else if (\n            escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n            escrowModle == IVoteEscrow.EscrowModle.RIBBON\n        ) {\n            try ITokenMinter(minter).mint(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n            try ITokenMinter(minter).distribute(_gauge) {} catch {\n                return _balance;\n            }\n        } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n            try IGauge(_gauge).claim_rewards() {} catch {\n                return _balance;\n            }\n        }\n\n        _balance = IERC20(veAsset).balanceOf(address(this));\n        IERC20(veAsset).safeTransfer(operator, _balance);\n\n        return _balance;\n    }\n\n    function claimRewards(address _gauge) external returns (bool) {\n        require(msg.sender == operator, \"!auth\");\n        IGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    function claimFees(address _distroContract, address _token) external returns (uint256) {\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistro(_distroContract).claim();\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }\n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return IGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator, \"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value: _value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n}\n\n\n",
        "CodeNames": [
            "ExtraRewardStashV1.sol",
            "BaseRewardPool.sol",
            "Booster.sol",
            "VoterProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "\n//claim veAsset and extra rewards and disperse to reward contracts\nfunction _earmarkRewards(uint256 _pid) internal {\n    PoolInfo storage pool = poolInfo[_pid];\n    require(pool.shutdown == false, \"pool is closed\");\n\n    address gauge = pool.gauge;\n\n    //claim veAsset\n    IStaker(staker).claimVeAsset(gauge);\n\n    //check if there are extra rewards\n    address stash = pool.stash;\n    if (stash != address(0)) {\n        //claim extra rewards\n        IStash(stash).claimRewards();\n        //process extra rewards\n        IStash(stash).processStash();\n    }\n\t..SNIP..\n}\n",
                    "\nfunction claimVeAsset(address _gauge) external returns (uint256) {\n    require(msg.sender == operator, \"!auth\");\n\n    uint256 _balance = 0;\n\n    if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n        try IGauge(_gauge).getReward() {} catch {\n            return _balance;\n        }\n    } else if (\n        escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n        escrowModle == IVoteEscrow.EscrowModle.RIBBON\n    ) {\n        try ITokenMinter(minter).mint(_gauge) {} catch {\n            return _balance;\n        }\n    } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n        try ITokenMinter(minter).distribute(_gauge) {} catch {\n            return _balance;\n        }\n    } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n        try IGauge(_gauge).claim_rewards() {} catch {\n            return _balance;\n        }\n    }\n\n    _balance = IERC20(veAsset).balanceOf(address(this));\n    IERC20(veAsset).safeTransfer(operator, _balance);\n\n    return _balance;\n}\n",
                    "\n@external\n@nonreentrant('lock')\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):\n    \"\"\"\n    @notice Claim available reward tokens for `_addr`\n    @param _addr Address to claim for\n    @param _receiver Address to transfer rewards to if set to\n                     ZERO_ADDRESS, uses the default reward receiver\n                     for the caller\n    \"\"\"\n    if _receiver != ZERO_ADDRESS:\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\n",
                    "\ndef set_rewards_receiver(_receiver: address):\n    \"\"\"\n    @notice Set the default reward receiver for the caller.\n    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\n    \"\"\"\n    self.rewards_receiver[msg.sender] = _receiver\n",
                    "\n//try claiming if there are reward tokens registered\nfunction claimRewards() external returns (bool) {\n    require(msg.sender == operator, \"!authorized\");\n\n    //this is updateable from v2 gauges now so must check each time.\n    checkForNewRewardTokens();\n\n    //make sure we're redirected\n    if (!hasRedirected) {\n        IDeposit(operator).setGaugeRedirect(pid);\n        hasRedirected = true;\n    }\n\n    uint256 length = tokenCount;\n    if (length  0) {\n        //claim rewards on gauge for staker\n        //using reward_receiver so all rewards will be moved to this stash\n        IDeposit(operator).claimRewards(pid, gauge);\n    }\n    return true;\n}\n"
                ],
                "Type": " Gauge Rewards Stuck In  VoterProxy  Contract When  ExtraRewardStashV3  Is Used Within Angle Deployment",
                "Description": "\n Note: This report aims to discuss the issue encountered when ExtraRewardStashV3 is used within Angle Deployment. There is also another issue when ExtraRewardStashV2 is used within Angle Deployment, but I will raise it in a separate report since ExtraRewardStashV2 and ExtraRewardStashV3 operate differently, and the proof-of-concept and mitigation are different too.\n\n\nIn this example, assume the following Angle's gauge setup\n\n Name = Angle sanDAI_EUR Gauge\n\n Symbol = SsanDAI_EUR\n\n reward_count = 2\n\n reward_tokens(0) = ANGLE\n\n reward_tokens(1) = DAI\n\n Gauge Contract: LiquidityGaugeV4.vy(https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy)\n\n Stash Contract: ExtraRewardStashV3(https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol)\n\nTo collect the gauge rewards, users would trigger the Booster._earmarkRewards function to claim veAsset and extra rewards from a gauge.\n\nPer the code logic, the function will attempt to execute the following two key operations:\n\n1.  First Operation  Claim the veAsset by calling VoterProxy.claimVeAsset. Call Flow as follow: VoterProxy.claimVeAsset()  IGauge(_gauge).claim_rewards().\n2.  Second Operation Claim extra rewards by calling ExtraRewardStashV3.claimRewards. Call flow as follows: ExtraRewardStashV3.claimRewards  Booster.claimRewards  VoterProxy.claimRewards  IGauge(_gauge).claim_rewards() .\n\nNote thatIGauge(_gauge).claim_rewards() will claim all available reward tokens from the Angle's gauge.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495\n\n\n//claim veAsset and extra rewards and disperse to reward contracts\nfunction _earmarkRewards(uint256 _pid) internal {\n    PoolInfo storage pool = poolInfo[_pid];\n    require(pool.shutdown == false, \"pool is closed\");\n\n    address gauge = pool.gauge;\n\n    //claim veAsset\n    IStaker(staker).claimVeAsset(gauge);\n\n    //check if there are extra rewards\n    address stash = pool.stash;\n    if (stash != address(0)) {\n        //claim extra rewards\n        IStash(stash).claimRewards();\n        //process extra rewards\n        IStash(stash).processStash();\n    }\n\t..SNIP..\n}\n\n\n\nSince this is a Angle Deployment, when the VoterProxy.claimVeAsset is triggered,  it will go through the if-else logic (escrowModle == IVoteEscrow.EscrowModle.ANGLE) and execute   IGauge(_gauge).claim_rewards() , and all rewards tokens will be sent to VoterProxy contract. Assume that 100 ANGLE and 100 DAI were received.\n\nNote that in this example, we have two reward tokens (ANGLE and DAI). Additionally, gauge redirection was not configured on the gauge at this point, thus the gauge rewards will be sent to the caller, which is the VoterProxy contract.\n\nSubsequently, the code IERC20(veAsset).safeTransfer(operator, _balance); will be executed, and veAsset (100 ANGLE) reward tokens will be transferred to the Booster contract for distribution. However, the 100 DAI reward tokens will remain stuck in the VoterProxy contract. As such, users will not be able to get any reward tokens (e.g. DAI, WETH) except veAsset (ANGLE) tokens from the gauges.\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224\n\n\nfunction claimVeAsset(address _gauge) external returns (uint256) {\n    require(msg.sender == operator, \"!auth\");\n\n    uint256 _balance = 0;\n\n    if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {\n        try IGauge(_gauge).getReward() {} catch {\n            return _balance;\n        }\n    } else if (\n        escrowModle == IVoteEscrow.EscrowModle.CURVE ||\n        escrowModle == IVoteEscrow.EscrowModle.RIBBON\n    ) {\n        try ITokenMinter(minter).mint(_gauge) {} catch {\n            return _balance;\n        }\n    } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {\n        try ITokenMinter(minter).distribute(_gauge) {} catch {\n            return _balance;\n        }\n    } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n        try IGauge(_gauge).claim_rewards() {} catch {\n            return _balance;\n        }\n    }\n\n    _balance = IERC20(veAsset).balanceOf(address(this));\n    IERC20(veAsset).safeTransfer(operator, _balance);\n\n    return _balance;\n}\n\n\nFollowing is Angle's Gauge Contract for reference:\n\n<https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344\n\n(Mainnet Deployed Address: <https://etherscan.io/address/0x8E2c0CbDa6bA7B65dbcA333798A3949B07638026)\n\n Note: Angle Protocol is observed to use LiquidityGaugeV4 contract for all of their gauges. Thus, ExtraRewardStashV3 is utilised during pool creation.\n\n\n@external\n@nonreentrant('lock')\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):\n    \"\"\"\n    @notice Claim available reward tokens for _addr\n    @param _addr Address to claim for\n    @param _receiver Address to transfer rewards to if set to\n                     ZERO_ADDRESS, uses the default reward receiver\n                     for the caller\n    \"\"\"\n    if _receiver != ZERO_ADDRESS:\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\n\n\n\nAfter the IStaker(staker).claimVeAsset(gauge); code within the Booster._earmarkRewards function is executed, IStash(stash).claimRewards();  and IStash(stash).processStash(); functions will be executed next. stash == ExtraRewardStashV3.\n\nThe ExtraRewardStashV3.claimRewards will call the Booster.setGaugeRedirect first so that all the gauge rewards will be redirected to ExtraRewardStashV3 stash contract. Subsequently, ExtraRewardStashV3.claimRewards will trigger Booster.claimRewards to claim the gauge rewards from the Angle's gauge.\n\nNote that this is the second time the contract attempts to claim gauge rewards from the gauge. Thus, no gauge rewards will be received since we already claimed them earlier. Next, ExtraRewardStashV3 will attempt to process all the tokens stored in its contract and send them to the respective reward contracts for distribution to the users. However, the contract does not have any tokens stored in it because the earlier attempt to claim gauge rewards return nothing.\n\nAs we can see, the DAI reward tokens are still stuck in the VoterProxy contract at this point.\n\n<https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332\n\n\ndef set_rewards_receiver(_receiver: address):\n    \"\"\"\n    @notice Set the default reward receiver for the caller.\n    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\n    @param _receiver Receiver address for any rewards claimed via claim_rewards\n    \"\"\"\n    self.rewards_receiver[msg.sender] = _receiver\n\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61\n\n\n//try claiming if there are reward tokens registered\nfunction claimRewards() external returns (bool) {\n    require(msg.sender == operator, \"!authorized\");\n\n    //this is updateable from v2 gauges now so must check each time.\n    checkForNewRewardTokens();\n\n    //make sure we're redirected\n    if (!hasRedirected) {\n        IDeposit(operator).setGaugeRedirect(pid);\n        hasRedirected = true;\n    }\n\n    uint256 length = tokenCount;\n    if (length  0) {\n        //claim rewards on gauge for staker\n        //using reward_receiver so all rewards will be moved to this stash\n        IDeposit(operator).claimRewards(pid, gauge);\n    }\n    return true;\n}\n\n\n\nUser's gauge rewards are frozen/stuck in VoterProxy contract. Additionally, there is no method to sweep/collect the reward tokens stuck in the VoterProxy contract.\n\n",
                "Repair": "\n Note: I do not see Booster.setGaugeRedirect being called in the deployment and testing scripts. Thus, it is fair to assume that the team is not aware of the need to trigger Booster.setGaugeRedirect during deployment. If the gauge redirection has been set to the stash contract ExtraRewardStashV3 right from the start before anyone triggered the earmarkRewards function, this issue should not occur.\n\nConsider triggering Booster.setGaugeRedirect during the deployment to set gauge redirection to stash contract (ExtraRewardStashV3) so that the Angle's gauge rewards will not be redirected to VoterProxy contract and get stuck there.\n\nAlternatively, update the Booster._earmarkRewards to as follows:\n\n\n//claim veAsset and extra rewards and disperse to reward contracts\nfunction _earmarkRewards(uint256 _pid) internal {\n\tPoolInfo storage pool = poolInfo[_pid];\n\trequire(pool.shutdown == false, \"pool is closed\");\n\n\taddress stash = pool.stash;\n\tif (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {\n\t\t//claims gauges rewards\n\t\tIStash(stash).claimRewards();\n\t\t//process gauges rewards\n\t\tIStash(stash).processStash();\n\t} else {\n\t\t//claim veAsset\n        IStaker(staker).claimVeAsset(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if (stash != address(0)) {\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\t}\n\n\t//veAsset balance\n    uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));\n\t..SNIP..\n}\n\n\nThere is no need to specifically call VoterProxy.claimVeAsset to fetch ANGLE for Angle Protocol because calling IStash(stash).claimRewards() will fetch both ANGLE and other reward tokens from the gauge anyway. When the stash contract receives the ANGLE tokens, it will automatically transfer all of them back to Booster contract when IStash(stash).processStash() is executed. The IStash(stash).claimRewards() function also performs a sanity check to ensure that the gauge redirection is pointing to itself before claiming the gauge rewards, and automatically configure them if it is not, so it will not cause the reward tokens to get stuck in VoterProxy contract.\n\n*   Curve uses an older version of LiquidityGauge contract. Thus, two calls are needed (Minter.mint to claim CRV and LiquidityGauge.claim_rewards to claim other rewards).\n\n*   Angle uses newer version of LiquidityGauge (V4) contract that just need one function call (LiquidityGauge.claim_rewards ) to fetch both veAsset and other rewards.\n\n*   IDLE uses LiquidityGauge (V3) contract. veAsset (IDLE) is minted by calling DistributorProxy.distribute and gauge rewards are claimed by calling LiquidityGauge.claim_rewards.\n\nDue to the discrepancies between different protocols in the reward claiming process, additional care must be taken to ensure that the flow of veAsset and gauge rewards are transferred to the appropriate contracts during integration. Otherwise, rewards will be stuck.\n\nLastly, I only see test cases written for claiming veAsset from the gauge. For completeness, it is recommended to also write test cases for claiming extra rewards from the gauge apart from veAsset.\n\nsolvetony (veToken Finance) confirmed and commented(https://github.com/code-423n4/2022-05-vetoken-findings/issues/209#issuecomment-1156668018):\n  Good catch, this issue is because Angle uses the same function for claim veAsset and extra rewards. \n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-05-vetoken-findings/issues/209#issuecomment-1193419949):\n  The warden has shown how Angle protocol will break certain invariants as the code assumes that claiming of veAsset to always be separate from claiming of additionalRewards.\n \n Due to this any additional reward emitted by the Angle Gauge will be stuck in the claiming contract.\n \n While impact is limited to loss of yield (loss of additional tokens), because the finding has broken the assumptions of the contract, meaning that Angle Protocol should not be integrated without a fix, I believe High Severity to be appropriate.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-05-vetoken-findings/issues/209#issuecomment-1199815504):\n  Upon further review, we may raise the concern of the contract being out of scope.\n \n However, given that:\n The sponsor Confirmed\n The vulnerability would be present in a normal configuration\n \n I believe the finding is of High Severity.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]