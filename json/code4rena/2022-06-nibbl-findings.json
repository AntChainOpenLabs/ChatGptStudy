[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "sell()",
                    "redeem()",
                    "buy()",
                    "bidder",
                    "initiateBuyout()",
                    "BUYOUT_DURATION",
                    "withdrawERC"
                ],
                "Type": " Buyout cannot be rejected when paused",
                "Description": "\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L300\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L362\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L464\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L495\n\n\nWhile buy() and sell() are only callable when the system is not paused, redeem() and withdrawERC721() are also callable when it is not. This means that the BUYOUT_DURATION is ignored in such cases and it is possible that users are not able to reject certain buyouts.\n\n\nA user initiates a buyout via initiateBuyout(). Just afterwards, the system is stopped. The token holders now cannot buy new tokens to increase the value. However, after two days, the bidder can still withdraw the NFT, i.e. there was no way for the users to reject this buyout.\n\n",
                "Repair": "\nIt should be possible to reset the buyoutEndTime (to the current block.timestamp) when the system is paused such that the token holders always have the possibility to reject a buyout.\n\nmundhrakeshav (Nibbl) disputed and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166321982):\n  Expected. When paused no operations should be available.\n\nfatherGoose1 (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166685840):\n  Strongly disagree with the sponsor's comment. Given that redeem()(https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L464) and withdrawERC721()(https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L495) DO NOT contain the whenNotPaused modifier, this ensures that pauses that occur during a buyout process will ensure the success of the buyout. The buyout success occurs by time passing a certain block.timestamp and the functionality to claim the NFT and retrieve the underlying are left open even during the pause. \n \n Similar to issue #261(https://github.com/code-423n4/2022-06-nibbl-findings/issues/261)\n \n I would agree with the sponsor if all of the withdraw()/redeem() functions contained the whenNotPaused modifier so that truly all functions were locked during a pause.\n\nmundhrakeshav (Nibbl) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1166747212):\n  Hmmm. Makes sense. We should pause redeem and Withdraw too.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/55#issuecomment-1170641593):\n  The readme does include \"Out of scope: Admin can pause and change certain parameters of the contract.\" however this report is not strictly about the ability to pause.\n \n  It should be possible to reset the buyoutEndTime\n \n In this scenario, an end time has already been defined. If pause is used at that time the window shortens or closes so when resumed the opportunity may have been missed already. The warden's recommendation here, or some variation of it, would provide a way to effectively allow the system to resume from where it left off when originally paused.\n \n I suspect the alternative of also pausing redeem / withdraw is not sufficient, as the window to buy/sell will still potentially be passed by the time the system resumes.\n \n I agree with the submitted Med risk for this issue since the \"function of the protocol or its availability could be impacted\".\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n    }\n}\n",
                    "//solidity\nfunction update() external {\n    (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n        UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n    uint32 timeElapsed = blockTimestamp blockTimestampLast; // overflow is desired\n"
                ],
                "Type": "  Twav.sol#_getTwav()  will revert when timestamp > 4294967296",
                "Description": "\nsolidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n    }\n}\n\n\nSince _blockTimestamp is uint32, subtraction underflow is desired at _twavObservationCurrent.timestamp _twavObservationPrev.timestamp.\n\nSee: <https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol#L43\n\nsolidity\nfunction update() external {\n    (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n        UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n    uint32 timeElapsed = blockTimestamp blockTimestampLast; // overflow is desired\n\n\nBecause the solidity version used by the current implementation is 0.8.10, and there are some breaking changes in Solidity v0.8.0:\n\n Arithmetic operations revert on underflow and overflow.\n\nRef: <https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics\n\nThe timestamp subtraction may revert due to underflow.\n\n\nSince _getTwav() is used in NibblVault.sol#_rejectBuyout(), if it reverts and there is a buyout, an essential feature of the NibblVault contract will be unavailable, causing users' funds to be frozen in the contract.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    unchecked {\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    }\n    \n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n\n\nsolidity\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        unchecked {\n            _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n        }\n    }\n}\n\nmundhrakeshav (Nibbl) acknowledged, but disagreed with severity(https://github.com/code-423n4/2022-06-nibbl-findings/issues/178)\n\nKenzoAgada (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166164271):\n  If I'm not mistaken, timestamp 4294967296 is 2106, I wouldn't call the contract breaking in 84 years a high severity issue. Plus the contract is truncating the timestamp on purpose. Seems to me more like a design choice and less of a bug.\n\nmingwatch (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166798846):\n   If I'm not mistaken, timestamp 4294967296 is 2106, I wouldn't call the contract breaking in 84 years a high severity issue. Plus the contract is truncating the timestamp on purpose. Seems to me more like a design choice and less of a bug.\n \n https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Twav/Twav.sol#L23-L25\n \n solidity\n function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n         uint32 _timeElapsed; \n         unchecked {\n             _timeElapsed = _blockTimestamp lastBlockTimeStamp;\n         }\n  \n  \n According to the above code, is obviously not a design choice.\n  \n\nKenzoAgada (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1166807275):\n   According to the above code, is obviously not a design choice.\n \n Ah, I think I understand what you mean, it is not handled consistently.\n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/178#issuecomment-1171706893):\n   it is not handled consistently\n \n Thanks for the clarifications!\n \n _getTwav would overflow once timestamps overflow uint32, but only when the current observation has overflowed while the previous observation did not.\n \n The window for this vulnerability is very small, just at the time timestamp starts to overflow in 2106 vaults active before or after that time should work as expected. \n \n This appears to be a Medium risk finding.  There's potentially a case to be made for high here but it's hard to make that call without a more complete POC included. The vault is an upgradeable contract so they have 84 years to sort this out -but it does seem like an issue that should be fixed.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "primaryReserveBalance",
                    "_chargeFee",
                    "(primaryReserveRatio * _initialTokenSupply * _initialTokenPrice)",
                    "_primaryReserveBalance",
                    "initiateBuyout",
                    "minBuyoutTime",
                    "sell",
                    "(SCALE *",
                    "buy",
                    "fictitiousPrimaryReserveBalance"
                ],
                "Type": " Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT",
                "Description": "\nThere is no sanity check to ensure that (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) is \u2265 (SCALE * 1e18). As a result, _primaryReserveBalance is given a value of 0 since divisions in solidity are rounded down. This also means that primaryReserveBalance and fictitiousPrimaryReserveBalance have a value of 0.\n\nWhen this happens, the buy function doesn\u2019t work because _chargeFee will revert on line 222(https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L222). You can\u2019t sell either since totalSupply == initialSupply. The only way to recover the NFT is for the owner of the NFT to call initiateBuyout but there is always the possibility that someone else also spotted this mistake and will attempt to also call initiateBuyout once the minBuyoutTime is reached. If the owner loses this gas war, the owner has effectively lost his NFT.\n\n",
                "Repair": "\nAdd some sanity checks to ensure a sane expected value for _initialTokenSupply and _initialTokenPrice. There were multiple instances when a user tried to interact with a contract but entered a wrong value because they are not aware they needed to include decimals. A recent example of this is <https://cointelegraph.com/news/1-million-rock-nft-sells-for-a-penny-in-all-ore-nothing-error.\n\n*\n\n*Note: Normally, I would categorise issues like this as medium severity since it is a loss predicated on having met certain conditions but because there is also a lack of sanity check on _minBuyoutTime, it is entirely possible for a seller to lose his NFT immediately once the vault is created. There are many monsters waiting in the dark forest, all it takes is one mistake. That said, I will defer the final judgement to the judges & sponsors.*\n\nmundhrakeshav (Nibbl) disputed, disagreed with severity and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1166304473):\n  Case when that would happen is _initialTokenSupply or _initialTokenPrice is 0. But then it would revert here\n https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1172976012):\n   Case when that would happen is _initialTokenSupply or _initialTokenPrice is 0.\n \n primaryReserveRatio = 200_000 and SCALE = 1_000_000 -so it seems this applies anytime _initialTokenSupply * _initialTokenPrice < 1_000_000 * 1e18 / 200_000, not just when one of those values is 0. Please correct me if I got that wrong.\n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/24#issuecomment-1172977395):\n  This is a good report. I agree this seems like something that should be addressed. Assuming my math is right, if the initialTokenPrice was 1 wei then the initialTokenSupply must be = 5e18. They are using the default of 18 decimals (which is also industry standard) so that's 5 tokens. Given this is not very large window and these values impact the curve -without a clear POC High would not be warranted, downgrading to Medium risk.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "initialize",
                    "uint",
                    "_initialTokenSupply",
                    "_initialTokenPrice",
                    "SCALE *",
                    "_secondaryReserveRatio"
                ],
                "Type": " [PNM-004",
                "Description": "\nuint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n_secondaryReserveRatio can be overflowed by setting a relatively small _initialTokenSupply and _initialTokenPrice. The result will be truncated by uint32, causing an overflow.\n\nThis overflow can bypass all the checks in function initialize. Any following functionality will be impacted since the _secondaryReserveRatio is incorrect.\n\n\n*   The user provide _initialTokenSupply and _initialTokenPrice, which meets SCALE * 1e18 == _initialTokenSupply * _initialTokenPrice\n*   The msg.value is set as 2  32 + X, where MIN_SECONDARY_RESERVE_RATIO <= X <= primaryReserveRatio. Note that msg.value is in Wei, so the deposited fund is not huge.\n\n\nAdd overflow checks.\n\nmundhrakeshav (Nibbl) acknowledged(https://github.com/code-423n4/2022-06-nibbl-findings/issues/273)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/273#issuecomment-1173223715):\n  OpenZeppelin has safe cast helpers that could be leveraged here.\n \n It is concerning that due to the truncation here, the configuration would not work how the user expects given the input parameters. And at this point the NFT has been escrowed into the vault. Because of this it seems Medium risk is a fair assessment. \n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n91:       function withdrawMultipleERC20(address[] memory _tokens) external override {\n\n99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n\n104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n41:           string memory _name,\n\n42:           string memory _symbol,\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n174:          string memory _tokenName, \n\n175:          string memory _tokenSymbol, \n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n"
                ],
                "Type": " Using  calldata  instead of  memory  for read-only arguments in  external  functions saves gas",
                "Description": "\nWhen a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution.\n\nIf the array is passed to an internal function which passes the array to another internal function where the array is modified and therefore memory is used in the external call, it's still more gass-efficient to use calldata when the external function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\n*There are 23 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n91:       function withdrawMultipleERC20(address[] memory _tokens) external override {\n\n99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n\n104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n41:           string memory _name,\n\n42:           string memory _symbol,\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41\n\nsolidity\nFile: contracts/NibblVault.sol\n\n174:          string memory _tokenName, \n\n175:          string memory _tokenSymbol, \n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174\n\n\n",
                "Repair": ""
            },
            {
                "Name": "8",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n",
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #2\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n",
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #3\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n"
                ],
                "Type": " Using  private  rather than  public  for constants, saves gas",
                "Description": "\nIf needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #2\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #3\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 232);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n"
                ],
                "Type": " User Could Change The State Of The System While In  Pause  Mode",
                "Description": "\nCalling NibblVault.updateTWAP function will change the state of the system. It will cause the TWAP to be updated and buyout to be rejected in certain condition.\n\nWhen the system is in Pause mode, the system state should be frozen. However, it was possible for someone to call the NibblVault.updateTWAP function during the Pause mode, thus making changes to the system state.\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L443\n\nsolidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 232);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n\n\n",
                "Repair": "\nEnsure that the NibblVault.updateVault function cannot be called when the system is in Pause mode.\n\nAdd the whenNotPaused modifier to the function.\n\nsolidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override whenNotPaused {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 232);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n\n\nmundhrakeshav (Nibbl) marked as duplicate and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/200#issuecomment-1166505154):\n  Duplicate of #56(https://github.com/code-423n4/2022-06-nibbl-findings/issues/56)\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/200#issuecomment-1173872782):\n   #56\n \n It's not clear to me how this is a dupe of #56 \n \n This is a valid concern and potentially a change worth making.\n \n   It will cause the TWAP to be updated and buyout to be rejected\n \n This makes me think Medium risk is correct here. In this scenario a buyout could be rejected without allowing other users to challenge that -seemingly breaking one of the benefits behind using Twap for this logic.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\n/// @notice current index of twavObservations index\nuint8 public twavObservationsIndex;\nuint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \nuint32 public lastBlockTimeStamp;\n\n/// @notice record of TWAV \nTwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n/// @notice updates twavObservations array\n/// @param _blockTimestamp timestamp of the block\n/// @param _valuation current valuation\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n",
                    "//solidity\n/// @notice returns the TWAV of the last 4 blocks\n/// @return _twav TWAV of the last 4 blocks\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n    }\n}\n"
                ],
                "Type": " Ineffective TWAV Implementation",
                "Description": "\nThe current TWAV implementation consists of an array of 4 observations/valuations called twavObservations. Whenever, the new valuation is updated, the new cumulative valuation will be appended to the twavObservations array and the oldest observation/valuation will be removed from the twavObservations array.\n\nDescription of current TWAV implementation can be found at <https://github.com/NibblNFT/nibbl-smartcontracts#twavsol\n\n *   Time-weighted average valuation\n *   Uses an array of length 4 which stores cumulative valuation and timestamp.\n *   TWAV is calculated between the most and least recent observations recorded in the array.\n *   TWAV array is updated only when the system is in buyout state. In case of buyout rejection, the array is reset.\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L11\n\nsolidity\n/// @notice current index of twavObservations index\nuint8 public twavObservationsIndex;\nuint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \nuint32 public lastBlockTimeStamp;\n\n/// @notice record of TWAV \nTwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n/// @notice updates twavObservations array\n/// @param _blockTimestamp timestamp of the block\n/// @param _valuation current valuation\nfunction _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n    uint32 _timeElapsed; \n    unchecked {\n        _timeElapsed = _blockTimestamp lastBlockTimeStamp;\n    }\n\n    uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n    twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n    lastBlockTimeStamp = _blockTimestamp;\n}\n\n\nWithin the NibblVault contract, the _updateTWAV function will be called whenever the following events happen during the buyout period:\n\n1.  NibbleVault.buy() and NibbleVault.Sell() functions are called\n2.  NibbleVault.initiateBuyout function is called\n3.  NibbleVault.updateTWAV function is called\n\nPer the code and comment of _getTwav() function, the function will return the TWAV of the last four (4) blocks. This function can be called by anyone.\n\nsolidity\n/// @notice returns the TWAV of the last 4 blocks\n/// @return _twav TWAV of the last 4 blocks\nfunction _getTwav() internal view returns(uint256 _twav){\n    if (twavObservations[TWAV_BLOCK_NUMBERS 1].timestamp != 0) {\n        uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n        TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n        TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n        _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n    }\n}\n\n\nTime weighted average valuation (TWAV) is supposed to be the average value of a security over a specified time (e.g. 15 minutes, 1 hour, 24 hours). However, based on the above implementation of the _getTwav function, it is not the average value of a security over a specific time.\n\nA user could call the updateTWAV function to add the new valuation/observation to the twavObservations array each time a new Ethereum block is mined. As such, the current implementation becomes the average value of a security over a specific number of observations (in this case 4 observations), thus it can be considered as Observation weighted average valuation (OWAV).\n\nThere is a fundamental difference between TWAV and OWAV.\n\n\nIn Ethereum, the average block time is around 15 seconds, so the time to take to mine 4 blocks will be 1 minute. As such, in term of TWAV, the current implementation only have a period of 1 minute, which is too short to prevent price manipulation.\n\nThe following shows an example where it is possible to buy tokens\u2192 increase the valuation above the rejection valuation\u2192 reject the buyout\u2192 dump the tokens within 1 minute:\n\nAssume that a buyer has triggered a buyout on the vault/NFT, and the buyout rejection price is 120 ETH and the current valuation is 100 ETH. Further assume that all elements in the  twavObservations array have already been populated.\n\nNote: Fees are ignored to illustrate the issue.\n\n1.  Block 100 at Time 0 Attacker called buy function to increase the current valuation to 120 ETH attempting to reject the buyout.\n2.  Block 101 at Time 15 Attacker called updateTWAV function. The current valuation (120 ETH) will be replaced the first element in twavObservations array.\n3.  Block 102 at Time 30 Attacker called updateTWAV function. The current valuation (120 ETH) will be replaced the second element in twavObservations array.\n4.  Block 103 at Time 45 Attacker called updateTWAV function. The current valuation (120 ETH) will be replaced the third element in twavObservations array.\n5.  Block 104 at Time 60 Attacker called sell function to sell/dump all his shares. Within the sell function, _updateTWAV will be first called, thus the current valuation (120 ETH) will be replaced the fourth element in twavObservations array. Then, the _rejectBuyout() will be called, and the _getTwav function will be triggered. At this point, the TWAV valuation is finally 120 ETH, thus the buyout is rejected. Subseqently, attacker's shares are burned, and attacker get back his funds.\n\nSince attacker could perform the above attack within 1 minute, it is very unlikely that the attackers will lose money to arbitrageurs as it takes some time for the arbitrageurs to notice such an opportunity.\n\nAttacker could also front-run or set a higher gas fee to ensure that their transaction get mined in the next block to minimize the attack window period.\n\n\nBuyout can be easily rejected by attackers\n\n",
                "Repair": "\nImplement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract.\n\nThere are trade offs when choosing the length of the period of time to calculate a TWAP. Longer periods are better to protect against price manipulation, but come at the expense of a slower, and potentially less accurate, price. Thus, the team should determine the optimal period.\n\nConsider referencing the popular Uniswap V2 TWAP design (<https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles)\n\nmundhrakeshav (Nibbl) disagreed with severity(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191)\n\nsseefried (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1166158748):\n  I had a Low Risk ([#142(https://github.com/code-423n4/2022-06-nibbl-findings/issues/142)) associated with _getTWAV too. I'm not sure it even averages over 4 observations.\n\nPicodes (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1166498885):\n  Some comments, as I personally don't think it's an high security issue:\n \n  the primary goal of the TWAV here is to avoid manipulations within the same block. As long as it's over multiple blocks, the attackers takes a risk as there could be arbitrages, so the attack risk is mitigated.\n  \n   the main assumption of the issue is:  \"it takes some time for the arbitrageurs to notice such an opportunity, and the 4 block window is too short.\" which seems false when you check on chain data: arbitrageurs are frequently super quick to react as it's their primary job: the first to check an opportunity takes it.\n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1173080518):\n  Great summary @Picodes , I agree with both points.\n \n Lowering this to a Medium risk. I may be incorrect, but it seems a secondary goal of Twap is price smoothing to avoid scenarios like what was outlined here. If that's correct then this impacts the function of the protocol and the recommendation is a good consideration.\n\ndmitriia (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174456950):\n  Same here, TWAP is essential to the protocol, while the ability to manipulate the price during last minute breaks the core logic of price discovery by greatly reducing the number of participants. The rationale that 4 blocks are enough and arbitrage is generally quick is sufficient for mainstream cases only, all other trading is at risk of direct manipulation, which is existential risk for the protocol. Can't see why the team pressing for medium here. \n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174459120):\n   Same here, TWAP is essential to the protocol, while the ability to manipulate the price during last minute breaks the core logic of price discovery by greatly reducing the number of participants. The rationale that 4 blocks are enough and arbitrage is generally quick is sufficient for mainstream cases only, all other trading is at risk of direct manipulation, which is existential risk for the protocol. Can't see why the team pressing for medium here.\n \n The stated goal of using Twap in their documentation is the same as above, to prevent same-block attacks. It seems the concern is the implicit behavior expected from using a \"time weighted\" variable. Personally I agree this seems like an area they may want to revisit. However the system behaves correctly and there is a tiny window for bots to respond.\n \n @mundhrakeshav @Picodes would you mind elaborating here as well?\n\nmundhrakeshav (Nibbl) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174608883):\n  Yeah, makes sense. We do plan to increase the array length.\n\nPicodes (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174707038):\n  I fully agree with both of you: it'd be indeed better to increase the array length to increase the robustness, but I still feel this is a medium issue as the system works as intended\n\ndmitriia (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174787468):\n  The system formally/technically works as intended, but being a price discovery engine, where participants having incentives to try to determine the NFT price, it will not be used if the window for such a discovery is mere 4 blocks. Formally the bots will have space to react. Realistically it will happen in the most mainstream cases only, when price discovery isn't much needed. I.e. exactly when the system can bring in something new, adding a mechanics for 'slow' usual users to add price information, it will not work as the set of participants who can add the information to the metric (react to move the price) is shrunk by a tiny reaction window. Who will take part in a price discovery game knowing that last minute bots are always can surface? Quite not everyone. This reduces the traction, and so the amount of information brought in by the system, as this is the users who bring in the additional signal, and ultimately it will be a piece of well known NFTs synched with main market with bots, adding no value to it. I.e. the system will work technically, but economically it will not make much sense, so will not be widely used by market actors and can end up provide little value to broad market. This is what I mean by existential risk, which is, of course high. \n \n I just feel that here and in general in C4 economic issues are tend to be underestimated, while having one usually tend to be a game changing aspect for a project. \n\nIllIllI000 (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1174927014):\n  @HardlyDifficult If the sponsor had used the term OWAV rather than TWAV, would this still be a medium-severity issue? It seems as though they knew the behavior they wanted (at least four user interactions where the average price is above the threshold) and just used the wrong term to describe it. I didn't file this issue because it seemed that way. The screenshot in this issue shows that they're interested in interactions, not duration of time https://github.com/code-423n4/2022-06-nibbl-findings/issues/144. It's possible they confirmed the issue because they weren't aware that comment vs code consistency issues are usually categorized as low risk\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/191#issuecomment-1175170494):\n  Great points @dmitriia and @IllIllI000 ! Both are compelling. This is certainly a grey area.\n \n Given how significantly this impacts how users would potentially view and interact with the system, I'm inclined to leave this a Medium risk instead of downgrading to Low, falling under \"the function of the protocol or its availability could be impacted\".\n \n And since this was intentional design and there is a window for bots to respond, I don't feel that High risk is justified.\n \n I'm happy to continue here or on Discord, and would love more input if others want to chime in on the severity here. I don't feel strongly but do think that Medium is the best fit here.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n303              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n304              if (_blockTimestamp != lastBlockTimeStamp) {\n305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n"
                ],
                "Type": " Buyouts that occur during the timestamp wrap will have valuation errors",
                "Description": "\nThe _blockTimestamp has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The _updateTWAV function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n303              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n304              if (_blockTimestamp != lastBlockTimeStamp) {\n305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n"
                ],
                "Type": "  ecrecover()  not checked for signer address of zero",
                "Description": "\nThe ecrecover() function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n"
                ],
                "Type": " Consider addings checks for signature malleability",
                "Description": "\nUse OpenZeppelin's ECDSA contract rather than calling ecrecover() directly\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n/// @audit 0xff\n72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n\n/// @audit 0xff\n91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n/// @audit 1e18\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n/// @audit 1e18\n195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n\n/// @audit 1e18\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n/// @audit 1e18\n253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n\n/// @audit 32\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n/// @audit 32\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n/// @audit 32\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 232));\n\n/// @audit 32\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n"
                ],
                "Type": "  constant s should be defined rather than using magic numbers",
                "Description": "\nEven assembly(https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals\n\n*There are 10 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n/// @audit 0xff\n72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n\n/// @audit 0xff\n91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72\n\nsolidity\nFile: contracts/NibblVault.sol\n\n/// @audit 1e18\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n/// @audit 1e18\n195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n\n/// @audit 1e18\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n/// @audit 1e18\n253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n\n/// @audit 32\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n/// @audit 32\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n/// @audit 32\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 232));\n\n/// @audit 32\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n27:       function getChainID() internal view returns (uint256 id) {\n"
                ],
                "Type": "  internal  functions only called once can be inlined to save gas",
                "Description": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n27:       function getChainID() internal view returns (uint256 id) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\ncontract Twav {\n    struct TwavObservation {\n        uint32 timestamp;\n        uint256 cumulativeValuation;\n    }\n\n    /// @notice current index of twavObservations index\n    uint8 public twavObservationsIndex;\n    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n    uint32 public lastBlockTimeStamp;\n\n    /// @notice record of TWAV \n    TwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n    /// @notice updates twavObservations array\n    /// @param _blockTimestamp timestamp of the block\n    /// @param _valuation current valuation\n    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n        uint32 _timeElapsed; \n        unchecked {\n            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n        }\n\n        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n        lastBlockTimeStamp = _blockTimestamp;\n    }\n\n    /// @notice returns the TWAV of the last 4 blocks\n    /// @return _twav TWAV of the last 4 blocks\n    function _getTwav() internal view returns(uint256 _twav){\n        if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n            TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n            TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n\n    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n        return twavObservations;\n    }\n}\n\n",
        "CodeNames": [
            "NibblVault.sol",
            "Twav.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "cumulativeValuation",
                    "_getTwav()",
                    "updateTWAV"
                ],
                "Type": "   _updateTwav()  and  _getTwav()  will revert when cumulativePrice overflows",
                "Description": "\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L40\n\n\nContract will break when cumulativeValuation overflows.\n\n\nCumulative prices are designed to work with overflows/underflows because in the end  the difference is important.\n\nIn _updateTwav()  when _prevCumulativeValuation + (_valuation *_timeElapsed)  overflows the contract will not work anymore.\n\n    twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative @audit overflow breaks the contract\n\nSame  problem in _getTwav()\n\n      _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);@audit same overflow breaks the contract\n\n    }\n\n\n<https://github.com/code-423n4/2022-04-phuture-findings/issues/62\n\n\nAdd unchecked keyword in every line you add / subtract cumulative prices.\n\nmundhrakeshav (Nibbl) acknowledged(https://github.com/code-423n4/2022-06-nibbl-findings/issues/246) \n\n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/246#issuecomment-1172978466):\n  Without a better POC of the issue occurring it's hard to justify this is High risk. e.g. maybe it could be forced by spamming updateTWAV, but it's not clear if that would require extremely large values or an unrealistic number of transactions.\n \n Related to https://github.com/code-423n4/2022-06-nibbl-findings/issues/178, that one includes unchecking the price in the recommendation but the rest of the description focuses on timestamp overflows while this one looks at price overflows.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "NibblVaultFactory.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "initiateBuyout",
                    "proposeNewVaultImplementation",
                    "updateVaultImplementation",
                    "BUYOUT_DURATION",
                    "UPDATE_TIME",
                    "vaultImplementation"
                ],
                "Type": " NibblVault buyout duration longer than update timelock",
                "Description": "\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37\n\n\nUser can buy out NFT by initiating the process through initiateBuyout, then he has to wait BUYOUT_DURATION which is 5 days and if the buyout will not get rejected he can claim the NFT. During that period bidder cannot cancel the process. The issue is that since NibblVault is used through proxy it is possible to change its implementation through administrative functionality in NibblVaultFactory and the timelock for update'ing implementation is only 2 days.\n\nAttack Scenario:\n\n1.  Bidder initiates buyout through initiateBuyout\n2.  Administrator of the protocol updates the vaultImplementation through proposeNewVaultImplementation\n3.  Bidder really does not like new implementation but cannot cancel buyout process\n4.  Administrator waits 2 days (the UPDATE_TIME) uses updateVaultImplementation and changes the implementation\n5.  Bidder loses funds/fait in the protocol\n\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158-L169\n\n*   <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L37\n\n\nManual Review / VSCode\n\n",
                "Repair": "\nIt is recommended to either implement functionality for bidder to cancel the bid or increase/decrease the UPDATE_TIME/BUYOUT_DURATION so the invariant BUYOUT_DURATION < UPDATE_TIME holds.\n\nmundhrakeshav (Nibbl) acknowledged, but disagreed with severity(https://github.com/code-423n4/2022-06-nibbl-findings/issues/278) \n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/278#issuecomment-1172985223):\n  It seems the bidder could be left in a bad state, and updating the thresholds here may be a nice way to maintain expectations. Since this scenario is based on the admin making an undesirable change, this is a Medium risk report.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol",
            "NibblVaultFactory.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "safeTransferFrom()",
                    "NFT(id=",
                    "buy()",
                    "initiateBuyout()",
                    "createVault()",
                    "createVault",
                    "_tokens",
                    "withdrawMultipleERC",
                    "NFT",
                    "for"
                ],
                "Type": " Reentrancy bug in Basket's withdraw multiple tokens function which gives attacker ability to transfer basket ownership and spend it but withdraw all the tokens out of basket",
                "Description": "\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41-L47\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68-L75\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91-L97\n\n\nBasket is used for keep multiple tokens in contract and mint one NFT token to represent their ownership. Basket only allows for owner of NFT(id=0) to withdraw tokens from Basket address. users can deposit multiple tokens in one Basket and then create a NibbVault based on that Basket NFT. but due to reentrancy vulnerability in Basket it's possible to call the multiple-token-withdraw functions (withdrawMultipleERC721(), withdrawMultipleERC1155(), withdrawMultipleERC721() and withdrawMultipleERC20()) and in the middle their external calls, spend Basket NFT (transfer ownership of id=0 to other contract, for example createVault()) and receive some fund from other, then in the rest of the multiple-token-withdraw function withdraw all the basket tokens. Basket shouldn't allow transferring ownership of id=0 in the middle of multiple token withdraws.\n\n\nThis is withdrawMultipleERC721() code:\n\n        function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n            require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n                emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n            }\n        }\n\nAs you can see, contract only checks the ownership of id=0 in the beginning of the function to see that user allowed to perform this action or not. then it iterates through user specified addresses and call safeTransferFrom() function in those address by user specified values. the bug is that in the middle of the external calls attacker can spend Basket NFT id=0 (give ownership of that basket to other contracts and receive fund from them, for example attacker can call createVault in NibblVaultFactory and create a vault and call other contracts to invest in that vault) then in the rest of the iterations in withdrawMultipleERC721() attacker can withdraw Basket tokens. so even so the ownership of the Basket has been transferred and attacker received funds for it, attacker withdraw Basket tokens too.\n\nThis is the steps attacker would perform:\n\n1.  Create a Basket with well known NFT token list. let's assume the Basket name is Basket_M\n2.  Give approve permission to NibblVaultFactory for Basket_M id=0 token.\n3.  Call Basket_M.withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) with list of all the tokens in basket to withdraw all of them, but the first address in the _tokens list is the address that attacker controls.\n4.  Basket_M would check that attacker is owner of the basket (owner of the id = 0) and in first iteration of the for it would call attacker controlled address which is a contract that attacker wrote its code.\n5.  Attacker contract would call NibblVaultFactory.createVault() with Basket_M address and id=0 to create a vault which then transfer the ownership of Basket_M id=0 to the vault address. let's assume it's Vault_M.\n6.  Attacker contract would buy some fraction of Vault_M by calling buy() function.\n7.  Let's assume there are other contracts(call it Invest_Contract) that would want to buy fraction of the well known NFTs in the basket and Invest_Contract invest some fund in vault having those NFT in vault's address or vault's basket just by calling Invest_Contract. attacker contract would call Invest_Contract  to invest in Vault_M and Invest_Contract would check that well known NFT is in Basket_M id=0 which belongs to Vault_M to it would invest money on it by calling initiateBuyout()\n8.  Attacker contract then withdraw his money from Vault_M .\n9.  The rest of Basket_M.withdrawMultipleERC721() for iterations performs and all the NFT tokens of the Basket_M would be send to attacker and Basket_M would have nothing.\n\nSteps 5 to 8 can be other things, the point is in those steps attacker would spent Basket_M and receive some fund from other contract while those other contracts checks that they are owner of the Basket_M which has well known NFT tokens, but in fact attacker withdraw those well known NFT tokens from Basket_M after spending it in the rest of the withdrawMultipleERC721() iterations. (those above step 5-8 is just a sample case)\n\nSo Basket shouldn't allow ownership transfer in the middle of the Basket_M.withdrawMultipleERC721() and similar multiple-token-withdraw functions or it should check the ownership in every iteration.\n\n\nVIM\n\n",
                "Repair": "\nCheck ownership of id=0 in every iteration or don't allow ownership transfer in the multiple-token-transfer functions.\n\nmundhrakeshav (Nibbl) disputed(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185) \n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1166658269):\n  Contract checks if you own it as owner of Basket has bought it, and as such is entitled to underlying tokens.\n\nKenzoAgada (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1166696834):\n  The attack is contingent on a regular user, creating a smart contract, which allows anybody to call it, which checks that a parameter-supplied Nibbl vault contains a Nibbl basket which contains a specific NFT, and then proceeds to buyout/buy shares of that vault.\n \n Honestly it seems like the vector of attack is possible but quite far fetched.\n\nHardlyDifficult (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173071137):\n  Creative thinking, this is what I'm here for!\n \n If I'm following the flow correctly.. you kick off a bulk withdraw from the basket, the first NFT in the list is a malicious contract which then creates a vault for that basket (so the contract needs to be the basket owner, which is okay). Now the vault is fully created for that basket which still has valuable NFTs in it but you're mid-tx. Your malicious contract pings other contracts which can be prompted to ape in via on-chain logic -their logic confirms all looks well and buys. But then control returns to the original batch withdrawal and the basket is drained.\n \n  Honestly it seems like the vector of attack is possible but quite far fetched.\n \n I think I'd agree. To put it in terms of risk, this is not High: \"valid attack path that does not have hand-wavy hypotheticals\" -this sounds a bit hand-wavy. Namely because it assumes Invest_Contract allows any address to trigger a purchase using other users funds which seems risky. And the victim here is Invest_Contract, not regular users of the protocol. Lowering to Medium. Great stuff though.\n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173125303):\n  The finding in essence is claiming that you can setup an empty Basket and sell it to external contracts, and those contracts would lose funds.\n \n If that were the case the vulnerability would be in the \"sniping / buying\" contracts and not in the Basket nor the Vault.\n \n The only thing the warden has shown is that they can create a Basket with a malicious token and through that they can call the Factory to create a Vault which after the tx will be empty.\n \n This is logically equivalent to selling an empty vault, or selling a vault of BryptoPunks (typo on purpose, it's a scam token).\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173126326):\n  @Alex the Entreprenerd -\n I agree in terms of normal usage. The key here is a 3rd party contract uses on-chain logic in order to authorize a purchase. If that were the case, while in the middle of the attack as described all checks that contract may perform would confirm assets were included and terms look good -it would not be able to determine that the basket was in the middle of a batch withdraw request. Let me know if I'm overlooking something.\n \n The basket itself does not need to hold a malicious token -the withdraw request takes an array of addresses, so the malicious contract only need to appear there.\n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173140273):\n   If that were the case, while in the middle of the attack as described all checks that contract may perform would confirm assets were included and terms look good -it would not be able to determine that the basket was in the middle of a batch withdraw request. Let me know if I'm overlooking something.\n \n The 3rd party contract would need to check that the Basket is properly set via ownerOf(Basket) == Vault (where Vault is an address contained in the list of nibbledVaults from factory).\n\n That would allow to determine if the contract is properly setup.\n \n  The basket itself does not need to hold a malicious token,\n  \n That is correct as you can setup any contract to accept the safeTransferFrom call.\n \n My statement is that an automated 3rd party contract can get rekt, but that's not the contract under audit.\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/185#issuecomment-1173175820):\n  Agree that it's the 3rd party contract that suffers a loss.\n \n An ownerOf(Basket) == Vault && ownerOf(NFT) == Basket check is insufficient here because if it's in the middle of this scenario then the owner checks will appear legit but by the end of the tx they won't be. That's the part that I'm still hung up on. Part of the Medium definition is \"the function of the protocol or its availability could be impacted\" -although not an explicit goal, is it not implicit that protocols can be built upon with other contracts. The concern here seems to limit that ability, one could not build a contract that decided to participate based on on-chain state alone w/ or w/o an allow list of NFTs -it would require a trusted actor to allow list specific vaults or to perform the action itself.\n \n This is certainly grey though. Very hypothetical, e.g. it's not clear that a 3rd party contract would ever be interested in a capability like this. This is an interesting discussion! I'll sleep on it, but please chime in if you have more to add I appreciate the feedback.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "ERC"
                ],
                "Type": " Basket NFT have no name and symbol",
                "Description": "\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6\n\n\nThe Basket contract is intended to be used behind a proxy. But the ERC721 implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.\n\n\nERC721(\"NFT Basket\", \"NFTB\") is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during delegateCall, these variables will not be initialized.\n\n",
                "Repair": "\nThe easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.\n\nmundhrakeshav (Nibbl) confirmed(https://github.com/code-423n4/2022-06-nibbl-findings/issues/317) \n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1166657024):\n  Finding is valid, impact is the name of the tokens.\n\nHardlyDifficult (judge) decreased severity to QA and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1172563153):\n  Confirmed this is an issue.\n \n Assets are not at risk, and the function of the protocol is not impacted. All baskets created will have an empty name/symbol but generally there is no requirement that these values are populated. It's mostly for a better experience on frontends including etherscan. Downgrading and merging with the warden's QA report #314.\n\nPicodes (warden) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1174704129):\n  @HardlyDifficult Indeed it does not break the protocol's logic and funds are not at risk, but the name and the symbol of the NFTs are not the ones chosen by the sponsor, and as it's the core of EIP721Metadata we could argue that the function of the protocol are impacted. \n Also the experience on frontends (etherscan, opensea, etc) would have been significantly degraded. It could easily be considered a medium issue to me especially considering the previous comments / reactions and the label \"confirmed\" added by the sponsor while it was high.\n\nHardlyDifficult (judge) increased severity to Medium and commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/317#issuecomment-1175198116):\n  Thanks @Picodes! I can get onboard with that line of thinking. Given how significant these fields are for 3rd party integrators such as Etherscan and Opensea this can be considered to fall under that definition of Medium risk. I'll upgrade this report and the dupes to Medium.\n\n\n\n*\n\n\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 82 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-06-nibbl-findings/issues/139) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: BowTiedWardens(https://github.com/code-423n4/2022-06-nibbl-findings/issues/236), joestakey(https://github.com/code-423n4/2022-06-nibbl-findings/issues/181), 0x1f8b(https://github.com/code-423n4/2022-06-nibbl-findings/issues/34), reassor(https://github.com/code-423n4/2022-06-nibbl-findings/issues/286), 0x29A(https://github.com/code-423n4/2022-06-nibbl-findings/issues/182), codexploder(https://github.com/code-423n4/2022-06-nibbl-findings/issues/41), Chom(https://github.com/code-423n4/2022-06-nibbl-findings/issues/252), hyh(https://github.com/code-423n4/2022-06-nibbl-findings/issues/220), berndartmueller(https://github.com/code-423n4/2022-06-nibbl-findings/issues/130), xiaoming90(https://github.com/code-423n4/2022-06-nibbl-findings/issues/209), defsec(https://github.com/code-423n4/2022-06-nibbl-findings/issues/167), ellahi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/297), 0xNineDec(https://github.com/code-423n4/2022-06-nibbl-findings/issues/133), cloudjunky(https://github.com/code-423n4/2022-06-nibbl-findings/issues/147), catchup(https://github.com/code-423n4/2022-06-nibbl-findings/issues/98), cryptphi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/74), cccz(https://github.com/code-423n4/2022-06-nibbl-findings/issues/160), c3phas(https://github.com/code-423n4/2022-06-nibbl-findings/issues/280), 0xNazgul(https://github.com/code-423n4/2022-06-nibbl-findings/issues/60), 0xf15ers(https://github.com/code-423n4/2022-06-nibbl-findings/issues/240), unforgiven(https://github.com/code-423n4/2022-06-nibbl-findings/issues/174), shenwilly(https://github.com/code-423n4/2022-06-nibbl-findings/issues/120), StErMi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/96), oyc_109(https://github.com/code-423n4/2022-06-nibbl-findings/issues/16), Lambda(https://github.com/code-423n4/2022-06-nibbl-findings/issues/53), kenta(https://github.com/code-423n4/2022-06-nibbl-findings/issues/187), sorrynotsorry(https://github.com/code-423n4/2022-06-nibbl-findings/issues/259), JohnSmith(https://github.com/code-423n4/2022-06-nibbl-findings/issues/87), UnusualTurtle(https://github.com/code-423n4/2022-06-nibbl-findings/issues/296), Tadashi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/321), sseefried(https://github.com/code-423n4/2022-06-nibbl-findings/issues/142), simon135(https://github.com/code-423n4/2022-06-nibbl-findings/issues/293), pashov(https://github.com/code-423n4/2022-06-nibbl-findings/issues/307), zzzitron(https://github.com/code-423n4/2022-06-nibbl-findings/issues/149), saian(https://github.com/code-423n4/2022-06-nibbl-findings/issues/214), robee(https://github.com/code-423n4/2022-06-nibbl-findings/issues/227), minhquanym(https://github.com/code-423n4/2022-06-nibbl-findings/issues/310), MadWookie(https://github.com/code-423n4/2022-06-nibbl-findings/issues/287), JMukesh(https://github.com/code-423n4/2022-06-nibbl-findings/issues/245), asutorufos(https://github.com/code-423n4/2022-06-nibbl-findings/issues/217), Picodes(https://github.com/code-423n4/2022-06-nibbl-findings/issues/314), rfa(https://github.com/code-423n4/2022-06-nibbl-findings/issues/284), TerrierLover(https://github.com/code-423n4/2022-06-nibbl-findings/issues/172), dipp(https://github.com/code-423n4/2022-06-nibbl-findings/issues/229), MiloTruck(https://github.com/code-423n4/2022-06-nibbl-findings/issues/157), SmartSek(https://github.com/code-423n4/2022-06-nibbl-findings/issues/255), naps62(https://github.com/code-423n4/2022-06-nibbl-findings/issues/151), TomJ(https://github.com/code-423n4/2022-06-nibbl-findings/issues/237), apostle0x01(https://github.com/code-423n4/2022-06-nibbl-findings/issues/25), zuhaibmohd(https://github.com/code-423n4/2022-06-nibbl-findings/issues/58), Wayne(https://github.com/code-423n4/2022-06-nibbl-findings/issues/117), Waze(https://github.com/code-423n4/2022-06-nibbl-findings/issues/152), kebabsec(https://github.com/code-423n4/2022-06-nibbl-findings/issues/153), PwnedNoMore(https://github.com/code-423n4/2022-06-nibbl-findings/issues/264), exd0tpy(https://github.com/code-423n4/2022-06-nibbl-findings/issues/83), Alex the Entreprenerd(https://github.com/code-423n4/2022-06-nibbl-findings/issues/283), Tomio(https://github.com/code-423n4/2022-06-nibbl-findings/issues/69), Varun_Verma(https://github.com/code-423n4/2022-06-nibbl-findings/issues/298), 0xc0ffEE(https://github.com/code-423n4/2022-06-nibbl-findings/issues/234), hansfriese(https://github.com/code-423n4/2022-06-nibbl-findings/issues/113), Treasure-Seeker(https://github.com/code-423n4/2022-06-nibbl-findings/issues/26), delfin454000(https://github.com/code-423n4/2022-06-nibbl-findings/issues/210), Limbooo(https://github.com/code-423n4/2022-06-nibbl-findings/issues/91), JC(https://github.com/code-423n4/2022-06-nibbl-findings/issues/311), 0xkatana(https://github.com/code-423n4/2022-06-nibbl-findings/issues/100), masterchief(https://github.com/code-423n4/2022-06-nibbl-findings/issues/285), fatherOfBlocks(https://github.com/code-423n4/2022-06-nibbl-findings/issues/79), slywaters(https://github.com/code-423n4/2022-06-nibbl-findings/issues/270), peritoflores(https://github.com/code-423n4/2022-06-nibbl-findings/issues/289), sashik_eth(https://github.com/code-423n4/2022-06-nibbl-findings/issues/322), _Adam(https://github.com/code-423n4/2022-06-nibbl-findings/issues/123), Funen(https://github.com/code-423n4/2022-06-nibbl-findings/issues/239), Nyamcil(https://github.com/code-423n4/2022-06-nibbl-findings/issues/124), sach1r0(https://github.com/code-423n4/2022-06-nibbl-findings/issues/81), Randyyy(https://github.com/code-423n4/2022-06-nibbl-findings/issues/299), 0x52(https://github.com/code-423n4/2022-06-nibbl-findings/issues/88), ElKu(https://github.com/code-423n4/2022-06-nibbl-findings/issues/171), Nethermind(https://github.com/code-423n4/2022-06-nibbl-findings/issues/215), RoiEvenHaim(https://github.com/code-423n4/2022-06-nibbl-findings/issues/242), ych18(https://github.com/code-423n4/2022-06-nibbl-findings/issues/196), and Noah3o6(https://github.com/code-423n4/2022-06-nibbl-findings/issues/225).*\n\n## Low Risk Issues\n\n|   | Issue                                                                                                               | Instances |\n| | :-----------------------------------------------------------------------------------------------------------------| :-------: |\n| 1 | Buyouts that occur during the timestamp wrap will have valuation errors                                             |     1     |\n| 2 | ecrecover() not checked for signer address of zero                                                                |     1     |\n| 3 | Return values of transfer()/transferFrom() not checked                                                          |     4     |\n| 4 | Input array lengths may differ                                                                                      |     4     |\n| 5 | _safeMint() should be used rather than _mint() wherever possible                                                |     1     |\n| 6 | Missing checks for address(0x0) when assigning values to address state variables                                |     6     |\n| 7 | Vulnerable to cross-chain replay attacks due to static DOMAIN_SEPARATOR/domainSeparator                         |     1     |\n| 8 | Upgradeable contract is missing a __gap[50] storage variable to allow for new storage variables in later versions |     1     |\n| 9 | Incorrect comments                                                                                                  |     3     |\n\nTotal: 22 instances over 9 issues\n\n\n"
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n191:          assetAddress = _assetAddress;\n\n193:          curator = _curator;\n\n487:          curator = _newCurator;\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n\n124:         pendingFeeTo = _newFeeAddress;\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n"
                ],
                "Type": " Missing checks for  address(0x0)  when assigning values to  address  state variables",
                "Description": "\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n191:          assetAddress = _assetAddress;\n\n193:          curator = _curator;\n\n487:          curator = _newCurator;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n\n124:         pendingFeeTo = _newFeeAddress;\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n13:   contract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n"
                ],
                "Type": " Missing  initializer  modifier on constructor",
                "Description": "\nOpenZeppelin recommends(https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the initializer modifier be applied to constructors in order to avoid potential griefs, social engineering(https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n13:   contract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit onERC721Received(), onERC1155Received()\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n"
                ],
                "Type": " Contract implements interface without extending the interface",
                "Description": "\nNot extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the override keyword to indicate that fact\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit onERC721Received(), onERC1155Received()\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n114:          require(_success);\n"
                ],
                "Type": "  require() / revert()  statements should have descriptive reason strings",
                "Description": "\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n114:          require(_success);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n64        function getVaultAddress(\n65            address _curator,\n66            address _assetAddress,\n67            uint256 _assetTokenID,\n68            uint256 _initialSupply,\n69:           uint256 _initialTokenPrice) public view returns(address _vault) {\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n76:       function getVaults() public view returns(ProxyVault[] memory ) {\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol   #3\n\n44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n"
                ],
                "Type": "  public  functions not called by the contract should be declared  external  instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public.\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n64        function getVaultAddress(\n65            address _curator,\n66            address _assetAddress,\n67            uint256 _assetTokenID,\n68            uint256 _initialSupply,\n69:           uint256 _initialTokenPrice) public view returns(address _vault) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n76:       function getVaults() public view returns(ProxyVault[] memory ) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76\n\nsolidity\nFile: contracts/Twav/Twav.sol   #3\n\n44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n29:               id := chainid()\n"
                ],
                "Type": " Non-assembly method available",
                "Description": "\nassembly{ id := chainid() } = uint256 id = block.chainid, assembly { size := extcodesize() } = uint256 size = address().code.length\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n29:               id := chainid()\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-11",
                "Location": [
                    "//solidity\nFile: contracts/Proxy/ProxyBasket.sol   #1\n\n/// @audit payable vs address\n20:           implementation = payable(_implementation);\n"
                ],
                "Type": " Cast is more restrictive than the type of the variable being assigned",
                "Description": "\nIf address foo is being used in an expression such as IERC20 token = FooToken(foo), then the more specific cast to FooToken is a waste because the only thing the compiler will check for is that FooToken extends IERC20 it won't check any of the function signatures. Therefore, it makes more sense to do IERC20 token = IERC20(token) or better yet FooToken token = FooToken(foo). The former may allow the file in which it's used to remove the import for FooToken\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Proxy/ProxyBasket.sol   #1\n\n/// @audit payable vs address\n20:           implementation = payable(_implementation);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Twav/Twav.sol   #1\n\n38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol   #2\n\n39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n"
                ],
                "Type": " Using  storage  instead of  memory  for structs/arrays saves gas",
                "Description": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/Twav/Twav.sol   #1\n\n38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38\n\nsolidity\nFile: contracts/Twav/Twav.sol   #2\n\n39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n/// @audit require() on line 185\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit require() on line 404\n406:          buyoutValuationDeposit = msg.value (_buyoutBid _currentValuation);\n\n/// @audit require() on line 404\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid _currentValuation));\n\n/// @audit if-condition on line 373\n378:                  uint256 _tokensPrimaryCurve = _totalSupply _initialTokenSupply;\n\n/// @audit if-condition on line 414\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid _currentValuation));\n"
                ],
                "Type": " Add  unchecked {}  for subtractions where the operands cannot underflow because of a previous  require()  or  if -statement",
                "Description": "\nrequire(a <= b); x = b a = require(a <= b); unchecked { x = b a }\n\n*There are 5 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n/// @audit require() on line 185\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit require() on line 404\n406:          buyoutValuationDeposit = msg.value (_buyoutBid _currentValuation);\n\n/// @audit require() on line 404\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid _currentValuation));\n\n/// @audit if-condition on line 373\n378:                  uint256 _tokensPrimaryCurve = _totalSupply _initialTokenSupply;\n\n/// @audit if-condition on line 414\n415:              safeTransferETH(payable(msg.sender), (_buyoutBid _currentValuation));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n"
                ],
                "Type": "  <array>.length  should not be looked up in every loop of a  for -loop",
                "Description": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (100 gas)\n*   memory arrays use MLOAD (3 gas)\n*   calldata arrays use CALLDATALOAD (3 gas)\n\nCaching the length changes each of these to a DUP<N (3 gas), and gets rid of the extra DUP<N needed to store the stack offset\n\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43\n\nsolidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506\n\n\n",
                "Repair": ""
            },
            {
                "Name": "0",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n48:           require(msg.value = MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n\n49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n\n107:          require(basketUpdateTime != 0 && block.timestamp = basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n131:          require(feeToUpdateTime != 0 && block.timestamp = feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n141:          require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp = feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n166:          require(vaultUpdateTime != 0 && block.timestamp = vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n"
                ],
                "Type": "  require() / revert()  strings longer than 32 bytes cost extra gas",
                "Description": "\nEach extra memory word of bytes past the original 32 incurs an MSTORE(https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs 3 gas\n\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n48:           require(msg.value = MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n\n49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n\n107:          require(basketUpdateTime != 0 && block.timestamp = basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n131:          require(feeToUpdateTime != 0 && block.timestamp = feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n141:          require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp = feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n166:          require(vaultUpdateTime != 0 && block.timestamp = vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "//solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n",
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n16:       mapping(bytes32 = mapping(address = bool)) public pendingRoles;\n"
                ],
                "Type": " Using  bool s for storage incurs overhead",
                "Description": "\nsolidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess ([100 gas(https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from 'false' to 'true', after having been 'true' in the past\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n16:       mapping(bytes32 = mapping(address = bool)) public pendingRoles;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16\n\n\n",
                "Repair": ""
            },
            {
                "Name": "5",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n"
                ],
                "Type": "  ++i  costs less gas than  i++ , especially when it's used in  for -loops ( --i / i--  too)",
                "Description": "\nSaves 6 gas per loop\n\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43\n\nsolidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506\n\n\n",
                "Repair": ""
            },
            {
                "Name": "6",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n107:          require(basketUpdateTime != 0 && block.timestamp = basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n131:          require(feeToUpdateTime != 0 && block.timestamp = feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp = feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n166:          require(vaultUpdateTime != 0 && block.timestamp = vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n"
                ],
                "Type": " Splitting  require()  statements that use  &&  saves gas",
                "Description": "\nSee this issue(https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n107:          require(basketUpdateTime != 0 && block.timestamp = basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n131:          require(feeToUpdateTime != 0 && block.timestamp = feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n149:          require(feeAdminUpdateTime != 0 && block.timestamp = feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n166:          require(vaultUpdateTime != 0 && block.timestamp = vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166\n\n\n",
                "Repair": ""
            },
            {
                "Name": "0",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n42:           require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #2\n\n486:          require(msg.sender == curator,\"NibblVault: Only Curator\");\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #3\n\n505:          require(msg.sender == bidder,\"NibblVault: Only winner\");\n"
                ],
                "Type": " Duplicated  require() / revert()  checks should be refactored to a modifier or function",
                "Description": "\nSaves deployment costs\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n42:           require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L42\n\nsolidity\nFile: contracts/NibblVault.sol   #2\n\n486:          require(msg.sender == curator,\"NibblVault: Only Curator\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486\n\nsolidity\nFile: contracts/NibblVault.sol   #3\n\n505:          require(msg.sender == bidder,\"NibblVault: Only winner\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505\n\n\n",
                "Repair": ""
            },
            {
                "Name": "3",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n\n140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n\n158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n173:      function pause() external onlyRole(PAUSER_ROLE) override {\n\n179:      function unPause() external onlyRole(PAUSER_ROLE) override {\n",
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {\n\n40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) {\n"
                ],
                "Type": " Functions guaranteed to revert when called by normal users can be marked  payable ",
                "Description": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n*There are 8 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n99:       function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n123:      function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n\n140:      function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n\n158:      function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n\n173:      function pause() external onlyRole(PAUSER_ROLE) override {\n\n179:      function unPause() external onlyRole(PAUSER_ROLE) override {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n32:       function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {\n\n40:       function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L32\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { NibblVaultFactory } from \"../NibblVaultFactory.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract ProxyBasket {\n    address immutable public implementation;\n\n    constructor(address _implementation) {\n        implementation = payable(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    //solhint-disable-next-line no-complex-fallback\n    fallback() external payable virtual {\n        address _implementation = implementation;\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }    \n    }\n\n    receive() external payable {    }\n\n    }\n\n\n\n\n",
        "CodeNames": [
            "Basket.sol",
            "ProxyBasket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n",
                    "//solidity\nFile: contracts/Basket.sol   #2\n\n94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #3\n\n517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #4\n\n526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n"
                ],
                "Type": " Return values of  transfer() / transferFrom()  not checked",
                "Description": "\nNot all IERC20 implementations revert() when there's a failure in transfer()/transferFrom(). The function signature has a boolean return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87\n\nsolidity\nFile: contracts/Basket.sol   #2\n\n94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94\n\nsolidity\nFile: contracts/NibblVault.sol   #3\n\n517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517\n\nsolidity\nFile: contracts/NibblVault.sol   #4\n\n526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n",
                    "//solidity\nFile: contracts/Basket.sol   #2\n\n68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #3\n\n545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #4\n\n504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n"
                ],
                "Type": " Input array lengths may differ",
                "Description": "\nIf the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41\n\nsolidity\nFile: contracts/Basket.sol   #2\n\n68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68\n\nsolidity\nFile: contracts/NibblVault.sol   #3\n\n545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545\n\nsolidity\nFile: contracts/NibblVault.sol   #4\n\n504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n15       function INIT_EIP712(string memory name, string memory version) internal {\n16           domainSeperator = keccak256(\n17               abi.encode(\n18                   EIP712_DOMAIN_TYPEHASH,\n19                   keccak256(bytes(name)),\n20                   keccak256(bytes(version)),\n21                   getChainID(),\n22                   address(this)\n23               )\n24           );\n25:      }\n"
                ],
                "Type": " Vulnerable to cross-chain replay attacks due to static  DOMAIN_SEPARATOR / domainSeparator ",
                "Description": "\nSee this(https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/EIP712Base.sol   #1\n\n15       function INIT_EIP712(string memory name, string memory version) internal {\n16           domainSeperator = keccak256(\n17               abi.encode(\n18                   EIP712_DOMAIN_TYPEHASH,\n19                   keccak256(bytes(name)),\n20                   keccak256(bytes(version)),\n21                   getChainID(),\n22                   address(this)\n23               )\n24           );\n25:      }\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n"
                ],
                "Type": " Upgradeable contract is missing a  __gap[50",
                "Description": "\nSee this(https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n173:     function initialize(\n",
                    "//solidity\nFile: contracts/Interfaces/IBasket.sol   #2\n\n10:      function initialise(address _curator) external;\n"
                ],
                "Type": " Inconsistent version of English being used",
                "Description": "\nSome functions use American English, whereas others use British English. A single project should use only one of the two\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n173:     function initialize(\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173\n\nsolidity\nFile: contracts/Interfaces/IBasket.sol   #2\n\n10:      function initialise(address _curator) external;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #2\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #3\n\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 232));\n",
                    "//solidity\nFile: contracts/NibblVault.sol   #4\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n"
                ],
                "Type": "  2<n> - 1  should be re-written as  type(uint<n>).max ",
                "Description": "\nEarlier versions of solidity can use uint<n(-1) instead. Expressions not including the 1 can often be re-written to accomodate the change (e.g. by using a  rather than a =, which will also save some gas)\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303\n\nsolidity\nFile: contracts/NibblVault.sol   #2\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365\n\nsolidity\nFile: contracts/NibblVault.sol   #3\n\n413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 232));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413\n\nsolidity\nFile: contracts/NibblVault.sol   #4\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n485       function updateCurator(address _newCurator) external override {\n486           require(msg.sender == curator,\"NibblVault: Only Curator\");\n487           curator = _newCurator;\n488:      }\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n124:         pendingFeeTo = _newFeeAddress;\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n"
                ],
                "Type": " Missing event and or timelock for critical parameter change",
                "Description": "\nEvents help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n485       function updateCurator(address _newCurator) external override {\n486           require(msg.sender == curator,\"NibblVault: Only Curator\");\n487           curator = _newCurator;\n488:      }\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #2\n\n100:         pendingBasketImplementation = _newBasketImplementation;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #3\n\n124:         pendingFeeTo = _newFeeAddress;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #4\n\n159:         pendingVaultImplementation = _newVaultImplementation;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-14",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n122:      ///@notice current status of vault\n\n125:      ///@notice reenterancy guard\n\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n\n221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n301:          //Make update on the first tx of the block\n\n318:                  //Gas Optimization\n\n363:          //Make update on the first tx of the block\n\n368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n\n377:                  //Gas Optimization\n\n389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n\n402:          //_buyoutBid: Bid User has made\n\n448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally\n\n500:      ///@notice withdraw multiple ERC721s\n",
                    "//solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n",
                    "//solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n"
                ],
                "Type": " Inconsistent spacing in comments",
                "Description": "\nSome lines use // x and some use //x. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 27 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n34:       uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n46:       uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n122:      ///@notice current status of vault\n\n125:      ///@notice reenterancy guard\n\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n220:          //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n\n221:          //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n228:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n244:              safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n\n301:          //Make update on the first tx of the block\n\n318:                  //Gas Optimization\n\n363:          //Make update on the first tx of the block\n\n368:                  _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n\n377:                  //Gas Optimization\n\n389:          safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n\n402:          //_buyoutBid: Bid User has made\n\n448:              _rejectBuyout(); //For the case when TWAV goes up when updated externally\n\n500:      ///@notice withdraw multiple ERC721s\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28\n\nsolidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L28\n\nsolidity\nFile: contracts/Proxy/ProxyVault.sol\n\n28:       //solhint-disable-next-line no-complex-fallback\n\n31:           //solhint-disable-next-line no-inline-assembly\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L28\n\nsolidity\nFile: contracts/Twav/Twav.sol\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L12\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-15",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\n\n79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease  _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n\n297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n\n358:      /// @dev if totalSupply  initialTokenSupply AND _amount to sell is greater than (_amtIn  totalSupply initialTokenSupply) then sell happens on primary curve and secondary curve both\n\n395:      /// @dev bidder needs to send funds equal to current valuation ((primaryReserveBalance fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol\n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n\n40:               _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n"
                ],
                "Type": " Lines are too long",
                "Description": "\nUsually lines in source code are limited to 80(https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164(https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 14 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L109\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n50:           _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L50\n\nsolidity\nFile: contracts/NibblVault.sol\n\n19:   /// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\n\n79:       /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease  _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n266:              return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n\n297:      /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n\n358:      /// @dev if totalSupply  initialTokenSupply AND _amount to sell is greater than (_amtIn  totalSupply initialTokenSupply) then sell happens on primary curve and secondary curve both\n\n395:      /// @dev bidder needs to send funds equal to current valuation ((primaryReserveBalance fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L19\n\nsolidity\nFile: contracts/Twav/Twav.sol\n\n28:           twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n\n40:               _twav = (_twavObservationCurrent.cumulativeValuation _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp _twavObservationPrev.timestamp);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-16",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Non-library/interface files should use fixed compiler versions, not floating ones",
                "Description": "\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma solidity ^0.8.0;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-17",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n/// @audit reenterancy\n125:      ///@notice reenterancy guard\n\n/// @audit pausablity\n152:      /// @dev pausablity implemented in factory\n\n/// @audit primaryReseveRatio\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit primaryReseveRatio\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit continous\n250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n\n/// @audit seconday\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n/// @audit continous\n270:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit continous\n282:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit Continous\n359:      /// @param _amtIn Continous Tokens to be sold\n\n/// @audit recieve\n361:      /// @param _to Address to recieve the reserve token to\n\n/// @audit airdops\n512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n\n/// @audit airdops\n531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n",
                    "//solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n",
                    "//solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n"
                ],
                "Type": " Typos",
                "Description": "\n*There are 14 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n/// @audit reenterancy\n125:      ///@notice reenterancy guard\n\n/// @audit pausablity\n152:      /// @dev pausablity implemented in factory\n\n/// @audit primaryReseveRatio\n200:          //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit primaryReseveRatio\n201:          curatorFee = (((_secondaryReserveRatio MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n\n/// @audit continous\n250:      /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n\n/// @audit seconday\n263:      /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n\n/// @audit continous\n270:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit continous\n282:      /// @param _amount amount of reserve tokens to buy continous tokens\n\n/// @audit Continous\n359:      /// @param _amtIn Continous Tokens to be sold\n\n/// @audit recieve\n361:      /// @param _to Address to recieve the reserve token to\n\n/// @audit airdops\n512:      /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n\n/// @audit airdops\n531:      /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125\n\nsolidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L26\n\nsolidity\nFile: contracts/Proxy/ProxyVault.sol\n\n/// @audit internall\n26:        * This function does not return to its internall call site, it will return directly to the external caller.\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L26\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-18",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/EIP712Base.sol (various lines)   #1\n\n"
                ],
                "Type": " File is missing NatSpec",
                "Description": "\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/EIP712Base.sol (various lines)   #1\n\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit secondaryReserveBalance on line 225\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n"
                ],
                "Type": " State variables should be cached in stack variables rather than re-reading them from storage",
                "Description": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n/// @audit secondaryReserveBalance on line 225\n226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n219:          feeAccruedCurator += _feeCurator;\n\n225:          secondaryReserveBalance += _feeCurve;\n\n242:          feeAccruedCurator += _feeCurator;\n\n320:                  secondaryReserveBalance += _lowerCurveDiff;\n\n380:                  primaryReserveBalance -= _saleReturn;\n\n429:              totalUnsettledBids += _buyoutValuationDeposit;\n\n457:          totalUnsettledBids -= _amount;\n"
                ],
                "Type": "  <x> += <y>  costs more gas than  <x> = <x> + <y>  for state variables",
                "Description": "\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n219:          feeAccruedCurator += _feeCurator;\n\n225:          secondaryReserveBalance += _feeCurve;\n\n242:          feeAccruedCurator += _feeCurator;\n\n320:                  secondaryReserveBalance += _lowerCurveDiff;\n\n380:                  primaryReserveBalance -= _saleReturn;\n\n429:              totalUnsettledBids += _buyoutValuationDeposit;\n\n457:          totalUnsettledBids -= _amount;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219\n\n\n",
                "Repair": ""
            },
            {
                "Name": "3",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol   #1\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease  _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n"
                ],
                "Type": "  >=  costs less gas than  > ",
                "Description": "\nThe compiler uses opcodes GT and ISZERO for solidity code that uses , but only requires LT for =, which saves 3 gas(https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol   #1\n\n224:          _feeCurve = _maxSecondaryBalanceIncrease  _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224\n\n\n",
                "Repair": ""
            },
            {
                "Name": "4",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n"
                ],
                "Type": " It costs more gas to initialize non- constant /non- immutable  variables to zero than to let the default of zero be applied",
                "Description": "\nNot overwriting the default for stack variables(https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves 8 gas. Storage and memory variables have larger savings\n\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43\n\nsolidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506\n\n\n",
                "Repair": ""
            },
            {
                "Name": "7",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n57:       uint32 public secondaryReserveRatio;\n\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n557:          uint8 v,\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol\n\n6:            uint32 timestamp;\n\n11:       uint8 public twavObservationsIndex;\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n13:       uint32 public lastBlockTimeStamp;\n\n21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n\n22:           uint32 _timeElapsed; \n\n37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n"
                ],
                "Type": " Usage of  uints / ints  smaller than 32 bytes (256 bits) incurs overhead",
                "Description": "\n When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nUse a larger size then downcast where needed\n\n*There are 14 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n28:       uint32 private constant primaryReserveRatio = 200_000; //20%\n\n57:       uint32 public secondaryReserveRatio;\n\n183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n\n303:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n365:              uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n445:          uint32 _blockTimestamp = uint32(block.timestamp % 232);\n\n557:          uint8 v,\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28\n\nsolidity\nFile: contracts/Twav/Twav.sol\n\n6:            uint32 timestamp;\n\n11:       uint8 public twavObservationsIndex;\n\n12:       uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n\n13:       uint32 public lastBlockTimeStamp;\n\n21:       function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n\n22:           uint32 _timeElapsed; \n\n37:               uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) 1) % TWAV_BLOCK_NUMBERS;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L6\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721URIStorage } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport { Counters }  from \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract NibblTestNFT is ERC721, ERC721Enumerable, ERC721URIStorage {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() ERC721(\"NibblTestNFT\", \"NTNFT\") {}\n\n    function _baseURI() internal pure override returns (string memory) {\n        return \"https://ipfs.io/ipfs/\";\n    }\n\n    function safeMint(address to, string memory uri) public {\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function tokenID() public view returns(uint256) {\n        return _tokenIdCounter.current();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n\n\n",
        "CodeNames": [
            "Basket.sol",
            "NibblTestNFT.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n24:           _mint(_curator, 0);\n"
                ],
                "Type": "  _safeMint()  should be used rather than  _mint()  wherever possible",
                "Description": "\n_mint() is discouraged(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of _safeMint() which ensures that the recipient is either an EOA or implements IERC721Receiver. Both OpenZeppelin(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and solmate(https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n24:           _mint(_curator, 0);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { NibblVaultFactory } from \"../NibblVaultFactory.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract ProxyBasket {\n    address immutable public implementation;\n\n    constructor(address _implementation) {\n        implementation = payable(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    //solhint-disable-next-line no-complex-fallback\n    fallback() external payable virtual {\n        address _implementation = implementation;\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }    \n    }\n\n    receive() external payable {    }\n\n    }\n\n\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol",
            "ProxyBasket.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol   #1\n\n/// @audit ERC1155, not ERC721\n58:      /// @notice withdraw an ERC721 token from this contract into your wallet\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol   #2\n\n/// @audit or zero if there have been fewer than four blocks\n34:      /// @return _twav TWAV of the last 4 blocks\n",
                    "//solidity\nFile: contracts/Twav/Twav.sol   #3\n\n/// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped)\n34:      /// @return _twav TWAV of the last 4 blocks\n"
                ],
                "Type": " Incorrect comments",
                "Description": "\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol   #1\n\n/// @audit ERC1155, not ERC721\n58:      /// @notice withdraw an ERC721 token from this contract into your wallet\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58\n\nsolidity\nFile: contracts/Twav/Twav.sol   #2\n\n/// @audit or zero if there have been fewer than four blocks\n34:      /// @return _twav TWAV of the last 4 blocks\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34\n\nsolidity\nFile: contracts/Twav/Twav.sol   #3\n\n/// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped)\n34:      /// @return _twav TWAV of the last 4 blocks\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34\n\n## Non-Critical Issues\n\n|    | Issue                                                                                                          | Instances |\n| -| :------------------------------------------------------------------------------------------------------------| :-------: |\n| 1  | Consider addings checks for signature malleability                                                             |     1     |\n| 2  | Misleading variable name                                                                                       |     1     |\n| 3  | Inconsistent version of English being used                                                                     |     2     |\n| 4  | Missing initializer modifier on constructor                                                                  |     1     |\n| 5  | Contract implements interface without extending the interface                                                  |     1     |\n| 6  | require()/revert() statements should have descriptive reason strings                                       |     1     |\n| 7  | public functions not called by the contract should be declared external instead                            |     3     |\n| 8  | Non-assembly method available                                                                                  |     1     |\n| 9  | 2<n 1 should be re-written as type(uint<n).max                                                       |     4     |\n| 10 | constants should be defined rather than using magic numbers                                                  |     10    |\n| 11 | Cast is more restrictive than the type of the variable being assigned                                          |     1     |\n| 12 | Missing event and or timelock for critical parameter change                                                    |     4     |\n| 13 | Expressions for constant values such as a call to keccak256(), should use immutable rather than constant |     5     |\n| 14 | Inconsistent spacing in comments                                                                               |     27    |\n| 15 | Lines are too long                                                                                             |     14    |\n| 16 | Non-library/interface files should use fixed compiler versions, not floating ones                              |     1     |\n| 17 | Typos                                                                                                          |     14    |\n| 18 | File is missing NatSpec                                                                                        |     1     |\n| 19 | NatSpec is incomplete                                                                                          |     12    |\n| 20 | Event is missing indexed fields                                                                              |     5     |\n\nTotal: 109 instances over 20 issues\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\ncontract Twav {\n    struct TwavObservation {\n        uint32 timestamp;\n        uint256 cumulativeValuation;\n    }\n\n    /// @notice current index of twavObservations index\n    uint8 public twavObservationsIndex;\n    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n    uint32 public lastBlockTimeStamp;\n\n    /// @notice record of TWAV \n    TwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n    /// @notice updates twavObservations array\n    /// @param _blockTimestamp timestamp of the block\n    /// @param _valuation current valuation\n    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n        uint32 _timeElapsed; \n        unchecked {\n            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n        }\n\n        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n        lastBlockTimeStamp = _blockTimestamp;\n    }\n\n    /// @notice returns the TWAV of the last 4 blocks\n    /// @return _twav TWAV of the last 4 blocks\n    function _getTwav() internal view returns(uint256 _twav){\n        if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n            TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n            TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n\n    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n        return twavObservations;\n    }\n}\n\n",
        "CodeNames": [
            "Twav.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts/Twav/Twav.sol   #1\n\n39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n"
                ],
                "Type": " Misleading variable name",
                "Description": "\n_twavObservationPrev is not the previous observation it's more like the trailing, or next-to-expire TWAV observation\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Twav/Twav.sol   #1\n\n39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { NibblVaultFactory } from \"../NibblVaultFactory.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract ProxyBasket {\n    address immutable public implementation;\n\n    constructor(address _implementation) {\n        implementation = payable(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    //solhint-disable-next-line no-complex-fallback\n    fallback() external payable virtual {\n        address _implementation = implementation;\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }    \n    }\n\n    receive() external payable {    }\n\n    }\n\n\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "ProxyBasket.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-13",
                "Location": [
                    "//solidity\nFile: contracts/NibblVault.sol\n\n51:       bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n",
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n",
                    "//solidity\nFile: contracts/Utilities/EIP712Base.sol\n\n7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n8             bytes(\n9                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n10            )\n11:       );\n"
                ],
                "Type": " Expressions for constant values such as a call to  keccak256() , should use  immutable  rather than  constant ",
                "Description": "\n*There are 5 instances of this issue:*\n\nsolidity\nFile: contracts/NibblVault.sol\n\n51:       bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol\n\n12:       bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n\n13:       bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n14:       bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12\n\nsolidity\nFile: contracts/Utilities/EIP712Base.sol\n\n7         bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n8             bytes(\n9                 \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n10            )\n11:       );\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n* @title Bancor formula by Bancor\n*\n* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements;\n* and to You under the Apache License, Version 2.0. \"\n*/\ncontract BancorFormula {\n    using SafeMath for uint256;\n    \n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_WEIGHT = 1_000_000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n        Auto-generated via 'PrintIntScalingFactors.py'\n    */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n        Auto-generated via 'PrintLn2ScalingFactors.py'\n    */\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n        Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n    */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n        Auto-generated via 'PrintFunctionConstructor.py'\n    */\n    uint256[128] private maxExpArray;\n    constructor() {\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\n        calculates the return for a given conversion (in the main token)\n        Formula:\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\n        @param _supply              token total supply\n        @param _connectorBalance    total connector balance\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\n        @param _depositAmount       deposit amount, in connector token\n        @return purchase return amount\n    */\n    function _calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) internal view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0)\n            return 0;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return _supply.mul(_depositAmount) / _connectorBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_connectorBalance);\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\n        calculates the return for a given conversion (in the connector token)\n        Formula:\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\n        @param _supply              token total supply\n        @param _connectorBalance    total connector\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\n        @param _sellAmount          sell amount, in the token itself\n        @return sale return amount\n    */\n    function _calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) internal view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0)\n            return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply)\n            return _connectorBalance;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return _connectorBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\n        uint256 temp1 = _connectorBalance.mul(result);\n        uint256 temp2 = _connectorBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n        General Description:\n            Determine a value of precision.\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n            Return the result along with the precision used.\n        Detailed Description:\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n            The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n            The larger \"precision\" is, the more accurately this value represents the real value.\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n            This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n    */\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) private view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = _baseN * FIXED_1 / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        }\n        else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        }\n        else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n        Compute log(x / FIXED_1) * FIXED_1.\n        This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n    */\n    function generalLog(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\n    }\n\n    /**\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\n    */\n    function floorLog2(uint256 _n) private pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        }\n        else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\n    function findPositionInMaxExpArray(uint256 _x) private view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x)\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x)\n            return hi;\n        if (maxExpArray[lo] >= _x)\n            return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n        This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n    */\n    function generalExp(uint256 _x, uint8 _precision) private pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision; res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n        Return log(x / FIXED_1) * FIXED_1\n        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n        Auto-generated via 'PrintFunctionOptimalLog.py'\n        Detailed description:\n        - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n        - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n        - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n        - The natural logarithm of the input is calculated by summing up the intermediate results above\n        - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n    */\n    function optimalLog(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;} // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;} // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;} // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;} // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;} // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;} // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;} // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;} // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = y * y / FIXED_1;\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n        Return e ^ (x / FIXED_1) * FIXED_1\n        Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n        Auto-generated via 'PrintFunctionOptimalExp.py'\n        Detailed description:\n        - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n        - The exponentiation of each binary exponent is given (pre-calculated)\n        - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n        - The exponentiation of the input is calculated by multiplying the intermediate results above\n        - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n    */\n    function optimalExp(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = z * y / FIXED_1; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = z * y / FIXED_1; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = z * y / FIXED_1; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = z * y / FIXED_1; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = z * y / FIXED_1; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = z * y / FIXED_1; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = z * y / FIXED_1; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = z * y / FIXED_1; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = z * y / FIXED_1; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = z * y / FIXED_1; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = z * y / FIXED_1; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = z * y / FIXED_1; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = z * y / FIXED_1; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = z * y / FIXED_1; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = z * y / FIXED_1; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = z * y / FIXED_1; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = z * y / FIXED_1; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { NibblVaultFactory } from \"../NibblVaultFactory.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract ProxyBasket {\n    address immutable public implementation;\n\n    constructor(address _implementation) {\n        implementation = payable(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    //solhint-disable-next-line no-complex-fallback\n    fallback() external payable virtual {\n        address _implementation = implementation;\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }    \n    }\n\n    receive() external payable {    }\n\n    }\n\n\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\nimport { IAccessControlMechanism } from \"../Interfaces/IAccessControlMechanism.sol\";\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\ncontract AccessControlMechanism is IAccessControlMechanism, AccessControl {\n    // Mechanism to implement propose and claim Access control Roles \n    // grantRole, revokeRole can be used to grant and revoke roles directly\n    \n    bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n\n    mapping(bytes32 => mapping(address => bool)) public pendingRoles;\n\n\n    constructor (address _admin) {\n        bytes32 _defaultAdminRole = DEFAULT_ADMIN_ROLE;\n        _grantRole(_defaultAdminRole, _admin);\n        _setRoleAdmin(_defaultAdminRole, _defaultAdminRole);\n        _setRoleAdmin(FEE_ROLE, _defaultAdminRole);\n        _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole);\n        _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole);\n    }\n\n    /// @notice sets admin role for a role\n    /// @dev can only be called adminRole of _role\n    /// @param _role roles whose admin needs to be updated\n    /// @param _adminRole new admin role\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {\n        _setRoleAdmin(_role, _adminRole);\n    }\n\n    /// @notice proposes a user for a role\n    /// @dev can only be called by admin of that role\n    /// @param _role _role to which the user is proposed\n    /// @param _to user proposed\n    function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) {\n        pendingRoles[_role][_to] = true;\n    }\n\n    /// @notice proposed user needs to claim the role\n    /// @dev can only be called by the proposed user\n    /// @param _role role to be claimed\n    function claimRole(bytes32 _role) external override {\n        require(pendingRoles[_role][msg.sender], \"AccessControl: Role not pending\");\n        _grantRole(_role, msg.sender);\n        delete pendingRoles[_role][msg.sender];\n    }\n\n\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { BancorFormula } from \"./Bancor/BancorFormula.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { NibblVaultFactory } from \"./NibblVaultFactory.sol\";\nimport { Twav } from \"./Twav/Twav.sol\";\nimport { EIP712Base } from \"./Utilities/EIP712Base.sol\";\nimport { INibblVault } from \"./Interfaces/INibblVault.sol\";\n\n/// @title Vault to lock NFTs and fractionalize ERC721 to ERC20.\n/// @dev This contract uses Bancor Formula to create an automated market for fractionalized ERC20s.\n/// @dev This contract creates 2 bonding curves, referred to as primary curve and secondary curve.\n/// @dev The primary curve has fixed specifications and reserveRatio.\n/// @dev The secondary curve is dynamic and has a variable reserveRatio, which depends on initial conditions given by the curator and the fee accumulated by the curve.\ncontract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base {\n\n    /// @notice Scale for calculations to avoid rounding errors\n    uint256 private constant SCALE = 1_000_000; \n\n    /// @notice Reserve ratio of primary curve \n    /// @dev primaryReserveRatio has been multiplied with SCALE\n    /// @dev primaryReserveRatio lies between 0 and 1_000_000, 500_000 is equivalent to 50% reserve ratio\n    uint32 private constant primaryReserveRatio = 200_000; //20%\n    \n    /// @notice The premium percentage above the buyoutBid at which the buyout is rejected\n    /// @dev REJECTION_PREMIUM has been multiplied with SCALE\n    /// @dev REJECTION_PREMIUM lies between 0 and 1_000_000, i.e. 100_000 means 10%\n    /// @dev if REJECTION_PREMIUM is 15% and the buyoutBid is 100, then the buyout is rejected when the valuation reaches 115\n    uint256 private constant REJECTION_PREMIUM = 150_000; //15%\n\n    /// @notice The days until which a buyout bid is valid, if the bid isn't rejected in buyout duration time, its automatically considered boughtOut\n    uint256 private constant BUYOUT_DURATION = 5 days; \n\n    /// @notice The percentage of fee that goes for liquidity in lower curve until its reserve ratio becomes equal to primaryReserveRatio\n    uint256 private constant CURVE_FEE = 4_000;\n\n    /// @notice minimum reserve ratio that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_RATIO = 50_000;\n\n    /// @notice minimum curator fee that the curator will get on adding minimal liquidity to the secondary curve\n    uint256 private constant MIN_CURATOR_FEE = 5_000; //0.5%\n\n    /// @notice minimum reserve balance that the secondary curve can have initially \n    uint256 private constant MIN_SECONDARY_RESERVE_BALANCE = 1e9;\n\n    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\n    /// @notice The reserve ratio of the secondary curve.\n    /// @dev secondaryReserveRatio has been multiplied with SCALE\n    /// @dev secondary reserve ratio is dynamic and it can be <= primaryReserveRatio\n    uint32 public secondaryReserveRatio;\n\n    /// @notice address of the factory contract\n    address payable public factory;\n\n    /// @notice address of the original NFT owner\n    address public curator; \n\n    /// @notice token address of the NFT being deposited in the vault\n    address public assetAddress;\n\n    /// @notice token ID of the NFT being deposited in the vault  \n    uint256 public assetID;\n\n    /// @notice address which triggered the buyout\n    address public bidder; \n\n    /// @notice initial price of the fractional ERC20 Token set by the curator\n    uint256 public initialTokenPrice;\n\n    /// @notice fictitious primary reserve balance, this is used for calculation purposes of trading on primary bonding curve.\n    /// @dev This variable defines the amount of reserve token that should be in the secondary curve if secondaryReserveRatio == primaryReserveRatio\n    /// @dev This variable also defines the amount of reserve token that should be in the primary curve if the primary curve started from 0 and went till initialTokenSupply \n    uint256 public fictitiousPrimaryReserveBalance;\n\n    /// @notice the valuation at which the buyout is rejected.\n    uint256 public buyoutRejectionValuation; \n    \n    /// @notice deposit made by bidder to initiate buyout \n    /// @dev buyoutValuationDeposit = currentValuation - ((reserveTokens in primary curve) + (reserveTokens in secondary curve))\n    uint256 public buyoutValuationDeposit; \n    \n    /// @notice initial token supply minted by curator\n    uint256 public initialTokenSupply; \n    \n    /// @notice reserve balance of the primary curve\n    uint256 public primaryReserveBalance;\n    \n    /// @notice reserve balance of the secondary curve\n    uint256 public secondaryReserveBalance;\n    \n    /// @notice total value of unclaimed fees accrued to the curator via trading on the bonding curve\n    uint256 public feeAccruedCurator; \n    \n    /// @notice the time at which the current buyout ends\n    uint256 public buyoutEndTime; \n    \n    /// @notice valuation at which the buyout was triggered\n    uint256 public buyoutBid;\n\n    /// @notice percentage of trading fee on the bonding curve that goes to the curator\n    uint256 public curatorFee;\n\n    /// @notice total value of unclaimed buyout bids\n    uint256 public totalUnsettledBids; \n\n    /// @notice minimum time after which buyout can be triggered\n    uint256 public minBuyoutTime;\n\n    /// @notice mapping of buyout bidders and their respective unsettled bids\n    mapping(address => uint256) public unsettledBids; \n    mapping(address => uint256) public nonces; \n    \n    enum Status {initialized, buyout}\n\n    ///@notice current status of vault\n    Status public status;\n\n    ///@notice reenterancy guard\n    uint256 private unlocked = 2;\n\n    modifier lock() {\n        require(unlocked == 1, 'NibblVault: LOCKED');\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n\n    /// @notice To check if buyout hasn't succeeded\n    /// @dev Check for the case when buyoutTime has not passed or buyout has been rejected\n    modifier notBoughtOut() {\n        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');\n        _;\n    }\n\n    /// @notice To check if buyout has succeeded\n    /// @dev For the case when buyoutTime has passed and buyout has not been rejected\n    modifier boughtOut() {\n        require(status == Status.buyout, \"NibblVault: status != buyout\");\n        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");\n        _;\n    }\n\n    /// @notice To check if system isn't paused\n    /// @dev pausablity implemented in factory\n    modifier whenNotPaused() {\n        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');\n        _;\n    }\n\n    /// @notice the function to initialize proxy vault parameters\n    /// @param _tokenName name of the fractionalized ERC20 token to be created\n    /// @param _tokenSymbol symbol of the fractionalized ERC20 token\n    /// @param _assetAddress address of the ERC721 being fractionalized\n    /// @param _assetID tokenId of the ERC721 being fractionalized\n    /// @param _curator owner of the asset getting fractionalized\n    /// @param _initialTokenSupply desired initial supply to be minted to curator\n    /// @param _initialTokenPrice desired initial token price set by curator \n    /// @param  _minBuyoutTime minimum time after which buyout can be triggered \n    /// @dev valuation = price * supply\n    /// @dev reserveBalance = valuation * reserveRatio\n    /// @dev Reserve Ratio = Reserve Token Balance / (Continuous Token Supply x Continuous Token Price)\n    /// @dev curatorFee is proportional to initialLiquidity added by user. \n    /// @dev curatorFee can be maximum of 2 * MinimumCuratorFee.\n\n    function initialize(\n        string memory _tokenName, \n        string memory _tokenSymbol, \n        address _assetAddress,\n        uint256 _assetID,\n        address _curator,\n        uint256 _initialTokenSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n    ) external override initializer payable {\n        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));\n        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");\n        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");\n        INIT_EIP712(\"NibblVault\", \"1\");\n        __ERC20_init(_tokenName, _tokenSymbol);\n        unlocked = 1;\n        initialTokenPrice=_initialTokenPrice;\n        factory = payable(msg.sender);\n        assetAddress = _assetAddress;\n        assetID = _assetID;\n        curator = _curator;\n        initialTokenSupply = _initialTokenSupply;\n        uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);\n        primaryReserveBalance = _primaryReserveBalance;\n        fictitiousPrimaryReserveBalance = _primaryReserveBalance;\n        secondaryReserveBalance = msg.value;\n        secondaryReserveRatio = _secondaryReserveRatio;\n        //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator\n        minBuyoutTime = _minBuyoutTime;\n        _mint(_curator, _initialTokenSupply);\n    }\n\n    /// @notice Function used to charge fee on trades\n    /// @dev There are 3 different fees charged - admin, curator and curve\n    /// @dev Admin fee percentage is fetched from the factory contract and the fee charged is transferred to factory contract\n    /// @dev Curator fee is fetched from curatorFee variable and total fee accrued is stored in feeAccruedCurator variable\n    /// @dev Curve fee is fetched from the CURVE_FEE variable and is added to the secondaryReserveBalance variable\n    /// @param _amount amount to charge fee on either a buy or sell order, fee is charged in reserve token\n    /// @return the amount after fee is deducted\n    function _chargeFee(uint256 _amount) private returns(uint256) {\n        address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        uint256 _feeCurve = (_amount * CURVE_FEE) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        //_maxSecondaryBalanceIncrease: is the max amount of secondary reserve balance that can be added to the vault\n        //_maxSecondaryBalanceIncrease cannot be more than fictitiousPrimaryReserveBalance\n        uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance;\n        // _feeCurve can't be higher than _maxSecondaryBalanceIncrease\n        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance\n        secondaryReserveBalance += _feeCurve;\n        secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade \n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator + _feeCurve);\n    }\n\n    /// @notice Function to charge fee in secondary curve\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount amount to charge fee on trade order, fee is charged in reserve token\n    /// @return amount of tokens after fee is deducted\n    function _chargeFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        feeAccruedCurator += _feeCurator;\n        if(_adminFeeAmt > 0) {\n            safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract\n        }\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n\n    /// @notice Maximum number of reserve tokens that can be held on SecondaryCurve at current secondary reserve ratio\n    /// @dev The max continous tokens on SecondaryCurve is equal to initialTokenSupply\n    /// @dev Reserve Token Balance = Reserve Ratio * (Continuous Token Supply x Continuous Token Price)\n    function getMaxSecondaryCurveBalance() private view returns(uint256){\n            return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));\n    }\n\n    /// @notice gives current valuation of the system\n    /// @dev valuation = price * supply\n    /// @dev fictitiousPrimaryReserveBalance doesn't denote any actual reserve balance its just for calculation purpose\n    /// @dev Actual reserve balance in primary curve = primaryReserveBalance - fictitiousPrimaryReserveBalance\n    /// @dev Total reserve balance = Actual reserve balance in primary curve + secondaryReserveBalance\n    /// @dev Total reserve balance = (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance\n    /// @dev Valuation = (Continuous Token Supply x Continuous Token Price) = Reserve Token Balance / Reserve Ratio\n    /// @dev Valuation = If current supply is on seconday curve we use secondaryReserveBalance and secondaryReserveRatio to calculate valuation else we use primary reserve ratio and balance\n    /// @return Current valuation of the system\n    function getCurrentValuation() private view returns(uint256) {\n            return totalSupply() < initialTokenSupply ? (secondaryReserveBalance * SCALE /secondaryReserveRatio) : ((primaryReserveBalance) * SCALE  / primaryReserveRatio);\n    }\n\n    /// @notice function to buy tokens on the primary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply >= initial supply\n    /// @dev _amount is charged with fee\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buyPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFee(_amount);\n        uint256 _primaryReserveBalance = primaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amountIn);\n        primaryReserveBalance = _primaryReserveBalance + _amountIn;\n    }\n    /// @notice function to buy tokens on secondary curve\n    /// @param _amount amount of reserve tokens to buy continous tokens\n    /// @dev This is executed when current supply < initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @dev _purchaseReturn is minted to _to\n    /// @return _purchaseReturn Purchase return\n    function _buySecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns (uint256 _purchaseReturn) {\n        uint256 _amountIn = _chargeFeeSecondaryCurve(_amount);\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _purchaseReturn = _calculatePurchaseReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amountIn);\n        secondaryReserveBalance = _secondaryReserveBalance + _amountIn;\n    }\n\n    /// @notice The function to buy fractional tokens for reserveTokens\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev It internally calls _buyPrimaryCurve or _buySecondaryCurve or both depending on the buyAmount and current supply\n    /// @dev if current totalSupply < initialTokenSupply AND _amount to buy tokens for is greater than (maxSecondaryCurveBalance - currentSecondaryCurveBalance) then buy happens on secondary curve and primary curve both\n    /// @param _minAmtOut Minimum amount of continuous token user receives, else the tx fails.\n    /// @param _to Address to mint the purchase return to\n    function buy(uint256 _minAmtOut, address _to) external override payable notBoughtOut lock whenNotPaused returns(uint256 _purchaseReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout();\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply >= _initialTokenSupply) {\n            _purchaseReturn = _buyPrimaryCurve(msg.value, _totalSupply);\n        } else {\n            uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance;\n            if (_lowerCurveDiff >= msg.value) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _lowerCurveDiff, _totalSupply + _purchaseReturn);\n            } \n        }\n        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");\n        _mint(_to, _purchaseReturn);\n        emit Buy(msg.sender, _purchaseReturn, msg.value);\n    }\n\n    /// @notice The function to sell fractional tokens on primary curve\n    /// @dev Executed when currentSupply > initialSupply\n    /// @dev _amount is charged with fee\n    /// @param _amount Amount of tokens to be sold on primary curve\n    /// @return _saleReturn Sale Return\n    function _sellPrimaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn) {\n        uint _primaryReserveBalance = primaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _primaryReserveBalance, primaryReserveRatio, _amount);\n        primaryReserveBalance = _primaryReserveBalance - _saleReturn;\n        _saleReturn = _chargeFee(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens on secondary curve\n    /// @dev Executed when current supply <= initial supply\n    /// @dev only admin and curator fee is charged in secondary curve\n    /// @param _amount Amount of tokens to be sold on SecondaryCurve\n    ///  @return _saleReturn Sale Return\n    function _sellSecondaryCurve(uint256 _amount, uint256 _totalSupply) private returns(uint256 _saleReturn){\n        uint _secondaryReserveBalance = secondaryReserveBalance;\n        _saleReturn = _calculateSaleReturn(_totalSupply, _secondaryReserveBalance, secondaryReserveRatio, _amount);\n        secondaryReserveBalance = _secondaryReserveBalance - _saleReturn;\n        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");\n        _saleReturn = _chargeFeeSecondaryCurve(_saleReturn);\n    }\n\n    /// @notice The function to sell fractional tokens for reserve token\n    /// @dev TWAV is updated only if buyout is active and only on first buy or sell txs of block.\n    /// @dev internally calls _sellPrimaryCurve or _sellSecondaryCurve or both depending on the sellAmount and current supply\n    /// @dev if totalSupply > initialTokenSupply AND _amount to sell is greater than (_amtIn > totalSupply - initialTokenSupply) then sell happens on primary curve and secondary curve both\n    /// @param _amtIn Continous Tokens to be sold\n    /// @param _minAmtOut Minimum amount of reserve token user receives, else the tx fails.\n    /// @param _to Address to recieve the reserve token to\n    function sell(uint256 _amtIn, uint256 _minAmtOut, address payable _to) external override notBoughtOut whenNotPaused returns(uint256 _saleReturn) {\n        //Make update on the first tx of the block\n        if (status == Status.buyout) {\n            uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n            if (_blockTimestamp != lastBlockTimeStamp) {\n                _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n                _rejectBuyout(); //For the case when TWAV goes up when updated on sell\n            }\n        }\n        uint256 _initialTokenSupply = initialTokenSupply;\n        uint256 _totalSupply = totalSupply();\n        if(_totalSupply > _initialTokenSupply) {\n            if ((_initialTokenSupply + _amtIn) <= _totalSupply) {\n                _saleReturn = _sellPrimaryCurve(_amtIn, _totalSupply);\n            } else {\n                //Gas Optimization\n                uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;\n                _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance;\n                primaryReserveBalance -= _saleReturn;\n                _saleReturn = _chargeFee(_saleReturn);\n                // _saleReturn = _sellPrimaryCurve(_tokensPrimaryCurve);\n                _saleReturn += _sellSecondaryCurve(_amtIn - _tokensPrimaryCurve, _initialTokenSupply);\n            } } else {\n                _saleReturn = _sellSecondaryCurve(_amtIn,_totalSupply);\n        }\n        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");\n        _burn(msg.sender, _amtIn);\n        safeTransferETH(_to, _saleReturn); //send _saleReturn to _to\n        emit Sell(msg.sender, _amtIn, _saleReturn);\n    }\n\n    /// @notice Function to initiate buyout of ERC721\n    /// @dev buyoutBid is set to current valuation\n    /// @dev bidder needs to send funds equal to current valuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance) to initiate buyout\n    /// This ensures that the original bidder doesn't need to support the whole valuation and liquidity in reserve can be used as well.\n    /// Buyout is initiated only when total bid amount >= currentValuation but extra funds over currentValuation are sent back to bidder.\n    function initiateBuyout() external override payable whenNotPaused returns(uint256 _buyoutBid) {\n        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");\n        require(status == Status.initialized, \"NibblVault: Status!=initialized\");\n        _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance;\n        //_buyoutBid: Bid User has made\n        uint256 _currentValuation = getCurrentValuation();\n        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");\n        // buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance); \n        buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);\n        bidder = msg.sender;\n        buyoutBid = _currentValuation;\n        // buyoutBid: Bid can only be placed at current valuation\n        buyoutRejectionValuation = (_currentValuation * (SCALE + REJECTION_PREMIUM)) / SCALE;\n        buyoutEndTime = block.timestamp + BUYOUT_DURATION;\n        status = Status.buyout;\n        _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));\n        if (_buyoutBid > _currentValuation) {\n            safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));\n        }\n        emit BuyoutInitiated(msg.sender, _buyoutBid);\n    }\n\n    /// @notice Function to reject buyout\n    /// @dev Triggered when someone buys tokens and curve valuation increases\n    /// @dev If TWAV >= Buyout rejection valuation then the buyout is rejected\n    /// @dev Called only when TWAV is updated\n    function _rejectBuyout() private notBoughtOut {\n        uint256 _twav = _getTwav();\n        if (_twav >= buyoutRejectionValuation) {\n            uint256 _buyoutValuationDeposit = buyoutValuationDeposit;\n            unsettledBids[bidder] += _buyoutValuationDeposit;\n            totalUnsettledBids += _buyoutValuationDeposit;\n            delete buyoutRejectionValuation;\n            delete buyoutEndTime;\n            delete bidder;\n            delete twavObservations;\n            delete twavObservationsIndex;\n            delete lastBlockTimeStamp;\n            status = Status.initialized;\n            emit BuyoutRejected(_twav);\n        }\n    }\n\n    /// @notice Updates the TWAV when in buyout\n    /// @dev TWAV can be updated only in buyout state\n    function updateTWAV() external override {\n        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n        uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n        if (_blockTimestamp != lastBlockTimeStamp) {\n            _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n            _rejectBuyout(); //For the case when TWAV goes up when updated externally\n        }\n    }\n\n    /// @notice Function to allow withdrawal of unsettledBids after buyout has been rejected\n    /// @param _to Address to receive the funds\n    function withdrawUnsettledBids(address payable _to) external override {\n        uint _amount = unsettledBids[msg.sender];\n        delete unsettledBids[msg.sender];\n        totalUnsettledBids -= _amount;\n        safeTransferETH(_to, _amount);\n    }\n\n    /// @notice Function for tokenholders to redeem their tokens for reserve token in case of buyout success\n    /// @dev The redeemed reserve token are in proportion to the token supply someone owns\n    /// @dev The amount available for redemption is contract balance - (total unsettled bid and curator fees accrued)\n    function redeem(address payable _to) external override boughtOut returns(uint256 _amtOut){\n        uint256 _balance = balanceOf(msg.sender);\n        _amtOut = ((address(this).balance - feeAccruedCurator - totalUnsettledBids) * _balance) / totalSupply();\n        _burn(msg.sender, _balance);\n        safeTransferETH(_to, _amtOut);\n    }\n\n    /// @notice Function to allow curator to redeem accumulated curator fee.\n    /// @param _to the address where curator fee will be sent\n    /// @dev can only be called by curator\n    function redeemCuratorFee(address payable _to) external override returns(uint256 _feeAccruedCurator) {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        _feeAccruedCurator = feeAccruedCurator;\n        feeAccruedCurator = 0;\n        safeTransferETH(_to, _feeAccruedCurator);\n    }\n\n\n    /// @notice to update the curator address\n    /// @param _newCurator new curator address \n    /// @dev can only be called by curator\n    function updateCurator(address _newCurator) external override {\n        require(msg.sender == curator,\"NibblVault: Only Curator\");\n        curator = _newCurator;\n    }\n\n\n    /// @notice Function for allowing bidder to unlock his ERC721 in case of buyout success\n    /// @param _assetAddress the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC721(address _assetAddress, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        IERC721(_assetAddress).safeTransferFrom(address(this), _to, _assetID);\n    }\n\n    ///@notice withdraw multiple ERC721s\n    /// @param _assetAddresses the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder,\"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assetAddresses.length; i++) {\n            IERC721(_assetAddresses[i]).safeTransferFrom(address(this), _to, _assetIDs[i]);\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC20s in case of buyout success\n    /// @notice ERC20s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC20(address _asset, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)));\n    }\n\n    /// @notice withdraw multiple ERC20s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _to the address where unlocked NFTs will be sent\n    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Function for allowing bidder to unlock his ERC1155s in case of buyout success\n    /// @notice ERC1155s can be accumulated by the underlying ERC721 in the vault as royalty or airdops \n    /// @param _asset the address of asset to be unlocked\n    /// @param _assetID the ID of asset to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawERC1155(address _asset, uint256 _assetID, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        uint256 balance = IERC1155(_asset).balanceOf(address(this),  _assetID);\n        IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\");\n    }\n\n    /// @notice withdraw multiple ERC1155s\n    /// @param _assets the addresses of assets to be unlocked\n    /// @param _assetIDs the IDs of assets to be unlocked\n    /// @param _to the address where unlocked NFT will be sent\n    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {\n        require(msg.sender == bidder, \"NibblVault: Only winner\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            uint256 balance = IERC1155(_assets[i]).balanceOf(address(this),  _assetIDs[i]);\n            IERC1155(_assets[i]).safeTransferFrom(address(this), _to, _assetIDs[i], balance, \"0\");\n        }\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        address signer = ecrecover(toTypedMessageHash(structHash), v, r, s);\n        require(signer == owner, \"NibblVault: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function safeTransferETH(address payable _to, uint256 _amount) private {\n        (bool success, ) = _to.call{value: _amount}(\"\");\n        require(success, \"NibblVault: ETH transfer failed\");\n    }\n\n    function onERC721Received( address, address, uint256, bytes calldata ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {}\n}\n\n",
        "CodeNames": [
            "Basket.sol",
            "BancorFormula.sol",
            "ProxyBasket.sol",
            "NibblVaultFactory.sol",
            "AccessControlMechanism.sol",
            "NibblVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-20",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n\n16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n\n17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n\n18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n\n19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n"
                ],
                "Type": " Event is missing  indexed  fields",
                "Description": "\nEach event should use three indexed fields if there are three or more fields\n\n*There are 5 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n15:       event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n\n16:       event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n\n17:       event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n\n18:       event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n\n19:       event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L15\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-06-nibbl-findings/issues/139#issuecomment-1173978577):\n  Great feedback & it all appears valid.\n\n*\n\n# Gas Optimizations\n\nFor this contest, 63 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-06-nibbl-findings/issues/140) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: joestakey(https://github.com/code-423n4/2022-06-nibbl-findings/issues/180), BowTiedWardens(https://github.com/code-423n4/2022-06-nibbl-findings/issues/125), _Adam(https://github.com/code-423n4/2022-06-nibbl-findings/issues/122), m_Rassska(https://github.com/code-423n4/2022-06-nibbl-findings/issues/221), 0xkatana(https://github.com/code-423n4/2022-06-nibbl-findings/issues/101), 0xKitsune(https://github.com/code-423n4/2022-06-nibbl-findings/issues/33), defsec(https://github.com/code-423n4/2022-06-nibbl-findings/issues/162), MiloTruck(https://github.com/code-423n4/2022-06-nibbl-findings/issues/158), c3phas(https://github.com/code-423n4/2022-06-nibbl-findings/issues/277), minhquanym(https://github.com/code-423n4/2022-06-nibbl-findings/issues/309), hansfriese(https://github.com/code-423n4/2022-06-nibbl-findings/issues/114), catchup(https://github.com/code-423n4/2022-06-nibbl-findings/issues/99), robee(https://github.com/code-423n4/2022-06-nibbl-findings/issues/228), UnusualTurtle(https://github.com/code-423n4/2022-06-nibbl-findings/issues/265), 0xNazgul(https://github.com/code-423n4/2022-06-nibbl-findings/issues/59), reassor(https://github.com/code-423n4/2022-06-nibbl-findings/issues/294), TomJ(https://github.com/code-423n4/2022-06-nibbl-findings/issues/204), sashik_eth(https://github.com/code-423n4/2022-06-nibbl-findings/issues/320), pashov(https://github.com/code-423n4/2022-06-nibbl-findings/issues/316), delfin454000(https://github.com/code-423n4/2022-06-nibbl-findings/issues/205), Tomio(https://github.com/code-423n4/2022-06-nibbl-findings/issues/70), slywaters(https://github.com/code-423n4/2022-06-nibbl-findings/issues/279), ElKu(https://github.com/code-423n4/2022-06-nibbl-findings/issues/170), JC(https://github.com/code-423n4/2022-06-nibbl-findings/issues/312), saian(https://github.com/code-423n4/2022-06-nibbl-findings/issues/212), 0x1f8b(https://github.com/code-423n4/2022-06-nibbl-findings/issues/32), Noah3o6(https://github.com/code-423n4/2022-06-nibbl-findings/issues/224), sach1r0(https://github.com/code-423n4/2022-06-nibbl-findings/issues/80), 8olidity(https://github.com/code-423n4/2022-06-nibbl-findings/issues/82), ajtra(https://github.com/code-423n4/2022-06-nibbl-findings/issues/155), ellahi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/295), oyc_109(https://github.com/code-423n4/2022-06-nibbl-findings/issues/15), TerrierLover(https://github.com/code-423n4/2022-06-nibbl-findings/issues/164), simon135(https://github.com/code-423n4/2022-06-nibbl-findings/issues/288), Chom(https://github.com/code-423n4/2022-06-nibbl-findings/issues/281), 0x29A(https://github.com/code-423n4/2022-06-nibbl-findings/issues/109), Waze(https://github.com/code-423n4/2022-06-nibbl-findings/issues/141), fatherOfBlocks(https://github.com/code-423n4/2022-06-nibbl-findings/issues/78), rfa(https://github.com/code-423n4/2022-06-nibbl-findings/issues/282), 0xf15ers(https://github.com/code-423n4/2022-06-nibbl-findings/issues/241), ACai(https://github.com/code-423n4/2022-06-nibbl-findings/issues/183), cRat1st0s(https://github.com/code-423n4/2022-06-nibbl-findings/issues/156), Picodes(https://github.com/code-423n4/2022-06-nibbl-findings/issues/315), Chandr(https://github.com/code-423n4/2022-06-nibbl-findings/issues/213), ych18(https://github.com/code-423n4/2022-06-nibbl-findings/issues/202), 0v3rf10w(https://github.com/code-423n4/2022-06-nibbl-findings/issues/93), Randyyy(https://github.com/code-423n4/2022-06-nibbl-findings/issues/230), zuhaibmohd(https://github.com/code-423n4/2022-06-nibbl-findings/issues/51), StErMi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/95), ynnad(https://github.com/code-423n4/2022-06-nibbl-findings/issues/119), cryptphi(https://github.com/code-423n4/2022-06-nibbl-findings/issues/75), Funen(https://github.com/code-423n4/2022-06-nibbl-findings/issues/238), Lambda(https://github.com/code-423n4/2022-06-nibbl-findings/issues/52), Nyamcil(https://github.com/code-423n4/2022-06-nibbl-findings/issues/116), kenta(https://github.com/code-423n4/2022-06-nibbl-findings/issues/186), Limbooo(https://github.com/code-423n4/2022-06-nibbl-findings/issues/90), IgnacioB(https://github.com/code-423n4/2022-06-nibbl-findings/issues/258), SmartSek(https://github.com/code-423n4/2022-06-nibbl-findings/issues/256), codexploder(https://github.com/code-423n4/2022-06-nibbl-findings/issues/40), exd0tpy(https://github.com/code-423n4/2022-06-nibbl-findings/issues/84), kebabsec(https://github.com/code-423n4/2022-06-nibbl-findings/issues/154), and Fitraldys(https://github.com/code-423n4/2022-06-nibbl-findings/issues/290).*\n\n|    | Issue                                                                                                                                                      | Instances |\n| -| :--------------------------------------------------------------------------------------------------------------------------------------------------------| :-------: |\n| 1  | Setting DEFAULT_ADMIN_ROLE as the role admin is redundant                                                                                                |     1     |\n| 2  | Using calldata instead of memory for read-only arguments in external functions saves gas                                                             |     23    |\n| 3  | Using storage instead of memory for structs/arrays saves gas                                                                                           |     2     |\n| 4  | State variables should be cached in stack variables rather than re-reading them from storage                                                               |     1     |\n| 5  | <x += <y costs more gas than <x = <x + <y for state variables                                                                                     |     7     |\n| 6  | internal functions only called once can be inlined to save gas                                                                                           |     1     |\n| 7  | Add unchecked {} for subtractions where the operands cannot underflow because of a previous require() or if-statement                                |     5     |\n| 8  | <array.length should not be looked up in every loop of a for-loop                                                                                     |     6     |\n| 9  | ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, as is the case when used in forand while-loops |     6     |\n| 10 | require()/revert() strings longer than 32 bytes cost extra gas                                                                                         |     7     |\n| 11 | Using bools for storage incurs overhead                                                                                                                  |     1     |\n| 12 | Use a more recent version of solidity                                                                                                                      |     1     |\n| 13 | = costs less gas than                                                                                                                                |     1     |\n| 14 | It costs more gas to initialize non-constant/non-immutable variables to zero than to let the default of zero be applied                                |     6     |\n| 15 | ++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too)                                                                |     6     |\n| 16 | Splitting require() statements that use && saves gas                                                                                                   |     4     |\n| 17 | Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead                                                                                   |     14    |\n| 18 | Using private rather than public for constants, saves gas                                                                                              |     3     |\n| 19 | Don't use SafeMath once the solidity version is 0.8.0 or greater                                                                                         |     1     |\n| 20 | Duplicated require()/revert() checks should be refactored to a modifier or function                                                                    |     3     |\n| 21 | Empty blocks should be removed or emit something                                                                                                           |     5     |\n| 22 | Use custom errors rather than revert()/require() strings to save gas                                                                                   |     41    |\n| 23 | Functions guaranteed to revert when called by normal users can be marked payable                                                                         |     8     |\n\nTotal: 153 instances over 23 issues\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\nimport { IAccessControlMechanism } from \"../Interfaces/IAccessControlMechanism.sol\";\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\ncontract AccessControlMechanism is IAccessControlMechanism, AccessControl {\n    // Mechanism to implement propose and claim Access control Roles \n    // grantRole, revokeRole can be used to grant and revoke roles directly\n    \n    bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");\n\n    mapping(bytes32 => mapping(address => bool)) public pendingRoles;\n\n\n    constructor (address _admin) {\n        bytes32 _defaultAdminRole = DEFAULT_ADMIN_ROLE;\n        _grantRole(_defaultAdminRole, _admin);\n        _setRoleAdmin(_defaultAdminRole, _defaultAdminRole);\n        _setRoleAdmin(FEE_ROLE, _defaultAdminRole);\n        _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole);\n        _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole);\n    }\n\n    /// @notice sets admin role for a role\n    /// @dev can only be called adminRole of _role\n    /// @param _role roles whose admin needs to be updated\n    /// @param _adminRole new admin role\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external override onlyRole(getRoleAdmin(_role)) {\n        _setRoleAdmin(_role, _adminRole);\n    }\n\n    /// @notice proposes a user for a role\n    /// @dev can only be called by admin of that role\n    /// @param _role _role to which the user is proposed\n    /// @param _to user proposed\n    function proposeGrantRole(bytes32 _role, address _to) external override onlyRole(getRoleAdmin(_role)) {\n        pendingRoles[_role][_to] = true;\n    }\n\n    /// @notice proposed user needs to claim the role\n    /// @dev can only be called by the proposed user\n    /// @param _role role to be claimed\n    function claimRole(bytes32 _role) external override {\n        require(pendingRoles[_role][msg.sender], \"AccessControl: Role not pending\");\n        _grantRole(_role, msg.sender);\n        delete pendingRoles[_role][msg.sender];\n    }\n\n\n}\n\n",
        "CodeNames": [
            "AccessControlMechanism.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole);\n23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole);\n24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole);\n25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole);\n"
                ],
                "Type": " Setting  DEFAULT_ADMIN_ROLE  as the role admin is redundant",
                "Description": "\nDEFAULT_ADMIN_ROLE is automatically(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole);\n23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole);\n24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole);\n25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole);\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { ERC721, IERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IBasket } from \"./Interfaces/IBasket.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n * Mint a single ERC721 which can hold NFTs\n */\ncontract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable {\n\n    event DepositERC721(address indexed token, uint256 tokenId, address indexed from);\n    event WithdrawERC721(address indexed token, uint256 tokenId, address indexed to);\n    event DepositERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event DepositERC1155Bulk(address indexed token, uint256[] tokenId, uint256[] amount, address indexed from);\n    event WithdrawERC1155(address indexed token, uint256 tokenId, uint256 amount, address indexed from);\n    event WithdrawETH(address indexed who);\n    event WithdrawERC20(address indexed token, address indexed who);\n\n    function initialise(address _curator) external override initializer {\n        _mint(_curator, 0);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) || interfaceId == type(IBasket).interfaceId;\n    }\n\n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).safeTransferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n\n    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);\n            emit WithdrawERC721(_tokens[i], _tokenId[i], _to);\n        }\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC721Unsafe(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC721(_token).transferFrom(address(this), _to, _tokenId);\n        emit WithdrawERC721(_token, _tokenId, _to);\n    }\n    \n    /// @notice withdraw an ERC721 token from this contract into your wallet\n    /// @param _token the address of the NFT you are withdrawing\n    /// @param _tokenId the ID of the NFT you are withdrawing\n    function withdrawERC1155(address _token, uint256 _tokenId, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);\n        IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");\n        emit WithdrawERC1155(_token, _tokenId, _balance, _to);\n    }\n\n    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 _balance = IERC1155(_tokens[i]).balanceOf(address(this),  _tokenIds[i]);\n            IERC1155(_tokens[i]).safeTransferFrom(address(this), _to, _tokenIds[i], _balance, \"0\");\n            emit WithdrawERC1155(_tokens[i], _tokenIds[i], _balance, _to);\n        }\n    }\n\n    /// @notice withdraw ETH in the case a held NFT earned ETH (ie. euler beats)\n    function withdrawETH(address payable _to) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        _to.transfer(address(this).balance);\n        emit WithdrawETH(_to);\n    }\n\n    /// @notice withdraw ERC20 in the case a held NFT earned ERC20\n    function withdrawERC20(address _token) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n        emit WithdrawERC20(_token, msg.sender);\n    }\n\n    function withdrawMultipleERC20(address[] memory _tokens) external override {\n        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this)));\n            emit WithdrawERC20(_tokens[i], msg.sender);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {\n        emit DepositERC721(msg.sender, id, from);\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155(msg.sender, id, amount, from);\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {\n        emit DepositERC1155Bulk(msg.sender, ids, amounts, from);\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n* @title Bancor formula by Bancor\n*\n* Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements;\n* and to You under the Apache License, Version 2.0. \"\n*/\ncontract BancorFormula {\n    using SafeMath for uint256;\n    \n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_WEIGHT = 1_000_000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n        Auto-generated via 'PrintIntScalingFactors.py'\n    */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n        Auto-generated via 'PrintLn2ScalingFactors.py'\n    */\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n        Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n    */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n        Auto-generated via 'PrintFunctionConstructor.py'\n    */\n    uint256[128] private maxExpArray;\n    constructor() {\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\n        calculates the return for a given conversion (in the main token)\n        Formula:\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\n        @param _supply              token total supply\n        @param _connectorBalance    total connector balance\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\n        @param _depositAmount       deposit amount, in connector token\n        @return purchase return amount\n    */\n    function _calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) internal view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0)\n            return 0;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return _supply.mul(_depositAmount) / _connectorBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_connectorBalance);\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\n        calculates the return for a given conversion (in the connector token)\n        Formula:\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\n        @param _supply              token total supply\n        @param _connectorBalance    total connector\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\n        @param _sellAmount          sell amount, in the token itself\n        @return sale return amount\n    */\n    function _calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) internal view returns (uint256) {\n        // validate input\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0)\n            return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply)\n            return _connectorBalance;\n\n        // special case if the weight = 100%\n        if (_connectorWeight == MAX_WEIGHT)\n            return _connectorBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\n        uint256 temp1 = _connectorBalance.mul(result);\n        uint256 temp2 = _connectorBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n        General Description:\n            Determine a value of precision.\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n            Return the result along with the precision used.\n        Detailed Description:\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n            The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n            The larger \"precision\" is, the more accurately this value represents the real value.\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n            This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n    */\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) private view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = _baseN * FIXED_1 / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        }\n        else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        }\n        else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision), precision);\n        }\n    }\n\n    /**\n        Compute log(x / FIXED_1) * FIXED_1.\n        This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n    */\n    function generalLog(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\n    }\n\n    /**\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\n    */\n    function floorLog2(uint256 _n) private pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        }\n        else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n    */\n    function findPositionInMaxExpArray(uint256 _x) private view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x)\n                lo = mid;\n            else\n                hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x)\n            return hi;\n        if (maxExpArray[lo] >= _x)\n            return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n        This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n    */\n    function generalExp(uint256 _x, uint8 _precision) private pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision; res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n        Return log(x / FIXED_1) * FIXED_1\n        Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n        Auto-generated via 'PrintFunctionOptimalLog.py'\n        Detailed description:\n        - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n        - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n        - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n        - The natural logarithm of the input is calculated by summing up the intermediate results above\n        - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n    */\n    function optimalLog(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;} // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;} // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;} // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;} // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;} // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;} // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;} // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;} // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = y * y / FIXED_1;\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n        Return e ^ (x / FIXED_1) * FIXED_1\n        Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n        Auto-generated via 'PrintFunctionOptimalExp.py'\n        Detailed description:\n        - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n        - The exponentiation of each binary exponent is given (pre-calculated)\n        - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n        - The exponentiation of the input is calculated by multiplying the intermediate results above\n        - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n    */\n    function optimalExp(uint256 x) private pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = z * y / FIXED_1; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = z * y / FIXED_1; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = z * y / FIXED_1; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = z * y / FIXED_1; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = z * y / FIXED_1; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = z * y / FIXED_1; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = z * y / FIXED_1; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = z * y / FIXED_1; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = z * y / FIXED_1; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = z * y / FIXED_1; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = z * y / FIXED_1; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = z * y / FIXED_1; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = z * y / FIXED_1; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = z * y / FIXED_1; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = z * y / FIXED_1; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = z * y / FIXED_1; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = z * y / FIXED_1; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = z * y / FIXED_1; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\ncontract Twav {\n    struct TwavObservation {\n        uint32 timestamp;\n        uint256 cumulativeValuation;\n    }\n\n    /// @notice current index of twavObservations index\n    uint8 public twavObservationsIndex;\n    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks \n    uint32 public lastBlockTimeStamp;\n\n    /// @notice record of TWAV \n    TwavObservation[TWAV_BLOCK_NUMBERS] public twavObservations;\n\n    /// @notice updates twavObservations array\n    /// @param _blockTimestamp timestamp of the block\n    /// @param _valuation current valuation\n    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal {\n        uint32 _timeElapsed; \n        unchecked {\n            _timeElapsed = _blockTimestamp - lastBlockTimeStamp;\n        }\n\n        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation;\n        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative\n        twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS;\n        lastBlockTimeStamp = _blockTimestamp;\n    }\n\n    /// @notice returns the TWAV of the last 4 blocks\n    /// @return _twav TWAV of the last 4 blocks\n    function _getTwav() internal view returns(uint256 _twav){\n        if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) {\n            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS;\n            TwavObservation memory _twavObservationCurrent = twavObservations[(_index)];\n            TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS];\n            _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp);\n        }\n    }\n\n    function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) {\n        return twavObservations;\n    }\n}\n\n",
        "CodeNames": [
            "Basket.sol",
            "BancorFormula.sol",
            "Twav.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n"
                ],
                "Type": "  ++i / i++  should be  unchecked{++i} / unchecked{i++}  when it is not possible for them to overflow, as is the case when used in  for - and  while -loops",
                "Description": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop(https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)\n\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n43:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n70:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n93:           for (uint256 i = 0; i < _tokens.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43\n\nsolidity\nFile: contracts/NibblVault.sol\n\n506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {\n\n525:          for (uint256 i = 0; i < _assets.length; i++) {\n\n547:          for (uint256 i = 0; i < _assets.length; i++) {\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { NibblVaultFactory } from \"../NibblVaultFactory.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract ProxyBasket {\n    address immutable public implementation;\n\n    constructor(address _implementation) {\n        implementation = payable(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    //solhint-disable-next-line no-complex-fallback\n    fallback() external payable virtual {\n        address _implementation = implementation;\n        //solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }    \n    }\n\n    receive() external payable {    }\n\n    }\n\n\n\n\n",
        "CodeNames": [
            "ProxyBasket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "2",
                "Location": [
                    "//solidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.2 to get simple compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Utilities/AccessControlMechanism.sol   #1\n\n4:    pragma solidity ^0.8.0;\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4\n\n\n",
                "Repair": ""
            },
            {
                "Name": "1",
                "Location": [
                    "//solidity\nFile: contracts/Basket.sol\n\n114:      receive() external payable {}\n",
                    "//solidity\nFile: contracts/NibblVaultFactory.sol\n\n183:      receive() payable external {    }\n",
                    "//solidity\nFile: contracts/NibblVault.sol\n\n585:      receive() external payable {}\n",
                    "//solidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n56:       receive() external payable {    }\n",
                    "//solidity\nFile: contracts/Proxy/ProxyVault.sol\n\n56:       receive() external payable {    }\n"
                ],
                "Type": " Empty blocks should be removed or emit something",
                "Description": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be abstract and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (if(x){}else if(y){...}else{...} = if(!x){if(y){...}else{...}})\n\n*There are 5 instances of this issue:*\n\nsolidity\nFile: contracts/Basket.sol\n\n114:      receive() external payable {}\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114\n\nsolidity\nFile: contracts/NibblVaultFactory.sol\n\n183:      receive() payable external {    }\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183\n\nsolidity\nFile: contracts/NibblVault.sol\n\n585:      receive() external payable {}\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585\n\nsolidity\nFile: contracts/Proxy/ProxyBasket.sol\n\n56:       receive() external payable {    }\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56\n\nsolidity\nFile: contracts/Proxy/ProxyVault.sol\n\n56:       receive() external payable {    }\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "revert()"
                ],
                "Type": " Use custom errors rather than  revert() / require()  strings to save gas",
                "Description": "\nCustom errors are available from solidity version 0.8.4. Custom errors save ~50 gas(https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby avoiding having to allocate and store the revert string(https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 41 instances of this issue:*\n\nSee original submission(https://github.com/code-423n4/2022-06-nibbl-findings/issues/140) for details.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.10;\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { NibblVault } from \"./NibblVault.sol\";\nimport { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { ProxyVault } from \"./Proxy/ProxyVault.sol\";\nimport { ProxyBasket } from \"./Proxy/ProxyBasket.sol\";\nimport { NibblVaultFactoryData } from \"./Utilities/NibblVaultFactoryData.sol\";\nimport { AccessControlMechanism } from \"./Utilities/AccessControlMechanism.sol\";\nimport { INibblVaultFactory } from \"./Interfaces/INibblVaultFactory.sol\";\nimport { Basket } from \"./Basket.sol\";\n\ncontract NibblVaultFactory is INibblVaultFactory, AccessControlMechanism, Pausable, NibblVaultFactoryData {\n    /// @notice Minimum initial reserve balance a user has to deposit to create a new vault\n    uint256 private constant MIN_INITIAL_RESERVE_BALANCE = 1e9;\n\n    /// @notice array containing the addresses of all the vaults\n    ProxyVault[] public nibbledTokens;\n    constructor (address _vaultImplementation, address _feeTo, address _admin, address _basketImplementation) AccessControlMechanism(_admin) {\n        vaultImplementation = _vaultImplementation;\n        feeTo = _feeTo;\n        basketImplementation = _basketImplementation;\n    }\n\n    /// @notice mints a new vault\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _curator address of the vault curator\n    /// @param _name name of the fractional token to be created\n    /// @param _symbol symbol of the fractional token\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price\n    /// @param _minBuyoutTime minimum time after which buyout can be triggered\n    function createVault(\n        address _assetAddress,\n        address _curator,\n        string memory _name,\n        string memory _symbol,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice,\n        uint256 _minBuyoutTime\n        ) external payable override whenNotPaused returns(address payable _proxyVault) {\n        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");\n        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");\n        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this))));\n        NibblVault _vault = NibblVault(payable(_proxyVault));\n        _vault.initialize{value: msg.value}(_name, _symbol, _assetAddress, _assetTokenID, _curator, _initialSupply,_initialTokenPrice, _minBuyoutTime);\n        IERC721(_assetAddress).safeTransferFrom(msg.sender, address(_vault), _assetTokenID);\n        nibbledTokens.push(ProxyVault(_proxyVault));\n        emit Fractionalise(_assetAddress, _assetTokenID, _proxyVault);\n    }\n\n    /// @notice get address of vault to be deployed\n    /// @param _curator address of curator\n    /// @param _assetAddress address of the NFT contract which is being fractionalized\n    /// @param _assetTokenID tokenId of the NFT being fractionalized\n    /// @param _initialSupply desired initial token supply\n    /// @param _initialTokenPrice desired initial token price    \n    function getVaultAddress(\n        address _curator,\n        address _assetAddress,\n        uint256 _assetTokenID,\n        uint256 _initialSupply,\n        uint256 _initialTokenPrice) public view returns(address _vault) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice));\n        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this))));\n        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _vault = address(uint160(uint256(_hash)));     \n    }\n\n    function getVaults() public view returns(ProxyVault[] memory ) {\n        return nibbledTokens;\n    }\n\n    function createBasket(address _curator, string memory _mix) public override returns(address)  {\n        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation));\n        Basket _basket = Basket(_basketAddress);\n        _basket.initialise(_curator);\n        emit BasketCreated(_curator, _basketAddress);\n        return _basketAddress;\n    }\n\n    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) {\n        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));\n        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _basket = address(uint160(uint256(hash)));     \n    }\n\n    /// @notice proposes new Basket implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by IMPLEMENTER_ROLE\n    /// @param _newBasketImplementation new implementation basket address\n    function proposeNewBasketImplementation(address _newBasketImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingBasketImplementation = _newBasketImplementation;\n        basketUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new basket implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateBasketImplementation() external override {\n        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        basketImplementation = pendingBasketImplementation;\n        delete basketUpdateTime;\n    }\n\n    function withdrawAdminFee() external override {\n        (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");\n        require(_success);\n    }\n\n    // Cancellation functions aren't required as we can call propose function again with different parameters\n\n    /// @notice proposes new admin fee address\n    /// @dev new address can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFeeAddress new address to receive admin fee on address\n    function proposeNewAdminFeeAddress(address _newFeeAddress) external override onlyRole(FEE_ROLE) {\n        pendingFeeTo = _newFeeAddress;\n        feeToUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee address\n    /// @dev can only be updated after timelock\n    function updateNewAdminFeeAddress() external override {\n        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeTo = pendingFeeTo;\n        delete feeToUpdateTime;\n    }\n\n    /// @notice proposes new admin fee\n    /// @dev new fee can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newFee new admin fee \n    function proposeNewAdminFee(uint256 _newFee) external override onlyRole(FEE_ROLE) {\n        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");\n        pendingFeeAdmin = _newFee;\n        feeAdminUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new admin fee\n    /// @dev new fee can be updated only after timelock\n    function updateNewAdminFee() external override {\n        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        feeAdmin = pendingFeeAdmin;\n        delete feeAdminUpdateTime;\n    }\n\n    /// @notice proposes new vault implementation\n    /// @dev new implementation can be updated only after timelock\n    /// @dev can only be called by FEE_ROLE\n    /// @param _newVaultImplementation new implementation vault address\n    function proposeNewVaultImplementation(address _newVaultImplementation) external override onlyRole(IMPLEMENTER_ROLE) {\n        pendingVaultImplementation = _newVaultImplementation;\n        vaultUpdateTime = block.timestamp + UPDATE_TIME;\n    }\n\n    /// @notice updates new vault implementation\n    /// @dev new vault implementation can be updated only after timelock\n    function updateVaultImplementation() external override {\n        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");\n        vaultImplementation = pendingVaultImplementation;\n        delete vaultUpdateTime;\n    }\n\n    /// @notice pauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function pause() external onlyRole(PAUSER_ROLE) override {\n        _pause();\n    }\n\n    /// @notice unpauses the system\n    /// @dev can only be called by PAUSER_ROLE\n    function unPause() external onlyRole(PAUSER_ROLE) override {\n        _unpause();\n    }\n\n    receive() payable external {    }\n\n}\n\n",
        "CodeNames": [
            "NibblVaultFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "9",
                "Location": [
                    "//solidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n9:    import { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n"
                ],
                "Type": " Don't use  SafeMath  once the solidity version is 0.8.0 or greater",
                "Description": "\nVersion 0.8.0 introduces internal overflow checks, so using SafeMath is redundant and adds overhead\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NibblVaultFactory.sol   #1\n\n9:    import { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\n<https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L9\n\n\n",
                "Repair": ""
            }
        ]
    }
]