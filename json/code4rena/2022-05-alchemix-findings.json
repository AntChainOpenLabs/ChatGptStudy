[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total  mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n",
                    "//solidity\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] amount;\n  }\n"
                ],
                "Type": " Alchemist can mint  AlTokens  above their assigned ceiling by calling  lowerHasMinted() ",
                "Description": "\nAlchemicTokenV2Base.sol#L111-L124(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124)<br\nAlchemicTokenV2Base.sol#L189-L191(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191)<br\n\nAn alchemist / user can mint more than their alloted amount of AlTokens by calling lowerHasMinted() before they reach their minting cap.\n\n\nFunction mint() in AlchemicTokenV2Base.sol\n\nsolidity\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total  mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n\nNote the require conditional check that total  mintCeiling[msg.sender].\n\nIn the same contract, there is the function lowerHasMinted() with the same permission level as mint and is thus callable by the same user as well.\n\nsolidity\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] amount;\n  }\n\n\nIt is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling lowerHasMinted() before any action that would make them exceed their minting cap.\n\n\nManual review, VScode\n\n",
                "Repair": "\nChange the permissioning on lowerHasMinted() to be restricted to a higher permissioned role like onlySentinel() , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.\n\n\n0xfoobar (Alchemix) confirmed(https://github.com/code-423n4/2022-05-alchemix-findings/issues/166#issuecomment-1140762092)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/166#issuecomment-1145217432):\n  Great find! This would allow whitelisted account to mint any number of tokens. However, as this pertains to only whitelisted accounts, I think medium severity is justified and correct.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "AlchemicTokenV"
                ],
                "Type": " No Storage Gap for Upgradeable Contract Might Lead to Storage Slot Collision",
                "Description": "\nAlchemicTokenV2Base.sol#L20(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20)<br\nCrossChainCanonicalBase.sol#L12(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12)<br\nTransmuterV2.sol#L26(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26)<br\nCrossChainCanonicalAlchemicTokenV2.sol#L7(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7)<br\n\nFor upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.\n\nRefer to the bottom part of this article: <https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n\n\nSeveral contracts are intended to be upgradeable contracts in the code base, including\n\n*   AlchemicTokenV2Base\n*   CrossChainCanonicalBase\n*   CrossChainCanonicalAlchemicTokenV2\n*   TransmuterV2\n\nHowever, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article:\n\n<https://docs.openzeppelin.com/contracts/3.x/upgradeable\n\nAs an example, both the AlchemicTokenV2Base and the CrossChainCanonicalBase are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.\n\n",
                "Repair": "\nRecommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.\n\nsolidity\nuint256[50] private __gap;\n\n\n0xfoobar (Alchemix) confirmed(https://github.com/code-423n4/2022-05-alchemix-findings/issues/44#issuecomment-1140765969)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/44#issuecomment-1153292612):\n  Agree with warden and severity. Storage gaps are essential wherever inheritance is used by an upgradeable contract.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-09",
                "Location": [
                    "address(",
                    "address"
                ],
                "Type": " Missing checks for  address(0x0)  when assigning values to  address  state variables",
                "Description": "\n*There are 24 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/RocketPool.sol   #1\n\n14:               keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"))\n"
                ],
                "Type": "  abi.encodePacked()  should not be used with dynamic types when passing the result to a hash function such as  keccak256() ",
                "Description": "\nUse abi.encode() instead which will pad items to 32 bytes, which will prevent hash collisions(https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. abi.encodePacked(0x123,0x456) = 0x123456 = abi.encodePacked(0x1,0x23456), but abi.encode(0x123,0x456) = 0x0...1230...456). \"Unless there is a compelling reason, abi.encode should be preferred\". If there is only one argument to abi.encodePacked() it can often be cast to bytes() or bytes32() instead(https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/libraries/RocketPool.sol   #1\n\n14:               keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"))\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/RocketPool.sol#L14\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "external",
                    "public"
                ],
                "Type": "  public  functions not called by the contract should be declared  external  instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public.\n\n*There are 12 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "constant"
                ],
                "Type": "  constant s should be defined rather than using magic numbers",
                "Description": "\n*There are 20 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "struct",
                    "address",
                    "mapping"
                ],
                "Type": " Multiple  address  mappings can be combined into a single  mapping  of an  address  to a  struct , where appropriate",
                "Description": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "for"
                ],
                "Type": "  <array>.length  should not be looked up in every loop of a  for -loop",
                "Description": "\nThe overheads outlined below are *PER LOOP*, excluding the first loop\n\n*   storage arrays incur a Gwarmaccess (100 gas)\n*   memory arrays use MLOAD (3 gas)\n*   calldata arrays use CALLDATALOAD (3 gas)\n\nCaching the length changes each of these to a DUP<N (3 gas), and gets rid of the extra DUP<N needed to store the stack offset\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [
                    "require()"
                ],
                "Type": "  require() / revert()  strings longer than 32 bytes cost extra gas",
                "Description": "\n\n",
                "Repair": ""
            },
            {
                "Name": "-16",
                "Location": [
                    "//solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n"
                ],
                "Type": " Using  bool s for storage incurs overhead",
                "Description": "\nsolidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27<br\nUse uint256(1) and uint256(2) for true/false\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-19",
                "Location": [
                    "//solidity\nFile: contracts-full/interfaces/external/IProxyAdmin.sol   #1\n\n3   pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\nsolidity\nFile: contracts-full/interfaces/external/IProxyAdmin.sol   #1\n\n3   pragma solidity ^0.8.0;\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/interfaces/external/IProxyAdmin.sol#L3\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-22",
                "Location": [
                    "for"
                ],
                "Type": "  ++i  costs less gas than  ++i , especially when it's used in  for -loops ( --i / i--  too)",
                "Description": "\nSaves 6 gas *PER LOOP*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-28",
                "Location": [
                    "//solidity\nFile: contracts-full/gALCX.sol   #1\n\n107           require(success, \"Transfer failed\");\n"
                ],
                "Type": " Duplicated  require() / revert()  checks should be refactored to a modifier or function",
                "Description": "\nSaves deployment costs\n\nsolidity\nFile: contracts-full/gALCX.sol   #1\n\n107           require(success, \"Transfer failed\");\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/gALCX.sol#L107\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-31",
                "Location": [
                    "revert()"
                ],
                "Type": " Use custom errors rather than  revert() / require()  strings to save deployment gas",
                "Description": "\nCustom errors are available from solidity version 0.8.4. The instances below match or exceed that version\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-33",
                "Location": [
                    "external",
                    "public"
                ],
                "Type": "  public  functions not called by the contract should be declared  external  instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public and can save gas by doing so.\n\n0xfoobar (Alchemix) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/28#issuecomment-1140784192):\n  Incredibly comprehensive, great work with the explanations and detailed line number links\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "AlchemistV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "unwrap",
                    "mint",
                    "wrap()"
                ],
                "Type": " DoS in wrap and unwrap",
                "Description": "\nFuseTokenAdapterV1.sol#L76(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76)<br\nFuseTokenAdapterV1.sol#L98(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98)<br\n\nThe code is doing wrong check, so when things will work it will revert.\n\n\nIn the function wrap() there is this lines:\n\n       if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {\n                revert FuseError(error);\n            }\n\nbut mint returns the amount that minted, so when error = amount the check will fail even though it worked good.\n\nSame in unwrap:\n\n    if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {\n                revert FuseError(error);\n            }\n\nthe redeem returns the amount.\n\n",
                "Repair": "\nI recommend to change the lines like this:\nin wrap:\n      if ((error = ICERC20(token).mint(amount)) != amount) {\n            revert FuseError(error);\n        }\n    \nand in unwrap:\n     if ((error = ICERC20(token).redeem(amount)) != amount) {\n            revert FuseError(error);\n        }\n    \n\n0xfoobar (Alchemix) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/159#issuecomment-1133987052):\n  This would not cause any loss of user funds because the deposit function would revert, but it is a needed fix in the Fuse Adapter. So recommend a lower severity.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/159#issuecomment-1146198103):\n  As no assets are at risk, medium risk seems correct because only the availability of the protocol is impacted.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-14",
                "Location": [
                    "_mint",
                    "burn",
                    "deposit",
                    "mint"
                ],
                "Type": " A well financed attacker could prevent any other users from minting synthetic tokens",
                "Description": "\nAlchemistV2.sol#L676-L683(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/AlchemistV2.sol#L676-L683)<br\nAlchemistV2.sol#L704(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/AlchemistV2.sol#L704)<br\nLimiters.sol#L84(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/libraries/Limiters.sol#L84)<br\n\nIn the AlchemistV2 contract, users can deposit collateral to then borrow/mint the synthetic tokens offered by the protocol. The protocol also defines a minting limit that specifies how many synthetic tokens can be minted in a given time period. This exists to prevent unbounded minting of synthetic tokens.\n\nEvery time a user calls mint, the internal _mint method decreases the current mint limit. This works as intended. However, there is nothing stopping an attacker from immediately burning their synthetic tokens by calling burn and then calling mint again. This is possible because the debt position is updated during the burn phase, which lets the user then mint again against the same deposited collateral.\n\nIn most cases this probably wouldn't be a problem if the mint limit is sufficiently high. However, it is currently possible for a well financed attacker to grief the contract by repeatedly minting and burning synthetic tokens to keep the contract pegged at the mint limit. This will prevent any normal users from minting any synthetic tokens, and hence prevents the protocol from performing as it should.\n\n\nAn attacker can repeatedly call mint followed by burn after depositing some collateral with deposit. If this is appropriately sized and timed, it can cause the mint call to fail for another user due to the check here(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/AlchemistV2.sol#L1068) that is called during mint here(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/AlchemistV2.sol#L1192).\n\n\nVSCode\n\n",
                "Repair": "\nThere should be an additional method added to the Limiters library that can increment the mint limit. This method can then be called during a burn call in the AlchemistV2 contract.\n\n    function increase(LinearGrowthLimiter storage self, uint256 amount) internal {\n      uint256 value = self.get();\n      self.lastValue = value + amount  self.maximum ? self.maximum : value + amount;\n    }\n\n0xfoobar (Alchemix) disputed and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/155#issuecomment-1134046370):\n  If somebody griefed, let alone the insanely high capital requirements, governance could simply raise the mint limit.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/155#issuecomment-1147232259):\n  As far as I can tell, this seems like a valid griefing attack. Assuming no fees are charged on mint/burn actions, it would be viable to use a flash loan to use up the entire mint limit, preventing other users from participating in the protocol. This could be mostly mitigated by charging a small fee on mints, which is sent to the protocol's governance contract or distributed to pre-existing stakers. Could you confirm this @0xfoobar ?\n\n0xfoobar (Alchemix) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/155#issuecomment-1147991797):\n  Upon further review the griefing action of\n \n 1. initiate flashloan\n 2. deposit\n 3. mint\n 4. burn\n 5. repay flashloan\n \n would be a valid approach to grief the protocol. No funds are at risk but we'll discuss internally how to best mitigate this.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/155#issuecomment-1149856681):\n  Agreed, keeping this issue as is!\n \n  This could have been upgraded to high risk if the ease of attack involved:\n  Limits on burning tokens.\n  The griefing attack is somewhat cheap, making it easy for attackers to maintain.\n \n But as the issue raised does not lead to a loss of user's funds, I believe medium risk to be justified.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-26",
                "Location": [
                    "public",
                    "private"
                ],
                "Type": " Using  private  rather than  public  for constants, saves gas",
                "Description": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"../../IERC20Minimal.sol\";\nimport \"../../IERC20Metadata.sol\";\n\n/// @title  IYearnVaultV2\n/// @author Yearn Finance\ninterface IYearnVaultV2 is IERC20Minimal, IERC20Metadata {\n  struct StrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtRatio;\n    uint256 minDebtPerHarvest;\n    uint256 maxDebtPerHarvest;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n    bool enforceChangeLimit;\n    uint256 profitLimitRatio;\n    uint256 lossLimitRatio;\n    address customCheck;\n  }\n\n  function apiVersion() external pure returns (string memory);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 expiry,\n    bytes calldata signature\n  ) external returns (bool);\n\n  // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n  function deposit() external returns (uint256);\n\n  function deposit(uint256 amount) external returns (uint256);\n\n  function deposit(uint256 amount, address recipient) external returns (uint256);\n\n  // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n  function withdraw() external returns (uint256);\n\n  function withdraw(uint256 maxShares) external returns (uint256);\n\n  function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n\n  function withdraw(\n    uint256 maxShares,\n    address recipient,\n    uint256 maxLoss\n  ) external returns (uint256);\n\n  function token() external view returns (address);\n\n  function strategies(address _strategy) external view returns (StrategyParams memory);\n\n  function pricePerShare() external view returns (uint256);\n\n  function totalAssets() external view returns (uint256);\n\n  function depositLimit() external view returns (uint256);\n\n  function maxAvailableShares() external view returns (uint256);\n\n  /// @notice View how much the Vault would increase this Strategy's borrow limit, based on its present performance\n  ///         (since its last report). Can be used to determine expectedReturn in your Strategy.\n  function creditAvailable() external view returns (uint256);\n\n  /// @notice View how much the Vault would like to pull back from the Strategy, based on its present performance\n  ///         (since its last report). Can be used to determine expectedReturn in your Strategy.\n  function debtOutstanding() external view returns (uint256);\n\n  /// @notice View how much the Vault expect this Strategy to return at the current block, based on its present\n  ///         performance (since its last report). Can be used to determine expectedReturn in your Strategy.\n  function expectedReturn() external view returns (uint256);\n\n  /// @notice This is the main contact point where the Strategy interacts with the Vault. It is critical that this call\n  ///         is handled as intended by the Strategy. Therefore, this function will be called by BaseStrategy to make\n  ///         sure the integration is correct.\n  function report(\n    uint256 _gain,\n    uint256 _loss,\n    uint256 _debtPayment\n  ) external returns (uint256);\n\n  /// @notice This function should only be used in the scenario where the Strategy is being retired but no migration of\n  ///         the positions are possible, or in the extreme scenario that the Strategy needs to be put into\n  ///         \"Emergency Exit\" mode in order for it to exit as quickly as possible. The latter scenario could be for any\n  ///         reason that is considered \"critical\" that the Strategy exits its position as fast as possible, such as a\n  ///         sudden change in market conditions leading to losses, or an imminent failure in an external dependency.\n  function revokeStrategy() external;\n\n  /// @notice View the governance address of the Vault to assert privileged functions can only be called by governance.\n  ///         The Strategy serves the Vault, so it is subject to governance defined by the Vault.\n  function governance() external view returns (address);\n\n  /// @notice View the management address of the Vault to assert privileged functions can only be called by management.\n  ///         The Strategy serves the Vault, so it is subject to management defined by the Vault.\n  function management() external view returns (address);\n\n  /// @notice View the guardian address of the Vault to assert privileged functions can only be called by guardian. The\n  ///         Strategy serves the Vault, so it is subject to guardian defined by the Vault.\n  function guardian() external view returns (address);\n}\n\n\n",
        "CodeNames": [
            "AlchemistV2.sol",
            "IYearnVaultV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "maxLoss",
                    "withdraw()"
                ],
                "Type": " YearnTokenAdapter allows a maximum loss of 100% when withdrawing",
                "Description": "\nYearnTokenAdapter.sol#L13(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L13)<br\nYearnTokenAdapter.sol#L43(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L43)<br\n\nYearnTokenAdapter allows slippage of 100% when withdrawing from the vault which will cause a loss of funds.\n\nHere's the documentation straight from the vault contract: <https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L1025-L1073\nIt allows the user to specify the maxLoss as the last parameter. It determines how many shares can be burned to fulfill the withdrawal. Currently, the contract uses 10.000 which is 100%. Meaning there is no slippage check at all. This is bound to cause a loss of funds.\n\nI'd suggest letting the user determine the slippage check themselves instead of hardcoding it.\n\n\nCurrent maxLoss value: <https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L13\n\ncall to Yearn vault's withdraw() function: <https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L43\n\n",
                "Repair": "\nAllow the user to specify the slippage value themselves:\n\nsol\n    function unwrap(uint256 amount, address recipient, uint maxLoss) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 balanceBefore = TokenUtils.safeBalanceOf(token, address(this));\n\n        uint256 amountWithdrawn = IYearnVaultV2(token).withdraw(amount, recipient, maxLoss);\n\n        uint256 balanceAfter = TokenUtils.safeBalanceOf(token, address(this));\n\n        // If the Yearn vault did not burn all of the shares then revert. This is critical in mathematical operations\n        // performed by the system because the system always expects that all of the tokens were unwrapped. In Yearn,\n        // this sometimes does not happen in cases where strategies cannot withdraw all of the requested tokens (an\n        // example strategy where this can occur is with Compound and AAVE where funds may not be accessible because\n        // they were lent out).\n        if (balanceBefore balanceAfter != amount) {\n            revert IllegalState();\n        }\n\n        return amountWithdrawn;\n    }\n\n\nIf you don't want to change the ITokenAdapter interface you can also leave the value blank. The vault will then use the default value (0.01%)\n\n\n0xfoobar (Alchemix) acknowledged, disagreed with severity and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/60#issuecomment-1133991312):\n\n This could be made more configurable by the end user but yearn vaults do not frequently experience high slippage. Slippage is handled upstream in the Alchemist contract. The reason why this slippage is set to 100% is so to permit handling of slippage in the Alchemist for all cases.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/60#issuecomment-1146206028):\n  Because we can't know how the yearn strategy implements withdrawals, its possible that it might contain custom swap logic which exposes itself to sandwich attacks. However, at face value, the current use of MAXIMUM_SLIPPAGE allows the contract to successfully unwrap their tokens under poor network conditions, but it makes sense for the user to have more control over this. Downgrading this to medium risk as I believe it is more in line with that.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IEthStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IEthStableMetaPool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IWETH9 weth;\n    IERC20 curveToken;\n    IEthStableMetaPool metaPool;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ETH, ALETH\n}\n\n/// @title  EthAssetManager\n/// @author Alchemix Finance\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum that was reclaimed.\n    event ReclaimEth(uint256 amount);\n\n    /// @notice Emitted when a token is swept to the admin.\n    ///\n    /// @param token  The token that was swept.\n    /// @param amount The amount of the token that was swept.\n    event SweepToken(address token, uint256 amount);\n\n    /// @notice Emitted when ethereum is swept to the admin.\n    ///\n    /// @param amount The amount of the token that was swept.\n    event SweepEth(uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The wrapped ethereum token.\n    IWETH9 public weth;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The meta pool contract.\n    IEthStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin            = params.admin;\n        operator         = params.operator;\n        rewardReceiver   = params.rewardReceiver;\n        transmuterBuffer = params.transmuterBuffer;\n        weth             = params.weth;\n        curveToken       = params.curveToken;\n        metaPool         = params.metaPool;\n        metaPoolSlippage = params.metaPoolSlippage;\n        convexToken      = params.convexToken;\n        convexBooster    = params.convexBooster;\n        convexRewards    = params.convexRewards;\n        convexPoolId     = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n            }\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    receive() external payable { }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        if (asset == MetaPoolAsset.ETH) {\n            return address(this).balance + token.balanceOf(address(this));\n        }\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of ethereum that one alETH is worth.\n    ///\n    /// @return The amount of the underlying token.\n    function exchangeRate() public view returns (uint256) {\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        return metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\n            10**SafeERC20.expectDecimals(address(alETH)),\n            metaBalances\n        );\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the meta pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The meta pool asset to flush.\n    /// @param amount The amount of the meta pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\n    ///         burning the meta pool tokens for ethereum.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of ethereum recalled.\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum to reclaim.\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\n        uint256 balance;\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\n\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\n\n        emit ReclaimEth(amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n        emit SweepToken(token, amount);\n    }\n\n    /// @notice Sweeps ethereum out of the contract to the admin.\n    ///\n    /// @param amount The amount of ethereum to sweep.\n    ///\n    /// @return result The result from the call to transfer ethereum.\n    function sweepEth(\n        uint256 amount\n    ) external lock onlyAdmin returns (bytes memory result) {\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState(\"Transfer failed\");\n        }\n\n        emit SweepEth(amount);\n\n        return result;\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Set an approval if not working with ethereum.\n        if (asset != MetaPoolAsset.ETH) {\n            IERC20 token = getTokenForMetaPoolAsset(asset);\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\n        }\n\n        uint256 value = asset == MetaPoolAsset.ETH\n            ? amounts[uint256(MetaPoolAsset.ETH)]\n            : 0;\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "EthAssetManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n",
                    "//solidity\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\n",
                    "//solidity\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n",
                    "//solidity\ndecimals     = SafeERC20.expectDecimals(address(alUSD));\n"
                ],
                "Type": " EthAssetManager and ThreePoolAssetManager don't control Meta tokens decimals",
                "Description": "\nBoth contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.\n\nIf actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as total is calculated as a plain sum of token amounts.\n\nIn the higher token decimals case minTotalAmount will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.\n\nIn the lower token decimals case minTotalAmount will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.\n\nSetting severity to medium as the contract can be used with various meta tokens (_metaPoolAssetCache  can be filled with any assets) and, whenever decimals differ from 18 add_liquidity uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.\n\nI.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.\n\n\nMeta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):\n\nThreePoolAssetManager.sol#L896-L905(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905)<br\n\nsolidity\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n\nThreePoolAssetManager.sol#L915-L919(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919)<br\n\nsolidity\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\n\n\nThe same plain sum approach is used in EthAssetManager._mintMetaPoolTokens:\n\nEthAssetManager.sol#L566-L573(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573)<br\n\nsolidity\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n\nWhen this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.\n\nNotice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as it\u2019s either fix and control on inception or do not fix and accommodate the logic):\n\nThreePoolAssetManager.sol#L338-L338(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338)<br\n\nsolidity\ndecimals     = SafeERC20.expectDecimals(address(alUSD));\n\n\n",
                "Repair": "\nIf meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.\n\nI.e. the decimals can be controlled in constructors:\n\nEthAssetManager.sol#L214-L219(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219)<br\n\nsolidity\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n+           } else {\n+           \t// check the decimals\n\t\t\t\t}\n        }\n\n\nThreePoolAssetManager.sol#L254-L256(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256)<br\n\nsolidity\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n+           // check the decimals            \n        }\n\n\nIn this case further decimals reading as it's done in calculateRebalance() is redundant.\n\nOtherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:\n\nThreePoolAssetManager.sol#L779-L779(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779)<br\n\nsolidity\nnormalizedTotal += amounts[i] * 10missingDecimals;\n\n\n0xfoobar (Alchemix) confirmed(https://github.com/code-423n4/2022-05-alchemix-findings/issues/63#issuecomment-1141380260)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/63#issuecomment-1153292871):\n  Agree with issue and its severity. minTotalAmount is affected by a change in a token's decimals, leading to improper handling by the contract. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "constant",
                    "immutable"
                ],
                "Type": " Remove or replace unused state variables",
                "Description": "\nSaves a storage slot. If the variable is assigned a non-zero value, saves Gsset (20000 gas). If it's assigned a zero value, saves Gsreset (2900 gas). If the variable remains unassigned, there is no gas savings. If the state variable is overriding an interface's public function, mark the variable as constant or immutable so that it does not use a storage slot, and manually add a getter function\n\nFor further details on this (and the warden's other gas optimizations), please see their full report(https://github.com/code-423n4/2022-05-alchemix-findings/issues/28).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-25",
                "Location": [
                    "constant",
                    "immutable",
                    "keccak"
                ],
                "Type": " Expressions for constant values such as a call to  keccak256() , should use  immutable  rather than  constant ",
                "Description": "\nSee this(https://github.com/ethereum/solidity/issues/9232) issue for a detail description of the issue\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "//solidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n"
                ],
                "Type": " YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying",
                "Description": "\nSome tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).\n\nThis can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.\n\nThen each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.\n\n\nwrap use one step approve:\n\nYearnTokenAdapter.sol#L30-L32(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32)<br\n\nsolidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n\n\nSome ERC20 forbid the approval of positive amount when the allowance is positive:\n\n<https://github.com/d-xo/weird-erc20#approval-race-protections\n\nFor example, USDT is supported by Yearn and can be the underlying asset:\n\n<https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7\n\n",
                "Repair": "\nAs the most general approach consider approving zero before doing so for the amount:\n\nsolidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n+      TokenUtils.safeApprove(underlyingToken, token, 0);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n\n\n0xfoobar (Alchemix) confirmed(https://github.com/code-423n4/2022-05-alchemix-findings/issues/99#issuecomment-1141378852)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/99#issuecomment-1146364671):\n  It seems like approve() will fail to execute on non-standard tokens which require the approval amount to start from zero. This is valid and should be updated to handle such tokens.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n"
                ],
                "Type": " TransmuterBuffer's setAlchemist will freeze deposited funds",
                "Description": "\nCurrently setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one.\n\nAs this require a number of checks the probability of operational mistake isn't low and it's prudent to introduce the main controls directly to the code to minimize it. In the case if the system go on with new Alchemist before realizing that there are some funds left in the old one, tedious and error prone manual recovery will be needed. There is also going to be a corresponding reputational damage.\n\nSetting the severity to medium as while the function is admin only, the impact is up to massive user fund freeze, i.e. this is system breaking with external assumptions.\n\n\nAlchemist implementation change can happen while there are open deposits remaining with the current contract. As there looks to be no process to transfer them in the code, such TransmuterBuffer's funds will be frozen with old alchemist:\n\nTransmuterBuffer.sol#L230-L232(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L230-L232)<br\n\nsolidity\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n\n\n",
                "Repair": "\nConsider requiring that all exposure to the old Alchemist is closed, for example both getAvailableFlow and getTotalCredit is zero.\n\nTransmuterBuffer.sol#L230-L231(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L231)<br\n\nsolidity\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n+\t\t  require(getTotalCredit() == 0, \"Credit exists with old Alchemist\");\n+       for (uint256 j = 0; j < registeredUnderlyings.length; j++) {\n+           require(getTotalUnderlyingBuffered[registeredUnderlyings[j]] == 0, \"Buffer exists with old Alchemist\");\n+       }\n        sources[alchemist] = false;\n\n\n0xfoobar (Alchemix) confirmed(https://github.com/code-423n4/2022-05-alchemix-findings/issues/117#issuecomment-1140762972)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/117#issuecomment-1153293529):\n  This is useful in preventing loss of funds when changing the protocol's alchemist contract.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n"
                ],
                "Type": " registerAsset misuse can permanently disable TransmuterBuffer and break the system",
                "Description": "\nTransmuterBuffer's refreshStrategies() is the only way to actualize _yieldTokens array. The function requires registeredUnderlyings array to match current Alchemist's _supportedUnderlyingTokens. In the same time registeredUnderlyings can be only increased via registerAsset(): there is no way to reduce, remove or reconstruct the array.\n\nThis way if registerAsset() was mistakenly called extra time or alchemist was switched with setAlchemist to a new one with less supported assets, then the strategy refresh becomes impossible and the TransmuterBuffer be blocked as it cannot be properly used without synchronization with Alchemist.\n\nThe redeployment of the contract doesn't provide an easy fix as it holds the accounting data that needs to be recreated (flowAvailable, currentExchanged mappings).\n\n\nrefreshStrategies require registeredUnderlyings to be equal to Alchemist's supportedUnderlyingTokens:\n\nTransmuterBuffer.sol#L377-L379(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L377-L379)<br\n\nsolidity\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n\n\nIf registeredUnderlyings has length more than Alchemist's _supportedUnderlyingTokens it doesn't look to be fixable and prohibits the future use of the contract, i.e. breaks the system.\n\n",
                "Repair": "\nThe issue is that there is no way to unregister the asset, so consider introducing a function to remove the underlying or simply delete the array so it can be reconstructed with a sequence of registerAsset calls.\n\nthetechnocratic (Alchemix) acknowledged and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/113#issuecomment-1139901087):\n\n There is no way for registerAsset to be accidentally called too many times, and it reverts if an asset doesn't exist in the Alchemist or has already been registered.<br\n The TransmuterBuffer *could* be assigned a new Alchemist with fewer assets, but it is safe to assume that the operator will not make such a grand oversight.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/113#issuecomment-1153294243):\n  Useful mitigation to prevent the TransmuterBuffer from being assigned a new Alchemist with fewer assets. In this event, the availability of the protocol is impacted. Valid medium.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "//solidity\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares  availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying amountUnderlying * 100 / 10000;\n        if (wantShares  0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n",
                    "//solidity\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n",
                    "//solidity\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) = currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered  flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] initialLocalBalance;\n        }\n\n        if (want  0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n"
                ],
                "Type": " TransmuterBuffer's _alchemistWithdraw use hard coded slippage that can lead to user losses",
                "Description": "\nexchange() - _exchange() - _alchemistWithdraw() is user funds utilizing call sequence and the slippage hard coded to 1% there can cause a range of issues.\n\nFor example, if there is not enough shares, the number of shares to withdraw will be unconditionally reduced to the number of the shares available. This can pass under 1% slippage and user will give away up to 1% without giving a consent to such a fee, which is big enough to notice.\n\nOn the other hand, in a similar situation when there is not enough shares available a user might knowingly want to execute with even bigger fee, but hard coded slippage will not be met and the withdraw be unavailable and funds frozen.\n\nSetting the severity to medium as the end impact is either modest user fund loss or exchange functionality unavailability.\n\n\n_alchemistWithdraw uses hard coded 1% slippage threshold and rewrites wantShares to be availableShares once TransmuterBuffer's position isn't big enough:\n\nTransmuterBuffer.sol#L511-L524(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L511-L524)<br\n\nsolidity\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares  availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying amountUnderlying * 100 / 10000;\n        if (wantShares  0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n\n\nAlchemist's _unwrap will revert withdrawUnderlying call once minimumAmountOut isn't met:\n\nAlchemistV2.sol#L1344-L1346(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1344-L1346)<br\n\nsolidity\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n\n\nThere are 2 use cases for the function:\n\nexchange (onlyKeeper) - _exchange - _alchemistWithdraw,\n\nsetFlowRate (onlyAdmin) - _exchange - _alchemistWithdraw\n\nexchange() is the most crucial as it should be able to fulfil various types of user funds exchange requests:\n\nTransmuterBuffer.sol#L526-L546(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L526-L546)<br\n\nsolidity\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) = currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered  flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] initialLocalBalance;\n        }\n\n        if (want  0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n\n\nThis way, one issue here is that user can end up giving away the full 1% unconditionally to market situation because there are not enough shares available.\n\nAnother one is that knowing that the conditions are bad or that there are not enough shares available and willing to run the exchange with bigger slippage the user will not be able to as there are no means to control it and the functionality will end up unavailable, being reverted by Alchemist's _unwrap check.\n\n",
                "Repair": "\nConsider adding the function argument with a default value of 1%, so the slippage can be tuned when it is needed.\n\nthetechnocratic (Alchemix) acknowledged and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/127#issuecomment-1139827436):\n  Allowing for a caller-defined slippage would enable more flexibility when using the exchange() and setFlowRate() calls.  However, the possibility of needing this flexibility at this time is very small, and because these functions are run by admins/keepers, there is room to modify the code if and when the flexibility becomes required.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/127#issuecomment-1153294479):\n  Agree with warden. During periods of high volatility, assets will be locked within the contract. As this limits protocol availability, potentially leading to further loss of funds as users cannot freely exit the protocol and sell tokens, medium risk is justified.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts-full/WETHGateway.sol   #1\n\n70           IAlchemistV2(alchemist).withdrawUnderlyingFrom(msg.sender, yieldToken, shares, address(this), minimumAmountOut);\n71   \n72           uint256 amount = WETH.balanceOf(address(this));\n73           WETH.withdraw(amount);\n74   \n75:          (bool success, ) = recipient.call{value: amount}(new bytes(0));\n"
                ],
                "Type": " Latent funds can be stolen",
                "Description": "\nIf someone manages, through either a bug or a mistake (self-destructing and sending funds to the contract), another user can claim the funds as their own. Measure the balance before and after, and use the difference, rather than measuring the total balance of the contract\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/WETHGateway.sol   #1\n\n70           IAlchemistV2(alchemist).withdrawUnderlyingFrom(msg.sender, yieldToken, shares, address(this), minimumAmountOut);\n71   \n72           uint256 amount = WETH.balanceOf(address(this));\n73           WETH.withdraw(amount);\n74   \n75:          (bool success, ) = recipient.call{value: amount}(new bytes(0));\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/WETHGateway.sol#L70-L75\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/TokenUtils.sol   #1\n\n65       function safeTransfer(address token, address recipient, uint256 amount) internal {\n66           (bool success, bytes memory data) = token.call(\n67               abi.encodeWithSelector(IERC20Minimal.transfer.selector, recipient, amount)\n68:          );\n"
                ],
                "Type": " Low level calls don't check for contract existence",
                "Description": "\nLow level calls return success if called on a destructed contract. See OpenZeppelin's Address.so which checks address.code.length\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/libraries/TokenUtils.sol   #1\n\n65       function safeTransfer(address token, address recipient, uint256 amount) internal {\n66           (bool success, bytes memory data) = token.call(\n67               abi.encodeWithSelector(IERC20Minimal.transfer.selector, recipient, amount)\n68:          );\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/libraries/TokenUtils.sol#L65-L68\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts-full/AlchemicTokenV2.sol   #1\n\n50     /// @notice An event which is emitted when the flash mint fee is updated.\n51     ///\n52     /// @param fee The new flash mint fee.\n53     event SetFlashMintFee(uint256 fee);\n54   \n55     constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n56       _setupRole(ADMIN_ROLE, msg.sender);\n57       _setupRole(SENTINEL_ROLE, msg.sender);\n58       _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n59       _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n60       flashMintFee = _flashFee;\n61:    }\n"
                ],
                "Type": " Behavior described by comment is incomplete",
                "Description": "\nThe event is not emitted when the fee is updated the first time (in the constructor)\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/AlchemicTokenV2.sol   #1\n\n50     /// @notice An event which is emitted when the flash mint fee is updated.\n51     ///\n52     /// @param fee The new flash mint fee.\n53     event SetFlashMintFee(uint256 fee);\n54   \n55     constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n56       _setupRole(ADMIN_ROLE, msg.sender);\n57       _setupRole(SENTINEL_ROLE, msg.sender);\n58       _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n59       _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n60       flashMintFee = _flashFee;\n61:    }\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2.sol#L50-L61\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/SafeCast.sol   #1\n\n13:       if (y = 2255) {\n"
                ],
                "Type": "  2<n> - 1  should be re-written as  type(uint<n>).max ",
                "Description": "\nEarlier versions of solidity can use uint<n(-1) instead. Expressions not including the 1 can often be re-written to accomodate the change (e.g. by using a  rather than a =, which will also save some gas)\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/libraries/SafeCast.sol   #1\n\n13:       if (y = 2255) {\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/SafeCast.sol#L13\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/Limiters.sol   #1\n\n12:       uint256 constant public MAX_COOLDOWN_BLOCKS = 7200;\n"
                ],
                "Type": " Numeric values having to do with time should use time units for readability",
                "Description": "\nThere are units(https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/libraries/Limiters.sol   #1\n\n12:       uint256 constant public MAX_COOLDOWN_BLOCKS = 7200;\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/Limiters.sol#L12\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.13 to get the ability to use using for with a list of free functions\n\n*There are 12 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/RocketPool.sol   #1\n\n1:    pragma //solidity =0.5.0;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.4 to get bytes.concat() instead of abi.encodePacked(<bytes,<bytes)\nUse a solidity version of at least 0.8.12 to get string.concat() instead of abi.encodePacked(<str,<str)\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/libraries/RocketPool.sol   #1\n\n1:    pragma solidity =0.5.0;\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/RocketPool.sol#L1\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [],
                "Type": " Inconsistent spacing in comments",
                "Description": "\nSome lines use // x and some use //x. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 11 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-19",
                "Location": [
                    "//solidity\nFile: contracts-full/AlchemicTokenV1.sol   #1\n\n110:   function setBlacklist(address minter) external onlySentinel {\n"
                ],
                "Type": " Use allowlist/denylist rather than blacklist/whitelist",
                "Description": "\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/AlchemicTokenV1.sol   #1\n\n110:   function setBlacklist(address minter) external onlySentinel {\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV1.sol#L110\n\n0xfoobar (Alchemix) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/228#issuecomment-1140785384):\n  Incredibly comprehensive, great writeup\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 46 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-05-alchemix-findings/issues/28) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: BowTiedWardens(https://github.com/code-423n4/2022-05-alchemix-findings/issues/137), joestakey(https://github.com/code-423n4/2022-05-alchemix-findings/issues/171), 0xkatana(https://github.com/code-423n4/2022-05-alchemix-findings/issues/124), AlleyCat(https://github.com/code-423n4/2022-05-alchemix-findings/issues/32), mics(https://github.com/code-423n4/2022-05-alchemix-findings/issues/81), WatchPug(https://github.com/code-423n4/2022-05-alchemix-findings/issues/164), 0x4non(https://github.com/code-423n4/2022-05-alchemix-findings/issues/95), 0xNazgul(https://github.com/code-423n4/2022-05-alchemix-findings/issues/56), simon135(https://github.com/code-423n4/2022-05-alchemix-findings/issues/139), fatherOfBlocks(https://github.com/code-423n4/2022-05-alchemix-findings/issues/220), robee(https://github.com/code-423n4/2022-05-alchemix-findings/issues/93), samruna(https://github.com/code-423n4/2022-05-alchemix-findings/issues/100), sashik_eth(https://github.com/code-423n4/2022-05-alchemix-findings/issues/214), TerrierLover(https://github.com/code-423n4/2022-05-alchemix-findings/issues/224), _Adam(https://github.com/code-423n4/2022-05-alchemix-findings/issues/216), 0x1f8b(https://github.com/code-423n4/2022-05-alchemix-findings/issues/85), 0xf15ers(https://github.com/code-423n4/2022-05-alchemix-findings/issues/148), 0xsomeone(https://github.com/code-423n4/2022-05-alchemix-findings/issues/118), catchup(https://github.com/code-423n4/2022-05-alchemix-findings/issues/143), ellahi(https://github.com/code-423n4/2022-05-alchemix-findings/issues/129), Funen(https://github.com/code-423n4/2022-05-alchemix-findings/issues/153), GimelSec(https://github.com/code-423n4/2022-05-alchemix-findings/issues/195), MiloTruck(https://github.com/code-423n4/2022-05-alchemix-findings/issues/172), oyc_109(https://github.com/code-423n4/2022-05-alchemix-findings/issues/83), Tomio(https://github.com/code-423n4/2022-05-alchemix-findings/issues/145), 0xDjango(https://github.com/code-423n4/2022-05-alchemix-findings/issues/202), csanuragjain(https://github.com/code-423n4/2022-05-alchemix-findings/issues/45), hake(https://github.com/code-423n4/2022-05-alchemix-findings/issues/66), hansfriese(https://github.com/code-423n4/2022-05-alchemix-findings/issues/169), Hawkeye(https://github.com/code-423n4/2022-05-alchemix-findings/issues/225), ignacio(https://github.com/code-423n4/2022-05-alchemix-findings/issues/110), MaratCerby(https://github.com/code-423n4/2022-05-alchemix-findings/issues/49), sikorico(https://github.com/code-423n4/2022-05-alchemix-findings/issues/89), Waze(https://github.com/code-423n4/2022-05-alchemix-findings/issues/174), 0v3rf10w(https://github.com/code-423n4/2022-05-alchemix-findings/issues/197), Fitraldys(https://github.com/code-423n4/2022-05-alchemix-findings/issues/188), horsefacts(https://github.com/code-423n4/2022-05-alchemix-findings/issues/219), kenta(https://github.com/code-423n4/2022-05-alchemix-findings/issues/151), Randyyy(https://github.com/code-423n4/2022-05-alchemix-findings/issues/176), throttle(https://github.com/code-423n4/2022-05-alchemix-findings/issues/205), UnusualTurtle(https://github.com/code-423n4/2022-05-alchemix-findings/issues/196), augustg(https://github.com/code-423n4/2022-05-alchemix-findings/issues/105), bobirichman(https://github.com/code-423n4/2022-05-alchemix-findings/issues/91), Cityscape(https://github.com/code-423n4/2022-05-alchemix-findings/issues/170), and JC(https://github.com/code-423n4/2022-05-alchemix-findings/issues/213).*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-08",
                "Location": [],
                "Type": "  <x> += <y>  costs more gas than  <x> = <x> + <y>  for state variables",
                "Description": "\n\n",
                "Repair": ""
            },
            {
                "Name": "-15",
                "Location": [
                    "//solidity\nFile: contracts-full/TransmuterBuffer.sol   #1\n\n515           (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n"
                ],
                "Type": " Remove unused local variable",
                "Description": "\nsolidity\nFile: contracts-full/TransmuterBuffer.sol   #1\n\n515           (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/TransmuterBuffer.sol#L515\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-18",
                "Location": [
                    "//solidity\nFile: contracts-full/libraries/SafeERC20.sol   #1\n\n2   pragma //solidity =0.8.4;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\nsolidity\nFile: contracts-full/libraries/SafeERC20.sol   #1\n\n2   pragma solidity =0.8.4;\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/libraries/SafeERC20.sol#L2\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-23",
                "Location": [],
                "Type": " Usage of  uints / ints  smaller than 32 bytes (256 bits) incurs overhead",
                "Description": "\n When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-24",
                "Location": [
                    "//solidity\nFile: contracts-full/AutoleverageBase.sol   #1\n\n102           bytes memory params = abi.encode(Details({\n103               pool: pool,\n104               poolInputIndex: poolInputIndex,\n105               poolOutputIndex: poolOutputIndex,\n106               alchemist: alchemist,\n107               yieldToken: yieldToken,\n108               recipient: msg.sender,\n109               targetDebt: targetDebt\n110           }));\n"
                ],
                "Type": "  abi.encode()  is less efficient than  abi.encodePacked() ",
                "Description": "\nsolidity\nFile: contracts-full/AutoleverageBase.sol   #1\n\n102           bytes memory params = abi.encode(Details({\n103               pool: pool,\n104               poolInputIndex: poolInputIndex,\n105               poolOutputIndex: poolOutputIndex,\n106               alchemist: alchemist,\n107               yieldToken: yieldToken,\n108               recipient: msg.sender,\n109               targetDebt: targetDebt\n110           }));\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L102-L110\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-30",
                "Location": [],
                "Type": " Empty blocks should be removed or emit something",
                "Description": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (if(x){}else if(y){...}else{...} = if(!x){if(y){...}else{...}})\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IEthStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IEthStableMetaPool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IWETH9 weth;\n    IERC20 curveToken;\n    IEthStableMetaPool metaPool;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ETH, ALETH\n}\n\n/// @title  EthAssetManager\n/// @author Alchemix Finance\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum that was reclaimed.\n    event ReclaimEth(uint256 amount);\n\n    /// @notice Emitted when a token is swept to the admin.\n    ///\n    /// @param token  The token that was swept.\n    /// @param amount The amount of the token that was swept.\n    event SweepToken(address token, uint256 amount);\n\n    /// @notice Emitted when ethereum is swept to the admin.\n    ///\n    /// @param amount The amount of the token that was swept.\n    event SweepEth(uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The wrapped ethereum token.\n    IWETH9 public weth;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The meta pool contract.\n    IEthStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin            = params.admin;\n        operator         = params.operator;\n        rewardReceiver   = params.rewardReceiver;\n        transmuterBuffer = params.transmuterBuffer;\n        weth             = params.weth;\n        curveToken       = params.curveToken;\n        metaPool         = params.metaPool;\n        metaPoolSlippage = params.metaPoolSlippage;\n        convexToken      = params.convexToken;\n        convexBooster    = params.convexBooster;\n        convexRewards    = params.convexRewards;\n        convexPoolId     = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n            }\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    receive() external payable { }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        if (asset == MetaPoolAsset.ETH) {\n            return address(this).balance + token.balanceOf(address(this));\n        }\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of ethereum that one alETH is worth.\n    ///\n    /// @return The amount of the underlying token.\n    function exchangeRate() public view returns (uint256) {\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        return metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\n            10**SafeERC20.expectDecimals(address(alETH)),\n            metaBalances\n        );\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the meta pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The meta pool asset to flush.\n    /// @param amount The amount of the meta pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\n    ///         burning the meta pool tokens for ethereum.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of ethereum recalled.\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum to reclaim.\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\n        uint256 balance;\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\n\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\n\n        emit ReclaimEth(amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n        emit SweepToken(token, amount);\n    }\n\n    /// @notice Sweeps ethereum out of the contract to the admin.\n    ///\n    /// @param amount The amount of ethereum to sweep.\n    ///\n    /// @return result The result from the call to transfer ethereum.\n    function sweepEth(\n        uint256 amount\n    ) external lock onlyAdmin returns (bytes memory result) {\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState(\"Transfer failed\");\n        }\n\n        emit SweepEth(amount);\n\n        return result;\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Set an approval if not working with ethereum.\n        if (asset != MetaPoolAsset.ETH) {\n            IERC20 token = getTokenForMetaPoolAsset(asset);\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\n        }\n\n        uint256 value = asset == MetaPoolAsset.ETH\n            ? amounts[uint256(MetaPoolAsset.ETH)]\n            : 0;\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "EthAssetManager.sol",
            "gALCX.sol",
            "AlchemistV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "//solidity\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n",
                    "//solidity\nuint public constant exchangeRatePrecision = 1e18;\n",
                    "//solidity\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance  0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n",
                    "//solidity\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n"
                ],
                "Type": " New gALCX token denomination can be depressed by the first depositor",
                "Description": "\nAn attacker can become the first depositor for a recently created gALCX contract, providing a tiny amount of ALCX tokens by calling stake(1) (raw values here, 1 is 1 wei, 1e18 is 1 ALCX). Then the attacker can directly transfer, for example, 10^6 * 1e18 1 of ALCX to the gALCX contract and run bumpExchangeRate(), effectively setting the cost of 1 gALCX to be 10^6 * 1e18 of ALCX. The attacker will still own 100% of the gALCX's ALCX pool being the only depositor.\n\nAll subsequent depositors will have their ALCX token investments rounded to 10^6 * 1e18, due to the lack of precision which initial tiny deposit caused, with the remainder divided between all current depositors, i.e. the subsequent depositors lose value to the attacker.\n\nFor example, if the second depositor brings in 1.9*10^6 * 1e18 of ALCX, only 1 of new vault to be issued as 1.9*10^6 * 1e18 divided by 10^6 * 1e18 will yield just 1, which means that 2.9*10^6 * 1e18 total ALCX pool will be divided 50/50 between the second depositor and the attacker, as each will have 1 wei of the total 2 wei of vault tokens, i.e. the depositor lost and the attacker gained 0.45 * 10^6 * 1e18 of ALCX tokens.\n\nAs there are no penalties to exit with gALCX.unstake(), the attacker can remain staked for an arbitrary time, gathering the share of all new deposits' remainder amounts.\n\nPlacing severity to be medium as this is principal funds loss scenario for many users (most of depositors), easily executable, but only new gALCX contract instances are vulnerable.\n\n\ngAmount of gALCX to be minted is determined as a quotient of amount provided and exchangeRate:\n\ngALCX.sol#L93-L94(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/gALCX.sol#L93-L94)<br\n\nsolidity\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n\n\ngALCX.sol#L15(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L15)<br\n\nsolidity\nuint public constant exchangeRatePrecision = 1e18;\n\n\nexchangeRate accumulates balance increments relative to total gALCX supply:\n\ngALCX.sol#L69-L76(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L69-L76)<br\n\nsolidity\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance  0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n\n\nWhen gALCX contract is new, the very first stake - bumpExchangeRate() yields nothing as the balance is empty, i.e. exchangeRate is still 1e18 and gAmount == amount:\n\ngALCX.sol#L85-L93(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/gALCX.sol#L85-L93)<br\n\nsolidity\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n\n\nThis way, as there is no minimum amount or special treatment for the first deposit, the very first gAmount can be made 1 wei with stake(1) call.\n\nThen, a combination of direct ALCX transfer and bumpExchangeRate() will make exchangeRate equal to the total amount provided by the attacker, say 10^6 * 1e18 * 1e18, as totalSupply is 1 wei.\n\nWhen a second depositor enters, the amount of gALCX to be minted is calculated as amount * exchangeRatePrecision / exchangeRate, which is amount / (10^6 * 1e18), which will trunk the amount to the nearest divisor of 10^6 * 1e18, effectively dividing the remainder between the depositor and the attacker.\n\nFor example, if the second depositor brings in 1.9*10^6 ALCX, only 1 (1 wei) of gALCX to be issued as 1.9*10^6 * 1e18 * 1e18 / (10^6 * 1e18 * 1e18) = 1.\n\nAs the attacker and depositor both have 1 of gALCX, each owns (2.9 / 2)*10^6 * 1e18 = 1.45*10^6 * 1e18, so the attacker effectively stole 0.45*10^6 * 1e18 from the depositor.\n\nAny deposit lower than total attacker's stake, 10^6 * 1e18, will be fully stolen from the depositor as 0 gALCX tokens will be issued in this case.\n\n\nThe issue is similar to the TOB-YEARN-003 one of the Trail of Bits audit of Yearn Finance:\n\n<https://github.com/yearn/yearn-security/tree/master/audits/20210719_ToB_yearn_vaultsv2\n\n",
                "Repair": "\nA minimum for deposit value can drastically reduce the economic viability of the attack. I.e. stake() can require each amount to surpass the threshold, and then an attacker would have to provide too big direct investment to capture any meaningful share of the subsequent deposits.\n\nAn alternative is to require only the first depositor to freeze big enough initial amount of liquidity. This approach has been used long enough by various projects, for example in Uniswap V2:\n\nUniswap/UniswapV2Pair.sol#L119-L121(https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L121)<br\n\n0xfoobar (Alchemix) acknowledged, disagreed with severity and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/135#issuecomment-1140704865):\n\n Not a risk with current 400 tokenholders, but good to incorporated into future designs.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/135#issuecomment-1146370503):\n  I think from the perspective of the contest, it is fair to assume that contracts are somewhat fresh. I'd be inclined to keep this as medium because it outlines a viable attack path that should be made public.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {CrossChainCanonicalBase} from \"./CrossChainCanonicalBase.sol\";\n\ncontract CrossChainCanonicalGALCX is CrossChainCanonicalBase {\n  function initialize(\n      string memory name, \n      string memory symbol, \n      address[] memory _bridgeTokens\n  ) public initializer {\n    __CrossChainCanonicalBase_init(\n      name,\n      symbol,\n      msg.sender,\n      _bridgeTokens\n    );\n  }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IEthStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IEthStableMetaPool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IWETH9 weth;\n    IERC20 curveToken;\n    IEthStableMetaPool metaPool;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ETH, ALETH\n}\n\n/// @title  EthAssetManager\n/// @author Alchemix Finance\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum that was reclaimed.\n    event ReclaimEth(uint256 amount);\n\n    /// @notice Emitted when a token is swept to the admin.\n    ///\n    /// @param token  The token that was swept.\n    /// @param amount The amount of the token that was swept.\n    event SweepToken(address token, uint256 amount);\n\n    /// @notice Emitted when ethereum is swept to the admin.\n    ///\n    /// @param amount The amount of the token that was swept.\n    event SweepEth(uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The wrapped ethereum token.\n    IWETH9 public weth;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The meta pool contract.\n    IEthStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin            = params.admin;\n        operator         = params.operator;\n        rewardReceiver   = params.rewardReceiver;\n        transmuterBuffer = params.transmuterBuffer;\n        weth             = params.weth;\n        curveToken       = params.curveToken;\n        metaPool         = params.metaPool;\n        metaPoolSlippage = params.metaPoolSlippage;\n        convexToken      = params.convexToken;\n        convexBooster    = params.convexBooster;\n        convexRewards    = params.convexRewards;\n        convexPoolId     = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n            }\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    receive() external payable { }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        if (asset == MetaPoolAsset.ETH) {\n            return address(this).balance + token.balanceOf(address(this));\n        }\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of ethereum that one alETH is worth.\n    ///\n    /// @return The amount of the underlying token.\n    function exchangeRate() public view returns (uint256) {\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        return metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\n            10**SafeERC20.expectDecimals(address(alETH)),\n            metaBalances\n        );\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the meta pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The meta pool asset to flush.\n    /// @param amount The amount of the meta pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\n    ///         burning the meta pool tokens for ethereum.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of ethereum recalled.\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum to reclaim.\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\n        uint256 balance;\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\n\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\n\n        emit ReclaimEth(amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n        emit SweepToken(token, amount);\n    }\n\n    /// @notice Sweeps ethereum out of the contract to the admin.\n    ///\n    /// @param amount The amount of ethereum to sweep.\n    ///\n    /// @return result The result from the call to transfer ethereum.\n    function sweepEth(\n        uint256 amount\n    ) external lock onlyAdmin returns (bytes memory result) {\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState(\"Transfer failed\");\n        }\n\n        emit SweepEth(amount);\n\n        return result;\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Set an approval if not working with ethereum.\n        if (asset != MetaPoolAsset.ETH) {\n            IERC20 token = getTokenForMetaPoolAsset(asset);\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\n        }\n\n        uint256 value = asset == MetaPoolAsset.ETH\n            ? amounts[uint256(MetaPoolAsset.ETH)]\n            : 0;\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.13;\n\nimport {FixedPointMathLib} from \"./solmate/FixedPointMathLib.sol\";\n\nimport {ICERC20} from \"../interfaces/external/compound/ICERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\n/// @notice Get up to date cToken data without mutating state.\n/// @author Transmissions11 (https://github.com/transmissions11/libcompound)\nlibrary LibFuse {\n    using FixedPointMathLib for uint256;\n\n    function viewUnderlyingBalanceOf(ICERC20 cToken, address user) internal view returns (uint256) {\n        return cToken.balanceOf(user).mulWadDown(viewExchangeRate(cToken));\n    }\n\n    function viewExchangeRate(ICERC20 cToken) internal view returns (uint256) {\n        uint256 accrualBlockNumberPrior = cToken.accrualBlockNumber();\n\n        if (accrualBlockNumberPrior == block.number) return cToken.exchangeRateStored();\n\n        uint256 totalCash = IERC20(cToken.underlying()).balanceOf(address(cToken));\n        uint256 borrowsPrior = cToken.totalBorrows();\n        uint256 reservesPrior = cToken.totalReserves();\n        uint256 adminFeesPrior = cToken.totalAdminFees();\n        uint256 fuseFeesPrior = cToken.totalFuseFees();\n\n        uint256 interestAccumulated; // Generated in new scope to avoid stack too deep.\n        {\n            uint256 borrowRateMantissa = cToken.interestRateModel().getBorrowRate(\n                totalCash,\n                borrowsPrior,\n                reservesPrior + adminFeesPrior + fuseFeesPrior\n            );\n\n            // Same as borrowRateMaxMantissa in CTokenInterfaces.sol\n            require(borrowRateMantissa <= 0.0005e16, \"RATE_TOO_HIGH\");\n\n            interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown(\n                borrowsPrior\n            );\n        }\n\n        uint256 totalReserves = cToken.reserveFactorMantissa().mulWadDown(interestAccumulated) + reservesPrior;\n        uint256 totalAdminFees = cToken.adminFeeMantissa().mulWadDown(interestAccumulated) + adminFeesPrior;\n        uint256 totalFuseFees = cToken.fuseFeeMantissa().mulWadDown(interestAccumulated) + fuseFeesPrior;\n\n        uint256 totalSupply = cToken.totalSupply();\n\n        return\n            totalSupply == 0\n                ? cToken.initialExchangeRateMantissa()\n                : (totalCash + (interestAccumulated + borrowsPrior) - (totalReserves + totalAdminFees + totalFuseFees))\n                    .divWadDown(totalSupply);\n    }\n}\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n",
        "CodeNames": [
            "gALCX.sol",
            "CrossChainCanonicalGALCX.sol",
            "EthAssetManager.sol",
            "LibFuse.sol",
            "AlchemistV2.sol",
            "AlchemicTokenV1.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "balance",
                    "(balance * exchangeRatePrecision) / totalSupply",
                    "unstake",
                    "stake",
                    "bumpExchangeRate",
                    "migrateSource",
                    "ALCX",
                    "totalSupply == 0",
                    "alcx.balanceOf(address(this))  0"
                ],
                "Type": " [gALCX.sol",
                "Description": "\nAn attacker can make the contract unusable when totalSupply is 0. Specifically,  bumpExchangeRate function does not work correctly which results in making stake, unstake and migrateSource functions that do not work as expected.\n\n\nHere are steps on how the gALCX contract can be unusable.\n\n1.  gALCX contract is deployed\n\n2.  The attacker sends the ALCX token to the deployed gALCX contract directly instead of using stake function so that the following balance variable has value.\n\ngALCX.sol#L73-L75(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-hardhat/gALCX.sol#L73-L75)<br\n    uint balance = alcx.balanceOf(address(this));\n\n    if (balance  0) {\n\n3.  Since the ALCX token is given to the gALCX contract directly, totalSupply == 0 and alcx.balanceOf(address(this))  0 becomes true.\n\ngALCX.sol#L76(https://github.com/code-423n4/2022-05-alchemix/blob/main/contracts-hardhat/gALCX.sol#L76)<br\n\n    exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n\n4.  Non attackers try to call stake function, but bumpExchangeRate function fails because of (balance * exchangeRatePrecision) / totalSupply when totalSupply is 0.\n\n5.  Owner cannot call migrateSource function since bumpExchangeRate will be in the same situation mentioned in the step4 above\n\n",
                "Repair": "\nAdd handling when totalSupply is 0 but alcx.balanceOf(address(this)) is more than 0.\n\n0xfoobar (Alchemix) acknowledged and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/198#issuecomment-1133996854):\n  Given that the gALCX deployment has 412 unique tokenholders on mainnet, this series of events is extraordinarily unlikely to occur. But we will keep it in mind for future deployments.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/198#issuecomment-1146895463):\n  Nice find! Early stakers can DoS new contract deployments, making it impossible for other users to participate in the protocol. As this does not lead to lost funds and is recoverable through redeployment, I believe medium severity to be justified by the warden.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n",
        "CodeNames": [
            "AlchemistV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-15",
                "Location": [
                    "//solidity\n    function price() external view returns (uint256) {\n        return IWstETH(token).getStETHByWstETH(10SafeERC20.expectDecimals(token));\n    }\n"
                ],
                "Type": " Lido adapter incorrectly calculates the price of the underlying token",
                "Description": "\nThe Lido adapter incorrectly calculates the price of WETH in terms of WstETH.\n\nThe function returns the price of WstETH in terms of stETH. The underlying token which we desire is WETH.\nSince stETH does not have the same value as WETH the output price incorrect.\n\nThe impact is severe as all the balance calculations require the price of the yield token converted to underlying. The incorrect price may over or understate the harvestable amount which is a core calculation in the protocol.\n\n\nThe function IWstETH(token).getStETHByWstETH() only converts WstETH to stETH. Thus, price() returns the value of WstETH in terms of stETH.\n\nsolidity\n    function price() external view returns (uint256) {\n        return IWstETH(token).getStETHByWstETH(10SafeERC20.expectDecimals(token));\n    }\n\n\n",
                "Repair": "\nAdd extra steps to price() to approximate the rate for converting stETH to ETH. This can be done using the same curve pool that is used to convert stETH to ETH in unwrap().\n\n0xfoobar (Alchemix) disputed and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/97#issuecomment-1133989793):\n \n The design mechanism relies upon stETH reaching eventual 1:1 redeemability for ETH after the merge and shanghai enables withdrawals. This is core to out like-kind collateral/asset model. We will update the stETH token adapter at that time to do direct redemptions instead of Curve swaps. So in the meantime, the protocol accrues discounted assets.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/97#issuecomment-1150012226):\n  While the sponsor's comments suggest that this will be a non-issue after the merge/shanghai enables withdrawals, I believe there is legitimacy in the fact that the protocol will accrue discounted assets. It does not lead to the loss of assets, but value can be leaked if WETH is priced incorrectly. As such, I'm downgrading this to medium severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-16",
                "Location": [
                    "//solidity\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n"
                ],
                "Type": " If  totalShares  for a token falls to zero while there is  pendingCredit  the contract will become stuck",
                "Description": "\nAlchemistV2.sol#L1290-L1300(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300)<br\nAlchemistV2.sol#L1268(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268)<br\nAlchemistV2.sol#L1532(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532)<br\nAlchemistV2.sol#L899(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899)<br\nAlchemistV2.sol#L1625(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625)<br\n\nIt is possible for the contract to become stuck and unable to perform any actions if the totalShares of a yield token fall to zero while there is some pendingCredit still to be paid.\n\nIt will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:\n\n*   _distributeCredit()\n*   _distributeUnlockedCredit()\n*   _calculateUnrealizedDebt()\n*   _convertSharesToYieldTokens()\n*   donate()\n\nFurthermore, any pendingCredit amount of tokens are still in the contract will become permanently stuck.\n\n\nThis case may arise under the follow steps\na) deposit() is called by a user then time passes to earn some yield\nb) harvest() is called by the keeper which calls _distributeCredit() and increases pendingCredit\nc) withdraw() is called by the user to withdraw all funds\n\nSince there is pendingCredit the following will have a non-zero balance for unlockedCredit however yieldTokenParams.totalShares is zero and thus we get a division by zero which reverts the entire transaction.\n\nsolidity\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n\nEach of the other listed functions will reach the same issue by attempting to divide some numerator by the totalShares which is zero.\n\n",
                "Repair": "\nConsider preventing totalShares from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.\n\nAnother option is to transfer the first 1000 shares to a \"burn\" account (e.g. 0x000...01), when the first user deposits.\n\nAlternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.\n\n0xfoobar (Alchemix) confirmed, disagreed with severity and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1133988067):\n  Disagree with severity because given the depth of distinct users using Alchemix, it is unlikely this scenario would occur.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1146196263):\n  This is an interesting issue. At the moment, it sits somewhere between medium and high risk, so I will need to think about this more before coming to a decision.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/104#issuecomment-1150102500):\n  After further thought, I think this does not fit the criteria of high severity for the following reasons:\n  The protocol can be DoS'd on new deployments via front-running, but it does not lead to lost funds by users. It'd only require a new deployment by the Alchemist team.\n  If the protocol was to migrate to a new version of the protocol, a mass withdrawal event could lead to locked pendingCredit. However, because rewards are harvested by a keeper, I believe this to be unlikely as migrations will most certainly be coordinated by the protocol and its keepers. As such, users will be aware that they would miss out on rewards if the keeper does not harvest rewards prior to the migration.\n  Rewards are regularly harvested by the keeper, and as such, the value at risk is somewhat negligible.\n \n For these reasons, I believe medium severity to be justified.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-08",
                "Location": [
                    "safeApprove()"
                ],
                "Type": "  safeApprove()  is deprecated",
                "Description": "\nDeprecated(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of safeIncreaseAllowance() and safeDecreaseAllowance(). If only setting the initial allowance to the value that means infinite, safeIncreaseAllowance() can be used instead\n\n*There are 32 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-13",
                "Location": [
                    "private"
                ],
                "Type": "  private  functions not called by the contract should be removed to save deployment gas",
                "Description": "\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState} from \"./base/Errors.sol\";\n\nimport {TokenUtils} from \"./libraries/TokenUtils.sol\";\n\ncontract CrossChainCanonicalBase is ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    // Constants for various precisions\n    uint256 private constant FEE_PRECISION = 1e6; // Okay to use constant declarations since compiler does not reserve a storage slot\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Swap fee numerators, denominator of FEE_PRECISION\n    mapping(address => uint256[2]) public swapFees;\n    mapping(address => bool) public feeExempt;\n\n    // Acceptable old tokens\n    address[] public bridgeTokensArray; // Used for external UIs\n    mapping(address => bool) public bridgeTokens; // Used for the logic checks\n\n    // Administrative booleans\n    bool public exchangesPaused; // Pause old token exchanges in case of an emergency\n    mapping(address => bool) public bridgeTokenEnabled;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier validBridgeToken(address tokenAddress) {\n        if (!bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function __CrossChainCanonicalBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _creatorAddress,\n        address[] memory _bridgeTokens\n    ) internal {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __EIP712_init_unchained(_name, \"1\");\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init_unchained(_name);\n        __ReentrancyGuard_init_unchained(); // Note: this is called here but not in AlchemicTokenV2Base. Careful if inheriting that without this\n        _transferOwnership(_creatorAddress);\n\n        // Initialize the starting old tokens\n        for (uint256 i = 0; i < _bridgeTokens.length; i++){ \n            // Mark as accepted\n            bridgeTokens[_bridgeTokens[i]] = true;\n\n            // Add to the array\n            bridgeTokensArray.push(_bridgeTokens[i]);\n\n            // Set a small swap fee initially of 0.04%\n            swapFees[_bridgeTokens[i]] = [400, 400];\n\n            // Make sure swapping is on\n            bridgeTokenEnabled[_bridgeTokens[i]] = true;\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensArray;\n    }\n\n    function _isFeeExempt(address targetAddress) internal view returns (bool) {\n        return feeExempt[targetAddress];\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Exchange old tokens for these canonical tokens\n    function exchangeOldForCanonical(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 canonicalTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Pull in the old tokens\n        TokenUtils.safeTransferFrom(bridgeTokenAddress, msg.sender, address(this), tokenAmount);\n\n        // Handle the fee, if applicable\n        canonicalTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonicalTokensOut -= ((canonicalTokensOut * swapFees[bridgeTokenAddress][0]) / FEE_PRECISION);\n        }\n\n        // Mint canonical tokens and give it to the sender\n        super._mint(msg.sender, canonicalTokensOut);\n    }\n\n    // Exchange canonical tokens for old tokens\n    function exchangeCanonicalForOld(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 bridgeTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Burn the canonical tokens\n        super._burn(msg.sender, tokenAmount);\n\n        // Handle the fee, if applicable\n        bridgeTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridgeTokensOut -= ((bridgeTokensOut * swapFees[bridgeTokenAddress][1]) / FEE_PRECISION);\n        }\n\n        // Give old tokens to the sender\n        TokenUtils.safeTransfer(bridgeTokenAddress, msg.sender, bridgeTokensOut);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL TOO ========== */\n\n    function toggleExchanges() external onlyOwner {\n        exchangesPaused = !exchangesPaused;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function addBridgeToken(address bridgeTokenAddress) external onlyOwner {\n        // Make sure the token is not already present\n        for (uint i = 0; i < bridgeTokensArray.length; i++){ \n            if (bridgeTokensArray[i] == bridgeTokenAddress) {\n                revert IllegalState();\n            }\n        }\n\n        // Add the old token\n        bridgeTokensArray.push(bridgeTokenAddress);\n\n        // Turn swapping on\n        bridgeTokenEnabled[bridgeTokenAddress] = true;\n\n        emit BridgeTokenAdded(bridgeTokenAddress);\n    }\n\n    function toggleBridgeToken(address bridgeTokenAddress, bool enabled) external onlyOwner {\n        // Toggle swapping\n        bridgeTokenEnabled[bridgeTokenAddress] = enabled;\n\n        emit BridgeTokenToggled(bridgeTokenAddress, enabled);\n    }\n\n    function setSwapFees(address bridgeTokenAddress, uint256 _bridgeToCanonical, uint256 _canonicalToOld) external onlyOwner {\n        swapFees[bridgeTokenAddress] = [_bridgeToCanonical, _canonicalToOld];\n\n        emit SwapFeeSet(bridgeTokenAddress, _bridgeToCanonical, _canonicalToOld);\n    }\n\n    function toggleFeesForAddress(address targetAddress) external onlyOwner {\n        feeExempt[targetAddress] = !feeExempt[targetAddress];\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(this)) {\n            revert IllegalArgument();\n        }\n\n        if (bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n\n        TokenUtils.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event BridgeTokenAdded(address indexed bridgeTokenAddress);\n    event BridgeTokenToggled(address indexed bridgeTokenAddress, bool state);\n    event SwapFeeSet(address indexed bridgeTokenAddress, uint bridgeToCanonical, uint canonicalToOld);\n}\n\n",
        "CodeNames": [
            "AlchemistV2.sol",
            "CrossChainCanonicalBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-17",
                "Location": [
                    "//solidity\nfunction _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n    return amount * _underlyingTokens[underlyingToken].conversionFactor;\n}\n",
                    "//solidity\nfunction repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n    ...\n    uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n    // Update the recipient's debt.\n    _updateDebt(recipient, -SafeCast.toInt256(credit));\n    ...\n"
                ],
                "Type": " Debt can be repaid with a depegged underlyingToken, which can be exploited by arbitrageurs and drives the market price of alToken to match the worst depegged underlyingToken",
                "Description": "\nAlchemistV2.sol#L1679-L1682(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1679-L1682)<br\n\nsolidity\nfunction _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n    return amount * _underlyingTokens[underlyingToken].conversionFactor;\n}\n\n\nAlchemistV2.sol#L743-L786(https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L743-L786)<br\n\nsolidity\nfunction repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n    ...\n    uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n    // Update the recipient's debt.\n    _updateDebt(recipient, -SafeCast.toInt256(credit));\n    ...\n\n\nWhen repaying the debt with an underlyingToken, the amount in terms of the underlyingToken (adjusted for decimals) will always be taken in a 1:1 ratio/price for the subtrahend of the debt.\n\nWe believe this design is flawed and be exploited by arbitrageurs and eventually drives the market price of alToken to match the worst depegged underlyingToken.\n\nBecause if alToken is trading at a higher price against the depegged underlyingToken, the arbitrageur can always mint alToken and market sell for more depegged underlyingToken and repay the debt.\n\n\nGiven:\n\n*   alUSD is trading at $1\n*   minimumCollateralization: 4/3\n\n\nAn arbitrageur can:\n\n1.  Deposit 100M USDC as collateral and mint 75M alUSD (100*0.75);\n2.  Market buy 75M USDT with 67.5M alUSD (75*0.9) and repay the debt;\n3.  Withdraw the 100M USDC collateral;\n4.  Dump the remaining 7.5M alUSD (75-67.5) for profit.\n\nThis can be repeated until the market price of alUSD drops to $0.9, the same price as USDT.\n\n",
                "Repair": "\nConsider updating the repay() function and change to market buy using the underlyingToken to alToken and then burn() the alToken to reduce debt.\n\n0xfoobar (Alchemix) acknowledged, disagreed with severity and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/161#issuecomment-1133953254):\n\n This is a core design choice underlying the Alchemix system. Like-kind collateral and debt assumes that assets will hold their relationship. The onus lies on governance to choose safe collateral assets.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-alchemix-findings/issues/161#issuecomment-1150112042):\n  I agree with what was raised by the warden but disagree with the associated severity. Because user's assets are tied to the underlying collateral, it makes sense that the a depegged token would be reflected in the price of alToken. As a result, arbitrageurs are free to profit off this by driving the price of alToken down to its true value. \n \n I consider this to be medium risk because of an unlikely assumption made when considering the likelihood of a depeg event. Assets are not at direct risk, but value can be leaked under certain assumptions.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 46 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-05-alchemix-findings/issues/228) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: GimelSec(https://github.com/code-423n4/2022-05-alchemix-findings/issues/193), AuditsAreUS(https://github.com/code-423n4/2022-05-alchemix-findings/issues/103), 0x1f8b(https://github.com/code-423n4/2022-05-alchemix-findings/issues/86), 0xsomeone(https://github.com/code-423n4/2022-05-alchemix-findings/issues/119), 0xDjango(https://github.com/code-423n4/2022-05-alchemix-findings/issues/201), joestakey(https://github.com/code-423n4/2022-05-alchemix-findings/issues/177), TerrierLover(https://github.com/code-423n4/2022-05-alchemix-findings/issues/223), cccz(https://github.com/code-423n4/2022-05-alchemix-findings/issues/126), fatherOfBlocks(https://github.com/code-423n4/2022-05-alchemix-findings/issues/221), hyh(https://github.com/code-423n4/2022-05-alchemix-findings/issues/136), robee(https://github.com/code-423n4/2022-05-alchemix-findings/issues/94), Ruhum(https://github.com/code-423n4/2022-05-alchemix-findings/issues/62), shenwilly(https://github.com/code-423n4/2022-05-alchemix-findings/issues/146), WatchPug(https://github.com/code-423n4/2022-05-alchemix-findings/issues/165), csanuragjain(https://github.com/code-423n4/2022-05-alchemix-findings/issues/46), jayjonah8(https://github.com/code-423n4/2022-05-alchemix-findings/issues/70), MaratCerby(https://github.com/code-423n4/2022-05-alchemix-findings/issues/50), BowTiedWardens(https://github.com/code-423n4/2022-05-alchemix-findings/issues/215), horsefacts(https://github.com/code-423n4/2022-05-alchemix-findings/issues/218), sikorico(https://github.com/code-423n4/2022-05-alchemix-findings/issues/90), tintin(https://github.com/code-423n4/2022-05-alchemix-findings/issues/168), catchup(https://github.com/code-423n4/2022-05-alchemix-findings/issues/142), cryptphi(https://github.com/code-423n4/2022-05-alchemix-findings/issues/211), ellahi(https://github.com/code-423n4/2022-05-alchemix-findings/issues/130), oyc_109(https://github.com/code-423n4/2022-05-alchemix-findings/issues/84), Picodes(https://github.com/code-423n4/2022-05-alchemix-findings/issues/179), throttle(https://github.com/code-423n4/2022-05-alchemix-findings/issues/204), BouSalman(https://github.com/code-423n4/2022-05-alchemix-findings/issues/116), 0x4non(https://github.com/code-423n4/2022-05-alchemix-findings/issues/96), bobirichman(https://github.com/code-423n4/2022-05-alchemix-findings/issues/92), Cityscape(https://github.com/code-423n4/2022-05-alchemix-findings/issues/167), delfin454000(https://github.com/code-423n4/2022-05-alchemix-findings/issues/133), mics(https://github.com/code-423n4/2022-05-alchemix-findings/issues/82), MiloTruck(https://github.com/code-423n4/2022-05-alchemix-findings/issues/173), simon135(https://github.com/code-423n4/2022-05-alchemix-findings/issues/138), 0xNazgul(https://github.com/code-423n4/2022-05-alchemix-findings/issues/57), Funen(https://github.com/code-423n4/2022-05-alchemix-findings/issues/154), 0xkatana(https://github.com/code-423n4/2022-05-alchemix-findings/issues/125), hake(https://github.com/code-423n4/2022-05-alchemix-findings/issues/65), Hawkeye(https://github.com/code-423n4/2022-05-alchemix-findings/issues/226), JC(https://github.com/code-423n4/2022-05-alchemix-findings/issues/212), kebabsec(https://github.com/code-423n4/2022-05-alchemix-findings/issues/200), kenta(https://github.com/code-423n4/2022-05-alchemix-findings/issues/152), samruna(https://github.com/code-423n4/2022-05-alchemix-findings/issues/101), and Waze(https://github.com/code-423n4/2022-05-alchemix-findings/issues/175).*\n\n## Summary\n\n### Low Risk Issues\n\n|    | Issue                                                                                                                       | Instances |\n| -| :-------------------------------------------------------------------------------------------------------------------------| ------|\n| 1  | Latent funds can be stolen                                                                                                  |     1     |\n| 2  | Low level calls don't check for contract existence                                                                          |     1     |\n| 3  | Set sane maximums for input parameters                                                                                      |     2     |\n| 4  | Behavior described by comment is incomplete                                                                                 |     1     |\n| 5  | Unsafe use of transfer()/transferFrom() with IERC20                                                                   |     4     |\n| 6  | Return values of transfer()/transferFrom() not checked                                                                  |     2     |\n| 7  | Unused/empty receive() function                                                                                           |     2     |\n| 8  | safeApprove() is deprecated                                                                                               |     32    |\n| 9  | Missing checks for address(0x0) when assigning values to address state variables                                        |     24    |\n| 10 | abi.encodePacked() should not be used with dynamic types when passing the result to a hash function such as keccak256() |     1     |\n| 11 | Upgradeable contract is missing a __gap[50] storage variable to allow for new storage variables in later versions         |     3     |\n\nTotal: 73 instances over 11 issues\n\n### Non-critical Issues\n\n|    | Issue                                                                                                                           | Instances |\n| -| :-----------------------------------------------------------------------------------------------------------------------------| ------|\n| 1  | Adding a return statement when the function defines a named return variable, is redundant                                     |     4     |\n| 2  | override function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings |     1     |\n| 3  | public functions not called by the contract should be declared external instead                                             |     12    |\n| 4  | 2<n 1 should be re-written as type(uint<n).max                                                                        |     1     |\n| 5  | constants should be defined rather than using magic numbers                                                                   |     20    |\n| 6  | Redundant cast                                                                                                                  |     4     |\n| 7  | Numeric values having to do with time should use time units for readability                                                     |     1     |\n| 8  | Missing event for critical parameter change                                                                                     |     3     |\n| 9  | Use a more recent version of solidity                                                                                           |     12    |\n| 10 | Use a more recent version of solidity                                                                                           |     1     |\n| 11 | Use scientific notation (e.g. 1e18) rather than exponentiation (e.g. 1018)                                                |     2     |\n| 12 | Inconsistent spacing in comments                                                                                                |     11    |\n| 13 | Non-library/interface files should use fixed compiler versions, not floating ones                                               |     16    |\n| 14 | Typos                                                                                                                           |     12    |\n| 15 | File does not contain an SPDX Identifier                                                                                        |     32    |\n| 16 | File is missing NatSpec                                                                                                         |     27    |\n| 17 | NatSpec is incomplete                                                                                                           |     17    |\n| 18 | Event is missing indexed fields                                                                                               |    111    |\n| 19 | Use allowlist/denylist rather than blacklist/whitelist                                                                          |     1     |\n\nTotal: 288 instances over 19 issues\n\n\n"
            },
            {
                "Name": "-32",
                "Location": [
                    "onlyOwner",
                    "payable"
                ],
                "Type": " Functions guaranteed to revert when called by normal users can be marked  payable ",
                "Description": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {ICurveFactoryethpool} from \"./interfaces/ICurveFactoryethpool.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\n\nimport {AutoleverageBase} from \"./AutoleverageBase.sol\";\n\n/// @title A zapper for leveraged deposits into the Alchemist\ncontract AutoleverageCurveFactoryethpool is AutoleverageBase {\n\n    address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    \n    /// @notice Used to receive ETH from factory pool swaps\n    receive() external payable {}\n\n    /// @inheritdoc AutoleverageBase\n    function _transferTokensToSelf(address underlyingToken, uint256 collateralInitial) internal override {\n        // Convert eth to weth if received eth, otherwise transfer weth\n        if (msg.value > 0) {\n            if (msg.value != collateralInitial) revert IllegalArgument(\"msg.value doesn't match collateralInitial\");\n            IWETH9(wethAddress).deposit{value: msg.value}();\n        } else {\n            IERC20(underlyingToken).transferFrom(msg.sender, address(this), collateralInitial);\n        }\n    }\n\n    /// @inheritdoc AutoleverageBase\n    function _maybeConvertCurveOutput(uint256 amountOut) internal override {\n        // Convert ETH output from Curve into WETH\n        IWETH9(wethAddress).deposit{value: amountOut}();\n    }\n\n    /// @inheritdoc AutoleverageBase\n    function _curveSwap(address poolAddress, address debtToken, int128 i, int128 j, uint256 minAmountOut) internal override returns (uint256 amountOut) {\n        // Curve swap\n        uint256 debtTokenBalance = IERC20(debtToken).balanceOf(address(this));\n        approve(debtToken, poolAddress);\n        return ICurveFactoryethpool(poolAddress).exchange(\n            i,\n            j,\n            debtTokenBalance,\n            minAmountOut\n        );\n    }\n\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\ncontract AlchemicTokenV2 is AccessControl, ReentrancyGuard, ERC20, IERC3156FlashLender {\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    flashMintFee = _flashFee;\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2Base.sol",
            "AlchemistV2.sol",
            "AlchemicTokenV1.sol",
            "AutoleverageCurveFactoryethpool.sol",
            "AlchemicTokenV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "SafeERC",
                    "IERC",
                    "transfer()",
                    "transferFrom()",
                    "safeTransfer()"
                ],
                "Type": " Unsafe use of  transfer() / transferFrom()  with  IERC20 ",
                "Description": "\nSome tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s transfer() and transferFrom() functions do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to IERC20, their function signatures do not match and therefore the calls made, revert. Use OpenZeppelin\u2019s SafeERC20's safeTransfer()/safeTransferFrom() instead\n\n*There are 4 instances of this issue.*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\ncontract AlchemicTokenV2 is AccessControl, ReentrancyGuard, ERC20, IERC3156FlashLender {\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    flashMintFee = _flashFee;\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState} from \"./base/Errors.sol\";\n\nimport {TokenUtils} from \"./libraries/TokenUtils.sol\";\n\ncontract CrossChainCanonicalBase is ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    // Constants for various precisions\n    uint256 private constant FEE_PRECISION = 1e6; // Okay to use constant declarations since compiler does not reserve a storage slot\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Swap fee numerators, denominator of FEE_PRECISION\n    mapping(address => uint256[2]) public swapFees;\n    mapping(address => bool) public feeExempt;\n\n    // Acceptable old tokens\n    address[] public bridgeTokensArray; // Used for external UIs\n    mapping(address => bool) public bridgeTokens; // Used for the logic checks\n\n    // Administrative booleans\n    bool public exchangesPaused; // Pause old token exchanges in case of an emergency\n    mapping(address => bool) public bridgeTokenEnabled;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier validBridgeToken(address tokenAddress) {\n        if (!bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function __CrossChainCanonicalBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _creatorAddress,\n        address[] memory _bridgeTokens\n    ) internal {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __EIP712_init_unchained(_name, \"1\");\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init_unchained(_name);\n        __ReentrancyGuard_init_unchained(); // Note: this is called here but not in AlchemicTokenV2Base. Careful if inheriting that without this\n        _transferOwnership(_creatorAddress);\n\n        // Initialize the starting old tokens\n        for (uint256 i = 0; i < _bridgeTokens.length; i++){ \n            // Mark as accepted\n            bridgeTokens[_bridgeTokens[i]] = true;\n\n            // Add to the array\n            bridgeTokensArray.push(_bridgeTokens[i]);\n\n            // Set a small swap fee initially of 0.04%\n            swapFees[_bridgeTokens[i]] = [400, 400];\n\n            // Make sure swapping is on\n            bridgeTokenEnabled[_bridgeTokens[i]] = true;\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensArray;\n    }\n\n    function _isFeeExempt(address targetAddress) internal view returns (bool) {\n        return feeExempt[targetAddress];\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Exchange old tokens for these canonical tokens\n    function exchangeOldForCanonical(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 canonicalTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Pull in the old tokens\n        TokenUtils.safeTransferFrom(bridgeTokenAddress, msg.sender, address(this), tokenAmount);\n\n        // Handle the fee, if applicable\n        canonicalTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonicalTokensOut -= ((canonicalTokensOut * swapFees[bridgeTokenAddress][0]) / FEE_PRECISION);\n        }\n\n        // Mint canonical tokens and give it to the sender\n        super._mint(msg.sender, canonicalTokensOut);\n    }\n\n    // Exchange canonical tokens for old tokens\n    function exchangeCanonicalForOld(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 bridgeTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Burn the canonical tokens\n        super._burn(msg.sender, tokenAmount);\n\n        // Handle the fee, if applicable\n        bridgeTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridgeTokensOut -= ((bridgeTokensOut * swapFees[bridgeTokenAddress][1]) / FEE_PRECISION);\n        }\n\n        // Give old tokens to the sender\n        TokenUtils.safeTransfer(bridgeTokenAddress, msg.sender, bridgeTokensOut);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL TOO ========== */\n\n    function toggleExchanges() external onlyOwner {\n        exchangesPaused = !exchangesPaused;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function addBridgeToken(address bridgeTokenAddress) external onlyOwner {\n        // Make sure the token is not already present\n        for (uint i = 0; i < bridgeTokensArray.length; i++){ \n            if (bridgeTokensArray[i] == bridgeTokenAddress) {\n                revert IllegalState();\n            }\n        }\n\n        // Add the old token\n        bridgeTokensArray.push(bridgeTokenAddress);\n\n        // Turn swapping on\n        bridgeTokenEnabled[bridgeTokenAddress] = true;\n\n        emit BridgeTokenAdded(bridgeTokenAddress);\n    }\n\n    function toggleBridgeToken(address bridgeTokenAddress, bool enabled) external onlyOwner {\n        // Toggle swapping\n        bridgeTokenEnabled[bridgeTokenAddress] = enabled;\n\n        emit BridgeTokenToggled(bridgeTokenAddress, enabled);\n    }\n\n    function setSwapFees(address bridgeTokenAddress, uint256 _bridgeToCanonical, uint256 _canonicalToOld) external onlyOwner {\n        swapFees[bridgeTokenAddress] = [_bridgeToCanonical, _canonicalToOld];\n\n        emit SwapFeeSet(bridgeTokenAddress, _bridgeToCanonical, _canonicalToOld);\n    }\n\n    function toggleFeesForAddress(address targetAddress) external onlyOwner {\n        feeExempt[targetAddress] = !feeExempt[targetAddress];\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(this)) {\n            revert IllegalArgument();\n        }\n\n        if (bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n\n        TokenUtils.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event BridgeTokenAdded(address indexed bridgeTokenAddress);\n    event BridgeTokenToggled(address indexed bridgeTokenAddress, bool state);\n    event SwapFeeSet(address indexed bridgeTokenAddress, uint bridgeToCanonical, uint canonicalToOld);\n}\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "AlchemicTokenV2.sol",
            "AlchemicTokenV2Base.sol",
            "CrossChainCanonicalBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "transfer()",
                    "boolean",
                    "revert()",
                    "IERC"
                ],
                "Type": " Return values of  transfer() / transferFrom()  not checked",
                "Description": "\nNot all IERC20 implementations revert() when there's a failure in transfer()/transferFrom(). The function signature has a boolean return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment\n\n*There are 2 instances of this issue.*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\ncontract AlchemicTokenV2 is AccessControl, ReentrancyGuard, ERC20, IERC3156FlashLender {\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    flashMintFee = _flashFee;\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-07",
                "Location": [
                    "receive()"
                ],
                "Type": " Unused/empty  receive()  function",
                "Description": "\nIf the intention is for the Ether to be used, the function should call another function, otherwise it should revert\n\n*There are 2 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "return"
                ],
                "Type": " Adding a  return  statement when the function defines a named return variable, is redundant",
                "Description": "\n*There are 4 instances of this issue.*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts-full/AutoleverageCurveMetapool.sol   #1\n\n20:       function _maybeConvertCurveOutput(uint256 amountOut) internal override {}\n"
                ],
                "Type": "  override  function arguments that are unused should have the variable name removed or commented out to avoid compiler warnings",
                "Description": "\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts-full/AutoleverageCurveMetapool.sol   #1\n\n20:       function _maybeConvertCurveOutput(uint256 amountOut) internal override {}\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageCurveMetapool.sol#L20\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState} from \"./base/Errors.sol\";\n\nimport {TokenUtils} from \"./libraries/TokenUtils.sol\";\n\ncontract CrossChainCanonicalBase is ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    // Constants for various precisions\n    uint256 private constant FEE_PRECISION = 1e6; // Okay to use constant declarations since compiler does not reserve a storage slot\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Swap fee numerators, denominator of FEE_PRECISION\n    mapping(address => uint256[2]) public swapFees;\n    mapping(address => bool) public feeExempt;\n\n    // Acceptable old tokens\n    address[] public bridgeTokensArray; // Used for external UIs\n    mapping(address => bool) public bridgeTokens; // Used for the logic checks\n\n    // Administrative booleans\n    bool public exchangesPaused; // Pause old token exchanges in case of an emergency\n    mapping(address => bool) public bridgeTokenEnabled;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier validBridgeToken(address tokenAddress) {\n        if (!bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function __CrossChainCanonicalBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _creatorAddress,\n        address[] memory _bridgeTokens\n    ) internal {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __EIP712_init_unchained(_name, \"1\");\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init_unchained(_name);\n        __ReentrancyGuard_init_unchained(); // Note: this is called here but not in AlchemicTokenV2Base. Careful if inheriting that without this\n        _transferOwnership(_creatorAddress);\n\n        // Initialize the starting old tokens\n        for (uint256 i = 0; i < _bridgeTokens.length; i++){ \n            // Mark as accepted\n            bridgeTokens[_bridgeTokens[i]] = true;\n\n            // Add to the array\n            bridgeTokensArray.push(_bridgeTokens[i]);\n\n            // Set a small swap fee initially of 0.04%\n            swapFees[_bridgeTokens[i]] = [400, 400];\n\n            // Make sure swapping is on\n            bridgeTokenEnabled[_bridgeTokens[i]] = true;\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensArray;\n    }\n\n    function _isFeeExempt(address targetAddress) internal view returns (bool) {\n        return feeExempt[targetAddress];\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Exchange old tokens for these canonical tokens\n    function exchangeOldForCanonical(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 canonicalTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Pull in the old tokens\n        TokenUtils.safeTransferFrom(bridgeTokenAddress, msg.sender, address(this), tokenAmount);\n\n        // Handle the fee, if applicable\n        canonicalTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonicalTokensOut -= ((canonicalTokensOut * swapFees[bridgeTokenAddress][0]) / FEE_PRECISION);\n        }\n\n        // Mint canonical tokens and give it to the sender\n        super._mint(msg.sender, canonicalTokensOut);\n    }\n\n    // Exchange canonical tokens for old tokens\n    function exchangeCanonicalForOld(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 bridgeTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Burn the canonical tokens\n        super._burn(msg.sender, tokenAmount);\n\n        // Handle the fee, if applicable\n        bridgeTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridgeTokensOut -= ((bridgeTokensOut * swapFees[bridgeTokenAddress][1]) / FEE_PRECISION);\n        }\n\n        // Give old tokens to the sender\n        TokenUtils.safeTransfer(bridgeTokenAddress, msg.sender, bridgeTokensOut);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL TOO ========== */\n\n    function toggleExchanges() external onlyOwner {\n        exchangesPaused = !exchangesPaused;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function addBridgeToken(address bridgeTokenAddress) external onlyOwner {\n        // Make sure the token is not already present\n        for (uint i = 0; i < bridgeTokensArray.length; i++){ \n            if (bridgeTokensArray[i] == bridgeTokenAddress) {\n                revert IllegalState();\n            }\n        }\n\n        // Add the old token\n        bridgeTokensArray.push(bridgeTokenAddress);\n\n        // Turn swapping on\n        bridgeTokenEnabled[bridgeTokenAddress] = true;\n\n        emit BridgeTokenAdded(bridgeTokenAddress);\n    }\n\n    function toggleBridgeToken(address bridgeTokenAddress, bool enabled) external onlyOwner {\n        // Toggle swapping\n        bridgeTokenEnabled[bridgeTokenAddress] = enabled;\n\n        emit BridgeTokenToggled(bridgeTokenAddress, enabled);\n    }\n\n    function setSwapFees(address bridgeTokenAddress, uint256 _bridgeToCanonical, uint256 _canonicalToOld) external onlyOwner {\n        swapFees[bridgeTokenAddress] = [_bridgeToCanonical, _canonicalToOld];\n\n        emit SwapFeeSet(bridgeTokenAddress, _bridgeToCanonical, _canonicalToOld);\n    }\n\n    function toggleFeesForAddress(address targetAddress) external onlyOwner {\n        feeExempt[targetAddress] = !feeExempt[targetAddress];\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(this)) {\n            revert IllegalArgument();\n        }\n\n        if (bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n\n        TokenUtils.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event BridgeTokenAdded(address indexed bridgeTokenAddress);\n    event BridgeTokenToggled(address indexed bridgeTokenAddress, bool state);\n    event SwapFeeSet(address indexed bridgeTokenAddress, uint bridgeToCanonical, uint canonicalToOld);\n}\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "CrossChainCanonicalBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-18",
                "Location": [
                    "indexed",
                    "event"
                ],
                "Type": " Event is missing  indexed  fields",
                "Description": "\nEach event should use three indexed fields if there are three or more fields\n\n*There are 111 instances of this issue.*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IEthStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IEthStableMetaPool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IWETH9 weth;\n    IERC20 curveToken;\n    IEthStableMetaPool metaPool;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ETH, ALETH\n}\n\n/// @title  EthAssetManager\n/// @author Alchemix Finance\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum that was reclaimed.\n    event ReclaimEth(uint256 amount);\n\n    /// @notice Emitted when a token is swept to the admin.\n    ///\n    /// @param token  The token that was swept.\n    /// @param amount The amount of the token that was swept.\n    event SweepToken(address token, uint256 amount);\n\n    /// @notice Emitted when ethereum is swept to the admin.\n    ///\n    /// @param amount The amount of the token that was swept.\n    event SweepEth(uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The wrapped ethereum token.\n    IWETH9 public weth;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The meta pool contract.\n    IEthStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin            = params.admin;\n        operator         = params.operator;\n        rewardReceiver   = params.rewardReceiver;\n        transmuterBuffer = params.transmuterBuffer;\n        weth             = params.weth;\n        curveToken       = params.curveToken;\n        metaPool         = params.metaPool;\n        metaPoolSlippage = params.metaPoolSlippage;\n        convexToken      = params.convexToken;\n        convexBooster    = params.convexBooster;\n        convexRewards    = params.convexRewards;\n        convexPoolId     = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n            }\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    receive() external payable { }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        if (asset == MetaPoolAsset.ETH) {\n            return address(this).balance + token.balanceOf(address(this));\n        }\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of ethereum that one alETH is worth.\n    ///\n    /// @return The amount of the underlying token.\n    function exchangeRate() public view returns (uint256) {\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        return metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\n            10**SafeERC20.expectDecimals(address(alETH)),\n            metaBalances\n        );\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the meta pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The meta pool asset to flush.\n    /// @param amount The amount of the meta pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\n    ///         burning the meta pool tokens for ethereum.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of ethereum recalled.\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum to reclaim.\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\n        uint256 balance;\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\n\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\n\n        emit ReclaimEth(amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n        emit SweepToken(token, amount);\n    }\n\n    /// @notice Sweeps ethereum out of the contract to the admin.\n    ///\n    /// @param amount The amount of ethereum to sweep.\n    ///\n    /// @return result The result from the call to transfer ethereum.\n    function sweepEth(\n        uint256 amount\n    ) external lock onlyAdmin returns (bytes memory result) {\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState(\"Transfer failed\");\n        }\n\n        emit SweepEth(amount);\n\n        return result;\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Set an approval if not working with ethereum.\n        if (asset != MetaPoolAsset.ETH) {\n            IERC20 token = getTokenForMetaPoolAsset(asset);\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\n        }\n\n        uint256 value = asset == MetaPoolAsset.ETH\n            ? amounts[uint256(MetaPoolAsset.ETH)]\n            : 0;\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n",
        "CodeNames": [
            "EthAssetManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-03",
                "Location": [
                    "immutable"
                ],
                "Type": " State variables only set in the constructor should be declared  immutable ",
                "Description": "\nAvoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a PUSH32 (3 gas). If getters are still desired, '_' can be added to the variable name and the getter can be added manually\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\ncontract AlchemicTokenV2 is AccessControl, ReentrancyGuard, ERC20, IERC3156FlashLender {\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    flashMintFee = _flashFee;\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "AlchemicTokenV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "external",
                    "calldata",
                    "memory"
                ],
                "Type": " Using  calldata  instead of  memory  for read-only arguments in  external  functions saves gas",
                "Description": "\nWhen a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2Base.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-09",
                "Location": [
                    "internal"
                ],
                "Type": "  internal  functions only called once can be inlined to save gas",
                "Description": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Tick.sol\";\nimport \"./libraries/TokenUtils.sol\";\n\n/// @title TransmuterV2\n///\n/// @notice A contract which facilitates the exchange of synthetic assets for their underlying\n//          asset. This contract guarantees that synthetic assets are exchanged exactly 1:1\n//          for the underlying asset.\ncontract TransmuterV2 is ITransmuterV2, Initializable, ReentrancyGuardUpgradeable, AccessControlUpgradeable {\n  using FixedPointMath for FixedPointMath.Number;\n  using Tick for Tick.Cache;\n\n  struct Account {\n    // The total number of unexchanged tokens that an account has deposited into the system\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that an account has had credited\n    uint256 exchangedBalance;\n    // The tick that the account has had their deposit associated in\n    uint256 occupiedTick;\n  }\n\n  struct UpdateAccountParams {\n    // The owner address whose account will be modified\n    address owner;\n    // The amount to change the account's unexchanged balance by\n    int256 unexchangedDelta;\n    // The amount to change the account's exchanged balance by\n    int256 exchangedDelta;\n  }\n\n  struct ExchangeCache {\n    // The total number of unexchanged tokens that exist at the start of the exchange call\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to at the start of the exchange call\n    uint256 satisfiedTick;\n    // The head of the active ticks queue at the start of the exchange call\n    uint256 ticksHead;\n  }\n\n  struct ExchangeState {\n    // The position in the buffer of current tick which is being examined\n    uint256 examineTick;\n    // The total number of unexchanged tokens that currently exist in the system for the current distribution step\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to, inclusive\n    uint256 satisfiedTick;\n    // The amount of tokens to distribute for the current step\n    uint256 distributeAmount;\n    // The accumulated weight to write at the new tick after the exchange is completed\n    FixedPointMath.Number accumulatedWeight;\n    // Reserved for the maximum weight of the current distribution step\n    FixedPointMath.Number maximumWeight;\n    // Reserved for the dusted weight of the current distribution step\n    FixedPointMath.Number dustedWeight;\n  }\n\n  struct UpdateAccountCache {\n    // The total number of unexchanged tokens that the account held at the start of the update call\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that the account held at the start of the update call\n    uint256 exchangedBalance;\n    // The tick that the account's deposit occupies at the start of the update call\n    uint256 occupiedTick;\n    // The total number of unexchanged tokens that exist at the start of the update call\n    uint256 totalUnexchanged;\n    // The current tick that is being written to\n    uint256 currentTick;\n  }\n\n  struct UpdateAccountState {\n    // The updated unexchanged balance of the account being updated\n    uint256 unexchangedBalance;\n    // The updated exchanged balance of the account being updated\n    uint256 exchangedBalance;\n    // The updated total unexchanged balance\n    uint256 totalUnexchanged;\n  }\n\n  address public constant ZERO_ADDRESS = address(0);\n\n  /// @dev The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n  /// @dev The identitifer of the sentinel role\n  bytes32 public constant SENTINEL = keccak256(\"SENTINEL\");\n\n  /// @inheritdoc ITransmuterV2\n  string public constant override version = \"2.2.0\";\n\n  /// @dev the synthetic token to be transmuted\n  address public syntheticToken;\n\n  /// @dev the underlying token to be received\n  address public override underlyingToken;\n\n  /// @dev The total amount of unexchanged tokens which are held by all accounts.\n  uint256 public totalUnexchanged;\n\n  /// @dev The total amount of tokens which are in the auxiliary buffer.\n  uint256 public totalBuffered;\n\n  /// @dev A mapping specifying all of the accounts.\n  mapping(address => Account) private accounts;\n\n  // @dev The tick buffer which stores all of the tick information along with the tick that is\n  //      currently being written to. The \"current\" tick is the tick at the buffer write position.\n  Tick.Cache private ticks;\n\n  // The tick which has been satisfied up to, inclusive.\n  uint256 private satisfiedTick;\n\n  /// @dev contract pause state\n  bool public isPaused;\n\n  /// @dev the source of the exchanged collateral\n  address public buffer;\n\n  /// @dev The address of the external whitelist contract.\n  address public override whitelist;\n\n  /// @dev The amount of decimal places needed to normalize collateral to debtToken\n  uint256 public override conversionFactor;\n\n  constructor() initializer {}\n\n  function initialize(\n    address _syntheticToken,\n    address _underlyingToken,\n    address _buffer,\n    address _whitelist\n  ) external initializer {\n    _setupRole(ADMIN, msg.sender);\n    _setRoleAdmin(ADMIN, ADMIN);\n    _setRoleAdmin(SENTINEL, ADMIN);\n\n    syntheticToken = _syntheticToken;\n    underlyingToken = _underlyingToken;\n    uint8 debtTokenDecimals = TokenUtils.expectDecimals(syntheticToken);\n    uint8 underlyingTokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n    conversionFactor = 10**(debtTokenDecimals - underlyingTokenDecimals);\n    buffer = _buffer;\n    // Push a blank tick to function as a sentinel value in the active ticks queue.\n    ticks.next();\n\n    isPaused = false;\n    whitelist = _whitelist;\n  }\n\n  /// @dev A modifier which checks if caller is an alchemist.\n  modifier onlyBuffer() {\n    if (msg.sender != buffer) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel or admin.\n  modifier onlySentinelOrAdmin() {\n    if (!hasRole(SENTINEL, msg.sender) && !hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel.\n  modifier notPaused() {\n    if (isPaused) {\n      revert IllegalState();\n    }\n    _;\n  }\n\n  function _onlyAdmin() internal view {\n    if (!hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n  }\n\n  function setCollateralSource(address _newCollateralSource) external {\n    _onlyAdmin();\n    buffer = _newCollateralSource;\n  }\n\n  function setPause(bool pauseState) external onlySentinelOrAdmin {\n    isPaused = pauseState;\n    emit Paused(isPaused);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function deposit(uint256 amount, address owner) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: owner,\n        unexchangedDelta: SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransferFrom(syntheticToken, msg.sender, address(this), amount);\n    emit Deposit(msg.sender, owner, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function withdraw(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({ \n        owner: msg.sender,\n        unexchangedDelta: -SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransfer(syntheticToken, recipient, amount);\n    emit Withdraw(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function claim(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: msg.sender,\n        unexchangedDelta: 0,\n        exchangedDelta: -SafeCast.toInt256(_normalizeUnderlyingTokensToDebt(amount))\n      })\n    );\n    TokenUtils.safeBurn(syntheticToken, _normalizeUnderlyingTokensToDebt(amount));\n    ITransmuterBuffer(buffer).withdraw(underlyingToken, amount, msg.sender);\n    emit Claim(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function exchange(uint256 amount) external override nonReentrant onlyBuffer notPaused {\n    uint256 normaizedAmount = _normalizeUnderlyingTokensToDebt(amount);\n\n    if (totalUnexchanged == 0) {\n      totalBuffered += normaizedAmount;\n      emit Exchange(msg.sender, amount);\n      return;\n    }\n\n    // Push a storage reference to the current tick.\n    Tick.Info storage current = ticks.current();\n\n    ExchangeCache memory cache = ExchangeCache({\n      totalUnexchanged: totalUnexchanged,\n      satisfiedTick: satisfiedTick,\n      ticksHead: ticks.head\n    });\n\n    ExchangeState memory state = ExchangeState({\n      examineTick: cache.ticksHead,\n      totalUnexchanged: cache.totalUnexchanged,\n      satisfiedTick: cache.satisfiedTick,\n      distributeAmount: normaizedAmount,\n      accumulatedWeight: current.accumulatedWeight,\n      maximumWeight: FixedPointMath.encode(0),\n      dustedWeight: FixedPointMath.encode(0)\n    });\n\n    // Distribute the buffered tokens as part of the exchange.\n    state.distributeAmount += totalBuffered;\n    totalBuffered = 0;\n\n    // Push a storage reference to the next tick to write to.\n    Tick.Info storage next = ticks.next();\n\n    // Only iterate through the active ticks queue when it is not empty.\n    while (state.examineTick != 0) {\n      // Check if there is anything left to distribute.\n      if (state.distributeAmount == 0) {\n        break;\n      }\n\n      Tick.Info storage examineTickData = ticks.get(state.examineTick);\n\n      // Add the weight for the distribution step to the accumulated weight.\n      state.accumulatedWeight = state.accumulatedWeight.add(\n        FixedPointMath.rational(state.distributeAmount, state.totalUnexchanged)\n      );\n\n      // Clear the distribute amount.\n      state.distributeAmount = 0;\n\n      // Calculate the current maximum weight in the system.\n      state.maximumWeight = state.accumulatedWeight.sub(examineTickData.accumulatedWeight);\n\n      // Check if there exists at least one account which is completely satisfied..\n      if (state.maximumWeight.n < FixedPointMath.ONE) {\n        break;\n      }\n\n      // Calculate how much weight of the distributed weight is dust.\n      state.dustedWeight = FixedPointMath.Number(state.maximumWeight.n - FixedPointMath.ONE);\n\n      // Calculate how many tokens to distribute in the next step. These are tokens from any tokens which\n      // were over allocated to accounts occupying the tick with the maximum weight.\n      state.distributeAmount = LiquidityMath.calculateProduct(examineTickData.totalBalance, state.dustedWeight);\n\n      // Remove the tokens which were completely exchanged from the total unexchanged balance.\n      state.totalUnexchanged -= examineTickData.totalBalance;\n\n      // Write that all ticks up to and including the examined tick have been satisfied.\n      state.satisfiedTick = state.examineTick;\n\n      // Visit the next active tick. This is equivalent to popping the head of the active ticks queue.\n      state.examineTick = examineTickData.next;\n    }\n\n    // Write the accumulated weight to the next tick.\n    next.accumulatedWeight = state.accumulatedWeight;\n\n    if (cache.totalUnexchanged != state.totalUnexchanged) {\n      totalUnexchanged = state.totalUnexchanged;\n    }\n\n    if (cache.satisfiedTick != state.satisfiedTick) {\n      satisfiedTick = state.satisfiedTick;\n    }\n\n    if (cache.ticksHead != state.examineTick) {\n      ticks.head = state.examineTick;\n    }\n\n    if (state.distributeAmount > 0) {\n      totalBuffered += state.distributeAmount;\n    }\n\n    emit Exchange(msg.sender, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getUnexchangedBalance(address owner) external view override returns (uint256 unexchangedBalance) {\n    Account storage account = accounts[owner];\n\n    if (account.occupiedTick <= satisfiedTick) {\n      return 0;\n    }\n\n    unexchangedBalance = account.unexchangedBalance;\n\n    uint256 exchanged = LiquidityMath.calculateProduct(\n      unexchangedBalance,\n      ticks.getWeight(account.occupiedTick, ticks.position)\n    );\n\n    unexchangedBalance -= exchanged;\n\n    return unexchangedBalance;\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getExchangedBalance(address owner) external view override returns (uint256 exchangedBalance) {\n    return _getExchangedBalance(owner);\n  }\n\n  function getClaimableBalance(address owner) external view override returns (uint256 claimableBalance) {\n    return _normalizeDebtTokensToUnderlying(_getExchangedBalance(owner));\n  }\n\n  /// @dev Updates an account.\n  ///\n  /// @param params The call parameters.\n  function _updateAccount(UpdateAccountParams memory params) internal {\n    Account storage account = accounts[params.owner];\n\n    UpdateAccountCache memory cache = UpdateAccountCache({\n      unexchangedBalance: account.unexchangedBalance,\n      exchangedBalance: account.exchangedBalance,\n      occupiedTick: account.occupiedTick,\n      totalUnexchanged: totalUnexchanged,\n      currentTick: ticks.position\n    });\n\n    UpdateAccountState memory state = UpdateAccountState({\n      unexchangedBalance: cache.unexchangedBalance,\n      exchangedBalance: cache.exchangedBalance,\n      totalUnexchanged: cache.totalUnexchanged\n    });\n\n    // Updating an account is broken down into five steps:\n    // 1). Synchronize the account if it previously occupied a satisfied tick\n    // 2). Update the account balances to account for exchanged tokens, if any\n    // 3). Apply the deltas to the account balances\n    // 4). Update the previously occupied and or current tick's liquidity\n    // 5). Commit changes to the account and global state when needed\n\n    // Step one:\n    // ---------\n    // Check if the tick that the account was occupying previously was satisfied. If it was, we acknowledge\n    // that all of the tokens were exchanged.\n    if (state.unexchangedBalance > 0 && satisfiedTick >= cache.occupiedTick) {\n      state.unexchangedBalance = 0;\n      state.exchangedBalance += cache.unexchangedBalance;\n    }\n\n    // Step Two:\n    // ---------\n    // Calculate how many tokens were exchanged since the last update.\n    if (state.unexchangedBalance > 0) {\n      uint256 exchanged = LiquidityMath.calculateProduct(\n        state.unexchangedBalance,\n        ticks.getWeight(cache.occupiedTick, cache.currentTick)\n      );\n\n      state.totalUnexchanged -= exchanged;\n      state.unexchangedBalance -= exchanged;\n      state.exchangedBalance += exchanged;\n    }\n\n    // Step Three:\n    // -----------\n    // Apply the unexchanged and exchanged deltas to the state.\n    state.totalUnexchanged = LiquidityMath.addDelta(state.totalUnexchanged, params.unexchangedDelta);\n    state.unexchangedBalance = LiquidityMath.addDelta(state.unexchangedBalance, params.unexchangedDelta);\n    state.exchangedBalance = LiquidityMath.addDelta(state.exchangedBalance, params.exchangedDelta);\n\n    // Step Four:\n    // ----------\n    // The following is a truth table relating various values which in combinations specify which logic branches\n    // need to be executed in order to update liquidity in the previously occupied and or current tick.\n    //\n    // Some states are not obtainable and are just discarded by setting all the branches to false.\n    //\n    // | P | C | M | Modify Liquidity | Add Liquidity | Subtract Liquidity |\n    // |---|---|---|------------------|---------------|--------------------|\n    // | F | F | F | F                | F             | F                  |\n    // | F | F | T | F                | F             | F                  |\n    // | F | T | F | F                | T             | F                  |\n    // | F | T | T | F                | T             | F                  |\n    // | T | F | F | F                | F             | T                  |\n    // | T | F | T | F                | F             | T                  |\n    // | T | T | F | T                | F             | F                  |\n    // | T | T | T | F                | T             | T                  |\n    //\n    // | Branch             | Reduction |\n    // |--------------------|-----------|\n    // | Modify Liquidity   | PCM'      |\n    // | Add Liquidity      | P'C + CM  |\n    // | Subtract Liquidity | PC' + PM  |\n\n    bool previouslyActive = cache.unexchangedBalance > 0;\n    bool currentlyActive = state.unexchangedBalance > 0;\n    bool migrate = cache.occupiedTick != cache.currentTick;\n\n    bool modifyLiquidity = previouslyActive && currentlyActive && !migrate;\n\n    if (modifyLiquidity) {\n      Tick.Info storage tick = ticks.get(cache.occupiedTick);\n\n      // Consolidate writes to save gas.\n      uint256 totalBalance = tick.totalBalance;\n      totalBalance -= cache.unexchangedBalance;\n      totalBalance += state.unexchangedBalance;\n      tick.totalBalance = totalBalance;\n    } else {\n      bool addLiquidity = (!previouslyActive && currentlyActive) || (currentlyActive && migrate);\n      bool subLiquidity = (previouslyActive && !currentlyActive) || (previouslyActive && migrate);\n\n      if (addLiquidity) {\n        Tick.Info storage tick = ticks.get(cache.currentTick);\n\n        if (tick.totalBalance == 0) {\n          ticks.addLast(cache.currentTick);\n        }\n\n        tick.totalBalance += state.unexchangedBalance;\n      }\n\n      if (subLiquidity) {\n        Tick.Info storage tick = ticks.get(cache.occupiedTick);\n        tick.totalBalance -= cache.unexchangedBalance;\n\n        if (tick.totalBalance == 0) {\n          ticks.remove(cache.occupiedTick);\n        }\n      }\n    }\n\n    // Step Five:\n    // ----------\n    // Commit the changes to the account.\n    if (cache.unexchangedBalance != state.unexchangedBalance) {\n      account.unexchangedBalance = state.unexchangedBalance;\n    }\n\n    if (cache.exchangedBalance != state.exchangedBalance) {\n      account.exchangedBalance = state.exchangedBalance;\n    }\n\n    if (cache.totalUnexchanged != state.totalUnexchanged) {\n      totalUnexchanged = state.totalUnexchanged;\n    }\n\n    if (cache.occupiedTick != cache.currentTick) {\n      account.occupiedTick = cache.currentTick;\n    }\n  }\n\n  /// @dev Checks the whitelist for msg.sender.\n  ///\n  /// @notice Reverts if msg.sender is not in the whitelist.\n  function _onlyWhitelisted() internal view {\n    // Check if the message sender is an EOA. In the future, this potentially may break. It is important that\n    // functions which rely on the whitelist not be explicitly vulnerable in the situation where this no longer\n    // holds true.\n    if (tx.origin != msg.sender) {\n      // Only check the whitelist for calls from contracts.\n      if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n        revert Unauthorized();\n      }\n    }\n  }\n\n  /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n  ///\n  /// @param amount          The amount of the debt token.\n  ///\n  /// @return The normalized amount.\n  function _normalizeUnderlyingTokensToDebt(uint256 amount) internal view returns (uint256) {\n    return amount * conversionFactor;\n  }\n\n  /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n  ///\n  /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n  ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n  ///      the debt token and the underlying token.\n  ///\n  /// @param amount          The amount of the debt token.\n  ///\n  /// @return The normalized amount.\n  function _normalizeDebtTokensToUnderlying(uint256 amount) internal view returns (uint256) {\n    return amount / conversionFactor;\n  }\n\n  function _getExchangedBalance(address owner) internal view returns (uint256 exchangedBalance) {\n    Account storage account = accounts[owner];\n\n    if (account.occupiedTick <= satisfiedTick) {\n      exchangedBalance = account.exchangedBalance;\n      exchangedBalance += account.unexchangedBalance;\n      return exchangedBalance;\n    }\n\n    exchangedBalance = account.exchangedBalance;\n\n    uint256 exchanged = LiquidityMath.calculateProduct(\n      account.unexchangedBalance,\n      ticks.getWeight(account.occupiedTick, ticks.position)\n    );\n\n    exchangedBalance += exchanged;\n\n    return exchangedBalance;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "TransmuterV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-11",
                "Location": [
                    "for",
                    "while"
                ],
                "Type": "  ++i / i++  should be  unchecked{++i} / unchecked{++i}  when it is not possible for them to overflow, as is the case when used in  for - and  while -loops",
                "Description": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas *PER LOOP*(https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title  AlchemicTokenV1\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version one alchemic tokens.\ncontract AlchemicTokenV1 is AccessControl, ERC20(\"Alchemix USD\", \"alUSD\") {\n  using SafeERC20 for ERC20;\n\n  /// @notice An event which is emitted when a minter is paused or unpaused.\n  ///\n  /// @param minter The address of the minter.\n  /// @param state  A flag indicating if the minter is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n  \n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping (address => bool) public whiteList;\n  \n  /// @notice A set of addresses which are blacklisted from minting new tokens.\n  mapping (address => bool) public blacklist;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping (address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping (address => uint256) public ceiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping (address => uint256) public hasMinted;\n  \n  constructor() {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    require(whiteList[msg.sender], \"AlTokenV1: Alchemist is not whitelisted\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is an admin.\n  modifier onlyAdmin() {\n    require(hasRole(ADMIN_ROLE, msg.sender), \"AlTokenV1: Only admin\");\n    _;\n  }\n\n  /// @dev A modifier which checks that `msg.sender` is a sentinel.\n  modifier onlySentinel() {\n    require(hasRole(SENTINEL_ROLE, msg.sender), \"AlTokenV1: Only sentinel\");\n    _;\n  }\n\n  /// @notice Mints tokens to `recipient`.\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is blacklisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    require(!blacklist[msg.sender], \"AlUSD: Alchemist is blacklisted.\");\n    require(!paused[msg.sender], \"AlUSD: Currently paused.\");\n\n    uint256 total = amount + hasMinted[msg.sender];\n    require(total <= ceiling[msg.sender], \"AlUSD: Alchemist's ceiling was breached.\");\n    hasMinted[msg.sender] = hasMinted[msg.sender] + amount;\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whiteList[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets `minter` as blacklisted from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to blacklist.\n  function setBlacklist(address minter) external onlySentinel {\n    blacklist[minter] = true;\n  }\n\n  /// @notice Pauses an alchemist from minting.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param alchemist The address of the alchemist to set as paused or unpaused.\n  /// @param state     A flag indicating if the alchemist should be paused or unpaused.\n  function pauseAlchemist(address alchemist, bool state) external onlySentinel {\n    paused[alchemist] = state;\n    emit Paused(alchemist, state);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    ceiling[minter] = maximum;\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`\n  ///\n  /// @param amount The amount of tokens to burn.\n  function burn(uint256 amount) public {\n      _burn(msg.sender, amount);\n  }\n\n  /// @notice Burns `amount` tokens from `owner`.\n  ///\n  /// @notice Reverts if the allowance of `msg.sender` is less than `amount`.\n  ///\n  /// @param owner  The address which owns the tokens to burn.\n  /// @param amount The amount of tokens to burn.\n  function burnFrom(address owner, uint256 amount) public {\n      uint256 decreasedAllowance = allowance(owner, msg.sender) - amount;\n      _approve(owner, msg.sender, decreasedAllowance);\n      _burn(owner, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) public onlyWhitelisted {\n      hasMinted[msg.sender] = hasMinted[msg.sender] - amount;\n  }\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\n\n/// @title  ITransmuterBuffer\n/// @author Alchemix Finance\n///\n/// @notice An interface contract to buffer funds between the Alchemist and the Transmuter\ncontract TransmuterBuffer is ITransmuterBuffer, AccessControl, Initializable {\n    using SafeMath for uint256;\n    using FixedPointMath for FixedPointMath.Number;\n\n    /// @notice The identifier of the role which maintains other roles.\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /// @notice The identifier of the keeper role.\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n\n    /// @inheritdoc ITransmuterBuffer\n    string public constant override version = \"2.2.0\";\n\n    /// @notice The alchemist address.\n    address public alchemist;\n\n    /// @notice The public transmuter address for each address.\n    mapping(address => address) public transmuter;\n\n    /// @notice The flowRate for each address.\n    mapping(address => uint256) public flowRate;\n\n    /// @notice The last update timestamp gor the flowRate for each address.\n    mapping(address => uint256) public lastFlowrateUpdate;\n\n    /// @notice The amount of flow available per ERC20.\n    mapping(address => uint256) public flowAvailable;\n\n    /// @notice The yieldTokens of each underlying supported by the Alchemist.\n    mapping(address => address[]) public _yieldTokens;\n\n    /// @notice The total amount of an underlying token that has been exchanged into the transmuter, and has not been claimed.\n    mapping(address => uint256) public currentExchanged;\n\n    /// @notice The underlying-tokens registered in the TransmuterBuffer.\n    address[] public registeredUnderlyings;\n\n    /// @notice The debt-token used by the TransmuterBuffer.\n    address public debtToken;\n\n    /// @notice A mapping of weighting schemas to be used in actions taken on the Alchemist (burn, deposit).\n    mapping(address => Weighting) public weightings;\n\n    /// @dev A mapping of addresses to denote permissioned sources of funds\n    mapping(address => bool) public sources;\n\n    /// @dev A mapping of addresses to their respective AMOs.\n    mapping(address => address) public amos;\n\n    /// @dev A mapping of underlying tokens to divert to the AMO.\n    mapping(address => bool) public divertToAmo;\n\n    constructor() initializer {}\n\n    /// @dev Initialize the contract\n    ///\n    /// @param _admin     The governing address of the buffer.\n    /// @param _debtToken The debt token minted by the Alchemist and accepted by the Transmuter.\n    function initialize(address _admin, address _debtToken) external initializer {\n        _setupRole(ADMIN, _admin);\n        _setRoleAdmin(ADMIN, ADMIN);\n        _setRoleAdmin(KEEPER, ADMIN);\n        debtToken = _debtToken;\n    }\n\n    /// @dev Only allows the transmuter to call the modified function\n    ///\n    /// Reverts if the caller is not a correct transmuter.\n    ///\n    /// @param underlyingToken the underlying token associated with the transmuter.\n    modifier onlyTransmuter(address underlyingToken) {\n        if (msg.sender != transmuter[underlyingToken]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only allows a governance-permissioned source to call the modified function\n    ///\n    /// Reverts if the caller is not a permissioned source.\n    modifier onlySource() {\n        if (!sources[msg.sender]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from the admin address are authorized to pass.\n    modifier onlyAdmin() {\n        if (!hasRole(ADMIN, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from a keeper address are authorized to pass.\n    modifier onlyKeeper() {\n        if (!hasRole(KEEPER, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getWeight(address weightToken, address token)\n        external\n        view\n        override\n        returns (uint256 weight)\n    {\n        return weightings[weightToken].weights[token];\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getAvailableFlow(address underlyingToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // total amount of collateral that the buffer controls in the alchemist\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(\n            underlyingToken\n        );\n\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            return totalUnderlyingBuffered;\n        } else {\n            return flowAvailable[underlyingToken];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalCredit() public view override returns (uint256 credit) {\n        (int256 debt, ) = IAlchemistV2(alchemist).accounts(address(this));\n        credit = debt >= 0 ? 0 : SafeCast.toUint256(-debt);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalUnderlyingBuffered(address underlyingToken)\n        public\n        view\n        override\n        returns (uint256 totalBuffered)\n    {\n        totalBuffered = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        for (uint256 i = 0; i < _yieldTokens[underlyingToken].length; i++) {\n            totalBuffered += _getTotalBuffered(_yieldTokens[underlyingToken][i]);\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setWeights(\n        address weightToken,\n        address[] memory tokens,\n        uint256[] memory weights\n    ) external override onlyAdmin {\n        Weighting storage weighting = weightings[weightToken];\n        delete weighting.tokens;\n        weighting.totalWeight = 0;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address yieldToken = tokens[i];\n\n            // For any weightToken that is not the debtToken, we want to verify that the yield-tokens being\n            // set for the weight schema accept said weightToken as collateral.\n            //\n            // We don't want to do this check on the debtToken because it is only used in the burnCredit() function\n            // and we want to be able to burn credit to any yield-token in the Alchemist.\n            if (weightToken != debtToken) {\n                IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                    .getYieldTokenParameters(yieldToken);\n                address underlyingToken = ITokenAdapter(params.adapter)\n                    .underlyingToken();\n\n                if (weightToken != underlyingToken) {\n                    revert IllegalState();\n                }\n            }\n\n            weighting.tokens.push(yieldToken);\n            weighting.weights[yieldToken] = weights[i];\n            weighting.totalWeight += weights[i];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setSource(address source, bool flag) external override onlyAdmin {\n        if (sources[source] == flag) {\n            revert IllegalArgument();\n        }\n        sources[source] = flag;\n        emit SetSource(source, flag);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setTransmuter(address underlyingToken, address newTransmuter) external override onlyAdmin {\n        if (ITransmuterV2(newTransmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n        transmuter[underlyingToken] = newTransmuter;\n        emit SetTransmuter(underlyingToken, newTransmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n\n        if (alchemist != address(0)) {\n            for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n                TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, 0);\n            }\n            TokenUtils.safeApprove(debtToken, alchemist, 0);\n        }\n\n        alchemist = _alchemist;\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, type(uint256).max);\n        }\n        TokenUtils.safeApprove(debtToken, alchemist, type(uint256).max);\n\n        emit SetAlchemist(alchemist);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAmo(address underlyingToken, address amo) external override onlyAdmin {\n        amos[underlyingToken] = amo;\n        emit SetAmo(underlyingToken, amo);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setDivertToAmo(address underlyingToken, bool divert) external override onlyAdmin {\n        divertToAmo[underlyingToken] = divert;\n        emit SetDivertToAmo(underlyingToken, divert);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function registerAsset(\n        address underlyingToken,\n        address _transmuter\n    ) external override onlyAdmin {\n        if (!IAlchemistV2(alchemist).isSupportedUnderlyingToken(underlyingToken)) {\n            revert IllegalState();\n        }\n\n        // only add to the array if not already contained in it\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            if (registeredUnderlyings[i] == underlyingToken) {\n                revert IllegalState();\n            }\n        }\n\n        if (ITransmuterV2(_transmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n\n        transmuter[underlyingToken] = _transmuter;\n        registeredUnderlyings.push(underlyingToken);\n        TokenUtils.safeApprove(underlyingToken, alchemist, type(uint256).max);\n        emit RegisterAsset(underlyingToken, _transmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setFlowRate(address underlyingToken, uint256 _flowRate)\n        external\n        override\n        onlyAdmin\n    {\n        _exchange(underlyingToken);\n\n        flowRate[underlyingToken] = _flowRate;\n        emit SetFlowRate(underlyingToken, _flowRate);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    function onERC20Received(address underlyingToken, uint256 amount)\n        external\n        override\n        onlySource\n    {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            _updateFlow(underlyingToken);\n\n            // total amount of collateral that the buffer controls in the alchemist\n            uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n\n            // if there is not enough locally buffered collateral to meet the flow rate, exchange only the exchanged amount\n            if (localBalance < flowAvailable[underlyingToken]) {\n                currentExchanged[underlyingToken] += amount;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(amount);\n            } else {\n                uint256 exchangeable = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n                currentExchanged[underlyingToken] += exchangeable;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeable);\n            }\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function exchange(address underlyingToken) external override onlyKeeper {\n        _exchange(underlyingToken);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function flushToAmo(address underlyingToken, uint256 amount) external override onlyKeeper {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            revert IllegalState();\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdraw(\n        address underlyingToken,\n        uint256 amount,\n        address recipient\n    ) external override onlyTransmuter(underlyingToken) {\n        if (amount > flowAvailable[underlyingToken]) {\n            revert IllegalArgument();\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (amount > localBalance) {\n            revert IllegalArgument();\n        }\n\n        flowAvailable[underlyingToken] -= amount;\n        currentExchanged[underlyingToken] -= amount;\n\n        TokenUtils.safeTransfer(underlyingToken, recipient, amount);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdrawFromAlchemist(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override onlyKeeper {\n        IAlchemistV2(alchemist).withdrawUnderlying(yieldToken, shares, address(this), minimumAmountOut);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function refreshStrategies() public override {\n        address[] memory supportedYieldTokens = IAlchemistV2(alchemist)\n            .getSupportedYieldTokens();\n        address[] memory supportedUnderlyingTokens = IAlchemistV2(alchemist)\n            .getSupportedUnderlyingTokens();\n\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n\n        // clear current strats\n        for (uint256 j = 0; j < registeredUnderlyings.length; j++) {\n            delete _yieldTokens[registeredUnderlyings[j]];\n        }\n\n        uint256 numYTokens = supportedYieldTokens.length;\n        for (uint256 i = 0; i < numYTokens; i++) {\n            address yieldToken = supportedYieldTokens[i];\n\n            IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                .getYieldTokenParameters(yieldToken);\n            if (params.enabled) {\n                _yieldTokens[params.underlyingToken].push(yieldToken);\n            }\n        }\n        emit RefreshStrategies();\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function burnCredit() external override onlyKeeper {\n        IAlchemistV2(alchemist).poke(address(this));\n        uint256 credit = getTotalCredit();\n        if (credit == 0) {\n            revert IllegalState();\n        }\n        IAlchemistV2(alchemist).mint(credit, address(this));\n\n        _alchemistAction(credit, debtToken, _alchemistDonate);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function depositFunds(address underlyingToken, uint256 amount)\n        external\n        override\n        onlyKeeper\n    {\n        if (amount == 0) {\n            revert IllegalArgument();\n        }\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (localBalance < amount) {\n            revert IllegalArgument();\n        }\n        _updateFlow(underlyingToken);\n        \n        // Don't deposit exchanged funds into the Alchemist.\n        // Doing so puts those funds at risk, and could lead to users being unable to claim\n        // their transmuted funds in the event of a vault loss.\n        if (localBalance - amount < currentExchanged[underlyingToken]) {\n            revert IllegalState();\n        }\n        _alchemistAction(amount, underlyingToken, _alchemistDeposit);\n    }\n\n    /// @dev Gets the total value of the yield tokens in units of underlying tokens that this contract holds.\n    ///\n    /// @param yieldToken The address of the target yield token.\n    function _getTotalBuffered(address yieldToken)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 balance, ) = IAlchemistV2(alchemist).positions(address(this), yieldToken);\n        IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n            .getYieldTokenParameters(yieldToken);\n        uint256 tokensPerShare = IAlchemistV2(alchemist)\n            .getUnderlyingTokensPerShare(yieldToken);\n        return (balance * tokensPerShare) / 10**params.decimals;\n    }\n\n    /// @dev Updates the available flow for a give underlying token\n    ///\n    /// @param underlyingToken the underlying token whos flow is being updated\n    function _updateFlow(address underlyingToken) internal returns (uint256) {\n        // additional flow to be allocated based on flow rate\n        uint256 marginalFlow = (block.timestamp -\n            lastFlowrateUpdate[underlyingToken]) * flowRate[underlyingToken];\n        flowAvailable[underlyingToken] += marginalFlow;\n        lastFlowrateUpdate[underlyingToken] = block.timestamp;\n        return marginalFlow;\n    }\n\n    /// @notice Runs an action on the Alchemist according to a given weighting schema.\n    ///\n    /// This function gets a weighting schema defined under the `weightToken` key, and calls the target action\n    /// with a weighted value of `amount` and the associated token.\n    ///\n    /// @param amount       The amount of funds to use in the action.\n    /// @param weightToken  The key of the weighting schema to be used for the action.\n    /// @param action       The action to be taken.\n    function _alchemistAction(\n        uint256 amount,\n        address weightToken,\n        function(address, uint256) action\n    ) internal {\n        IAlchemistV2(alchemist).poke(address(this));\n\n        Weighting storage weighting = weightings[weightToken];\n        for (uint256 j = 0; j < weighting.tokens.length; j++) {\n            address token = weighting.tokens[j];\n            uint256 actionAmt = (amount * weighting.weights[token]) / weighting.totalWeight;\n            action(token, actionAmt);\n        }\n    }\n\n    /// @notice Donate credit weight to a target yield-token by burning debt-tokens.\n    ///\n    /// @param token    The target yield-token.\n    /// @param amount      The amount of debt-tokens to burn.\n    function _alchemistDonate(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).donate(token, amount);\n    }\n\n    /// @notice Deposits funds into the Alchemist.\n    ///\n    /// @param token  The yield-token to deposit.\n    /// @param amount The amount to deposit.\n    function _alchemistDeposit(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).depositUnderlying(\n            token,\n            amount,\n            address(this),\n            0\n        );\n    }\n\n    /// @notice Withdraws funds from the Alchemist.\n    ///\n    /// @param token            The yield-token to withdraw.\n    /// @param amountUnderlying The amount of underlying to withdraw.\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10**decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares > availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying - amountUnderlying * 100 / 10000;\n        if (wantShares > 0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) >= currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered - initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered > flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] - initialLocalBalance;\n        }\n\n        if (want > 0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 exchangeDelta = 0;\n        if (localBalance > flowAvailable[underlyingToken]) {\n            exchangeDelta = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n        } else {\n            exchangeDelta = localBalance - currentExchanged[underlyingToken];\n        }\n\n        if (exchangeDelta > 0) {\n            currentExchanged[underlyingToken] += exchangeDelta;\n            ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeDelta);\n        }\n    }\n\n    /// @notice Flush funds to the amo.\n    ///\n    /// @param underlyingToken The underlyingToken to flush.\n    /// @param amount          The amount to flush.\n    function _flushToAmo(address underlyingToken, uint256 amount) internal {\n        TokenUtils.safeTransfer(underlyingToken, amos[underlyingToken], amount);\n        IERC20TokenReceiver(amos[underlyingToken]).onERC20Received(underlyingToken, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV1.sol",
            "TransmuterBuffer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-17",
                "Location": [
                    "revert()/require()",
                    "SafeMath"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.0 to get overflow protection without SafeMath\nUse a solidity version of at least 0.8.2 to get compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\ncontract AlchemicTokenV2 is AccessControl, ReentrancyGuard, ERC20, IERC3156FlashLender {\n\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  constructor(string memory _name, string memory _symbol, uint256 _flashFee) ERC20(_name, _symbol) {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n    flashMintFee = _flashFee;\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2Base.sol",
            "AlchemicTokenV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-21",
                "Location": [
                    "override",
                    "internal"
                ],
                "Type": "  internal  functions not called by the contract should be removed to save deployment gas",
                "Description": "\nIf the functions are required by an interface, the contract should inherit from that interface and use the override keyword\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\n\n/// @title  ITransmuterBuffer\n/// @author Alchemix Finance\n///\n/// @notice An interface contract to buffer funds between the Alchemist and the Transmuter\ncontract TransmuterBuffer is ITransmuterBuffer, AccessControl, Initializable {\n    using SafeMath for uint256;\n    using FixedPointMath for FixedPointMath.Number;\n\n    /// @notice The identifier of the role which maintains other roles.\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /// @notice The identifier of the keeper role.\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n\n    /// @inheritdoc ITransmuterBuffer\n    string public constant override version = \"2.2.0\";\n\n    /// @notice The alchemist address.\n    address public alchemist;\n\n    /// @notice The public transmuter address for each address.\n    mapping(address => address) public transmuter;\n\n    /// @notice The flowRate for each address.\n    mapping(address => uint256) public flowRate;\n\n    /// @notice The last update timestamp gor the flowRate for each address.\n    mapping(address => uint256) public lastFlowrateUpdate;\n\n    /// @notice The amount of flow available per ERC20.\n    mapping(address => uint256) public flowAvailable;\n\n    /// @notice The yieldTokens of each underlying supported by the Alchemist.\n    mapping(address => address[]) public _yieldTokens;\n\n    /// @notice The total amount of an underlying token that has been exchanged into the transmuter, and has not been claimed.\n    mapping(address => uint256) public currentExchanged;\n\n    /// @notice The underlying-tokens registered in the TransmuterBuffer.\n    address[] public registeredUnderlyings;\n\n    /// @notice The debt-token used by the TransmuterBuffer.\n    address public debtToken;\n\n    /// @notice A mapping of weighting schemas to be used in actions taken on the Alchemist (burn, deposit).\n    mapping(address => Weighting) public weightings;\n\n    /// @dev A mapping of addresses to denote permissioned sources of funds\n    mapping(address => bool) public sources;\n\n    /// @dev A mapping of addresses to their respective AMOs.\n    mapping(address => address) public amos;\n\n    /// @dev A mapping of underlying tokens to divert to the AMO.\n    mapping(address => bool) public divertToAmo;\n\n    constructor() initializer {}\n\n    /// @dev Initialize the contract\n    ///\n    /// @param _admin     The governing address of the buffer.\n    /// @param _debtToken The debt token minted by the Alchemist and accepted by the Transmuter.\n    function initialize(address _admin, address _debtToken) external initializer {\n        _setupRole(ADMIN, _admin);\n        _setRoleAdmin(ADMIN, ADMIN);\n        _setRoleAdmin(KEEPER, ADMIN);\n        debtToken = _debtToken;\n    }\n\n    /// @dev Only allows the transmuter to call the modified function\n    ///\n    /// Reverts if the caller is not a correct transmuter.\n    ///\n    /// @param underlyingToken the underlying token associated with the transmuter.\n    modifier onlyTransmuter(address underlyingToken) {\n        if (msg.sender != transmuter[underlyingToken]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only allows a governance-permissioned source to call the modified function\n    ///\n    /// Reverts if the caller is not a permissioned source.\n    modifier onlySource() {\n        if (!sources[msg.sender]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from the admin address are authorized to pass.\n    modifier onlyAdmin() {\n        if (!hasRole(ADMIN, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from a keeper address are authorized to pass.\n    modifier onlyKeeper() {\n        if (!hasRole(KEEPER, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getWeight(address weightToken, address token)\n        external\n        view\n        override\n        returns (uint256 weight)\n    {\n        return weightings[weightToken].weights[token];\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getAvailableFlow(address underlyingToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // total amount of collateral that the buffer controls in the alchemist\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(\n            underlyingToken\n        );\n\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            return totalUnderlyingBuffered;\n        } else {\n            return flowAvailable[underlyingToken];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalCredit() public view override returns (uint256 credit) {\n        (int256 debt, ) = IAlchemistV2(alchemist).accounts(address(this));\n        credit = debt >= 0 ? 0 : SafeCast.toUint256(-debt);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalUnderlyingBuffered(address underlyingToken)\n        public\n        view\n        override\n        returns (uint256 totalBuffered)\n    {\n        totalBuffered = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        for (uint256 i = 0; i < _yieldTokens[underlyingToken].length; i++) {\n            totalBuffered += _getTotalBuffered(_yieldTokens[underlyingToken][i]);\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setWeights(\n        address weightToken,\n        address[] memory tokens,\n        uint256[] memory weights\n    ) external override onlyAdmin {\n        Weighting storage weighting = weightings[weightToken];\n        delete weighting.tokens;\n        weighting.totalWeight = 0;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address yieldToken = tokens[i];\n\n            // For any weightToken that is not the debtToken, we want to verify that the yield-tokens being\n            // set for the weight schema accept said weightToken as collateral.\n            //\n            // We don't want to do this check on the debtToken because it is only used in the burnCredit() function\n            // and we want to be able to burn credit to any yield-token in the Alchemist.\n            if (weightToken != debtToken) {\n                IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                    .getYieldTokenParameters(yieldToken);\n                address underlyingToken = ITokenAdapter(params.adapter)\n                    .underlyingToken();\n\n                if (weightToken != underlyingToken) {\n                    revert IllegalState();\n                }\n            }\n\n            weighting.tokens.push(yieldToken);\n            weighting.weights[yieldToken] = weights[i];\n            weighting.totalWeight += weights[i];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setSource(address source, bool flag) external override onlyAdmin {\n        if (sources[source] == flag) {\n            revert IllegalArgument();\n        }\n        sources[source] = flag;\n        emit SetSource(source, flag);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setTransmuter(address underlyingToken, address newTransmuter) external override onlyAdmin {\n        if (ITransmuterV2(newTransmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n        transmuter[underlyingToken] = newTransmuter;\n        emit SetTransmuter(underlyingToken, newTransmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n\n        if (alchemist != address(0)) {\n            for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n                TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, 0);\n            }\n            TokenUtils.safeApprove(debtToken, alchemist, 0);\n        }\n\n        alchemist = _alchemist;\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, type(uint256).max);\n        }\n        TokenUtils.safeApprove(debtToken, alchemist, type(uint256).max);\n\n        emit SetAlchemist(alchemist);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAmo(address underlyingToken, address amo) external override onlyAdmin {\n        amos[underlyingToken] = amo;\n        emit SetAmo(underlyingToken, amo);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setDivertToAmo(address underlyingToken, bool divert) external override onlyAdmin {\n        divertToAmo[underlyingToken] = divert;\n        emit SetDivertToAmo(underlyingToken, divert);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function registerAsset(\n        address underlyingToken,\n        address _transmuter\n    ) external override onlyAdmin {\n        if (!IAlchemistV2(alchemist).isSupportedUnderlyingToken(underlyingToken)) {\n            revert IllegalState();\n        }\n\n        // only add to the array if not already contained in it\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            if (registeredUnderlyings[i] == underlyingToken) {\n                revert IllegalState();\n            }\n        }\n\n        if (ITransmuterV2(_transmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n\n        transmuter[underlyingToken] = _transmuter;\n        registeredUnderlyings.push(underlyingToken);\n        TokenUtils.safeApprove(underlyingToken, alchemist, type(uint256).max);\n        emit RegisterAsset(underlyingToken, _transmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setFlowRate(address underlyingToken, uint256 _flowRate)\n        external\n        override\n        onlyAdmin\n    {\n        _exchange(underlyingToken);\n\n        flowRate[underlyingToken] = _flowRate;\n        emit SetFlowRate(underlyingToken, _flowRate);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    function onERC20Received(address underlyingToken, uint256 amount)\n        external\n        override\n        onlySource\n    {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            _updateFlow(underlyingToken);\n\n            // total amount of collateral that the buffer controls in the alchemist\n            uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n\n            // if there is not enough locally buffered collateral to meet the flow rate, exchange only the exchanged amount\n            if (localBalance < flowAvailable[underlyingToken]) {\n                currentExchanged[underlyingToken] += amount;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(amount);\n            } else {\n                uint256 exchangeable = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n                currentExchanged[underlyingToken] += exchangeable;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeable);\n            }\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function exchange(address underlyingToken) external override onlyKeeper {\n        _exchange(underlyingToken);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function flushToAmo(address underlyingToken, uint256 amount) external override onlyKeeper {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            revert IllegalState();\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdraw(\n        address underlyingToken,\n        uint256 amount,\n        address recipient\n    ) external override onlyTransmuter(underlyingToken) {\n        if (amount > flowAvailable[underlyingToken]) {\n            revert IllegalArgument();\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (amount > localBalance) {\n            revert IllegalArgument();\n        }\n\n        flowAvailable[underlyingToken] -= amount;\n        currentExchanged[underlyingToken] -= amount;\n\n        TokenUtils.safeTransfer(underlyingToken, recipient, amount);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdrawFromAlchemist(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override onlyKeeper {\n        IAlchemistV2(alchemist).withdrawUnderlying(yieldToken, shares, address(this), minimumAmountOut);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function refreshStrategies() public override {\n        address[] memory supportedYieldTokens = IAlchemistV2(alchemist)\n            .getSupportedYieldTokens();\n        address[] memory supportedUnderlyingTokens = IAlchemistV2(alchemist)\n            .getSupportedUnderlyingTokens();\n\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n\n        // clear current strats\n        for (uint256 j = 0; j < registeredUnderlyings.length; j++) {\n            delete _yieldTokens[registeredUnderlyings[j]];\n        }\n\n        uint256 numYTokens = supportedYieldTokens.length;\n        for (uint256 i = 0; i < numYTokens; i++) {\n            address yieldToken = supportedYieldTokens[i];\n\n            IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                .getYieldTokenParameters(yieldToken);\n            if (params.enabled) {\n                _yieldTokens[params.underlyingToken].push(yieldToken);\n            }\n        }\n        emit RefreshStrategies();\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function burnCredit() external override onlyKeeper {\n        IAlchemistV2(alchemist).poke(address(this));\n        uint256 credit = getTotalCredit();\n        if (credit == 0) {\n            revert IllegalState();\n        }\n        IAlchemistV2(alchemist).mint(credit, address(this));\n\n        _alchemistAction(credit, debtToken, _alchemistDonate);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function depositFunds(address underlyingToken, uint256 amount)\n        external\n        override\n        onlyKeeper\n    {\n        if (amount == 0) {\n            revert IllegalArgument();\n        }\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (localBalance < amount) {\n            revert IllegalArgument();\n        }\n        _updateFlow(underlyingToken);\n        \n        // Don't deposit exchanged funds into the Alchemist.\n        // Doing so puts those funds at risk, and could lead to users being unable to claim\n        // their transmuted funds in the event of a vault loss.\n        if (localBalance - amount < currentExchanged[underlyingToken]) {\n            revert IllegalState();\n        }\n        _alchemistAction(amount, underlyingToken, _alchemistDeposit);\n    }\n\n    /// @dev Gets the total value of the yield tokens in units of underlying tokens that this contract holds.\n    ///\n    /// @param yieldToken The address of the target yield token.\n    function _getTotalBuffered(address yieldToken)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 balance, ) = IAlchemistV2(alchemist).positions(address(this), yieldToken);\n        IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n            .getYieldTokenParameters(yieldToken);\n        uint256 tokensPerShare = IAlchemistV2(alchemist)\n            .getUnderlyingTokensPerShare(yieldToken);\n        return (balance * tokensPerShare) / 10**params.decimals;\n    }\n\n    /// @dev Updates the available flow for a give underlying token\n    ///\n    /// @param underlyingToken the underlying token whos flow is being updated\n    function _updateFlow(address underlyingToken) internal returns (uint256) {\n        // additional flow to be allocated based on flow rate\n        uint256 marginalFlow = (block.timestamp -\n            lastFlowrateUpdate[underlyingToken]) * flowRate[underlyingToken];\n        flowAvailable[underlyingToken] += marginalFlow;\n        lastFlowrateUpdate[underlyingToken] = block.timestamp;\n        return marginalFlow;\n    }\n\n    /// @notice Runs an action on the Alchemist according to a given weighting schema.\n    ///\n    /// This function gets a weighting schema defined under the `weightToken` key, and calls the target action\n    /// with a weighted value of `amount` and the associated token.\n    ///\n    /// @param amount       The amount of funds to use in the action.\n    /// @param weightToken  The key of the weighting schema to be used for the action.\n    /// @param action       The action to be taken.\n    function _alchemistAction(\n        uint256 amount,\n        address weightToken,\n        function(address, uint256) action\n    ) internal {\n        IAlchemistV2(alchemist).poke(address(this));\n\n        Weighting storage weighting = weightings[weightToken];\n        for (uint256 j = 0; j < weighting.tokens.length; j++) {\n            address token = weighting.tokens[j];\n            uint256 actionAmt = (amount * weighting.weights[token]) / weighting.totalWeight;\n            action(token, actionAmt);\n        }\n    }\n\n    /// @notice Donate credit weight to a target yield-token by burning debt-tokens.\n    ///\n    /// @param token    The target yield-token.\n    /// @param amount      The amount of debt-tokens to burn.\n    function _alchemistDonate(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).donate(token, amount);\n    }\n\n    /// @notice Deposits funds into the Alchemist.\n    ///\n    /// @param token  The yield-token to deposit.\n    /// @param amount The amount to deposit.\n    function _alchemistDeposit(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).depositUnderlying(\n            token,\n            amount,\n            address(this),\n            0\n        );\n    }\n\n    /// @notice Withdraws funds from the Alchemist.\n    ///\n    /// @param token            The yield-token to withdraw.\n    /// @param amountUnderlying The amount of underlying to withdraw.\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10**decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares > availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying - amountUnderlying * 100 / 10000;\n        if (wantShares > 0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) >= currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered - initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered > flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] - initialLocalBalance;\n        }\n\n        if (want > 0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 exchangeDelta = 0;\n        if (localBalance > flowAvailable[underlyingToken]) {\n            exchangeDelta = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n        } else {\n            exchangeDelta = localBalance - currentExchanged[underlyingToken];\n        }\n\n        if (exchangeDelta > 0) {\n            currentExchanged[underlyingToken] += exchangeDelta;\n            ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeDelta);\n        }\n    }\n\n    /// @notice Flush funds to the amo.\n    ///\n    /// @param underlyingToken The underlyingToken to flush.\n    /// @param amount          The amount to flush.\n    function _flushToAmo(address underlyingToken, uint256 amount) internal {\n        TokenUtils.safeTransfer(underlyingToken, amos[underlyingToken], amount);\n        IERC20TokenReceiver(amos[underlyingToken]).onERC20Received(underlyingToken, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TransmuterBuffer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-27",
                "Location": [
                    "//solidity\nFile: contracts-full/TransmuterBuffer.sol   #1\n\n7   import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n"
                ],
                "Type": " Don't use  SafeMath  once the solidity version is 0.8.0 or greater",
                "Description": "\nVersion 0.8.0 introduces internal overflow checks, so using SafeMath is redundant and adds overhead\n\nsolidity\nFile: contracts-full/TransmuterBuffer.sol   #1\n\n7   import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/TransmuterBuffer.sol#L7\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\ninterface IAaveLendingPool {\n\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);\n\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n}\n\n",
        "CodeNames": [
            "IAaveLendingPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-29",
                "Location": [
                    "//solidity\nFile: contracts-full/ThreePoolAssetManager.sol   #1\n\n355               if ((examineBalance = (v.maximum + v.minimum) / 2) == previousBalance) break;\n"
                ],
                "Type": " Multiplication/division by two should use bit shifting",
                "Description": "\n<x * 2 is equivalent to <x << 1 and <x / 2 is the same as <x  1. The MUL and DIV opcodes cost 5 gas, whereas SHL and SHR only cost 3 gas\n\nsolidity\nFile: contracts-full/ThreePoolAssetManager.sol   #1\n\n355               if ((examineBalance = (v.maximum + v.minimum) / 2) == previousBalance) break;\n\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/ThreePoolAssetManager.sol#L355\n\n\n",
                "Repair": ""
            }
        ]
    }
]