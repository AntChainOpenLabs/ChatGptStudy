[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport '@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\ncontract UnlockProtocolGovernor is Initializable,\n  GovernorUpgradeable,\n  GovernorCountingSimpleUpgradeable,\n  GovernorVotesUpgradeable,\n  GovernorTimelockControlUpgradeable\n  {\n\n  uint256 _votingDelay;\n  uint256 _votingPeriod;\n  uint256 _quorum;\n\n  function initialize(ERC20VotesUpgradeable _token, TimelockControllerUpgradeable _timelock)\n    public initializer\n  {\n    __Governor_init('Unlock Protocol Governor');\n    __GovernorCountingSimple_init();\n    __GovernorVotes_init(_token);\n    __GovernorTimelockControl_init(_timelock);\n\n    _votingDelay = 1; // 1 block\n    _votingPeriod = 45818; // 1 week\n    _quorum = 15000e18; // 15k UDT\n  }\n\n  /*\n  * Events to track params changes\n  */\n  event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);\n  event VotingDelayUpdated(uint256 oldVotingDelay, uint256 newVotingDelay);\n  event VotingPeriodUpdated(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n  function votingDelay() public view override returns (uint256) {\n    return _votingDelay;\n  }\n\n  function votingPeriod() public view override returns (uint256) {\n    return _votingPeriod;\n  }\n\n  function quorum(uint256 blockNumber) public view override returns (uint256) {\n    require(blockNumber < block.number, 'ERC20Votes: block not yet mined');\n    return _quorum;\n  }\n\n  // governance setters\n  function setVotingDelay(uint256 newVotingDelay) public onlyGovernance {\n    uint256 oldVotingDelay = _votingDelay;\n    _votingDelay = newVotingDelay;\n    emit VotingDelayUpdated(oldVotingDelay, newVotingDelay);\n  }\n\n  function setVotingPeriod(uint256 newVotingPeriod) public onlyGovernance {\n    uint256 oldVotingPeriod = _votingPeriod;\n    _votingPeriod = newVotingPeriod;\n    emit VotingPeriodUpdated(oldVotingPeriod, newVotingPeriod);\n  }\n\n  function setQuorum(uint256 newQuorum) public onlyGovernance {\n    uint256 oldQuorum = _quorum;\n    _quorum = newQuorum;\n    emit QuorumUpdated(oldQuorum, newQuorum);\n  }\n\n  // The following functions are overrides required by Solidity.\n  function getVotes(address account, uint256 blockNumber)\n    public\n    view\n    override(IGovernorUpgradeable, GovernorVotesUpgradeable)\n    returns (uint256)\n  {\n    return super.getVotes(account, blockNumber);\n  }\n\n  function state(uint256 proposalId)\n    public\n    view\n    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    returns (ProposalState)\n  {\n    return super.state(proposalId);\n  }\n\n  function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)\n    public\n    override(GovernorUpgradeable, IGovernorUpgradeable)\n    returns (uint256)\n  {\n    return super.propose(targets, values, calldatas, description);\n  }\n\n  function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    internal\n    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n  {\n    super._execute(proposalId, targets, values, calldatas, descriptionHash);\n  }\n\n  function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    internal\n    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    returns (uint256)\n  {\n    return super._cancel(targets, values, calldatas, descriptionHash);\n  }\n\n  function _executor()\n    internal\n    view\n    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    returns (address)\n  {\n    return super._executor();\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n",
        "CodeNames": [
            "UnlockProtocolGovernor.sol",
            "Unlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "UnlockProtocol",
                    "tokensToDistribute"
                ],
                "Type": " MEV miner can mint larger than expected UDT total supply",
                "Description": "\nUnlockProtocol attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made;\n\n        uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;\n\nwe can see that arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n\n",
                "Repair": "\nUsing an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.\n\njulien51 (Unlock Protocol) disputed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-991699670):\n   we can see that arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n \n As you noted it would be capped by the actual increase of the GDP transaction.\n \n However we could indeed use an oracle to determine the average gas price over a certain number of blocks to limit the risk even further. \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009512489):\n  I think the warden has raised a valid issue of value extractions. Whether the value extracted is capped at a certain number of tokens, I don't think the issue is nullified as a result. Miners can realistically fill up blockspace by abusing this behaviour and then selling netted tokens on the open market. I'll consider marking this as medium, what do you think @julien51 ?\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009577434):\n  I think maxTokens will be set to IMintableERC20(udt).totalSupply() / 2 upon the first call to recordKeyPurchase(). If I'm not mistaken, this could allow a malicious miner could effectively distribute half of the token supply in one tx.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1013810733):\n  After further offline discussions with @julien51. We agree that this is an issue that needs to be addressed.\n \n If we consider real-world values for IMintableERC20(udt).totalSupply() and IMintableERC20(udt).totalSupply() as 1_000_000e18 and 400e18 respectively. Then a miner could mint up to ~1247 UDT tokens valued at $USD 124,688 if they provide a single Ether as their purchase amount. Obviously this can be abused to generate a huge amount of profit for miners, so as this is a viable way to extract value from the protocol, I will be keeping this as high severity.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n",
        "CodeNames": [
            "PublicLock.sol",
            "Unlock.sol",
            "IPublicLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "purchase()",
                    "shareKey()",
                    "shareKey",
                    "freeTrial",
                    "keyPrice",
                    "expirationDuration",
                    "cancelAndRefund()",
                    "freeTrialLength"
                ],
                "Type": " Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol",
                "Description": "\nThe current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of their time to another user using shareKey.\n\nThis makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to expirationDuration and call refund to steal from the protocol.\n\n\nGiven:\n\n*   keyPrice is 1 ETH;\n*   expirationDuration is 360 days;\n*   freeTrialLength is 31 days.\n\nThe attacker can create two wallet addresses: Alice and Bob.\n\n1.  Alice calls purchase(), transfer 30 days via shareKey() to Bob, then calls cancelAndRefund() to get full refund; Repeat 12 times;\n2.  Bob calls cancelAndRefund() and get 1 ETH.\n\n",
                "Repair": "\nConsider disabling cancelAndRefund() for users who transferred time to another user.\n\njulien51 (Unlock Protocol) confirmed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-979656014):\n  I think this is valid! The free trial approach is indeed a risk on that front and we need to \"warn\" lock managers about this more.\n \n  For lock manager who still want to offer free trials, the best approach would probably be to set a high transfer fee to make sure that free trials cannot be transfered.\n \n  As a consequence of this, I am not sure this is as critical as indicated by the submitter.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1013831268):\n  Nice find!\n \n From what I can tell at least, this does seem like a viable attack vector. Can I ask why this should not be treated as high risk? @julien51 \n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1068786053):\n  Sorry for the long delay here.\n  In short: this is valid, but only an issue for locks which are enabling free trials (no one has done it) and we would make sure our UI shows this as a potential issue.\n  In other words: a lock manager would need to _explicitly_ enable free trials, despite our warning to put their own funds at risk. For that reason I don't think this is \"High\".\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1075667239):\n  While this is a valid issue pertaining only to lock managers who _explicitly_ enable free trials, this may still lead to a loss of funds if cancelAndRefund is called by a user who has transferred their time to another account. I still believe this deserves a high severity rating.\n \n  In my honest opinion, a warning isn't sufficient to prevent such abuse. I think on-chain enforcement ideal in this situation.\n\n\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "purchase()",
                    "freeTrial",
                    "keyPrice",
                    "freeTrialLength",
                    "cancelAndRefund()"
                ],
                "Type": " Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends",
                "Description": "\nThe current design/implementation allows users who are refunded before to get another freeTrial. This can be exploited by malicious users to get an infinite free trial.\n\n\nGiven:\n\n*   keyPrice is 1 ETH;\n*   freeTrialLength is 31 days.\n\nA malicious user can:\n\n1.  Call purchase(), pay 1 ETH and get 31 days of freeTrial on day 1;\n2.  Call cancelAndRefund() on day 30 and get 1 ETH of refund; then call purchase() again, pay 1 ETH and get 31 days of freeTrial again.\n\nRepeat the steps above and the user can get infinite freeTrial.\n\n\nA malicious third party may provide a service named freeUnlock, which will call cancelAndRefund() and purchase() automatically right before the end of the freeTrial. This can cause fund loss to all the owners that provide a freeTrial.\n\n",
                "Repair": "\nConsider adding a mapping(address = uint256) freeTrialEnds and make sure each address can only get 1 freeTrial.\n\njulien51 (Unlock Protocol) disputed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-979654912):\n  Isn't that the case with every free trial system? \n If they use the same address the lock manager could easily use the hook system to keep track of who already had received a  full refund and not grant it on the 2nd cancellation.\n The user could still use new addresses all the time, and in that case that would be valid, but that is actually the case with a lot of systems like that :)\n One of my roommates in college was just subscribing to newspaper and getting the full risk-free refund by using a different name every time (but used the same address)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1013831584):\n  While I agree with the warden, there is potential for unlimited free trials. Limiting a free trial to a single address does not resolve the issue as an attacker can generate any number of addresses from a single seed. However, I do understand this is a tricky issue to workaround. \n  \n  So I'm not sure how this should be treated as it does affect how the protocol is intended to operate. Is there any reason for users to not abuse this @julien51 ? Typically with newspapers, you have to provide credit card details, so an individual is really limited by the number of cards they hold.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014073979):\n  As you noted, there is _no way_ to prevent free trials from being abused which is why by default, locks do *not* have a free trial: they have to be manually explicitly configured. From there, since it's trivial to just create an infinite number of accounts, anyone could just claim free trials over and over from new accounts.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014093336):\n  As per sponsor, trials are not enabled by default. But seeing as this impacts protocol availability through abuse if enabled. I'll mark this as medium.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n",
        "CodeNames": [
            "IPublicLock.sol",
            "ERC20Patched.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nif (toKey.tokenId == 0) {\n  toKey.tokenId = _tokenId;\n  _recordOwner(_recipient, _tokenId);\n  // Clear any previous approvals\n  _clearApproval(_tokenId);\n}\n\nif (previousExpiration <= block.timestamp) {\n  // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n  // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n  toKey.expirationTimestamp = fromKey.expirationTimestamp;\n  toKey.tokenId = _tokenId;\n\n  // Reset the key Manager to the key owner\n  _setKeyManagerOf(_tokenId, address(0));\n\n  _recordOwner(_recipient, _tokenId);\n} else {\n  // The recipient has a non expired key. We just add them the corresponding remaining time\n  // SafeSub is not required since the if confirms `previousExpiration block.timestamp` cannot underflow\n  toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration block.timestamp;\n}\n"
                ],
                "Type": "  MixinTransfer.sol#transferFrom  Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users",
                "Description": "\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152\n\nsolidity\nif (toKey.tokenId == 0) {\n  toKey.tokenId = _tokenId;\n  _recordOwner(_recipient, _tokenId);\n  // Clear any previous approvals\n  _clearApproval(_tokenId);\n}\n\nif (previousExpiration <= block.timestamp) {\n  // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n  // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n  toKey.expirationTimestamp = fromKey.expirationTimestamp;\n  toKey.tokenId = _tokenId;\n\n  // Reset the key Manager to the key owner\n  _setKeyManagerOf(_tokenId, address(0));\n\n  _recordOwner(_recipient, _tokenId);\n} else {\n  // The recipient has a non expired key. We just add them the corresponding remaining time\n  // SafeSub is not required since the if confirms previousExpiration block.timestamp cannot underflow\n  toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration block.timestamp;\n}\n\n\nBased on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.\n\nHowever, in L131-136, the key manager is not being reset.\n\nThis allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.\n\n\nGiven:\n\n*   Alice owns a key that is valid until 1 year later.\n\n1.  Alice calls setKeyManagerOf(), making herself the keyManager;\n2.  Alice calls transferFrom(), transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;\n3.  Alice calls transferFrom() again, transferring the key back from Bob.\n\n",
                "Repair": "\nConsider resetting the key manager regardless of the status of the recipient's key.\n\njulien51 (Unlock Protocol) confirmed(https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-991678597):\n  I _think_ you are onto something here. We will need to investigate further and reproduce to fix!\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1013830991):\n  @julien51 Just following up if you were able to double-check this?\n\njulien51 (Unlock Protocol) confirmed(https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1068786599):\n  This is indeed valid and I think we will need to \"patch\" this. We're still unsure how but we're exploring multiple ways.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinLockCore.sol';\n\n\n/**\n * @title Mixin for managing `Key` data, as well as the * Approval related functions needed to meet the ERC721\n * standard.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinKeys is\n  MixinLockCore\n{\n  // The struct for a key\n  struct Key {\n    uint tokenId;\n    uint expirationTimestamp;\n  }\n\n  // Emitted when the Lock owner expires a user's Key\n  event ExpireKey(uint indexed tokenId);\n\n  // Emitted when the expiration of a key is modified\n  event ExpirationChanged(\n    uint indexed _tokenId,\n    uint _amount,\n    bool _timeAdded\n  );\n\n  event KeyManagerChanged(uint indexed _tokenId, address indexed _newManager);\n\n\n  // Keys\n  // Each owner can have at most exactly one key\n  // TODO: could we use public here? (this could be confusing though because it getter will\n  // return 0 values when missing a key)\n  mapping (address => Key) internal keyByOwner;\n\n  // Each tokenId can have at most exactly one owner at a time.\n  // Returns 0 if the token does not exist\n  // TODO: once we decouple tokenId from owner address (incl in js), then we can consider\n  // merging this with totalSupply into an array instead.\n  mapping (uint => address) internal _ownerOf;\n\n  // Addresses of owners are also stored in an array.\n  // Addresses are never removed by design to avoid abuses around referals\n  address[] public owners;\n\n  // A given key has both an owner and a manager.\n  // If keyManager == address(0) then the key owner is also the manager\n  // Each key can have at most 1 keyManager.\n  mapping (uint => address) public keyManagerOf;\n\n    // Keeping track of approved transfers\n  // This is a mapping of addresses which have approved\n  // the transfer of a key to another address where their key can be transferred\n  // Note: the approver may actually NOT have a key... and there can only\n  // be a single approved address\n  mapping (uint => address) private approved;\n\n    // Keeping track of approved operators for a given Key manager.\n  // This approves a given operator for all keys managed by the calling \"keyManager\"\n  // The caller may not currently be the keyManager for ANY keys.\n  // These approvals are never reset/revoked automatically, unlike \"approved\",\n  // which is reset on transfer.\n  mapping (address => mapping (address => bool)) private managerToOperatorApproved;\n\n    // Ensure that the caller is the keyManager of the key\n  // or that the caller has been approved\n  // for ownership of that key\n  modifier onlyKeyManagerOrApproved(\n    uint _tokenId\n  )\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      _isApproved(_tokenId, msg.sender) ||\n      isApprovedForAll(_ownerOf[_tokenId], msg.sender),\n      'ONLY_KEY_MANAGER_OR_APPROVED'\n    );\n    _;\n  }\n\n  // Ensures that an owner owns or has owned a key in the past\n  modifier ownsOrHasOwnedKey(\n    address _keyOwner\n  ) {\n    require(\n      keyByOwner[_keyOwner].expirationTimestamp > 0, 'HAS_NEVER_OWNED_KEY'\n    );\n    _;\n  }\n\n  // Ensures that an owner has a valid key\n  modifier hasValidKey(\n    address _user\n  ) {\n    require(\n      getHasValidKey(_user), 'KEY_NOT_VALID'\n    );\n    _;\n  }\n\n  // Ensures that a key has an owner\n  modifier isKey(\n    uint _tokenId\n  ) {\n    require(\n      _ownerOf[_tokenId] != address(0), 'NO_SUCH_KEY'\n    );\n    _;\n  }\n\n  // Ensure that the caller owns the key\n  modifier onlyKeyOwner(\n    uint _tokenId\n  ) {\n    require(\n      ownerOf(_tokenId) == msg.sender, 'ONLY_KEY_OWNER'\n    );\n    _;\n  }\n\n  /**\n   * In the specific case of a Lock, each owner can own only at most 1 key.\n   * @return The number of NFTs owned by `_keyOwner`, either 0 or 1.\n  */\n  function balanceOf(\n    address _keyOwner\n  )\n    public\n    view\n    returns (uint)\n  {\n    require(_keyOwner != address(0), 'INVALID_ADDRESS');\n    return getHasValidKey(_keyOwner) ? 1 : 0;\n  }\n\n  /**\n   * Checks if the user has a non-expired key.\n   */\n  function getHasValidKey(\n    address _keyOwner\n  )\n    public\n    view\n    returns (bool)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp > block.timestamp;\n  }\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n  */\n  function getTokenIdFor(\n    address _account\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_account].tokenId;\n  }\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp;\n  }\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners()\n    public\n    view\n    returns (uint)\n  {\n    return owners.length;\n  }\n\n  // Returns the owner of a given tokenId\n  function ownerOf(\n    uint _tokenId\n  ) public view\n    returns(address)\n  {\n    return _ownerOf[_tokenId];\n  }\n\n  /**\n  * @notice Public function for updating transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address with the manager's rights for the given key.\n  * Setting _keyManager to address(0) means the keyOwner is also the keyManager\n   */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) public\n    isKey(_tokenId)\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      isLockManager(msg.sender),\n      'UNAUTHORIZED_KEY_MANAGER_UPDATE'\n    );\n    _setKeyManagerOf(_tokenId, _keyManager);\n  }\n\n  function _setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) internal\n  {\n    if(keyManagerOf[_tokenId] != _keyManager) {\n      keyManagerOf[_tokenId] = _keyManager;\n      _clearApproval(_tokenId);\n      emit KeyManagerChanged(_tokenId, address(0));\n    }\n  }\n\n    /**\n   * This approves _approved to get ownership of _tokenId.\n   * Note: that since this is used for both purchase and transfer approvals\n   * the approved token may not exist.\n   */\n  function approve(\n    address _approved,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(msg.sender != _approved, 'APPROVE_SELF');\n\n    approved[_tokenId] = _approved;\n    emit Approval(_ownerOf[_tokenId], _approved, _tokenId);\n  }\n\n    /**\n   * @notice Get the approved address for a single NFT\n   * @dev Throws if `_tokenId` is not a valid NFT.\n   * @param _tokenId The NFT to find the approved address for\n   * @return The approved address for this NFT, or the zero address if there is none\n   */\n  function getApproved(\n    uint _tokenId\n  ) public view\n    isKey(_tokenId)\n    returns (address)\n  {\n    address approvedRecipient = approved[_tokenId];\n    return approvedRecipient;\n  }\n\n    /**\n   * @dev Tells whether an operator is approved by a given keyManager\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  ) public view\n    returns (bool)\n  {\n    uint tokenId = keyByOwner[_owner].tokenId;\n    address keyManager = keyManagerOf[tokenId];\n    if(keyManager == address(0)) {\n      return managerToOperatorApproved[_owner][_operator];\n    } else {\n      return managerToOperatorApproved[keyManager][_operator];\n    }\n  }\n\n  /**\n  * Returns true if _keyManager is the manager of the key\n  * identified by _tokenId\n   */\n  function _isKeyManager(\n    uint _tokenId,\n    address _keyManager\n  ) internal view\n    returns (bool)\n  {\n    if(keyManagerOf[_tokenId] == _keyManager ||\n      (keyManagerOf[_tokenId] == address(0) && ownerOf(_tokenId) == _keyManager)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Assigns the key a new tokenId (from totalSupply) if it does not already have\n   * one assigned.\n   */\n  function _assignNewTokenId(\n    Key storage _key\n  ) internal\n  {\n    if (_key.tokenId == 0) {\n      // This is a brand new owner\n      // We increment the tokenId counter\n      _totalSupply++;\n      // we assign the incremented `_totalSupply` as the tokenId for the new key\n      _key.tokenId = _totalSupply;\n    }\n  }\n\n  /**\n   * Records the owner of a given tokenId\n   */\n  function _recordOwner(\n    address _keyOwner,\n    uint _tokenId\n  ) internal\n  {\n    if (ownerOf(_tokenId) != _keyOwner) {\n      // TODO: this may include duplicate entries\n      owners.push(_keyOwner);\n      // We register the owner of the tokenID\n      _ownerOf[_tokenId] = _keyOwner;\n    }\n  }\n\n  /**\n  * @notice Modify the expirationTimestamp of a key\n  * by a given amount.\n  * @param _tokenId The ID of the key to modify.\n  * @param _deltaT The amount of time in seconds by which\n  * to modify the keys expirationTimestamp\n  * @param _addTime Choose whether to increase or decrease\n  * expirationTimestamp (false == decrease, true == increase)\n  * @dev Throws if owner does not have a valid key.\n  */\n  function _timeMachine(\n    uint _tokenId,\n    uint256 _deltaT,\n    bool _addTime\n  ) internal\n  {\n    address tokenOwner = ownerOf(_tokenId);\n    require(tokenOwner != address(0), 'NON_EXISTENT_KEY');\n    Key storage key = keyByOwner[tokenOwner];\n    uint formerTimestamp = key.expirationTimestamp;\n    bool validKey = getHasValidKey(tokenOwner);\n    if(_addTime) {\n      if(validKey) {\n        key.expirationTimestamp = formerTimestamp + _deltaT;\n      } else {\n        key.expirationTimestamp = block.timestamp + _deltaT;\n      }\n    } else {\n      key.expirationTimestamp = formerTimestamp - _deltaT;\n    }\n    emit ExpirationChanged(_tokenId, _deltaT, _addTime);\n  }\n\n    /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param _to operator address to set the approval\n   * @param _approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(\n    address _to,\n    bool _approved\n  ) public\n    onlyIfAlive\n  {\n    require(_to != msg.sender, 'APPROVE_SELF');\n    managerToOperatorApproved[msg.sender][_to] = _approved;\n    emit ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n    /**\n   * @dev Checks if the given user is approved to transfer the tokenId.\n   */\n  function _isApproved(\n    uint _tokenId,\n    address _user\n  ) internal view\n    returns (bool)\n  {\n    return approved[_tokenId] == _user;\n  }\n\n    /**\n   * @dev Function to clear current approval of a given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(\n    uint256 _tokenId\n  ) internal\n  {\n    if (approved[_tokenId] != address(0)) {\n      approved[_tokenId] = address(0);\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinKeys.sol';\nimport './MixinRoles.sol';\n\n\n/**\n * @title Mixin allowing the Lock owner to grant / gift keys to users.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinGrantKeys is\n  MixinRoles,\n  MixinKeys\n{\n  /**\n   * Allows the Lock owner to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external\n    onlyKeyGranterOrManager\n  {\n    for(uint i = 0; i < _recipients.length; i++) {\n      address recipient = _recipients[i];\n      uint expirationTimestamp = _expirationTimestamps[i];\n      address keyManager = _keyManagers[i];\n\n      require(recipient != address(0), 'INVALID_ADDRESS');\n\n      Key storage toKey = keyByOwner[recipient];\n      require(expirationTimestamp > toKey.expirationTimestamp, 'ALREADY_OWNS_KEY');\n\n      uint idTo = toKey.tokenId;\n\n      if(idTo == 0) {\n        _assignNewTokenId(toKey);\n        idTo = toKey.tokenId;\n        _recordOwner(recipient, idTo);\n      }\n      // Set the key Manager\n      _setKeyManagerOf(idTo, keyManager);\n      emit KeyManagerChanged(idTo, keyManager);\n\n      toKey.expirationTimestamp = expirationTimestamp;\n      // trigger event\n      emit Transfer(\n        address(0), // This is a creation.\n        recipient,\n        idTo\n      );\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "ERC20Patched.sol",
            "IPublicLock.sol",
            "MixinKeys.sol",
            "MixinGrantKeys.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction transferFrom(\n  address _from,\n  address _recipient,\n  uint _tokenId\n)\n  public\n  onlyIfAlive\n  hasValidKey(_from)\n  onlyKeyManagerOrApproved(_tokenId)\n{\n  // @audit this is skipped if user had a key that expired\n  if (toKey.tokenId == 0) {\n    toKey.tokenId = _tokenId;\n    _recordOwner(_recipient, _tokenId);\n    // Clear any previous approvals\n    _clearApproval(_tokenId);\n  }\n\n  if (previousExpiration <= block.timestamp) {\n    // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n    // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n    toKey.expirationTimestamp = fromKey.expirationTimestamp;\n    toKey.tokenId = _tokenId;\n\n    // Reset the key Manager to the key owner\n    // @audit  doesn't clear approval if key manager already was 0\n    _setKeyManagerOf(_tokenId, address(0));\n\n    _recordOwner(_recipient, _tokenId);\n  }\n  // ...\n}\n\n// \nfunction _setKeyManagerOf(\n  uint _tokenId,\n  address _keyManager\n) internal\n{\n  // @audit-ok only clears approved if key manager updated\n  if(keyManagerOf[_tokenId] != _keyManager) {\n    keyManagerOf[_tokenId] = _keyManager;\n    _clearApproval(_tokenId);\n    emit KeyManagerChanged(_tokenId, address(0));\n  }\n}\n"
                ],
                "Type": " Approvals not cleared after key transfer",
                "Description": "\nThe locks implement three different approval types, see onlyKeyManagerOrApproved for an overview:\n\n*   key manager (map keyManagerOf)\n*   single-person approvals (map approved). Cleared by _clearApproval or _setKeyManagerOf\n*   operator approvals (map managerToOperatorApproved)\n\nThe MixinTransfer.transferFrom requires any of the three approval types in the onlyKeyManagerOrApproved modifier on the tokenId to authenticate transfers from from.\n\nNotice that if the to address previously had a key but it expired only the _setKeyManagerOf call is performed, which does not clear approved if the key manager was already set to 0:\n\nsolidity\nfunction transferFrom(\n  address _from,\n  address _recipient,\n  uint _tokenId\n)\n  public\n  onlyIfAlive\n  hasValidKey(_from)\n  onlyKeyManagerOrApproved(_tokenId)\n{\n  // @audit this is skipped if user had a key that expired\n  if (toKey.tokenId == 0) {\n    toKey.tokenId = _tokenId;\n    _recordOwner(_recipient, _tokenId);\n    // Clear any previous approvals\n    _clearApproval(_tokenId);\n  }\n\n  if (previousExpiration <= block.timestamp) {\n    // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n    // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n    toKey.expirationTimestamp = fromKey.expirationTimestamp;\n    toKey.tokenId = _tokenId;\n\n    // Reset the key Manager to the key owner\n    // @audit  doesn't clear approval if key manager already was 0\n    _setKeyManagerOf(_tokenId, address(0));\n\n    _recordOwner(_recipient, _tokenId);\n  }\n  // ...\n}\n\n// \nfunction _setKeyManagerOf(\n  uint _tokenId,\n  address _keyManager\n) internal\n{\n  // @audit-ok only clears approved if key manager updated\n  if(keyManagerOf[_tokenId] != _keyManager) {\n    keyManagerOf[_tokenId] = _keyManager;\n    _clearApproval(_tokenId);\n    emit KeyManagerChanged(_tokenId, address(0));\n  }\n}\n\n\n\nIt's possible to sell someone a key and then claim it back as the approvals are not always cleared.\n\n\n*   Attacker A has a valuable key (tokenId = 42) with an expiry date far in the future.\n*   A sets approvals for their second attacker controlled account A' by calling MixinKeys.setApprovalForAll(A', true), which sets managerToOperatorApproved[A][A'] = true.\n*   A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above _setKeyManagerOf(42, address(0)); in transferFrom\n*   A sets single-token approval to A' by calling MixinKeys.approve(A', 42), setting approved[42] = A'.\n*   A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The transferFrom(A, V, 42) call sets the owner of token 42 to V, but does not clear the approved[42] == A' field as described above. (_setKeyManagerOf(_tokenId, address(0)); is called but the key manager was already zero, which then does not clear approvals.)\n*   A' can claim back the token by calling transferFrom(V, A', 42) and the onlyKeyManagerOrApproved(42) modifier will pass as approved[42] == A' is still set.\n\n",
                "Repair": "\nThe _setKeyManagerOf function should not handle clearing approvals of single-token approvals (approved) as these are two separate approval types.\nThe transferFrom function should always call _clearApproval in the (previousExpiration <= block.timestamp) case.\n\njulien51 (Unlock Protocol) confirmed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/160#issuecomment-991687080):\n  Thanks for reporting this.\n  This is valid and we will fix it.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n",
        "CodeNames": [
            "Unlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "uniswapOracle"
                ],
                "Type": " Unlock: free UDT arbitrage opportunity",
                "Description": "\nUniswap v2 made oracle attacks much more expensive to execute (since it needs to be manipulated over X number of blocks) however its biggest drawback is that it reacts slow to price volatility (depends on how far back you look). Depending on a single oracle is still very risky and can be exploited given the correct conditions.\n\nAssuming the ideal conditions, it is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher; high enough such that the malicious user can still profit even after requesting for a refund (w/ or w/o a free trial).\n\n\nThis exploit is made possible because of:\n\n*   the over dependency on a single price oracle\n*   UDT token distribution logic is flawed\n\nThe following assumptions has to be true for this attack to work:\n\n1.  price of UDT on an exchange is much higher than that from the price retrieved from the uniswapOracle.\n2.  Since the price retrieved by udtOracle.updateAndConsult() only updates once per day, it is slow to react to the volatility of UDT price movements.\n3.  Malicious user creates a lock and buys many keys across multiple addresses.\n4.  Malicious user sells these UDT tokens on the exchanges w/ the higher price.\n5.  Malicious user requests for a refund on the keys owned.\n6.  Repeat until it is no longer profitable i.e. price on other exchanges become close to parity with the price retrieved by the uniswapOracle.\n\n",
                "Repair": "\n*   Use the average of multiple oracle sources so that the price of UDT tokens (from Unlock.sol's PoV) reacts faster.\n*   UDT tokens distributed based on the duration of key ownership.\n\njulien51 (Unlock Protocol) disagreed with severity and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1004137608):\n  As you noted this is pretty theoretical and given that the amount of UDT minted is capped to the gas spent, the user will need to 1) purchase a LOT of keys and 2) cancel them all and 3) find an exchange where the price is significantly different. \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1010535323):\n  Nice find!\n \n While, I do agree this is a difficult attack to perform, it is still a valid way of extracting value from the protocol. Hence, I believe this should be kept as medium.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1068788560):\n  We will mitigate this in an upcoming upgrade by moving to Uniswap v3 for our oracles. \n\n\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;\n"
                ],
                "Type": " Referrer discount token amount can be manipulated",
                "Description": "\nThe Unlock.recordKeyPurchase function is called on each key purchase (MixinPurchase.purchase) and mints UDT tokens to the referrer.\nThe amount to mint is based on the transaction's gas price which is controlled by the caller (purchaser):\n\nsolidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;\n\n\n\nTokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price.\nDepending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n\n",
                "Repair": "\nThe amount minted should be more predictable and not depend on the user's gas price input.\nConsider declaring an *average gas price* storage variable that is set by a trusted party and use this one instead.\n\njulien51 (Unlock Protocol) disagreed with severity and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-991691106):\n   Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n \n Since we get the token price from the Uniswap oracle, the amount of tokens received is always at most equal to what they would have spent to acquire them on Uniswap.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-1013842955):\n  As the uniswap oracle provides averaged price data, if there is any discrepancy between the spot price and the TWAP price, this can definitely be abused to extract value from the protocol. Keeping this as medium.\n\n\n\n\n"
            },
            {
                "Name": "M-11",
                "Location": [
                    "//solidity\nmaxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n"
                ],
                "Type": " Missing scaling factor in  recordKeyPurchase ?",
                "Description": "\nThe Unlock.recordKeyPurchase function computes the maxTokens as:\n\nsolidity\nmaxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n\n\nNote that grossNetworkProduct was already increased by valueInETH in the code before.\nMeaning, the (2 + 2 * valueInETH / grossNetworkProduct) part of the computation will almost always be 2 as usually grossNetworkProduct  2 * valueInETH, and thus the 2 * valueInETH / grossNetworkProduct is zero by integer division.\n\n\nThe maxTokens curve might not be computed as intended and lead to being able to receive more token rewards than intended.\n\n",
                "Repair": "\nThe comment \"we distribute tokens using asymptotic curve between 0 and 0.5\" should be more clear to indicate how exactly the curve looks like.\nIt could be that a floating-point number was desired instead of the integer division in 2 * valueInETH / grossNetworkProduct. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-991690466):\n  I am not fully sure I understand what the problem is here?\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1013844481):\n  I think the warden is raising an issue where 2 * valueInEth / grossNetworkProduct will more than likely truncate and return 0. I think this is a valid finding.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1068793080):\n  Hum, we did some tests and could not reproduce here.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1075696998):\n  I'm not sure how 2 * valueInETH / grossNetworkProduct does not always lead to some truncation. grossNetworkProduct is equal to valueInETH in the first call but always greater than valueInETH in any subsequent calls.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n",
        "CodeNames": [
            "Unlock.sol",
            "ERC20Patched.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;\n"
                ],
                "Type": " Potential economic attack on UDT grants to the referrer",
                "Description": "\nIn the current implementation, Unlock.sol#recordKeyPurchase() will send estimatedGasForPurchase * tx.gasprice worth of UDT to the referrer.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L325-L325\n\nsolidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;\n\n\nWe believe there are multiple potential economic attack vectors to exploit this.\n\nIf estimatedGasForPurchase is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured estimatedGasForPurchase, it can be exploited simply by creating a lock and call purchase() many times to mint UDT.\n\nEven if estimatedGasForPurchase is configured to an amount similar to the actual gas cost, a more sophisticated attack is still possible:\n\n\nGiven:\n\n*   estimatedGasForPurchase is configured as 200,000;\n*   The gas cost of a regular purchase call is about 200,000.\n\nThe attacker can create a lock contract and set the token address to a special gas saving token, which will SELFDESTRUCT to get a gas refund on transfer.\n\nThe attacker can:\n\n1.  Mint gas saving token with gas price: 1 gwei;\n2.  Call purchase() and use 48 contract slots with gas price: 1000 gwei;\n\nTotal gas saved will be ~0.8 ETH (or other native tokens, eg. BNB, MATIC). Therefore, the attacker will profit ~0.8 ETH worth of UDT.\n\nSee: <https://gastoken.io/\n\n",
                "Repair": "\nConsider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.\n\njulien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-991673917):\n   If estimatedGasForPurchase is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured estimatedGasForPurchase, it can be exploited simply by creating a lock and call purchase() many times to mint UDT.\n \n Absolutely but considering the security model, the admin indeed have full control over the protocol. We are thinking about finding a mechanism to not hardcode gas spent but use the actual number eventually. When we do that we should consider the impact of things like gas-token (even though EIP1559 has probably made them mostly impractical?).\n \n At this point given that the gas spent is hardcoded, there is a de-facto cap on how much UDT they could earn (based on the token price).\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1013811232):\n  While I agree with the warden, there is potential for value extraction, however, it does require the admin to be unaware about upcoming network upgrades. \n \n As the sponsor has noted, they will be moving towards a dynamic estimatedGasForPurchase value, however, from the perspective of the c4 contest, this doesn't change the outcome of my decision.\n \n  As the protocol may leak value based on certain network assumptions, I'll mark this as medium severity.\n  \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\nPlease note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1068789965):\n  I don't think the protocl can \"leak\" value based on that.\n  The tokens that are used to compute GDP and distribute tokens have to be approved by the DAO (right now only USDC, DAI and BAT have been approved on mainnet, and only USDC on Polygon). I don't think the DAO would approve gas tokens givem that indeed they could result in leakage of UDT, so I think it is minor.\n\n0xleastwood (judge) decreased severity to Low and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1075674165):\n  Considering the sponsor's comments, I actually agree that this is less likely than initially stated. Similar to the SafeERC20 issue, it isn't expected that gas saving tokens will be approved to compute and distribute UDT tokens. I'll downgrade this to low.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\n  token.transferFrom(msg.sender, address(this), pricePaid);\n"
                ],
                "Type": " Support of different ERC20 tokens",
                "Description": "\nThe current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success (see: <https://github.com/d-xo/weird-erc20). Function purchase transfers tokens from msg.sender but it does not check the return value, nor how many tokens were actually transferred:\n\nsolidity\n  token.transferFrom(msg.sender, address(this), pricePaid);\n\n\n",
                "Repair": "\nI have 2 suggestions here:\n\n1.  Use SafeERC20 library to handle token transfers: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\n2.  Consider checking the actual balances transferred (balance after-before) or clearly documenting that you do not support deflationary / rebasing / etc tokens.\n\njulien51 (Unlock Protocol) disputed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-991662738):\n  The only party that would be penalized in the examples you describe is the lock manager (and beneficiary) who has explicitly deployed the lock using the (noncompliant) ERC20.\n If we consider the threat model here then I think this is not really an issue, as additional checks would incur a gas cost for everyone.\n\nPlease note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1068790582):\n  The fact that this requires an explicit action by the lock manager (ie using a buggy/malicious ERC20 token) and that it puts only _their_ tokens at risk, I think this is minor.\n\n0xleastwood (judge) decreased severity to Low and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1075664726):\n  Giving this a bit more thought, I think its always safe to enforce these checks rather than leave it up to the lock manage to potentially make the mistake and then be liable for this mistake later on. However, considering the threat model, I do think this is better suited as a low severity issue.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n",
        "CodeNames": [
            "IPublicLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "cancelAndRefund",
                    "withdraw",
                    "expireAndRefundFor"
                ],
                "Type": " Key buyers will not be able to get refund if lock manager withdraws profits",
                "Description": "\nUnlock contains a feature in which a key buyer can ask for a refund.\nThe refund is sent from the lock where the purchase funds were sent.\nThe lock manager can withdraw all funds from the lock.\nTherefore, if the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request refund.\nEven if a lock manager is not malicious, if he would want to enable users to cancel their key, he would have to keep track of how much tokens need to be kept in the contract in order to enable this not a trivial calculation. A naive lock manager might accidentally disable refunds for his clients.\n\n\nRefunds are not guaranteed.\nA user might buy a key expecting to cancel it within some time, only to discover he can not cancel it. (This loss of user funds is why I consider this a high risk finding.)\nAn unaware lock manager who just wants to withdraw all his profits might accidentally discover that he removed his users' ability to cancel their key.\n\n\nIt seems the Unlock team is aware to some extent that withdrawing breaks refunds, as they state in the withdraw function:\n\n       * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\n       *  -however be wary of draining funds as it breaks the cancelAndRefund and expireAndRefundFor\n       * use cases.\n\nHowever, even if just the owner is allowed to call it, he may break the refund functionality on purpose or accidentally.\nLooking on Unlock documentation I don't see a warning to creators about withdrawing their funds.\n\n\nwithdraw function has no limit on the amount withdrawn, therefore the owner can withdraw all funds:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L133:#L162\n\ncancelAndRefund transfers the funds from the same lock contract:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L118\nTherefore if there are not enough funds, the transfer will fail.\n\n",
                "Repair": "\nPerhaps a sort of MasterChef-like shares system can be implemented in order to make sure the owner leaves enough funds in the lock to process refunds.\n\njulien51 (Unlock Protocol) disagreed with severity and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-976135073):\n  As noted, this is actually documented. You are right though that we should make this more obvious on the UI.\n I would not classify this as High Risk.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1013832438):\n  Nice find! I think this can be downgraded to medium as the availability of the protocol is impacted by this issue.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1068791454):\n  This would not affect the whole protocol but only the \"malicious\" lock and it is impractice not only documented but also how these things work in the real world. If Netflix went out of business tomorrow, I could not get a refund on this month's membership fee...\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1075662850):\n  While I mostly agree with the sponsor, this may be intended behaviour as user's should not be entitled to a refund in this case. However, based on what was known at the time, it seemed like this broke the functionality of cancelAndRefund and expireAndRefundFor functions, hence why it was marked as medium severity.\n\n\n\n\n"
            },
            {
                "Name": "M-14",
                "Location": [
                    "updateKeyPricing()"
                ],
                "Type": " MixinRefunds: frontrun updateKeyPricing() for free profit",
                "Description": "\nA malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.\n\n\nWhen updateKeyPricing() is called to increase the price of a key, it is possible to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price.\n\n",
                "Repair": "\nKeep track of the price at which keys are purchased so that when you issue a refund, you use the original keyPrice to refund instead of the updated keyPrice\n\njulien51 (Unlock Protocol) acknowledged, but disagreed with High severity and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):\n  This is only true for locks where there is no penalty. We should make it clear on the front-end that when changing the price it is recommended to set up a penalty (at least temporarily) for the price difference so that no key can be refunded for the full price.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):\n  Circling back on this, I'm not sure how a penalty would be correctly applied to all locks. Wouldn't users who wanted to get a refund for their key get penalised if they purchase after the change in key price? I think it would also be safer to update the key price and apply the penalty in the one transaction.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):\n  I think that is a good finding, but there again (like often) I think this is pretty edgy.\n  The cancellation penalty is pretty easy to apply just to a single lock from the lock manager's perspective(https://github.com/unlock-protocol/unlock/blob/b7c5a555efc3c2be619cbb942eb67d4008baa049/smart-contracts/contracts/mixins/MixinRefunds.sol#L70). Before changing the lock price, a lock manager can easily apply a penalty for the difference in price. IE if I change the price from 10 to 12, I apply a penalty for 2 and anyone who tries to abuse this will only get a refund of 12-2 = 10.\n \n  On top of that we're actually storing the amount paid for the latest key as part of our next upgrade to support automatically recurring memberships, which should make things even more robust as anyone will only get re-imbursed based on what they paid...\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):\n  Considering the sponsor's comments and after some further discussion on Discord. I think it is more correct to downgrade this to medium severity. While it isn't clear, the lock manager is expected to apply a penalty before updating the cost of a membership such that users cannot game the price difference. However, this isn't enforced on-chain or documented anywhere so based on the judge's and warden's context at the time, this seemed like a valid high severity issue. It is important to note that users who refund their membership after purchasing a membership post price change will be refunded less than users who purchased their memberships before the price change. The sponsor is looking to integrate these fixes in their next upgrade.\n\n \n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n",
        "CodeNames": [
            "ERC20Patched.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "transferFrom"
                ],
                "Type": " Key transfer will destroy key if from==to",
                "Description": "\nIf calling transferFrom with _from == _recipient, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).\n\n\nA key manager or approved might accidentally destroy user's token.\n\nNote: this requires user error and so I'm not sure if this is a valid finding.\nHowever, few things make me think that it is valid:\n\n*   Unlock protocol checks for transfer to 0-address, so some input validation is there\n*   Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen.\n*   This scenario manifests a unique and probably unintended behavior\n\n\nBy following transferFrom's execution:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166\nOne can see that in the case where _from == _recipient with a valid key:\n\n*   The function will deduct transfer fee from the key\n*   The function will incorrectly add more time to the key's expiration ([L151(https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151))\n*   The function will expire and reset the key ([L155(https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158))\n\nTherefore, the user will lose his key without getting a refund.\n\n",
                "Repair": "\nAdd a require statement in the beginning of transferFrom:\nrequire(_from != _recipient, 'TRANSFER_TO_SELF');\n\njulien51 (Unlock Protocol) confirmed(https://github.com/code-423n4/2021-11-unlock-findings/issues/87)\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/87#issuecomment-1068792003):\n  Fixed since then :)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n",
        "CodeNames": [
            "PublicLock.sol",
            "IPublicLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "shareKey",
                    "_maxNumberOfKeys",
                    "maxNumberOfKeys"
                ],
                "Type": " MixinPurchase:shareKey allows to generate keys without purchasing",
                "Description": "\nThe shareKey function allows a user to share some time with another user that doesn't already has/had a key and this generates a new key. This even allows the user to generate more keys than _maxNumberOfKeys.\n\nAttacker generates a lot of EOA addresses, buys a key, share the minimum necessary time with each address and in each \"sharing\" a new key gets generated. This allows cheaply to allocate alot of \"keys\" with out really purchasing them and a lot of user can't get a \"key\" because purchase has a modifier notSoldOut, that limits the max purchasable to \"keys\" to maxNumberOfKeys\n\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n\nManual Analysis\n\n",
                "Repair": "\n*   rethink the whole shareKey thingy,\n\njulien51 (Unlock Protocol) acknowledged and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-979648865):\n  I am not sure this is a bug or even a risk. \n Someone could actually achieve the same thing by purchasing keys at the full price and cancelling them immediately getting an almost full refund (or even full refund when there is a free trial) and could quickly get the lock to \"sell out\". \n It is actually the case with any NFT project where there is a cap/limit to number of tokens and someone can easily \"Capture\" them all.\n \n One way to limit the impact for the lock manager would be to set a cancellation penalty AND a transfer fee.  \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1013834438):\n  Nice find! While I understand what the sponsor is saying, this does seem like a valid way to deny a lock from selling membership to honest users.\n\njulien51 (Unlock Protocol) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1068792488):\n  Note that a lock manager can easily increase supply to mitigate that (and even could _delete_ existing keys/NFT to reduce the outstanding supply)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1075656944):\n  While the lock manager can restore the contract to some valid state, this will still impact protocol availability, even in the short-term.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n",
        "CodeNames": [
            "PublicLock.sol",
            "Unlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "initialize()"
                ],
                "Type": " Frontrunning  PublicLock.initialize()  can prevent upgrades due to insufficient access control",
                "Description": "\nThe unlock protocols base contract Unlock.sol uses setLocktemplate() to initialize the implementation contract for the PublicLock proxy. This function will initialize the relevant PublicLock contract which has been deployed separately. PublicLock.initialize() does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the setLocktemplate() forcing the deployer of PublicLock's implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.\n\n\nLack of access control on initialize(https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/PublicLock.sol#L42-L51)\n\n",
                "Repair": "\nImplement valid access control on the PublicLock contract to ensure only the relevant deployer can initialize().\n\njulien51 (Unlock Protocol) disagreed with severity(https://github.com/code-423n4/2021-11-unlock-findings/issues/132)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/132#issuecomment-1075675604):\n  I agree with the warden, _publicLockAddress is deployed separately and hence initialize can be called before setLockTemplate is called.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinRoles.sol';\nimport './MixinDisable.sol';\nimport './MixinKeys.sol';\nimport './MixinFunds.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\n/**\n * @title Mixin for the transfer-related functions needed to meet the ERC721\n * standard.\n * @author Nick Furfaro\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\n\ncontract MixinTransfer is\n  MixinRoles,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  using AddressUpgradeable for address;\n\n  event TransferFeeChanged(\n    uint transferFeeBasisPoints\n  );\n\n  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // The fee relative to keyPrice to charge when transfering a Key to another account\n  // (potentially on a 0x marketplace).\n  // This is calculated as `keyPrice * transferFeeBasisPoints / BASIS_POINTS_DEN`.\n  uint public transferFeeBasisPoints;\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_to != address(0), 'INVALID_ADDRESS');\n    address keyOwner = _ownerOf[_tokenId];\n    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');\n    Key storage fromKey = keyByOwner[keyOwner];\n    Key storage toKey = keyByOwner[_to];\n    uint idTo = toKey.tokenId;\n    uint time;\n    // get the remaining time for the origin key\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    // get the transfer fee based on amount of time wanted share\n    uint fee = getTransferFee(keyOwner, _timeShared);\n    uint timePlusFee = _timeShared + fee;\n\n    // ensure that we don't try to share too much\n    if(timePlusFee < timeRemaining) {\n      // now we can safely set the time\n      time = _timeShared;\n      // deduct time from parent key, including transfer fee\n      _timeMachine(_tokenId, timePlusFee, false);\n    } else {\n      // we have to recalculate the fee here\n      fee = getTransferFee(keyOwner, timeRemaining);\n      time = timeRemaining - fee;\n      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key\n      emit ExpireKey(_tokenId);\n    }\n\n    if (idTo == 0) {\n      _assignNewTokenId(toKey);\n      idTo = toKey.tokenId;\n      _recordOwner(_to, idTo);\n      emit Transfer(\n        address(0), // This is a creation or time-sharing\n        _to,\n        idTo\n      );\n    } else if (toKey.expirationTimestamp <= block.timestamp) {\n      // reset the key Manager for expired keys\n      _setKeyManagerOf(idTo, address(0));\n    }\n\n    // add time to new key\n    _timeMachine(idTo, time, true);\n    // trigger event\n    emit Transfer(\n      keyOwner,\n      _to,\n      idTo\n    );\n\n    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');\n  }\n\n  function transferFrom(\n    address _from,\n    address _recipient,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    hasValidKey(_from)\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(ownerOf(_tokenId) == _from, 'TRANSFER_FROM: NOT_KEY_OWNER');\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_recipient != address(0), 'INVALID_ADDRESS');\n    uint fee = getTransferFee(_from, 0);\n\n    Key storage fromKey = keyByOwner[_from];\n    Key storage toKey = keyByOwner[_recipient];\n\n    uint previousExpiration = toKey.expirationTimestamp;\n    // subtract the fee from the senders key before the transfer\n    _timeMachine(_tokenId, fee, false);\n\n    if (toKey.tokenId == 0) {\n      toKey.tokenId = _tokenId;\n      _recordOwner(_recipient, _tokenId);\n      // Clear any previous approvals\n      _clearApproval(_tokenId);\n    }\n\n    if (previousExpiration <= block.timestamp) {\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\n      toKey.tokenId = _tokenId;\n\n      // Reset the key Manager to the key owner\n      _setKeyManagerOf(_tokenId, address(0));\n\n      _recordOwner(_recipient, _tokenId);\n    } else {\n      // The recipient has a non expired key. We just add them the corresponding remaining time\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n      toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n    }\n\n    // Effectively expiring the key for the previous owner\n    fromKey.expirationTimestamp = block.timestamp;\n\n    // Set the tokenID to 0 for the previous owner to avoid duplicates\n    fromKey.tokenId = 0;\n\n    // trigger event\n    emit Transfer(\n      _from,\n      _recipient,\n      _tokenId\n    );\n  }\n\n  /**\n   * @notice An ERC-20 style transfer.\n   * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n   * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n   * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n   */\n  function transfer(\n    address _to,\n    uint _value\n  ) public\n    returns (bool success)\n  {\n    uint maxTimeToSend = _value * expirationDuration;\n    Key storage fromKey = keyByOwner[msg.sender];\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    if(maxTimeToSend < timeRemaining)\n    {\n      shareKey(_to, fromKey.tokenId, maxTimeToSend);\n    }\n    else\n    {\n      transferFrom(msg.sender, _to, fromKey.tokenId);\n    }\n\n    // Errors will cause a revert\n    return true;\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address\n  * @dev This works identically to the other function with an extra data parameter,\n  *  except this function just sets data to ''\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  )\n    public\n  {\n    safeTransferFrom(_from, _to, _tokenId, '');\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address.\n  * When transfer is complete, this functions\n  *  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  *  `onERC721Received` on `_to` and throws if the return value is not\n  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  * @param _data Additional data with no specified format, sent in call to `_to`\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  )\n    public\n  {\n    transferFrom(_from, _to, _tokenId);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');\n\n  }\n\n  /**\n   * Allow the Lock owner to change the transfer fee.\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  )\n    external\n    onlyLockManager\n  {\n    emit TransferFeeChanged(\n      _transferFeeBasisPoints\n    );\n    transferFeeBasisPoints = _transferFeeBasisPoints;\n  }\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  )\n    public view\n    returns (uint)\n  {\n    if(! getHasValidKey(_keyOwner)) {\n      return 0;\n    } else {\n      Key storage key = keyByOwner[_keyOwner];\n      uint timeToTransfer;\n      uint fee;\n      // Math: safeSub is not required since `hasValidKey` confirms timeToTransfer is positive\n      // this is for standard key transfers\n      if(_time == 0) {\n        timeToTransfer = key.expirationTimestamp - block.timestamp;\n      } else {\n        timeToTransfer = _time;\n      }\n      fee = timeToTransfer * transferFeeBasisPoints / BASIS_POINTS_DEN;\n      return fee;\n    }\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n}\n\n// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n",
        "CodeNames": [
            "MixinTransfer.sol",
            "ERC20Patched.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "//solidity\nuint fee = getTransferFee(keyOwner, _timeShared);\nuint timePlusFee = _timeShared + fee;\n",
                    "//solidity\nif(timePlusFee < timeRemaining) {\n  // now we can safely set the time\n  time = _timeShared;\n  // deduct time from parent key, including transfer fee\n  _timeMachine(_tokenId, timePlusFee, false);\n} else {\n  // we have to recalculate the fee here\n  fee = getTransferFee(keyOwner, timeRemaining);\n  // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time\n  time = timeRemaining fee;\n}\n"
                ],
                "Type": " Inaccurate fees computation",
                "Description": "\nThe MixinTransfer.shareKey function wants to compute a fee such that time + fee * time == timeRemaining (timePlusFee):\n\nsolidity\nuint fee = getTransferFee(keyOwner, _timeShared);\nuint timePlusFee = _timeShared + fee;\n\n\nHowever, if the time remaining is less than the computed fee time, the computation changes and a different formula is applied.\nThe fee is now simply taken on the remaining time.\n\nsolidity\nif(timePlusFee < timeRemaining) {\n  // now we can safely set the time\n  time = _timeShared;\n  // deduct time from parent key, including transfer fee\n  _timeMachine(_tokenId, timePlusFee, false);\n} else {\n  // we have to recalculate the fee here\n  fee = getTransferFee(keyOwner, timeRemaining);\n  // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time\n  time = timeRemaining fee;\n}\n\n\nIt should compute the time without fee as time = timeRemaining / (1.0 + fee_as_decimal) instead, i.e., time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN).\n\n\nTo demonstrate the difference with a 10% fee and a _timeShared = 10,000s which should be credited to the to account.\n\nThe correct time plus fee which is reduced from from (as in the timePlusFee < timeRemaining branch) would be 10,000 + 10% * 10,000 = 11,000.\n\nHowever, if from has not enough time remaining and timePlusFee = timeRemaining, the entire time remaining is reduced from from but the credited time is computed wrongly as:\n(Let's assume timeRemaining == timePlusFee): time = 11,000 10% * 11,000 = 11,000 1,100 = 9900.\n\nThey would receive 100 seconds less than what they are owed.\n\n\nWhen transferring more time than the from account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).\n\n",
                "Repair": "\nIt should change the first if branch condition to timePlusFee <= timeRemaining (less than or equal).\nIn the else branch, it should compute the time without fee as time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN).\n\njulien51 (Unlock Protocol) confirmed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/165#issuecomment-991683180):\n  Great find!\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.17 <0.9.0;\n\n/**\n* @title The PublicLock Interface\n* @author Nick Furfaro (unlock-protocol.com)\n */\n\n\ninterface IPublicLock\n{\n\n// See indentationissue description here:\n// https://github.com/duaraghav8/Ethlint/issues/268\n// solium-disable indentation\n\n  /// Functions\n  function initialize(\n    address _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) external;\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  // receive() external payable;\n  // fallback() external payable;\n\n  // roles\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n  * @notice The version number of the current implementation on this network.\n  * @return The current version number.\n  */\n  function publicLockVersion() external pure returns (uint16);\n\n  /**\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\n  * @dev Throws if called by other than a lock manager.\n  * @dev Throws if lock contract has already been disabled.\n  */\n  function disableLock() external;\n\n  /**\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @dev Throws if called by other than a lock manager or beneficiary\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external;\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) external\n    returns (bool);\n\n  /**\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if lock has been disabled\n   * @dev Throws if _tokenAddress is not a valid token\n   * @param _keyPrice The new price to set for keys\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\n   * or 0 to use ETH\n   */\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\n\n  /**\n   * A function which lets a Lock manager update the beneficiary account,\n   * which receives funds on withdrawal.\n   * @dev Throws if called by other than a Lock manager or beneficiary\n   * @dev Throws if _beneficiary is address(0)\n   * @param _beneficiary The new address to set as the beneficiary\n   */\n  function updateBeneficiary( address _beneficiary ) external;\n\n  /**\n   * Checks if the user has a non-expired key.\n   * @param _user The address of the key owner\n   */\n  function getHasValidKey(\n    address _user\n  ) external view returns (bool);\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n   * @param _account The address of the key owner\n  */\n  function getTokenIdFor(\n    address _account\n  ) external view returns (uint);\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) external view returns (uint timestamp);\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners() external view returns (uint);\n\n  /**\n   * Allows a Lock manager to assign a descriptive name for this Lock.\n   * @param _lockName The new name for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockName(\n    string calldata _lockName\n  ) external;\n\n  /**\n   * Allows a Lock manager to assign a Symbol for this Lock.\n   * @param _lockSymbol The new Symbol for the lock\n   * @dev Throws if called by other than a Lock manager\n   */\n  function updateLockSymbol(\n    string calldata _lockSymbol\n  ) external;\n\n  /**\n    * @dev Gets the token symbol\n    * @return string representing the token symbol\n    */\n  function symbol()\n    external view\n    returns(string memory);\n\n    /**\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\n   * @dev Throws if called by other than a Lock manager\n   * @param _baseTokenURI String representing the base of the URI for this lock.\n   */\n  function setBaseTokenURI(\n    string calldata _baseTokenURI\n  ) external;\n\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\n   *  Metadata JSON Schema\".\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n   * @param _tokenId The tokenID we're inquiring about\n   * @return String representing the URI for the requested token\n   */\n  function tokenURI(\n    uint256 _tokenId\n  ) external view returns(string memory);\n\n  /**\n   * @notice Allows a Lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external;\n\n  /**\n   * Allows a Lock manager to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   * @dev Throws if called by other than a Lock manager\n   * @param _recipients An array of receiving addresses\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external;\n\n  /**\n  * @dev Purchase function\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\n  * (_value is ignored when using ETH)\n  * @param _recipient address of the recipient of the purchased key\n  * @param _referrer address of the user making the referral\n  * @param _data arbitrary data populated by the front-end which initiated the sale\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\n  * than keyPrice is approved for spending).\n  */\n  function purchase(\n    uint256 _value,\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external payable;\n\n  /**\n   * @notice returns the minimum price paid for a purchase with these params.\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\n   */\n  function purchasePriceFor(\n    address _recipient,\n    address _referrer,\n    bytes calldata _data\n  ) external view\n    returns (uint);\n\n  /**\n   * Allow a Lock manager to change the transfer fee.\n   * @dev Throws if called by other than a Lock manager\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\n   * Ex: 200 bps = 2%\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  ) external;\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @dev Throws if _keyOwner does not have a valid key\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   * @param _time The amount of time to calculate the fee for.\n   * @return The transfer fee in seconds.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  ) external view returns (uint);\n\n  /**\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\n   * @param _keyOwner The key owner to whom we wish to send a refund to\n   * @param amount The amount to refund the key-owner\n   * @dev Throws if called by other than a Lock manager\n   * @dev Throws if _keyOwner does not have a valid key\n   */\n  function expireAndRefundFor(\n    address _keyOwner,\n    uint amount\n  ) external;\n\n   /**\n   * @dev allows the key manager to expire a given tokenId\n   * and send a refund to the keyOwner based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId) external;\n\n  /**\n   * Allow a Lock manager to change the refund penalty.\n   * @dev Throws if called by other than a Lock manager\n   * @param _freeTrialLength The new duration of free trials for this lock\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external;\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * @param _keyOwner The key owner to get the refund value for.\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  ) external view returns (uint refund);\n\n  function addKeyGranter(address account) external;\n\n  function addLockManager(address account) external;\n\n  function isKeyGranter(address account) external view returns (bool);\n\n  function isLockManager(address account) external view returns (bool);\n\n  function onKeyPurchaseHook() external view returns(address);\n\n  function onKeyCancelHook() external view returns(address);\n\n  function revokeKeyGranter(address _granter) external;\n\n  function renounceLockManager() external;\n\n  ///===================================================================\n  /// Auto-generated getter functions from public state variables\n\n  function beneficiary() external view returns (address );\n\n  function expirationDuration() external view returns (uint256 );\n\n  function freeTrialLength() external view returns (uint256 );\n\n  function isAlive() external view returns (bool );\n\n  function keyPrice() external view returns (uint256 );\n\n  function maxNumberOfKeys() external view returns (uint256 );\n\n  function owners(uint256 ) external view returns (address );\n\n  function refundPenaltyBasisPoints() external view returns (uint256 );\n\n  function tokenAddress() external view returns (address );\n\n  function transferFeeBasisPoints() external view returns (uint256 );\n\n  function unlockProtocol() external view returns (address );\n\n  function keyManagerOf(uint) external view returns (address );\n\n  ///===================================================================\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @dev Throws if key is not valid.\n  * @dev Throws if `_to` is the zero address\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n  * `onERC721Received` on `_to` and throws if the return value is not\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @dev Emit Transfer event\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) external;\n\n  /**\n  * @notice Update transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address to assign the rights to for the given key\n  */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) external;\n\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n  ///===================================================================\n\n  /// From ERC165.sol\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n  ///===================================================================\n\n  /// From ERC-721\n  /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    \n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n    * @notice Get the approved address for a single NFT\n    * @dev Throws if `_tokenId` is not a valid NFT.\n    * @param _tokenId The NFT to find the approved address for\n    * @return operator The approved address for this NFT, or the zero address if there is none\n    */\n    function getApproved(uint256 _tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    /**\n    * Innherited from Open Zeppelin AccessControl.sol\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @notice An ERC-20 style transfer.\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n     */\n    function transfer(\n      address _to,\n      uint _value\n    ) external\n      returns (bool success);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport './MixinDisable.sol';\nimport './MixinRoles.sol';\nimport '../interfaces/IUnlock.sol';\nimport './MixinFunds.sol';\nimport '../interfaces/hooks/ILockKeyCancelHook.sol';\nimport '../interfaces/hooks/ILockKeyPurchaseHook.sol';\n\n\n/**\n * @title Mixin for core lock data and functions.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinLockCore is\n  MixinRoles,\n  MixinFunds,\n  MixinDisable\n{\n  using AddressUpgradeable for address;\n\n  event Withdrawal(\n    address indexed sender,\n    address indexed tokenAddress,\n    address indexed beneficiary,\n    uint amount\n  );\n\n  event PricingChanged(\n    uint oldKeyPrice,\n    uint keyPrice,\n    address oldTokenAddress,\n    address tokenAddress\n  );\n\n   /**\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n    */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n    */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n    */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  // Unlock Protocol address\n  // TODO: should we make that private/internal?\n  IUnlock public unlockProtocol;\n\n  // Duration in seconds for which the keys are valid, after creation\n  // should we take a smaller type use less gas?\n  // TODO: add support for a timestamp instead of duration\n  uint public expirationDuration;\n\n  // price in wei of the next key\n  // TODO: allow support for a keyPriceCalculator which could set prices dynamically\n  uint public keyPrice;\n\n  // Max number of keys sold if the keyReleaseMechanism is public\n  uint public maxNumberOfKeys;\n\n  // A count of how many new key purchases there have been\n  uint internal _totalSupply;\n\n  // The account which will receive funds on withdrawal\n  address payable public beneficiary;\n\n  // The denominator component for values specified in basis points.\n  uint internal constant BASIS_POINTS_DEN = 10000;\n\n  ILockKeyPurchaseHook public onKeyPurchaseHook;\n  ILockKeyCancelHook public onKeyCancelHook;\n\n  // Ensure that the Lock has not sold all of its keys.\n  modifier notSoldOut() {\n    require(maxNumberOfKeys > _totalSupply, 'LOCK_SOLD_OUT');\n    _;\n  }\n\n  modifier onlyLockManagerOrBeneficiary()\n  {\n    require(\n      isLockManager(msg.sender) || msg.sender == beneficiary,\n      'ONLY_LOCK_MANAGER_OR_BENEFICIARY'\n    );\n    _;\n  }\n\n  function _initializeMixinLockCore(\n    address payable _beneficiary,\n    uint _expirationDuration,\n    uint _keyPrice,\n    uint _maxNumberOfKeys\n  ) internal\n  {\n    require(_expirationDuration <= 100 * 365 * 24 * 60 * 60, 'MAX_EXPIRATION_100_YEARS');\n    unlockProtocol = IUnlock(msg.sender); // Make sure we link back to Unlock's smart contract.\n    beneficiary = _beneficiary;\n    expirationDuration = _expirationDuration;\n    keyPrice = _keyPrice;\n    maxNumberOfKeys = _maxNumberOfKeys;\n  }\n\n  // The version number of the current implementation on this network\n  function publicLockVersion(\n  ) public pure\n    returns (uint16)\n  {\n    return 9;\n  }\n\n  /**\n   * @dev Called by owner to withdraw all funds from the lock and send them to the `beneficiary`.\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\n   * the same as `tokenAddress` in MixinFunds.\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\n   *\n   * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n   * use cases.\n   */\n  function withdraw(\n    address _tokenAddress,\n    uint _amount\n  ) external\n    onlyLockManagerOrBeneficiary\n  {\n\n    // get balance\n    uint balance;\n    if(_tokenAddress == address(0)) {\n      balance = address(this).balance;\n    } else {\n      balance = IERC20Upgradeable(_tokenAddress).balanceOf(address(this));\n    }\n\n    uint amount;\n    if(_amount == 0 || _amount > balance)\n    {\n      require(balance > 0, 'NOT_ENOUGH_FUNDS');\n      amount = balance;\n    }\n    else\n    {\n      amount = _amount;\n    }\n\n    emit Withdrawal(msg.sender, _tokenAddress, beneficiary, amount);\n    // Security: re-entrancy not a risk as this is the last line of an external function\n    _transfer(_tokenAddress, beneficiary, amount);\n  }\n\n  /**\n   * A function which lets the owner of the lock change the pricing for future purchases.\n   * This consists of 2 parts: The token address and the price in the given token.\n   * In order to set the token to ETH, use 0 for the token Address.\n   */\n  function updateKeyPricing(\n    uint _keyPrice,\n    address _tokenAddress\n  )\n    external\n    onlyLockManager\n    onlyIfAlive\n  {\n    uint oldKeyPrice = keyPrice;\n    address oldTokenAddress = tokenAddress;\n    require(\n      _tokenAddress == address(0) || IERC20Upgradeable(_tokenAddress).totalSupply() > 0,\n      'INVALID_TOKEN'\n    );\n    keyPrice = _keyPrice;\n    tokenAddress = _tokenAddress;\n    emit PricingChanged(oldKeyPrice, keyPrice, oldTokenAddress, tokenAddress);\n  }\n\n  /**\n   * A function which lets the owner of the lock update the beneficiary account,\n   * which receives funds on withdrawal.\n   */\n  function updateBeneficiary(\n    address payable _beneficiary\n  ) external\n  {\n    require(msg.sender == beneficiary || isLockManager(msg.sender), 'ONLY_BENEFICIARY_OR_LOCKMANAGER');\n    require(_beneficiary != address(0), 'INVALID_ADDRESS');\n    beneficiary = _beneficiary;\n  }\n\n  /**\n   * @notice Allows a lock manager to add or remove an event hook\n   */\n  function setEventHooks(\n    address _onKeyPurchaseHook,\n    address _onKeyCancelHook\n  ) external\n    onlyLockManager()\n  {\n    require(_onKeyPurchaseHook == address(0) || _onKeyPurchaseHook.isContract(), 'INVALID_ON_KEY_SOLD_HOOK');\n    require(_onKeyCancelHook == address(0) || _onKeyCancelHook.isContract(), 'INVALID_ON_KEY_CANCEL_HOOK');\n    onKeyPurchaseHook = ILockKeyPurchaseHook(_onKeyPurchaseHook);\n    onKeyCancelHook = ILockKeyCancelHook(_onKeyCancelHook);\n  }\n\n  function totalSupply()\n    public\n    view returns(uint256)\n  {\n    return _totalSupply;\n  }\n\n  /**\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\n   */\n  function approveBeneficiary(\n    address _spender,\n    uint _amount\n  ) public\n    onlyLockManagerOrBeneficiary\n    returns (bool)\n  {\n    return IERC20Upgradeable(tokenAddress).approve(_spender, _amount);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n// SPDX-License-Identifier: MIT\n// Sources flattened with hardhat v2.4.1 https://hardhat.org\npragma solidity ^0.8.0;\n\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol@v2.5.0\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.2.0\n\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(initializing || !initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.2.0\n\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.2.0\n\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    // string private _name;\n    // string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        // _name = name_;\n        // _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    // function name() public view virtual override returns (string memory) {\n    //     return _name;\n    // }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    // function symbol() public view virtual override returns (string memory) {\n    //     return _symbol;\n    // }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[50] private ______gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return recover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return recover(hash, r, vs);\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    function __EIP712_init_unsafe(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    function __ERC20Permit_init_unsafe(string memory name) internal {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol@v4.2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol@v4.2.0\n\n\n\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init_unchained() internal initializer {\n    }\n\n    function __ERC20Votes_init_unsafe() internal {\n        if (_totalSupplyCheckpoints.length == 0 || _totalSupplyCheckpoints[_totalSupplyCheckpoints.length - 1].votes != totalSupply()) {\n            delete _totalSupplyCheckpoints;\n            _writeCheckpoint(_totalSupplyCheckpoints, _add, totalSupply());\n        }\n    }\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n    uint256[47] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol@v4.2.0\n\n\n\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {\n    function __ERC20VotesComp_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File scripts/udt-upgrade/ERC20Patched.template.sol\n\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\n\nabstract contract MinterRoleUpgradeable is Initializable, ContextUpgradeable {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    function initialize(address sender) public virtual initializer {\n        if (!isMinter(sender)) {\n            _addMinter(sender);\n        }\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20DetailedUpgradeable is Initializable, IERC20Upgradeable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    function initialize(string memory name, string memory symbol, uint8 decimals) public virtual initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    uint256[50] private ______gap;\n}\n\nabstract contract ERC20MintableUpgradeable is Initializable, ERC20Upgradeable, MinterRoleUpgradeable {\n    function initialize(address sender) public virtual override initializer {\n        MinterRoleUpgradeable.initialize(sender);\n    }\n\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinKeys.sol';\nimport './MixinRoles.sol';\n\n\n/**\n * @title Mixin allowing the Lock owner to grant / gift keys to users.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinGrantKeys is\n  MixinRoles,\n  MixinKeys\n{\n  /**\n   * Allows the Lock owner to give a collection of users a key with no charge.\n   * Each key may be assigned a different expiration date.\n   */\n  function grantKeys(\n    address[] calldata _recipients,\n    uint[] calldata _expirationTimestamps,\n    address[] calldata _keyManagers\n  ) external\n    onlyKeyGranterOrManager\n  {\n    for(uint i = 0; i < _recipients.length; i++) {\n      address recipient = _recipients[i];\n      uint expirationTimestamp = _expirationTimestamps[i];\n      address keyManager = _keyManagers[i];\n\n      require(recipient != address(0), 'INVALID_ADDRESS');\n\n      Key storage toKey = keyByOwner[recipient];\n      require(expirationTimestamp > toKey.expirationTimestamp, 'ALREADY_OWNS_KEY');\n\n      uint idTo = toKey.tokenId;\n\n      if(idTo == 0) {\n        _assignNewTokenId(toKey);\n        idTo = toKey.tokenId;\n        _recordOwner(recipient, idTo);\n      }\n      // Set the key Manager\n      _setKeyManagerOf(idTo, keyManager);\n      emit KeyManagerChanged(idTo, keyManager);\n\n      toKey.expirationTimestamp = expirationTimestamp;\n      // trigger event\n      emit Transfer(\n        address(0), // This is a creation.\n        recipient,\n        idTo\n      );\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Unlock.sol",
            "IPublicLock.sol",
            "MixinLockCore.sol",
            "PublicLock.sol",
            "ERC20Patched.sol",
            "MixinGrantKeys.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "notSoldOut",
                    "grantKey",
                    "_totalSupply",
                    "shareKey",
                    "_assignNewTokenId",
                    "maxNumberOfKeys",
                    "purchase"
                ],
                "Type": " Missing maxNumberOfKeys checks in shareKey and grantKey",
                "Description": "\nMore keys can be minted than maxNumberOfKeys since shareKey and grantKey do not check if the lock is sold out.\n\n\nMore keys can be minted than intended.\n\n\nIn both shareKey and grantKey, if minting a new token, a new token is simply minted (and _totalSupply increased) without checking it against maxNumberOfKeys.\nThis is unlike purchase, which has the notSoldOut modifier.\n\ngrantKey:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42\n\nshareKey:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84\nBoth functions call _assignNewTokenId which does not check maxNumberOfKeys.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322\nSo you can say that _assignNewTokenId is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).\n\n",
                "Repair": "\nAdd a check to _assignNewTokenId that will revert if we need to record a new key and maxNumberOfKeys has been reached.\n\njulien51 (Unlock Protocol) confirmed and commented(https://github.com/code-423n4/2021-11-unlock-findings/issues/55#issuecomment-1004066282):\n  This is actually intentional. We want the lock manager to be able to grant keys even if the lock is sold out. Note that the lock manager could also increase the supply if they needed anyway.\n  However, we should take that into account in the shareKey flow so I'll mark as confirmed for that flow.\n\n\n\n\n"
            }
        ]
    }
]