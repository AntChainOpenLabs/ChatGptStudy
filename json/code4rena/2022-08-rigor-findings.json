[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Community.sol",
            "Disputes.sol",
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "diff\ndiff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts\nindex ae9e202..752e01f 100644\n--a/test/utils/projectTests.ts\n+++ b/test/utils/projectTests.ts\n@@ -441,7 +441,7 @@ export const projectTests = async ({\n     }\n   });\n\n it('should be able to invite contractor', async () = {\n+  it.only('should be able to invite contractor', async () = {\n     expect(await project.contractor()).to.equal(ethers.constants.AddressZero);\n     const data = {\n       types: 'address', 'address'],\n@@ -452,6 +452,7 @@ export const projectTests = async ({\n       signers[1],\n     ]);\n     const tx = await project.inviteContractor(encodedData, signature);\n+    const tx2 = await project.setComplete(encodedData, signature);\n     await expect(tx)\n       .to.emit(project, 'ContractorInvited')\n       .withArgs(signers[1].address);\n"
                ],
                "Type": " Untyped data signing",
                "Description": "\nCommunity.sol#L175(https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L175)<br\nCommunity.sol#L213(https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L213)<br\nCommunity.sol#L530(https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L530)<br\nDisputes.sol#L91(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Disputes.sol#L91)<br\nProject.sol#L142(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L142)<br\nProject.sol#L167(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L167)<br\nProject.sol#L235(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L235)<br\nProject.sol#L286(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L286)<br\nProject.sol#L346(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L346)<br\nProject.sol#L402(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L402)<br\nProject.sol#L499(https://github.com/code-423n4/2022-08-rigor/blob/f2498c86dbd0e265f82ec76d9ec576442e896a87/contracts/Project.sol#L499)<br\n\nIn many places of the project (see affected code), untyped application data is directly hashed and signed. This is strongly disencouraged, as it enables different attacks (that each could be considered their own issue / vulnerability, but I submitted it as one, as they have all the same root cause):\n\n1.) Signature reuse across different Rigor projects:<br\nWhile some signature contain the project address, not all do. For instance, updateProjectHash only contains a _hash and a _nonce. Therefore, we can have the following scenario: Bob is the owner of project A and signs / submit updateProjectHash with nonce 0 and some hash. Then, a project B that also has Bob as the owner is created. Attacker Charlie can simply take the _data and _signature that Bob previously submitted to project A and send it to project B. As this project will have a nonce of 0 (fresh created), it will accept it. updateTaskHash is also affected by this.<br\n2.) Signature reuse across different chains:<br\nBecause the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let's say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user's (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains.<br\n3.) Signature reuse across Rigor functions:<br\nSome functions accept and decode data / signatures that were intended for other functions. For instance, see this example of providing the data & signature that was intended for inviteContractor to setComplete:\n\ndiff\ndiff --git a/test/utils/projectTests.ts b/test/utils/projectTests.ts\nindex ae9e202..752e01f 100644\n--a/test/utils/projectTests.ts\n+++ b/test/utils/projectTests.ts\n@@ -441,7 +441,7 @@ export const projectTests = async ({\n     }\n   });\n\n it('should be able to invite contractor', async () = {\n+  it.only('should be able to invite contractor', async () = {\n     expect(await project.contractor()).to.equal(ethers.constants.AddressZero);\n     const data = {\n       types: 'address', 'address'],\n@@ -452,6 +452,7 @@ export const projectTests = async ({\n       signers[1],\n     ]);\n     const tx = await project.inviteContractor(encodedData, signature);\n+    const tx2 = await project.setComplete(encodedData, signature);\n     await expect(tx)\n       .to.emit(project, 'ContractorInvited')\n       .withArgs(signers[1].address);\n\n\nWhile this reverts because there is no task that corresponds to the address that is signed there, this is not always the case.<br\n4.) Signature reuse from different Ethereum projects & phishing<br\nBecause the payload of these signatures is very generic (two addresses, a byte and two uints), there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his Rigor project in danger.\n\n",
                "Repair": "\nI strongly recommend to follow EIP-712(https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712:<br\n1.) There is always a domain separator that includes the contract address.<br\n2.) The chain ID is included in the domain separator<br\n3.) There is a type hash (of the function name / parameters)<br\n4.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)\n\nparv3213 (Rigor) confirmed(https://github.com/code-423n4/2022-08-rigor-findings/issues/75)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "Community.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "lastTimestamp",
                    "noOfDays",
                    "returnToLender()"
                ],
                "Type": " Builder can halve the interest paid to a community owner due to arithmetic rounding",
                "Description": "\nCommunity.sol#L685-L686(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L685-L686)<br\n\nDue to arithmetic rounding in returnToLender(), a builder can halve the APR paid to a community owner by paying every 1.9999 days. This allows a builder to drastically decrease the amount of interest paid to a community owner, which in turn allows them to advertise very high APR rates to secure funding, most of which they will not pay.\n\nThis issue occurs in the calculation of noOfDays in returnToLender() which calculates the number of days since interest has last been calculated. If a builder repays a very small amount of tokens every 1.9999 days, then the noOfDays will be rounded down to 1 days however lastTimestamp is updated to the current timestamp anyway, so the builder essentially accumulates only 1 day of interest after 2 days.\n\nI believe this is high severity because a community owner can have a drastic decrease in interest gained from a loan which counts as lost rewards. Additionally, this problem does not require a malicious builder because if a builder pays at a wrong time, the loaner receives less interest anyway.\n\n\n1.  A community owner provides a loan of 500_000 tokens to a builder with an APR of 10% (ignoring treasury fees)\n2.  Therefore, the community owner will expect an interest of 136.9 tokens per day (273.9 per 2 days)\n3.  A builder repays 0.000001 tokens at lastTimestamp + 2*86400 1\n4.  noOfDays rounds down to 1 thereby accumulating 500_000 * 100 * 1 / 365000 = 136 tokens for 2 days\n5.  Therefore, the community owner only receives 5% APR with negligible expenses for the builder\n\n\nVS Code\n\n",
                "Repair": "\nThere are two possible mitigations:\n\n1.  Add a scalar to noOfDays so that any rounding which occurs is negligible\n\ni.e.\n\nsolidity\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60\n\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000 /\n                SCALAR;\n\n\n2.  Remove the noOfDays calculation and calculate interest in one equation which reduces arithmetic rounding\n\nsolidity\nuint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                (block.timestamp -\n            _communityProject.lastTimestamp) /\n                365000 /\n                86400;\n\n\nzgorizzo69 (Rigor) confirmed(https://github.com/code-423n4/2022-08-rigor-findings/issues/180)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "escrow",
                    "_signature",
                    "_data"
                ],
                "Type": " Builder can call  Community.escrow  again to reduce debt further using same signatures",
                "Description": "\nCommunity.sol#L509(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Community.sol#L509)<br\n\nSince there is no nonce in the data decoded at the beginning of function escrow, a builder can call the function multiple times reducing their debt as much as they wish.\n\n\n*   A builder has a debt of $50,000\n*   A lender, a builder, and an escrow agent all ~~enter a bar~~ sign a message that will reduce the debt of the builder by $5,000, upon receipt of physical cash.\n*   Function escrow is called and debt is reduced to $45,000.\n*   The builder, using the same _data and _signature then calls escrow a further 9 times reducing their debt to zero.\n\n",
                "Repair": "\n1.  Similar to function publishProject, add a new field into the ProjectDetails(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/interfaces/ICommunity.sol#L19-L32) struct called escrowNonce.\n\n2.  Modify function escrow to check this nonce and update it after the debt has been reduced.\n\nSee the diff below for full changes.\n\ndiff\ndiff --git a/contracts/Community.sol b/contracts/Community.sol\nindex 1585670..b834d0e 100644\n--a/contracts/Community.sol\n+++ b/contracts/Community.sol\n@@ -15,7 +15,7 @@ import {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n /\n  * @title Community Contract for HomeFi v2.5.0\n-\n+\n  * @notice Module for coordinating lending groups on HomeFi protocol\n  */\n contract Community is\n@@ -520,10 +520,11 @@ contract Community is\n             address _agent,\n             address _project,\n             uint256 _repayAmount,\n+            uint256 _escrowNonce,\n             bytes memory _details\n         ) = abi.decode(\n                 _data,\n               (uint256, address, address, address, address, uint256, bytes)\n+                (uint256, address, address, address, address, uint256, uint256, bytes)\n             );\n\n         // Compute hash from bytes\n@@ -540,6 +541,12 @@ contract Community is\n             _lender == _communities[_communityID].owner,\n             \"Community::!Owner\"\n         );\n+        ProjectDetails storage _communityProject =\n+          _communities[_communityID].projectDetails[_project];\n+        require(\n+            _escrowNonce == _communityProject.escrowNonce,\n+            \"Community::invalid escrowNonce\"\n+        );\n\n         // check signatures\n         checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n@@ -548,6 +555,7 @@ contract Community is\n\n         // Internal call to reduce debt\n         _reduceDebt(_communityID, _project, _repayAmount, _details);\n+        _communityProject.escrowNonce = _communityProject.escrowNonce + 1;\n         emit DebtReducedByEscrow(_agent);\n     }\n\ndiff --git a/contracts/interfaces/ICommunity.sol b/contracts/interfaces/ICommunity.sol\nindex c45bbf0..652f51c 100644\n--a/contracts/interfaces/ICommunity.sol\n+++ b/contracts/interfaces/ICommunity.sol\n@@ -29,6 +29,7 @@ interface ICommunity {\n         uint256 lentAmount; // current principal lent to project (needs to be repaid by project's builder)\n         uint256 interest; // total accrued interest on lentAmount\n         uint256 lastTimestamp; // timestamp when last lending / repayment was made\n+        uint256 escrowNonce; // signing nonce to use when reducing debt by escrow\n     }\n\n\nzgorizzo69 (Rigor) confirmed(https://github.com/code-423n4/2022-08-rigor-findings/issues/161)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [
                    "lastTimestamp",
                    "lendToProject",
                    "repayLender",
                    "reduceDebt",
                    "escrow",
                    "lentAmount",
                    "claimInterest"
                ],
                "Type": " Wrong APR can be used when project is unpublished and published again ",
                "Description": "\nCommunity.sol#L267(https://github.com/code-423n4/2022-08-rigor/blob/e35f5f61be9ff4b8dc5153e313419ac42964d1fd/contracts/Community.sol#L267)<br\n\nWhen a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).\n\n\n1.) Project A is published in community I with an APR of 3%. The community lends 1,000,000 USD to the project.<br\n2.) Project A is unpublished, the lentAmount is still 1,000,000 USD.<br\n3.) During one year, no calls to repayLender, reduceDebt, or escrow happens, i.e. the interest is never added and the lastTimestamp not updated.<br\n4.) After one year, the project is published again in the same community. Because the FED raised interest rates, it is specified that the APR should be 5% from now on.<br\n5.) Another $1,000,000 is lent to the project by calling lendToProject. Now, claimInterest is called which calculates the interest of the last year for the first million. However, the function already uses the new APR of 5%, meaning the added interest is 50,000 USD instead of the correct 30,000 USD.\n\n",
                "Repair": "\nWhen publishing a project, if the lentAmount for the community is non-zero, calculate the interest before updating the APR.\n\nparv3213 (Rigor) confirmed(https://github.com/code-423n4/2022-08-rigor-findings/issues/83)\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/*******************************************************************************\n * ----------------------------------STRUCTS---------------------------------- *\n *******************************************************************************/\n\n// Task metadata\nstruct Task {\n    // Metadata //\n    uint256 cost; // Cost of task\n    address subcontractor; // Subcontractor of task\n    // Lifecycle //\n    TaskStatus state; // Status of task\n    mapping(uint256 => bool) alerts; // Alerts of task\n}\n\n/*******************************************************************************\n * -----------------------------------ENUMS----------------------------------- *\n *******************************************************************************/\n\nenum TaskStatus {\n    None,\n    Inactive,\n    Active,\n    Complete\n}\n\nenum Lifecycle {\n    None,\n    TaskAllocated,\n    SCConfirmed\n}\n\n/**\n * @title Tasks Library for HomeFi v2.5.0\n\n * @notice Internal library used in Project. Contains functions specific to a task actions and lifecycle.\n */\nlibrary Tasks {\n    /// @dev only allow inactive tasks. Task is inactive if SC is unconfirmed.\n    modifier onlyInactive(Task storage _self) {\n        require(_self.state == TaskStatus.Inactive, \"Task::active\");\n        _;\n    }\n\n    /// @dev only allow active tasks. Task is inactive if SC is confirmed.\n    modifier onlyActive(Task storage _self) {\n        require(_self.state == TaskStatus.Active, \"Task::!Active\");\n        _;\n    }\n\n    /// @dev only allow funded tasks.\n    modifier onlyFunded(Task storage _self) {\n        require(\n            _self.alerts[uint256(Lifecycle.TaskAllocated)],\n            \"Task::!funded\"\n        );\n        _;\n    }\n\n    /// MUTABLE FUNCTIONS ///\n\n    // Task Status Changing Functions //\n\n    /**\n     * @notice Create a new Task object\n\n     * @dev cannot operate on initialized tasks\n\n     * @param _self Task the task struct being mutated\n     * @param _cost uint the number of tokens to be escrowed in this contract\n     */\n    function initialize(Task storage _self, uint256 _cost) public {\n        _self.cost = _cost;\n        _self.state = TaskStatus.Inactive;\n        _self.alerts[uint256(Lifecycle.None)] = true;\n    }\n\n    /**\n     * @notice Attempt to transition task state from Payment Pending to Complete\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task whose state is being mutated\n     */\n    function setComplete(Task storage _self)\n        internal\n        onlyActive(_self)\n        onlyFunded(_self)\n    {\n        // State/ Lifecycle //\n        _self.state = TaskStatus.Complete;\n    }\n\n    // Subcontractor Joining //\n\n    /**\n     * @dev Invite a subcontractor to the task\n     * @dev modifier onlyInactive\n\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc address the subcontractor being invited\n     */\n    function inviteSubcontractor(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        _self.subcontractor = _sc;\n    }\n\n    /**\n     * @dev As a subcontractor, accept an invitation to participate in a task.\n     * @dev modifier onlyInactive\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc Address of sender\n     */\n    function acceptInvitation(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        // Prerequisites //\n        require(_self.subcontractor == _sc, \"Task::!SC\");\n\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = true;\n        _self.state = TaskStatus.Active;\n    }\n\n    // Task Funding //\n\n    /**\n     * @dev Set a task as funded\n\n     * @param _self Task the task being set as funded\n     */\n    function fundTask(Task storage _self) internal {\n        // State/ Lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = true;\n    }\n\n    /**\n     * @dev Set a task as un-funded\n\n     * @param _self Task the task being set as funded\n     */\n    function unAllocateFunds(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = false;\n    }\n\n    /**\n     * @dev Set a task as un accepted/approved for SC\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task being set as funded\n     */\n    function unApprove(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n        _self.state = TaskStatus.Inactive;\n    }\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * @dev Determine the current state of all alerts in the project\n\n     * @param _self Task the task being queried for alert status\n\n     * @return _alerts bool[3] array of bool representing whether Lifecycle alert has been reached\n     */\n    function getAlerts(Task storage _self)\n        internal\n        view\n        returns (bool[3] memory _alerts)\n    {\n        uint256 _length = _alerts.length;\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n    }\n\n    /**\n     * @dev Return the numerical encoding of the TaskStatus enumeration stored as state in a task\n\n     * @param _self Task the task being queried for state\n     \n     * @return _state uint 0: none, 1: inactive, 2: active, 3: complete\n     */\n    function getState(Task storage _self)\n        internal\n        view\n        returns (uint256 _state)\n    {\n        return uint256(_self.state);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Tasks.sol",
            "Community.sol",
            "Disputes.sol",
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "changeOrder",
                    "allocateFunds()",
                    "acceptInvite()",
                    "it('should be able to complete a task'",
                    "setComplete()",
                    "unApprove()",
                    "changeOrder()"
                ],
                "Type": " Project funds can be drained by reusing signatures, in some cases",
                "Description": "\nProject.sol#L386-L490(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490)<br\nProject.sol#L330-L359(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330-L359)<br\nTasks.sol#L153-L164(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/libraries/Tasks.sol#L153-L164)<br\n\nThis attack path is the results of signatures reusing in 2 functions changeOrder() and setComplete(), and a missing modifier at Tasks.unApprove() library function.\n\n\n\nCurrent or previous subcontractor of a task can drain the project out of its funds by running setComplete() multiple times.\n\nThis can be exploited in 3 scenarios:\n\n*   The price of a task was changed to a price higher than available funds (i.e. totalLent _totalAllocated, and therefore gets unapproved), and than changed back to the original price (or any price that's not higher than available funds)\n*   The subcontractor for a task was changed via changeOrder and then changed back to the original subcontractor\n    *   e.g. Bob was the original SC, it was changed to Alice, and then back to Bob\n*   Similar to the case above, but even if the current SC is different from the original SC it can still work if the current and previous SCs are teaming up to run the attack\n    *   e.g. Bob was the original SC, it was changed to Alice, and changed again to Eve. And now Alice and Eve are teaming up to drain funds from the project\n\nAfter setComplete() ran once by the legitimate users (i.e. signed by contractor, SC and builder), the attackers can now run it multiple times:\n\n*   Reuse signatures to run changeOrder() changing SC or setting the price to higher than available funds\n    *   The only signer that might change is the subcontractor, he's either teaming up with the attacker (scenario #3) or he was the SC when it was first called (scenario #2)\n*   In case of price change:\n    *   change it back to the original price via changeOrder(), reusing signatures\n    *   Run allocateFunds() to mark it as funded again\n*   SC runs acceptInvite() to mark task as active\n*   Run setComplete() reusing signatures\n    *   If SC has changed replace his signature with the current one (current SC should be one of the attackers)\n*   Repeat till the project runs out of funds\n\n\nThis can also be used by external users (you don't need to be builder/GC/SC in order to run changeOrder()) to troll the system (This still requires the task to be changed at least twice, otherwise re-running changeOrder() with the same data would have no effect).\n\n*   Changing the task cost up or down, getting the SC paid a different amount than intended (if it goes unnoticed, or front-run the setComplete() function)\n*   Unapproving a task by setting a different SC or a price higher than available funds\n    *   The legitimate users can change it back, but the attacker can change it again, both sides playing around till someone gets tired :)\n\n\nSince the tests depend on each other, the PoC tests were created by adding them to the file test/utils/projectTests.ts, after the function it('should be able to complete a task' ([Line 1143(https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/test/utils/projectTests.ts#L1143)).\n\nIn the first test a subcontractor is changed and then changed back.<br\nIn the second scenario a price is changed to the new price (that is higher than the total available funds, and therefore is unapproved) and then back to its original price (it can actually be any price that is not higher than the available funds).<br\nIn both cases I'm demonstrating how the project can be drained out of fund.\n\n*Note: see warden's original submission(https://github.com/code-423n4/2022-08-rigor-findings/issues/95) for full proof of concept.*\n\n\nHardhat\n\n",
                "Repair": "\n*   Use nonce to protect setComplete() and changeOrder() from signatures reuse\n*   Add the onlyActive() modifier to Tasks.unApprove()\n*   Consider limiting allocateFunds() for builder only (this is not necessary to resolve the bug, just for hardening security)\n\nzgorizzo69 (Rigor) confirmed and commented(https://github.com/code-423n4/2022-08-rigor-findings/issues/95#issuecomment-1210501767):\n  Very nice wrap up.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @title SignatureDecoder for HomeFi v2.5.0\n \n * @notice Decodes signatures that a encoded as bytes\n */\nlibrary SignatureDecoder {\n    /**\n    * @dev Recovers address who signed the message\n\n    * @param messageHash bytes32 - keccak256 hash of message\n    * @param messageSignatures bytes - concatenated message signatures\n    * @param pos uint256 - which signature to read\n\n    * @return address - recovered address\n    */\n    function recoverKey(\n        bytes32 messageHash,\n        bytes memory messageSignatures,\n        uint256 pos\n    ) internal pure returns (address) {\n        if (messageSignatures.length % 65 != 0) {\n            return (address(0));\n        }\n\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = signatureSplit(messageSignatures, pos);\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);\n        }\n    }\n\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n\n    /**\n    * @dev Divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\n    * @dev Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\n\n    * @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\n    * @param signatures concatenated rsv signatures\n    */\n    function signatureSplit(bytes memory signatures, uint256 pos)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let signaturePos := mul(0x41, pos)\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n            v := byte(0, mload(add(signatures, add(signaturePos, 0x60))))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Community.sol",
            "SignatureDecoder.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "community",
                    "recoverKey",
                    "_signature",
                    "checkSignatureValidity(_newMemberAddr, _hash, _signature,",
                    "_data",
                    "address(",
                    "ecrecover",
                    "_address",
                    "_newMemberAddr",
                    "_communities[_communityID]",
                    "_recoveredSignature",
                    "checkSignatureValidity",
                    "v !=",
                    "addMember",
                    "_communityID",
                    "signature"
                ],
                "Type": " Add members to the not yet created community",
                "Description": "\nCommunity.sol#L187(https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L187)<br\nCommunity.sol#L179(https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L179)<br\nCommunity.sol#L878(https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Community.sol#L878)<br\nSignatureDecoder.sol#L39(https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/libraries/SignatureDecoder.sol#L39)<br\n\nThere is a addMember function in the Community.  The function accepts _data that should be signed by the _community.owner and _newMemberAddr.\n\n            // Compute hash from bytes\n            bytes32 _hash = keccak256(_data);\n\n            // Decode params from _data\n            (\n                uint256 _communityID,\n                address _newMemberAddr,\n                bytes memory _messageHash\n            ) = abi.decode(_data, (uint256, address, bytes));\n\n            CommunityStruct storage _community = _communities[_communityID];\n\n            // check signatures\n            checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n            checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\nThe code above shows exactly what the contract logic looks like.\n\n1.  _communityID is taken from the data provided by user, so it can arbitrarily. Specifically,  community with selected _communityID can be not yet created. For instance, it can be equal to the communityCount + 1, thus the next created community will have this _communityID.\n\n2.  _communities[_communityID] will store null values for all fields, for a selected _communityID. That means, _community.owner == address(0)\n\n3.  checkSignatureValidity with a parameters address(0), _hash, _signature, 0 will not revert a call if an attacker provide incorrect _signature.\n\nLet's see the implementation of checkSignatureValidity:\n\n            // Decode signer\n            address _recoveredSignature = SignatureDecoder.recoverKey(\n                _hash,\n                _signature,\n                _signatureIndex\n            );\n\n            // Revert if decoded signer does not match expected address\n            // Or if hash is not approved by the expected address.\n            require(\n                _recoveredSignature == _address || approvedHashes[_address][_hash],\n                \"Community::invalid signature\"\n            );\n\n            // Delete from approvedHash. So that signature cannot be reused.\n            delete approvedHashes[_address][_hash];\n\nNo restrictions on _recoveredSignature or _address. Moreover, if SignatureDecoder.recoverKey can return zero value, then there will be no revert.\n\n           if (messageSignatures.length % 65 != 0) {\n                return (address(0));\n            }\n\n            uint8 v;\n            bytes32 r;\n            bytes32 s;\n            (v, r, s) = signatureSplit(messageSignatures, pos);\n\n            // If the version is correct return the signer address\n            if (v != 27 && v != 28) {\n                return (address(0));\n            } else {\n                // solium-disable-next-line arg-overflow\n                return ecrecover(toEthSignedMessageHash(messageHash), v, r, s);\n            }\n\nAs we can see below, recoverKey function can return zero value, if an ecrecover return zero value or if v != 27 || v != 28. Both cases are completely dependent on the input parameters to the function, namely from signature that is provided by attacker.\n\n4.  checkSignatureValidity(_newMemberAddr, _hash, _signature, 1) will not revert the call if an attacker provide correct signature in the function. It is obviously possible.\n\nAll in all, an attacker can add as many members as they want, BEFORE the community will be created.\n\n",
                "Repair": "\n1.  checkSignatureValidity/recoverKey should revert the call if an address == 0.\n2.  addMember should have a require(_communityId <= communityCount)\n\nparv3213 (Rigor) confirmed(https://github.com/code-423n4/2022-08-rigor-findings/issues/298)\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-08-rigor-findings/issues/298#issuecomment-1229125034):\n  Nice catch!\n \n Btw, this v != 27 && v != 28 check is no longer needed:\n \n solidity\n if (v != 27 && v != 28) {\n             return (address(0));\n }\n \n \n See: https://twitter.com/alexberegszaszi/status/1534461421454606336?s=20&t=H0Dv3ZT2bicx00hLWJk7Fg\n\n\n\n*\n\n\n"
            }
        ]
    }
]