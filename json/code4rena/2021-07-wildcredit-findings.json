[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IController.sol';\nimport './interfaces/IRewardDistribution.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ERC20.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is TransferHelper {\n\n  // Prevents division by zero and other undesirable behaviour\n  uint public constant MIN_RESERVE = 1000;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public debtOf;\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\n  mapping (address => uint) public totalDebt;\n  mapping (address => IERC20) public lpToken;\n\n  IController public controller;\n  address public tokenA;\n  address public tokenB;\n  uint public lastBlockAccrued;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n\n  receive() external payable {}\n\n  function initialize(\n    address _lpTokenMaster,\n    address _controller,\n    IERC20 _tokenA,\n    IERC20 _tokenB\n  ) external {\n    require(address(tokenA) == address(0), \"LendingPair: already initialized\");\n    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), \"LendingPair: cannot be ZERO address\");\n\n    controller = IController(_controller);\n    tokenA = address(_tokenA);\n    tokenB = address(_tokenB);\n    lastBlockAccrued = block.number;\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable {\n    accrueAccount(_account);\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external {\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n    _checkMinReserve(address(WETH));\n  }\n\n  function withdraw(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdraw(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(_token)].balanceOf(msg.sender);\n    _withdraw(_token, amount);\n    _safeTransfer(IERC20(_token), msg.sender, amount);\n  }\n\n  function withdrawAllETH() external {\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);\n    _withdraw(address(WETH), amount);\n    _wethWithdrawTo(msg.sender, amount);\n  }\n\n  function borrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _borrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    uint amount = debtOf[_token][_account];\n    _repay(_account, _token, amount);\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account) external payable {\n    accrueAccount(_account);\n\n    uint amount = debtOf[address(WETH)][_account];\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n\n    _depositWeth();\n    _repay(_account, address(WETH), amount);\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _repay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue() public {\n    if (lastBlockAccrued < block.number) {\n      _accrueInterest(tokenA);\n      _accrueInterest(tokenB);\n      lastBlockAccrued = block.number;\n    }\n  }\n\n  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {\n      return controller.LIQ_MIN_HEALTH();\n    }\n\n    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);\n    uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrrow;\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    return _borrowBalance(_account, _borrowedToken, _returnToken);\n  }\n\n  function supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _borrowRatePerBlock(_token);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccountInterest(_account);\n    _accrueAccountInterest(feeRecipient());\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);\n    return newInterest * _lpRate(_token) / 100e18;\n  }\n\n  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _pendingBorrowInterest(_token, _account);\n  }\n\n  function feeRecipient() public view returns(address) {\n    return controller.feeRecipient();\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= controller.LIQ_MIN_HEALTH(), \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt = debtOf[_token][_account];\n    uint repayAmount = debt > _amount ? _amount : debt;\n\n    if (repayAmount > 0) {\n      _repay(_account, _token, repayAmount);\n    }\n\n    uint depositAmount = _amount - repayAmount;\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n\n    if (withdrawAmount > 0) {\n      _withdraw(_token, withdrawAmount);\n    }\n\n    uint borrowAmount = _amount - withdrawAmount;\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  function _distributeReward(address _account) internal {\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\n\n    if (address(rewardDistribution) != address(0)) {\n      rewardDistribution.distributeReward(_account, tokenA);\n      rewardDistribution.distributeReward(_account, tokenB);\n    }\n  }\n\n  function _mintSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].mint(_account, _amount);\n    }\n  }\n\n  function _burnSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].burn(_account, _amount);\n    }\n  }\n\n  function _mintDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] += _amount;\n    totalDebt[_token] += _amount;\n  }\n\n  function _burnDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] -= _amount;\n    totalDebt[_token] -= _amount;\n  }\n\n  function _accrueAccountInterest(address _account) internal {\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\n\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\n    _accrueAccountDebt(tokenA, _account);\n    _accrueAccountDebt(tokenB, _account);\n\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\n  }\n\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\n    if (_amount > 0) {\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\n\n      _mintSupply(_token, _account, newSupplyAccount);\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\n    }\n  }\n\n  function _accrueAccountDebt(address _token, address _account) internal {\n    if (debtOf[_token][_account] > 0) {\n      uint newDebt = _pendingBorrowInterest(_token, _account);\n      _mintDebt(_token, _account, newDebt);\n    }\n  }\n\n  function _withdraw(address _token, uint _amount) internal {\n\n    lpToken[address(_token)].burn(msg.sender, _amount);\n\n    checkAccountHealth(msg.sender);\n\n    emit Withdraw(_token, _amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(lpToken[address(_token)].balanceOf(msg.sender) == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebt(_token, msg.sender, _amount);\n\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repay(address _account, address _token, uint _amount) internal {\n    _burnDebt(_token, _account, _amount);\n    emit Repay(_account, _token, _amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    _checkOracleSupport(tokenA);\n    _checkOracleSupport(tokenB);\n\n    require(debtOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupply(_token, _account, _amount);\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _accrueInterest(address _token) internal {\n    uint blocksElapsed = block.number - lastBlockAccrued;\n    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;\n    cumulativeInterestRate[_token] += newInterest;\n  }\n\n  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize();\n    return IERC20(newLPToken);\n  }\n\n  function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {\n    if (_amount > 0) {\n      bool success = _token.transfer(_recipient, _amount);\n      require(success, \"LendingPair: transfer failed\");\n      _checkMinReserve(address(_token));\n    }\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal override {\n    if (_amount > 0) {\n      TransferHelper._wethWithdrawTo(_to, _amount);\n      _checkMinReserve(address(WETH));\n    }\n  }\n\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\n    return _newInterest(debtOf[_token][_account], _token, _account);\n  }\n\n  function _borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));\n  }\n\n  function _supplyCredit(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;\n  }\n\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) internal view returns(uint) {\n\n    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _checkOracleSupport(address _token) internal view {\n    require(controller.tokenSupported(_token), \"LendingPair: token not supported\");\n  }\n\n  function _checkMinReserve(address _token) internal view {\n    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, \"LendingPair: below MIN_RESERVE\");\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    require(controller.depositsEnabled(), \"LendingPair: deposits disabled\");\n\n    uint depositLimit = controller.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require((lpToken[_token].totalSupply()) <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    require(controller.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n\n    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;\n    require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");\n\n    uint borrowLimit = controller.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebt[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _systemRate(address _token) internal view returns(uint) {\n    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return 100e18 - _systemRate(_token);\n  }\n\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\n    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;\n  }\n}\n\n\n",
        "CodeNames": [
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction accrueAccount(address _account) public {\n  // distributes before updating accrual state\n  _distributeReward(_account);\n  accrue();\n  _accrueAccountInterest(_account);\n\n  if (_account != feeRecipient()) {\n    _accrueAccountInterest(feeRecipient());\n  }\n}\n"
                ],
                "Type": " Reward computation is wrong",
                "Description": "\nThe LendingPair.accrueAccount function distributes rewards before updating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt).\nThis means the percentage of the user's balance to the total is not correct as the total can be updated several times in between.\n\nsolidity\nfunction accrueAccount(address _account) public {\n  // distributes before updating accrual state\n  _distributeReward(_account);\n  accrue();\n  _accrueAccountInterest(_account);\n\n  if (_account != feeRecipient()) {\n    _accrueAccountInterest(feeRecipient());\n  }\n}\n\n\nExample: Two users deposit the same amounts in the same block. Thus, after some time they should receive the same tokens.\n1. User A and B deposit 1000 tokens (in the same block) and are minted 1000 tokens in return. Total supply = 2000\n2. Assume after 50,000 blocks, A calls accrueAccount(A) which first calls _distributeReward. A is paid out 1000/2000 = 50% of the 50,000 blocks reward since deposit. Afterwards, accrue + _accrueAccountInterest(A) is called and A is minted 200 more tokens due to supplier lending rate. The supply totalSupply is now 2200.\n3. After another 50,000 blocks, A calls accrueAccount(A) again. which first calls _distributeReward. A is paid out 1200/2200 = 54.5454% of the 50,000 blocks reward since deposit.\n\nFrom here, you can already see that A receives more than 50% of the 100,000 block rewards although they deposited at the same time as B and didn't deposit or withdraw any funds.\nB will receive ~1000/2200 = 45% (ignoring any new LP supply tokens minted for A's second claim.)\n\nThe impact is that wrong rewards will be minted users which do not represent their real fair share. Usually, users will get fewer rewards than they should receive, as their individual interest was not updated yet, but the totals (total debt and total supply) could have been updated by other accounts in between.\n\nThere are two issues that both contribute to it:\ntotal LP supply and total debt must be updated by the total new interest when accrue is called, not only increased by an individual user's interest. See my other issue \"Reward computation is wrong\" that goes into more depth\nLending/borrow accrual must happen before reward distribution\n\ntalegift (Wild Credit) acknowledged but disagreed with severity(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/116#issuecomment-880581152):\n  _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements._\n\n Update to severity 2\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/116#issuecomment-890597758):\n  Disagree with sponsor about severity, this is significant accounting error.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-02",
                "Location": [
                    "_accrueAccountInterest",
                    "cumulativeInterestRate",
                    "liquidateAccount"
                ],
                "Type": "  LendingPair.liquidateAccount  does not accrue and update  cumulativeInterestRate ",
                "Description": "\nThe LendingPair.liquidateAccount function does not accrue and update the cumulativeInterestRate first, it only calls _accrueAccountInterest which does not update and instead uses the old cumulativeInterestRate.\n\nThe liquidatee (borrower)'s state will not be up-to-date.\nI could skip some interest payments by liquidating myself instead of repaying if I'm under-water.\nAs the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.\n\n",
                "Repair": "Recommend calling accrueAccount instead of _accrueAccountInterest\n\ntalegift (Wild Credit) confirmed but disagreed with severity(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122#issuecomment-880580414):\n  _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements._\n\n Update to severity 2\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/122#issuecomment-890597983):\n  No funds are lost however a user can steal \"unpaid interest\" from the protocol. Keeping high risk.\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "liquidateAccount",
                    "supplyOutput",
                    "_safeTransfer(IERC"
                ],
                "Type": "  LendingPair.liquidateAccount  fails if tokens are lent out",
                "Description": "\nThe LendingPair.liquidateAccount function tries to pay out underlying supply tokens to the liquidator using _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput) but there's no reason why there should be enough supplyOutput amount in the contract, the contract only ensures minReserve.\n\nAs a result, no liquidations can be performed if all tokens are lent out.\nExample: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves minReserve). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.\n\n",
                "Repair": "Recommend minting LP supply tokens to msg.sender instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.\n\ntalegift (Wild Credit) confirmed but disagreed with severity(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123#issuecomment-880580148):\n  _Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements._\n\n Update to severity 2\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123#issuecomment-890598465):\n  If liquidation is impossible, there's insolvency risk and that creates a risk to lose user funds. Keeping high severity.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nusdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]})\nlending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]})\n",
                    "//solidity\n  Error: Transaction reverted: function returned an unexpected amount of data\n      at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)\n      at LendingPair.deposit (contracts/LendingPair.sol:95)\n"
                ],
                "Type": "  safeTransferFrom  in  TransferHelper  is not  safeTransferFrom ",
                "Description": "\nA non standard ERC20 token would always raise error when calling _safeTransferFrom.  If a user creates a USDT/DAI pool and deposit into the pool he would find out there's never a counterpart deposit. See TransferHelper.sol #L19(https://github.com/code-423n4/2021-07-wildcredit/blob/82c48d73fd27a9d4d5d4a395b3affcef4ef6c5c8/contracts/TransferHelper.sol#L19).\n\nTransferHelper does not uses SafeERC20 library as the function name implies.\n\nA sample POC:\nsolidity\nusdt.functions.approve(lending_pair.address, deposit_amount).transact({'from': w3.eth.accounts[0]})\nlending_pair.functions.deposit(w3.eth.accounts[0], usdt.address, deposit_amount).transact({'from': w3.eth.accounts[0]})\n\n\nError Message:\nsolidity\n  Error: Transaction reverted: function returned an unexpected amount of data\n      at LendingPair._safeTransferFrom (contracts/TransferHelper.sol:20)\n      at LendingPair.deposit (contracts/LendingPair.sol:95)\n\n\n",
                "Repair": "Recommend using openzeppelin SafeERC20 in transferHelper (and any other contract that uses IERC20).\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67)\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/67#issuecomment-890585396):\n  This can effect deposits so it's a medium risk.\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\n  // Prevents division by zero and other undesirable behavior\n  uint public constant MIN_RESERVE = 1000;\n"
                ],
                "Type": "  _wethWithdrawTo  is vulnerable re-entrancy",
                "Description": "\nThe function withdrawBorrowETH invokes _wethWithdrawTo and later _checkMinReserve, however, the check of reserve is not necessary here, as function _wethWithdrawTo also does that after transferring the ether. However, this reserve check might be bypassed as TransferHelper._wethWithdrawTo uses a low level call that is vulnerable to re-entrancy attacks. As this MIN_RESERVE sounds like an important value, you should consider preventing re-entrancy attacks here.\nsolidity\n  // Prevents division by zero and other undesirable behavior\n  uint public constant MIN_RESERVE = 1000;\n\n",
                "Repair": "Recommend considering using re-entrancy guard(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) on all main action functions (e.g. deposit, withdraw, borrow,repay, etc...):\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/71)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV3Pool.sol';\nimport './interfaces/IUniswapV3Factory.sol';\nimport './interfaces/ILinkOracle.sol';\nimport './interfaces/IUniswapPriceConverter.sol';\nimport './external/Ownable.sol';\n\ncontract UniswapV3Oracle is Ownable {\n\n  IUniswapV3Factory public constant uniFactory    = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n  ILinkOracle       public constant wethOracle    = ILinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n  address           public constant WETH          = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  uint24            public constant WETH_POOL_FEE = 3000;\n\n  struct Pool {\n    address pairToken;\n    uint24  poolFee;\n  }\n\n  uint32 public twapPeriod;\n  uint   public minObservations;\n\n  IUniswapPriceConverter public uniPriceConverter;\n\n  mapping(address => Pool) public pools;\n\n  event PoolAdded(address indexed token);\n  event PoolRemoved(address indexed token);\n\n  constructor(\n    IUniswapPriceConverter _uniPriceConverter,\n    uint32       _twapPeriod,\n    uint         _minObservations\n  ) {\n    uniPriceConverter = _uniPriceConverter;\n    twapPeriod        = _twapPeriod;\n    minObservations   = _minObservations;\n  }\n\n  function addPool(\n    address _token,\n    address _pairToken,\n    uint24  _poolFee\n  ) external onlyOwner {\n\n    _validatePool(_token, _pairToken, _poolFee);\n\n    pools[_token] = Pool({\n      pairToken: _pairToken,\n      poolFee: _poolFee\n    });\n\n    emit PoolAdded(_token);\n  }\n\n  function removePool(address _token) external onlyOwner {\n    pools[_token] = Pool(address(0), 0);\n    emit PoolRemoved(_token);\n  }\n\n  function setUniPriceConverter(IUniswapPriceConverter _value) external onlyOwner {\n    uniPriceConverter = _value;\n  }\n\n  function setTwapPeriod(uint32 _value) external onlyOwner {\n    twapPeriod = _value;\n  }\n\n  function setMinObservations(uint _value) external onlyOwner {\n    minObservations = _value;\n  }\n\n  function tokenPrice(address _token) external view returns(uint) {\n    require(pools[_token].pairToken != address(0), \"UniswapV3Oracle: token not supported\");\n    _validatePool(_token, pools[_token].pairToken, pools[_token].poolFee);\n\n    uint ethValue = uniPriceConverter.assetToAssetThruRoute(\n      _token,\n      10 ** IERC20(_token).decimals(),\n      WETH,\n      twapPeriod,\n      pools[_token].pairToken,\n      [pools[_token].poolFee, WETH_POOL_FEE]\n    );\n\n    return ethValue * ethPrice() / 1e18;\n  }\n\n  function ethPrice() public view returns(uint) {\n    return wethOracle.latestAnswer() * 1e10;\n  }\n\n  function isPoolValid(address _token, address _pairToken, uint24 _poolFee) public view returns(bool) {\n    address poolAddress = uniFactory.getPool(_token, _pairToken, _poolFee);\n    if (poolAddress == address(0)) { return false; }\n\n    (, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();\n    return observationSlots >= minObservations;\n  }\n\n  function tokenSupported(address _token) external view returns(bool) {\n    return pools[_token].pairToken != address(0);\n  }\n\n  function _validatePool(address _token, address _pairToken, uint24 _poolFee) internal view {\n    require(isPoolValid(_token, _pairToken, _poolFee), \"UniswapV3Oracle: invalid pool\");\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapV3Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n  (\n    roundId,\n    rawPrice,\n    ,\n    updateTime,\n    answeredInRound\n  ) = AggregatorV3Interface(XXXXX).latestRoundData();\n  require(rawPrice  0, \"Chainlink price <= 0\");\n  require(updateTime != 0, \"Incomplete round\");\n  require(answeredInRound = roundId, \"Stale price\");\n"
                ],
                "Type": " Chainlink - Use  latestRoundData  instead of  latestAnswer  to run more validations",
                "Description": "\nUniswapV3Oracle.sol is calling latestAnswer to get the last WETH price. This method will return the last value, but you won't be able to check if the data is fresh.\nOn the other hand, calling the method latestRoundData allow you to run some extra validations\n\nsolidity\n  (\n    roundId,\n    rawPrice,\n    ,\n    updateTime,\n    answeredInRound\n  ) = AggregatorV3Interface(XXXXX).latestRoundData();\n  require(rawPrice  0, \"Chainlink price <= 0\");\n  require(updateTime != 0, \"Incomplete round\");\n  require(answeredInRound = roundId, \"Stale price\");\n\n\nSee the chainlink documentation(https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round) for more information.\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75)\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75#issuecomment-890584877):\n  Since slate prices could have quite serious consequences, I'll bump it to medium risk.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IERC20.sol';\n\nimport './external/Math.sol';\n\ncontract InterestRateModel {\n\n  // Per block\n  uint public constant MIN_RATE  = 0;\n  uint public constant LOW_RATE  = 8371385083713;   // 20%    / year = 20e18   / 365 / 86400 * 13.2 (block time)\n  uint public constant HIGH_RATE = 418569254185692; // 1,000% / year = 1000e18 / 365 / 86400 * 13.2 (block time)\n\n  uint public constant TARGET_UTILIZATION = 80e18; // 80%\n  uint public constant SYSTEM_RATE        = 50e18; // share of fees earned by the system\n\n  function supplyRatePerBlock(ILendingPair _pair, address _token) external view returns(uint) {\n    return borrowRatePerBlock(_pair, _token) * (100e18 - SYSTEM_RATE) / 100e18;\n  }\n\n  function borrowRatePerBlock(ILendingPair _pair, address _token) public view returns(uint) {\n    uint debt = _pair.totalDebt(_token);\n    uint supply = IERC20(_pair.lpToken(_token)).totalSupply();\n\n    if (supply == 0 || debt == 0) { return MIN_RATE; }\n\n    uint utilization = Math.min(debt * 100e18 / supply, 100e18);\n\n    if (utilization < TARGET_UTILIZATION) {\n      uint rate = LOW_RATE * utilization / 100e18;\n      return (rate < MIN_RATE) ? MIN_RATE : rate;\n    } else {\n      utilization = 100e18 * ( debt - (supply * TARGET_UTILIZATION / 100e18) ) / (supply * (100e18 - TARGET_UTILIZATION) / 100e18);\n      utilization = Math.min(utilization, 100e18);\n      return LOW_RATE + (HIGH_RATE - LOW_RATE) * utilization / 100e18;\n    }\n  }\n\n  function utilizationRate(ILendingPair _pair, address _token) external view returns(uint) {\n    uint debt = _pair.totalDebt(_token);\n    uint supply = IERC20(_pair.lpToken(_token)).totalSupply();\n\n    if (supply == 0 || debt == 0) { return 0; }\n\n    return Math.min(debt * 100e18 / supply, 100e18);\n  }\n\n  // InterestRateModel can later be replaced for more granular fees per _lendingPair\n  function systemRate(ILendingPair _pair, address _token) external pure returns(uint) {\n    return SYSTEM_RATE;\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IController.sol';\nimport './interfaces/IRewardDistribution.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ERC20.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is TransferHelper {\n\n  // Prevents division by zero and other undesirable behaviour\n  uint public constant MIN_RESERVE = 1000;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public debtOf;\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\n  mapping (address => uint) public totalDebt;\n  mapping (address => IERC20) public lpToken;\n\n  IController public controller;\n  address public tokenA;\n  address public tokenB;\n  uint public lastBlockAccrued;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n\n  receive() external payable {}\n\n  function initialize(\n    address _lpTokenMaster,\n    address _controller,\n    IERC20 _tokenA,\n    IERC20 _tokenB\n  ) external {\n    require(address(tokenA) == address(0), \"LendingPair: already initialized\");\n    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), \"LendingPair: cannot be ZERO address\");\n\n    controller = IController(_controller);\n    tokenA = address(_tokenA);\n    tokenB = address(_tokenB);\n    lastBlockAccrued = block.number;\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable {\n    accrueAccount(_account);\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external {\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n    _checkMinReserve(address(WETH));\n  }\n\n  function withdraw(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdraw(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(_token)].balanceOf(msg.sender);\n    _withdraw(_token, amount);\n    _safeTransfer(IERC20(_token), msg.sender, amount);\n  }\n\n  function withdrawAllETH() external {\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);\n    _withdraw(address(WETH), amount);\n    _wethWithdrawTo(msg.sender, amount);\n  }\n\n  function borrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _borrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    uint amount = debtOf[_token][_account];\n    _repay(_account, _token, amount);\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account) external payable {\n    accrueAccount(_account);\n\n    uint amount = debtOf[address(WETH)][_account];\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n\n    _depositWeth();\n    _repay(_account, address(WETH), amount);\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _repay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue() public {\n    if (lastBlockAccrued < block.number) {\n      _accrueInterest(tokenA);\n      _accrueInterest(tokenB);\n      lastBlockAccrued = block.number;\n    }\n  }\n\n  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {\n      return controller.LIQ_MIN_HEALTH();\n    }\n\n    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);\n    uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrrow;\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    return _borrowBalance(_account, _borrowedToken, _returnToken);\n  }\n\n  function supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _borrowRatePerBlock(_token);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccountInterest(_account);\n    _accrueAccountInterest(feeRecipient());\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);\n    return newInterest * _lpRate(_token) / 100e18;\n  }\n\n  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _pendingBorrowInterest(_token, _account);\n  }\n\n  function feeRecipient() public view returns(address) {\n    return controller.feeRecipient();\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= controller.LIQ_MIN_HEALTH(), \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt = debtOf[_token][_account];\n    uint repayAmount = debt > _amount ? _amount : debt;\n\n    if (repayAmount > 0) {\n      _repay(_account, _token, repayAmount);\n    }\n\n    uint depositAmount = _amount - repayAmount;\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n\n    if (withdrawAmount > 0) {\n      _withdraw(_token, withdrawAmount);\n    }\n\n    uint borrowAmount = _amount - withdrawAmount;\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  function _distributeReward(address _account) internal {\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\n\n    if (address(rewardDistribution) != address(0)) {\n      rewardDistribution.distributeReward(_account, tokenA);\n      rewardDistribution.distributeReward(_account, tokenB);\n    }\n  }\n\n  function _mintSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].mint(_account, _amount);\n    }\n  }\n\n  function _burnSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].burn(_account, _amount);\n    }\n  }\n\n  function _mintDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] += _amount;\n    totalDebt[_token] += _amount;\n  }\n\n  function _burnDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] -= _amount;\n    totalDebt[_token] -= _amount;\n  }\n\n  function _accrueAccountInterest(address _account) internal {\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\n\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\n    _accrueAccountDebt(tokenA, _account);\n    _accrueAccountDebt(tokenB, _account);\n\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\n  }\n\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\n    if (_amount > 0) {\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\n\n      _mintSupply(_token, _account, newSupplyAccount);\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\n    }\n  }\n\n  function _accrueAccountDebt(address _token, address _account) internal {\n    if (debtOf[_token][_account] > 0) {\n      uint newDebt = _pendingBorrowInterest(_token, _account);\n      _mintDebt(_token, _account, newDebt);\n    }\n  }\n\n  function _withdraw(address _token, uint _amount) internal {\n\n    lpToken[address(_token)].burn(msg.sender, _amount);\n\n    checkAccountHealth(msg.sender);\n\n    emit Withdraw(_token, _amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(lpToken[address(_token)].balanceOf(msg.sender) == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebt(_token, msg.sender, _amount);\n\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repay(address _account, address _token, uint _amount) internal {\n    _burnDebt(_token, _account, _amount);\n    emit Repay(_account, _token, _amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    _checkOracleSupport(tokenA);\n    _checkOracleSupport(tokenB);\n\n    require(debtOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupply(_token, _account, _amount);\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _accrueInterest(address _token) internal {\n    uint blocksElapsed = block.number - lastBlockAccrued;\n    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;\n    cumulativeInterestRate[_token] += newInterest;\n  }\n\n  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize();\n    return IERC20(newLPToken);\n  }\n\n  function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {\n    if (_amount > 0) {\n      bool success = _token.transfer(_recipient, _amount);\n      require(success, \"LendingPair: transfer failed\");\n      _checkMinReserve(address(_token));\n    }\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal override {\n    if (_amount > 0) {\n      TransferHelper._wethWithdrawTo(_to, _amount);\n      _checkMinReserve(address(WETH));\n    }\n  }\n\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\n    return _newInterest(debtOf[_token][_account], _token, _account);\n  }\n\n  function _borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));\n  }\n\n  function _supplyCredit(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;\n  }\n\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) internal view returns(uint) {\n\n    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _checkOracleSupport(address _token) internal view {\n    require(controller.tokenSupported(_token), \"LendingPair: token not supported\");\n  }\n\n  function _checkMinReserve(address _token) internal view {\n    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, \"LendingPair: below MIN_RESERVE\");\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    require(controller.depositsEnabled(), \"LendingPair: deposits disabled\");\n\n    uint depositLimit = controller.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require((lpToken[_token].totalSupply()) <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    require(controller.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n\n    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;\n    require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");\n\n    uint borrowLimit = controller.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebt[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _systemRate(address _token) internal view returns(uint) {\n    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return 100e18 - _systemRate(_token);\n  }\n\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\n    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;\n  }\n}\n\n\n",
        "CodeNames": [
            "InterestRateModel.sol",
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nfunction accrueAccount(address _account) public {\n  _distributeReward(_account);\n  // accrue only updates cumulativeInterestRate to the newInterest\n  // newInterest is not added to total debt or total LP supply!\n  accrue();\n  // instead total debt / total LP supply is increased here by a much smaller amount, the new interest specific for the updating user\n  _accrueAccountInterest(_account);\n\n  if (_account != feeRecipient()) {\n    _accrueAccountInterest(feeRecipient());\n  }\n}\n"
                ],
                "Type": " Total LP supply & total debt accrual is wrong",
                "Description": "\nThe total debt and total supply only increase when debt/supply is minted to the user when it should increase by the entire new interest amount on each accrual.\n\nsolidity\nfunction accrueAccount(address _account) public {\n  _distributeReward(_account);\n  // accrue only updates cumulativeInterestRate to the newInterest\n  // newInterest is not added to total debt or total LP supply!\n  accrue();\n  // instead total debt / total LP supply is increased here by a much smaller amount, the new interest specific for the updating user\n  _accrueAccountInterest(_account);\n\n  if (_account != feeRecipient()) {\n    _accrueAccountInterest(feeRecipient());\n  }\n}\n\n\nThe borrow rates (see borrowRatePerBlock) are wrong due to the wrong utilization ratio: The borrow utilization rate uses LPToken.totalSupply. Assume there's a single lender supplying $100k, another single borrower borrows $70k (ignoring irrelevant details like liquidation and the borrower not putting up collateral for the sake of the argument).\nAfter some time debt accrued and the supplier \"updates\" by calling accrue (but the borrower does not update), this increases the LP total supply to, say, $110k, while total debt is not updated. The utilization rate and thus the borrow rate is now less than before (from 70/100=70% to 70/110=63%). In reality, it should have increased as the supplier interest is only a fraction of the borrower accumulated debt. From now on less debt than expected accrues until the borrower is updated and total debt is increased.\nTo get the correct borrow rates in the current system, every borrower and every supplier would need to be updated on every accrual which is infeasible.\n\n",
                "Repair": "Recommend doing it like Compound/Aave, increase total debt and total supply on each accrual by the total new interest (not by the specific user's interest only).\nThis might require a bigger refactor because the LP token is treated as a (\"lazy-evaluated\") rebasing token and the total supply is indeed the total tokens in circulation LP.totalSupply() and one cannot mint the new interest to all users at once in each accrue.\nThat's why Compound uses an interest-bearing token and tracks total supply separately and Aave uses a real rebasing token that dynamically scales the balance in balanceOf and must not be updated individually for each user.\n\ntalegift (Wild Credit) confirmed but disagreed with severity(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/115#issuecomment-880577179):\n  The issue seems to only impact interest rate calculation. It doesn't allow anyone to steal the funds.\n\n Severity should be set to 1.\n\nghoul-sol (Judge) commented(https://github.com/code-423n4/2021-07-wildcredit-findings/issues/115#issuecomment-890597388):\n  I'm making this medium risk as no funds are lost but the accounting is basically incorrect.\n\n\n"
            }
        ]
    }
]