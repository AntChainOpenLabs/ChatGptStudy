[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexGmx.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "redeem",
                    "depositGlpETH()",
                    "depositGlp",
                    "GlpManager"
                ],
                "Type": " The  redeem  related functions are likely to be blocked",
                "Description": "*Submitted by KingNFT(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/113), also found by xiaoming90(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/186), ladboy233(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/161), 0x52(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/110), rvierdiiev(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/62), and HE1M(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/58)*\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L615\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L685\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L712\n\n\nThe following redeem related functions are likely to be blocked, users will not be able to retrieve their funds.\n\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    );\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    );\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    );\n\n\nThe GlpManager contract of GMX has a cooldownDuration limit on redeem/unstake (_removeLiquidity()). While there is at least one deposit/stake (_addLiquidity()) operation in the past cooldownDuration time, redemption would fail. Obviously this limitation is user-based,  and PirexGmx contract is one such user.\n\n<https://github.com/gmx-io/gmx-contracts/blob/c3618b0d6fc1b88819393dc7e6c785e32e78c72b/contracts/core/GlpManager.sol#L234\n\n    Current setting of cooldownDuration is 15 minutes, the max value is 2 days.\n\n<https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#readContract\n\nDue to the above limit, there are 3 risks that can block redemption for Pirex users.\n\n1. The normal case\n\nLet's say there is 10% GMX users will use Pirex to manage their GLP.\n\nBy checking recent history of GMX router contract, we can find the average stake interval is smaller than 1 minute\n<https://arbiscan.io/address/0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1\n\nLet's take\n\n    averageStakeIntervalOfGMX = 30 seconds\n\nSo if Pirex has 10% of GMX users, then\n\n    averageStakeIntervalOfPirex = 30 \u00f7 10% = 300 seconds\n\nThe probability of successfully redeeming is a typical Poisson distribution: <https://en.wikipedia.org/wiki/Poisson_distribution.\n\nWith\n\n    \u03bb = cooldownDuration \u00f7 averageStakeIntervalOfPirex = 15 * 60 \u00f7 300 = 3\n    k = 0\n\nSo we get\n\n    P \u2248 1 \u00f7 (2.718 * 2.718 * 2.718) \u2248 0.05 \n\nConclusion\n\n    If Pirex has 10 % of GMX users, then the redemption will fail with 95% probability.\n\nA full list of % of GMX users versus failure probability of redemption\n\n    1% : 26%\n    5% : 78%\n    10% : 95%\n    20% : 99.75%\n    30% : 99.98%\n\n2. The attack case\n\nIf an attacker, such as bad competitors of similar projects, try to exploit this vulnerability. \n\nLet's estimate the cost for attack.\n\nAn attacker can deposit a very small GLP, such as 1 wei, so we can ignore the GLP cost and only focus on GAS cost.\n\nBy checking the explorer history <https://arbiscan.io\nWe are safe to assume the cost for calling \n\ndepositGlpETH() or depositGlp is\n\n    txCost = 0.1 USD\n\nTo block redemption, attacker has to execute a deposit call every 15 minutes, so\n\n    dailyCost = 24 * (60 / 15) * 0.1 = 9.6 USD\n    yearCost = 365 * 9.6 = 3504 USD\n\nConclusion\n\n    If an attacker wants to block Pirex users funds, his yearly cost is only about 3.5k USD.\n\n3. GMX adjusts protocol parameters\n\nIf GMX increases cooldownDuration to 2 days, it will obviously cause redemption not working.\n\n\nVS Code\n\n",
                "Repair": "\nReserve some time range for redemption only. e.g. 1 of every 7 days.\n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/113)\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    \u26a0\ufe0f NOTABLE PRIVILEGED METHODS \u26a0\ufe0f\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexRewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n/\n    @notice Update global accrual state\n    @param  globalState    GlobalState  Global state of the producer token\n    @param  producerToken  ERC20        Producer token contract\n*/\nfunction _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n\tinternal\n{\n    uint256 totalSupply = producerToken.totalSupply();\n    uint256 lastUpdate = globalState.lastUpdate;\n    uint256 lastSupply = globalState.lastSupply;\n\n    // Calculate rewards, the product of seconds elapsed and last supply\n    // Only calculate and update states when needed\n    if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n        uint256 rewards = globalState.rewards +\n            (block.timestamp lastUpdate) *\n            lastSupply;\n            \n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n   \t..SNIP..\n}\n",
                    "//solidity\n/\n    @notice Update user rewards accrual state\n    @param  producerToken  ERC20    Rewards-producing token\n    @param  user           address  User address\n*/\nfunction userAccrue(ERC20 producerToken, address user) public {\n    if (address(producerToken) == address(0)) revert ZeroAddress();\n    if (user == address(0)) revert ZeroAddress();\n\n    UserState storage u = producerTokens[producerToken].userStates[user];\n    uint256 balance = producerToken.balanceOf(user);\n\n    // Calculate the amount of rewards accrued by the user up to this call\n    uint256 rewards = u.rewards +\n    u.lastBalance *\n    (block.timestamp u.lastUpdate);\n    \n    u.lastUpdate = block.timestamp.safeCastTo32();\n    u.lastBalance = balance.safeCastTo224();\n    u.rewards = rewards;\n    ..SNIP..\n}\n",
                    "//solidity\nFile: PirexRewards.sol\n373:     function claim(ERC20 producerToken, address user) external {\n..SNIP..\n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n..SNIP..\n417:     }\n",
                    "//solidity\n(rewardState * userRewards) / globalRewards\n(13 * 5) / 13 = 5\n",
                    "//solidity\n[1 staked GMX * (T82 T80) * 2esGMX/sec] + 1 staked GMX * (T84 T83) * 1esGMX/sec]\n[1 staked GMX * 3 secs * 2esGMX/sec] + 1 staked GMX * 2secs * 1esGMX/sec]\n6 + 2 = 8\n",
                    "//solidity\n[4 staked GMX * 2secs * 1esGMX/sec] = 8\n",
                    "//solidity\n(rewardState * userRewards) / globalRewards\n(16 * 5) / 13 = 6.15 = 6\n",
                    "//solidity\n(rewardState * userRewards) / globalRewards\n(16 * 8) / 13 = 9.85 = 9\n"
                ],
                "Type": " Users Receive Less Rewards Due To Miscalculations",
                "Description": "*Submitted by xiaoming90(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/177), also found by __141345__(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/258)*\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373\n\n\nThe amount of rewards accrued by global and user states is computed by the following steps:\n\n1.  Calculate seconds elapsed since the last update (block.timestamp lastUpdate)\n2.  Calculate the new rewards by multiplying seconds elapsed by the last supply ((block.timestamp lastUpdate) * lastSupply)\n3.  Append the new rewards to the existing rewards (rewards = rewards + (block.timestamp lastUpdate) * lastSupply)\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L305\n\nsolidity\n/\n    @notice Update global accrual state\n    @param  globalState    GlobalState  Global state of the producer token\n    @param  producerToken  ERC20        Producer token contract\n*/\nfunction _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n\tinternal\n{\n    uint256 totalSupply = producerToken.totalSupply();\n    uint256 lastUpdate = globalState.lastUpdate;\n    uint256 lastSupply = globalState.lastSupply;\n\n    // Calculate rewards, the product of seconds elapsed and last supply\n    // Only calculate and update states when needed\n    if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n        uint256 rewards = globalState.rewards +\n            (block.timestamp lastUpdate) *\n            lastSupply;\n            \n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n   \t..SNIP..\n}\n\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L281\n\nsolidity\n/\n    @notice Update user rewards accrual state\n    @param  producerToken  ERC20    Rewards-producing token\n    @param  user           address  User address\n*/\nfunction userAccrue(ERC20 producerToken, address user) public {\n    if (address(producerToken) == address(0)) revert ZeroAddress();\n    if (user == address(0)) revert ZeroAddress();\n\n    UserState storage u = producerTokens[producerToken].userStates[user];\n    uint256 balance = producerToken.balanceOf(user);\n\n    // Calculate the amount of rewards accrued by the user up to this call\n    uint256 rewards = u.rewards +\n    u.lastBalance *\n    (block.timestamp u.lastUpdate);\n    \n    u.lastUpdate = block.timestamp.safeCastTo32();\n    u.lastBalance = balance.safeCastTo224();\n    u.rewards = rewards;\n    ..SNIP..\n}\n\n\nWhen a user claims the rewards, the number of reward tokens the user is entitled to is equal to the rewardState scaled by the ratio of the userRewards to the globalRewards. Refer to Line 403 below.\n\nThe rewardState represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).\n\nThe rewardState of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. PirexRewards.harvest is called). On the other hand, the rewardState will decrease if the users claim the rewards.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373\n\nsolidity\nFile: PirexRewards.sol\n373:     function claim(ERC20 producerToken, address user) external {\n..SNIP..\n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n..SNIP..\n417:     }\n\n\n\nThe Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is constant throughout the entire period (from T80 to T84) and the emission rate is 1 esGMX per 1 GMX staked per second.\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.\n\nA = Alice and B = Bob; each block represents 1 GMX token staked.\n\n![(https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)\n\nBased on the above graph:\n\n*   Alice staked 1 GMX token from T80 to T84. Alice will earn five (5) esGMX tokens at the end of T84.\n*   Bob staked 4 GMX tokens from T83 to T84. Bob will earn eight (8) esGMX tokens at the end of T84.\n*   A total of 13 esGMX will be harvested by PirexRewards contract at the end of T84\n\nThe existing reward distribution design in the PirexRewards contract will work perfectly if the emission rate is constant, similar to the example above.\n\nIn this case, the state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 13 esGMX tokens (5 + 8)\n*   globalRewards = 13\n*   Accrued userRewards of Alice = 5\n*   Accrued userRewards of Bob = 8\n\nWhen Alice calls the PirexRewards.claim function to claim her rewards at the end of T84, she will get back five (5) esGMX tokens, which is correct.\n\nsolidity\n(rewardState * userRewards) / globalRewards\n(13 * 5) / 13 = 5\n\n\n\nHowever, the fact is that the emission rate of reward tokens (e.g. esGMX or WETH) is not constant. Instead, the emission rate is dynamic and depends on various factors, such as the following:\n\n*   The number of rewards tokens allocated by GMX governance for each month. Refer to <https://gov.gmx.io/t/esgmx-emissions/272. In some months, the number of esGMX emissions will be higher.\n*   The number of GMX/GLP tokens staked by the community. The more tokens being staked by the community users, the more diluted the rewards will be.\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked for each second during the period.\n\nA = Alice and B = Bob; each block represents 1 GMX token staked.\n\n![(https://user-images.githubusercontent.com/102820284/204132445-50422095-c02c-4f45-95d6-575667211092.png)\n\nThe Multiplier Point (MP) effect will be ignored for simplicity. Assume that the emission rate is as follows:\n\n*   From T80 to 82: 2 esGMX per 1 GMX staked per second (Higher emission rate)\n*   From T83 to 84: 1 esGMX per 1 GMX staked per second (Lower emission rate)\n\nBy manually computing the amount of esGMX reward tokens that Alice is entitled to at the end of T84:\n\nsolidity\n1 staked GMX * (T82 T80) * 2esGMX/sec] + 1 staked GMX * (T84 T83) * 1esGMX/sec]\n1 staked GMX * 3 secs * 2esGMX/sec] + 1 staked GMX * 2secs * 1esGMX/sec]\n6 + 2 = 8\n\n\nAlice will be entitled to 8 esGMX reward tokens at the end of T84.\n\nBy manually computing the amount of esGMX reward tokens that Bob is entitled to at the end of T84:\n\nsolidity\n4 staked GMX * 2secs * 1esGMX/sec] = 8\n\n\nBob will be entitled to 8 esGMX reward tokens at the end of T84.\n\nHowever, the existing reward distribution design in the PirexRewards contract will cause Alice to get fewer reward tokens than she is entitled to and cause Bob to get more rewards than he is entitled to.\n\nThe state variable will be as follows at the end of T84, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 16 esGMX tokens (8 + 8)\n*   globalRewards = 13\n*   Accrued userRewards of Alice = 5\n*   Accrued userRewards of Bob = 8\n\nWhen Alice calls the PirexRewards.claim function to claim her rewards at the end of T84, she will only get back six (6) esGMX tokens, which is less than eight (8) esGMX tokens she is entitled to or earned.\n\nsolidity\n(rewardState * userRewards) / globalRewards\n(16 * 5) / 13 = 6.15 = 6\n\n\nWhen Bob calls the PirexRewards.claim function to claim his rewards at the end of T84, he will get back nine (9) esGMX tokens, which is more than eight (8) esGMX tokens he is entitled to or earned.\n\nsolidity\n(rewardState * userRewards) / globalRewards\n(16 * 8) / 13 = 9.85 = 9\n\n\n\nAs shown in the PoC, some users will lose their reward tokens due to the miscalculation within the existing reward distribution design.\n\n",
                "Repair": "\nUpdate the existing reward distribution design to handle the dynamic emission rate. Implement the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which are not vulnerable to this issue:\n\n*   <https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226\n*   <https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61\n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/177) \n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nuint256 amount = (rewardState * userRewards) / globalRewards;\n",
                    "//solidity\nFile: PirexRewards.sol\n368:     /\n369:         @notice Claim rewards\n370:         @param  producerToken  ERC20    Producer token contract\n371:         @param  user           address  User\n372:     */\n373:     function claim(ERC20 producerToken, address user) external {\n374:         if (address(producerToken) == address(0)) revert ZeroAddress();\n375:         if (user == address(0)) revert ZeroAddress();\n376: \n377:         harvest();\n378:         userAccrue(producerToken, user);\n379: \n380:         ProducerToken storage p = producerTokens[producerToken];\n381:         uint256 globalRewards = p.globalState.rewards;\n382:         uint256 userRewards = p.userStates[user].rewards;\n383: \n384:         // Claim should be skipped and not reverted on zero global/user reward\n385:         if (globalRewards != 0 && userRewards != 0) {\n386:             ERC20[] memory rewardTokens = p.rewardTokens;\n387:             uint256 rLen = rewardTokens.length;\n388: \n389:             // Update global and user reward states to reflect the claim\n390:             p.globalState.rewards = globalRewards userRewards;\n391:             p.userStates[user].rewards = 0;\n392: \n393:             emit Claim(producerToken, user);\n394: \n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n404: \n405:                 if (amount != 0) {\n406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out\n407:                     p.rewardStates[rewardToken] = rewardState amount;\n408: \n409:                     producer.claimUserReward(\n410:                         address(rewardToken),\n411:                         amount,\n412:                         recipient\n413:                     );\n414:                 }\n415:             }\n416:         }\n417:     }\n",
                    "//solidity\namount = (rewardState * userRewards) / globalRewards;\n",
                    "//solidity\namount = (rewardState * userRewards) / globalRewards;\n60,000 * 6 / 600,000\n360,000/600,000 = 0.6 = 0\n"
                ],
                "Type": " User's Accrued Rewards Will Be Lost",
                "Description": "*Submitted by xiaoming90(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184)*\n\nIf the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the PirexRewards.claim function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.\n\nThe amount of reward tokens that are claimable by a user is computed in Line 403 of the PirexRewards.claim function.\n\nIf the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.\n\nsolidity\nuint256 amount = (rewardState * userRewards) / globalRewards;\n\n\nSince the user's accrued rewards is cleared at Line 391 within the PirexRewards.claim function (p.userStates[user].rewards = 0;), the user's accrued rewards will be lost.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373\n\nsolidity\nFile: PirexRewards.sol\n368:     /\n369:         @notice Claim rewards\n370:         @param  producerToken  ERC20    Producer token contract\n371:         @param  user           address  User\n372:     */\n373:     function claim(ERC20 producerToken, address user) external {\n374:         if (address(producerToken) == address(0)) revert ZeroAddress();\n375:         if (user == address(0)) revert ZeroAddress();\n376: \n377:         harvest();\n378:         userAccrue(producerToken, user);\n379: \n380:         ProducerToken storage p = producerTokens[producerToken];\n381:         uint256 globalRewards = p.globalState.rewards;\n382:         uint256 userRewards = p.userStates[user].rewards;\n383: \n384:         // Claim should be skipped and not reverted on zero global/user reward\n385:         if (globalRewards != 0 && userRewards != 0) {\n386:             ERC20[] memory rewardTokens = p.rewardTokens;\n387:             uint256 rLen = rewardTokens.length;\n388: \n389:             // Update global and user reward states to reflect the claim\n390:             p.globalState.rewards = globalRewards userRewards;\n391:             p.userStates[user].rewards = 0;\n392: \n393:             emit Claim(producerToken, user);\n394: \n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n404: \n405:                 if (amount != 0) {\n406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out\n407:                     p.rewardStates[rewardToken] = rewardState amount;\n408: \n409:                     producer.claimUserReward(\n410:                         address(rewardToken),\n411:                         amount,\n412:                         recipient\n413:                     );\n414:                 }\n415:             }\n416:         }\n417:     }\n\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked in PirexGmx for each second during the period. Note that the graph is not drawn proportionally.\n\nGreen = Number of GMX tokens staked by Alice\n\nBlue = Number of GMX tokens staked by Bob\n\n![(https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)\n\nBased on the above graph:\n\n*   Alice staked 1 GMX token for 4 seconds (From T80 to T85)\n*   Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)\n\nAssume that the emission rate is 0.1 esGMX per 1 GMX staked per second.\n\nIn this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 60,000 esGMX tokens (600,000 * 0.1)\n*   globalRewards = 600,000 (100,000 * 6)\n*   Accrued userRewards of Alice = 6\n*   Accrued userRewards of Bob = 599,994 (99,999 * 6)\n\nFollowing is the description of rewardState for reference:\n\n The rewardState represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).\n\n The rewardState of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. PirexRewards.harvest is called). On the other hand, the rewardState will decrease if the users claim the rewards.\n\nAt the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec * 6).\n\nFollowing is the formula used in the PirexRewards contract to compute the number of reward tokens a user is entitled to.\n\nsolidity\namount = (rewardState * userRewards) / globalRewards;\n\n\nIf Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.\n\nsolidity\namount = (rewardState * userRewards) / globalRewards;\n60,000 * 6 / 600,000\n360,000/600,000 = 0.6 = 0\n\n\nSince Alice's accrued rewards are cleared at Line 391 within the PirexRewards.claim function (p.userStates[user].rewards = 0;), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the PirexRewards.claim function.\n\nAnother side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.\n\n\nUsers who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the PirexRewards.claim function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.\n\nAdditionally, the PirexRewards.claim function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the PirexRewards.claim function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).\n\n",
                "Repair": "\nFollowing are some of the possible remediation actions:\n\n#### 1. Use  RewardPerToken   approach\n\nAvoid calculating the rewards that the users are entitled based on the ratio of userRewards and globalRewards.\n\nInstead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which are not vulnerable to this issue:\n\n*   <https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226\n*   <https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61\n\n#### 2. Fallback logic ifamount ==  0\n\nIf the amount is zero, revert the transaction. Alternatively, if the amount is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.\n\ndiff\nfunction claim(ERC20 producerToken, address user) external {\n..SNIP..\n\t\t\tuint256 amount = (rewardState * userRewards) / globalRewards;\n\n\t\t\tif (amount != 0) {\n\t\t\t\t// Update reward state (i.e. amount) to reflect reward tokens transferred out\n\t\t\t\tp.rewardStates[rewardToken] = rewardState amount;\n\n\t\t\t\tproducer.claimUserReward(\n\t\t\t\t\taddress(rewardToken),\n\t\t\t\t\tamount,\n\t\t\t\t\trecipient\n\t\t\t\t);\n-\t\t\t}\n+\t\t\t} else {\n+\t\t\t\trevert ZeroRewardTokens();\n+\t\t\t}\n..SNIP..\n}\n\n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184) \n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "AutoPxGmx.sol",
            "AutoPxGlp.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nFile: PirexERC4626.sol\n156:     function convertToShares(uint256 assets)\n157:         public\n158:         view\n159:         virtual\n160:         returns (uint256)\n161:     {\n162:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n163: \n164:         return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n165:     }\n",
                    "//solidity\nFile: AutoPxGmx.sol\n199:     function previewWithdraw(uint256 assets)\n200:         public\n201:         view\n202:         override\n203:         returns (uint256)\n204:     {\n205:         // Calculate shares based on the specified assets' proportion of the pool\n206:         uint256 shares = convertToShares(assets);\n207: \n208:         // Save 1 SLOAD\n209:         uint256 _totalSupply = totalSupply;\n210: \n211:         // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n212:         return\n213:             (_totalSupply == 0 || _totalSupply shares == 0)\n214:                 ? shares\n215:                 : (shares * FEE_DENOMINATOR) /\n216:                     (FEE_DENOMINATOR withdrawalPenalty);\n217:     }\n",
                    "//solidity\nFile: AutoPxGmx.sol\n315:     function withdraw(\n316:         uint256 assets,\n317:         address receiver,\n318:         address owner\n319:     ) public override returns (uint256 shares) {\n320:         // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n321:         compound(poolFee, 1, 0, true);\n322:         \n323:         shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n324: \n325:         if (msg.sender != owner) {\n326:             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n327: \n328:             if (allowed != type(uint256).max)\n329:                 allowance[owner][msg.sender] = allowed shares;\n330:         }\n331: \n332:         _burn(owner, shares);\n333: \n334:         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n335: \n336:         asset.safeTransfer(receiver, assets);\n337:     }\n",
                    "//solidity\nassets.mulDivDown(supply, totalAssets())\n99WETH.mulDivDown(10 shares, 1000WETH)\n(99 * 10) / 1000\n990 / 1000 = 0.99 = 0\n"
                ],
                "Type": " Malicious Users Can Drain The Assets Of Auto Compound Vault",
                "Description": "*Submitted by xiaoming90(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/178), also found by pashov(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/388), adriro(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/380), poirots(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/290), unforgiven(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/264), bin2chen(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/246), PaludoX0(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/211), 0xSmartContract(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/197), ladboy233(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/127), Ruhum(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/98), cccz(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/89), koxuan(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/74), 8olidity(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/54), and rvierdiiev(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/27)*\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315\n\n\n Note: This issue affects both the AutoPxGmx and AutoPxGlp vaults. Since the root cause is the same, the PoC of AutoPxGlp vault is omitted for brevity.\n\nThe PirexERC4626.convertToShares function relies on the mulDivDown function in Line 164 when calculating the number of shares needed in exchange for a certain number of assets. Note that the computation is rounded down, therefore, if the result is less than 1 (e.g. 0.9), Solidity will round them down to zero. Thus, it is possible that this function will return zero.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156\n\nsolidity\nFile: PirexERC4626.sol\n156:     function convertToShares(uint256 assets)\n157:         public\n158:         view\n159:         virtual\n160:         returns (uint256)\n161:     {\n162:         uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n163: \n164:         return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n165:     }\n\n\nThe AutoPxGmx.previewWithdraw function relies on the PirexERC4626.convertToShares function in Line 206. Thus, this function will also \"round down\".\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L199\n\nsolidity\nFile: AutoPxGmx.sol\n199:     function previewWithdraw(uint256 assets)\n200:         public\n201:         view\n202:         override\n203:         returns (uint256)\n204:     {\n205:         // Calculate shares based on the specified assets' proportion of the pool\n206:         uint256 shares = convertToShares(assets);\n207: \n208:         // Save 1 SLOAD\n209:         uint256 _totalSupply = totalSupply;\n210: \n211:         // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n212:         return\n213:             (_totalSupply == 0 || _totalSupply shares == 0)\n214:                 ? shares\n215:                 : (shares * FEE_DENOMINATOR) /\n216:                     (FEE_DENOMINATOR withdrawalPenalty);\n217:     }\n\n\nThe AutoPxGmx.withdraw function relies on the AutoPxGmx.previewWithdraw function. In certain conditions, the AutoPxGmx.previewWithdraw function in Line 323 will return zero if the withdrawal amount causes the division within the PirexERC4626.convertToShares function to round down to zero (usually due to a small amount of withdrawal amount).\n\nIf the AutoPxGmx.previewWithdraw function in Line 323 returns zero, no shares will be burned at Line 332. Subsequently, in Line 336, the contract will transfer the assets to the users. As a result, the users receive the assets without burning any of their shares, effectively allowing them to receive assets for free.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L315\n\nsolidity\nFile: AutoPxGmx.sol\n315:     function withdraw(\n316:         uint256 assets,\n317:         address receiver,\n318:         address owner\n319:     ) public override returns (uint256 shares) {\n320:         // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n321:         compound(poolFee, 1, 0, true);\n322:         \n323:         shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n324: \n325:         if (msg.sender != owner) {\n326:             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n327: \n328:             if (allowed != type(uint256).max)\n329:                 allowance[owner][msg.sender] = allowed shares;\n330:         }\n331: \n332:         _burn(owner, shares);\n333: \n334:         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n335: \n336:         asset.safeTransfer(receiver, assets);\n337:     }\n\n\nAssume that the vault with the following state:\n\n*   Total Asset = 1000 WETH\n*   Total Supply = 10 shares\n\nAssume that Alice wants to withdraw 99 WETH from the vault. Thus, she calls the AutoPxGmx.withdraw(99 WETH) function.\n\nThe PirexERC4626.convertToShares function will compute the number of shares that Alice needs to burn in exchange for 99 WETH.\n\nsolidity\nassets.mulDivDown(supply, totalAssets())\n99WETH.mulDivDown(10 shares, 1000WETH)\n(99 * 10) / 1000\n990 / 1000 = 0.99 = 0\n\n\nHowever, since Solidity rounds 0.99 down to 0, Alice does not need to burn a single share. She will receive 99 WETH for free.\n\n\nMalicious users can withdraw the assets from the vault for free, effectively allowing them to drain the assets of the vault.\n\n",
                "Repair": "\nEnsure that at least 1 share is burned when the users withdraw their assets.\n\nThis can be mitigated by updating the previewWithdraw function to round up instead of round down when computing the number of shares to be burned.\n\ndiff\nfunction previewWithdraw(uint256 assets)\n\tpublic\n\tview\n\toverride\n\treturns (uint256)\n{\n\t// Calculate shares based on the specified assets' proportion of the pool\n-\tuint256 shares = convertToShares(assets);\n+\tuint256 shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t\n\t// Save 1 SLOAD\n\tuint256 _totalSupply = totalSupply;\n\n\t// Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n\treturn\n\t\t(_totalSupply == 0 || _totalSupply shares == 0)\n\t\t\t? shares\n\t\t\t: (shares * FEE_DENOMINATOR) /\n\t\t\t\t(FEE_DENOMINATOR withdrawalPenalty);\n}\n\n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/264) \n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexGmx.sol",
            "AutoPxGlp.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n    ",
                    "//solidity\n// test/AutoPxGmx.t.sol\nfunction testSharePriceManipulation_AUDIT() external {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"Alice\");\n    vm.label(bob, \"Bob\");\n\n    // Resetting the withdrawal fee for cleaner amounts.\n    autoPxGmx.setWithdrawalPenalty(0);\n\n    vm.startPrank(address(pirexGmx));        \n    pxGmx.mint(alice, 10e18);\n    pxGmx.mint(bob, 19e18);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pxGmx.approve(address(autoPxGmx), 1);\n    // Alice deposits 1 wei of pxGMX and gets 1 wei of shares.\n    autoPxGmx.deposit(1, alice);\n    // Alice sends 10e18-1 of pxGMX and sets the price of 1 wei of shares to 10e18 pxGMX.\n    pxGmx.transfer(address(autoPxGmx), 10e18-1);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pxGmx.approve(address(autoPxGmx), 19e18);\n    // Bob deposits 19e18 of pxGMX and gets 1 wei of shares due to rounding and the price manipulation.\n    autoPxGmx.deposit(19e18, bob);\n    vm.stopPrank();\n\n    // Alice and Bob redeem their shares.           \n    vm.prank(alice);\n    autoPxGmx.redeem(1, alice, alice);\n    vm.prank(bob);\n    autoPxGmx.redeem(1, bob, bob);\n\n    // Alice and Bob both got 14.5 pxGMX.\n    // But Alice deposited 10 pxGMX and Bob deposited 19 pxGMX \u2013 thus, Alice stole pxGMX tokens from Bob.\n    // With withdrawal fees enabled, Alice would've been penalized more than Bob\n    // (14.065 pxGMX vs 14.935 pxGMX tokens withdrawn, respectively),\n    // but Alice would've still gotten more pxGMX that she deposited.\n    assertEq(pxGmx.balanceOf(alice), 14.5e18);\n    assertEq(pxGmx.balanceOf(bob), 14.5e18);\n}\n"
                ],
                "Type": " Underlying assets stealing in  AutoPxGmx  and  AutoPxGlp  via share price manipulation",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/275), also found by seyni(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/407), gogo(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/401), pashov(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/384), hl_(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/339), rbserver(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/331), peanuts(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/307), __141345__(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/266), unforgiven(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/259), Lambda(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/253), joestakey(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/252), JohnSmith(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/219), R2(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/201), Koolex(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/200), xiaoming90(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/180), yongskiws(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/162), carrotsmuggler(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/151), ladboy233(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/128), 0xSmartContract(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/109), KingNFT(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/90), cccz(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/81), HE1M(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/67), rvierdiiev(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/59), koxuan(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/57), 8olidity(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/52), and 0xLad(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/40)*\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156-L165\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L167-L176\n\n\npxGMX and pxGLP tokens can be stolen from depositors in AutoPxGmx and AutoPxGlp vaults by manipulating the price of a share.\n\n\nERC4626 vaults are subject to a share price manipulation attack that allows an attacker to steal underlying tokens from other depositors (this is a known issue(https://github.com/transmissions11/solmate/issues/178) of Solmate's ERC4626 implementation). Consider this scenario (this is applicable to AutoPxGmx and AutoPxGlp vaults):\n\n1.  Alice is the first depositor of the AutoPxGmx vault;\n2.  Alice deposits 1 wei of pxGMX tokens;\n3.  in the deposit function ([PirexERC4626.sol#L60(https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L60)), the amount of shares is calculated using the previewDeposit function:\n\n    solidity\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n    \n\n4.  Since Alice is the first depositor (totalSupply is 0), she gets 1 share (1 wei);\n5.  Alice then *sends* 9999999999999999999 pxGMX tokens (10e18 1) to the vault;\n6.  The price of 1 share is 10 pxGMX tokens now: Alice is the only depositor in the vault, she's holding 1 wei of shares, and the balance of the pool is 10 pxGMX tokens;\n7.  Bob deposits 19 pxGMX tokens and gets only 1 share due to the rounding in the convertToShares function: 19e18 * 1 / 10e18 == 1;\n8.  Alice redeems her share and gets a half of the deposited assets, 14.5 pxGMX tokens (less the withdrawal fee);\n9.  Bob redeems his share and gets only 14.5 pxGMX (less the withdrawal fee), instead of the 19 pxGMX he deposited.\n\nsolidity\n// test/AutoPxGmx.t.sol\nfunction testSharePriceManipulation_AUDIT() external {\n    address alice = address(0x31337);\n    address bob = address(0x12345);\n    vm.label(alice, \"Alice\");\n    vm.label(bob, \"Bob\");\n\n    // Resetting the withdrawal fee for cleaner amounts.\n    autoPxGmx.setWithdrawalPenalty(0);\n\n    vm.startPrank(address(pirexGmx));        \n    pxGmx.mint(alice, 10e18);\n    pxGmx.mint(bob, 19e18);\n    vm.stopPrank();\n\n    vm.startPrank(alice);\n    pxGmx.approve(address(autoPxGmx), 1);\n    // Alice deposits 1 wei of pxGMX and gets 1 wei of shares.\n    autoPxGmx.deposit(1, alice);\n    // Alice sends 10e18-1 of pxGMX and sets the price of 1 wei of shares to 10e18 pxGMX.\n    pxGmx.transfer(address(autoPxGmx), 10e18-1);\n    vm.stopPrank();\n\n    vm.startPrank(bob);\n    pxGmx.approve(address(autoPxGmx), 19e18);\n    // Bob deposits 19e18 of pxGMX and gets 1 wei of shares due to rounding and the price manipulation.\n    autoPxGmx.deposit(19e18, bob);\n    vm.stopPrank();\n\n    // Alice and Bob redeem their shares.           \n    vm.prank(alice);\n    autoPxGmx.redeem(1, alice, alice);\n    vm.prank(bob);\n    autoPxGmx.redeem(1, bob, bob);\n\n    // Alice and Bob both got 14.5 pxGMX.\n    // But Alice deposited 10 pxGMX and Bob deposited 19 pxGMX \u2013 thus, Alice stole pxGMX tokens from Bob.\n    // With withdrawal fees enabled, Alice would've been penalized more than Bob\n    // (14.065 pxGMX vs 14.935 pxGMX tokens withdrawn, respectively),\n    // but Alice would've still gotten more pxGMX that she deposited.\n    assertEq(pxGmx.balanceOf(alice), 14.5e18);\n    assertEq(pxGmx.balanceOf(bob), 14.5e18);\n}\n\n\n",
                "Repair": "\nConsider either of these options:\n\n1.  In the deposit function of PirexERC4626, consider requiring a reasonably high minimal amount of assets during first deposit. The amount needs to be high enough to mint many shares to reduce the rounding error and low enough to be affordable to users.\n2.  On the first deposit, consider minting a fixed and high amount of shares, irrespective of the deposited amount.\n3.  Consider seeding the pools during deployment. This needs to be done in the deployment transactions to avoid front-running attacks. The amount needs to be high enough to reduce the rounding error.\n4.  Consider sending first 1000 wei of shares to the zero address. This will significantly increase the cost of the attack by forcing an attacker to pay 1000 times of the share price they want to set. For a well-intended user, 1000 wei of shares is a negligible amount that won't diminish their share significantly.\n\nPicodes (judge) increased severity to High(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/275) \n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/407) \n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {AccessControl} from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract PxERC20 is ERC20, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    PirexRewards public immutable pirexRewards;\n\n    error ZeroAddress();\n    error ZeroAmount();\n    error EmptyString();\n\n    /**\n        @param  _pirexRewards  address  PirexRewards contract address\n        @param  _name          string   Token name (e.g. Pirex GLP)\n        @param  _symbol        string   Token symbol (e.g. pxGLP)\n        @param  _decimals      uint8    Token decimals (e.g. 18)\n    */\n    constructor(\n        address _pirexRewards,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert EmptyString();\n        if (bytes(_symbol).length == 0) revert EmptyString();\n        if (_decimals == 0) revert ZeroAmount();\n\n        pirexRewards = PirexRewards(_pirexRewards);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Mint tokens\n        @param  to      address  Token recipient\n        @param  amount  uint256  Token mint amount\n    */\n    function mint(address to, uint256 amount)\n        external\n        virtual\n        onlyRole(MINTER_ROLE)\n    {\n        _mint(to, amount);\n\n        // Accrue global and user rewards and store post-mint supply for future accrual\n        pirexRewards.globalAccrue(this);\n        pirexRewards.userAccrue(this, to);\n    }\n\n    /**\n        @notice Burn tokens\n        @param  from    address  Token owner\n        @param  amount  uint256  Token burn amount\n    */\n    function burn(address from, uint256 amount)\n        external\n        virtual\n        onlyRole(BURNER_ROLE)\n    {\n        _burn(from, amount);\n\n        // Accrue global and user rewards and store post-burn supply for future accrual\n        pirexRewards.globalAccrue(this);\n        pirexRewards.userAccrue(this, from);\n    }\n\n    /**\n        @notice Transfer tokens (called by token owner)\n        @param  to      address  Token recipient\n        @param  amount  uint256  Token transfer amount\n        @return         bool     Token transfer status\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        // Accrue rewards for sender, up to their current balance and kick off accrual for receiver\n        pirexRewards.userAccrue(this, msg.sender);\n        pirexRewards.userAccrue(this, to);\n\n        return true;\n    }\n\n    /**\n        @notice Transfer tokens (called by account with allowance)\n        @param  from    address  Token owner\n        @param  to      address  Token recipient\n        @param  amount  uint256  Token transfer amount\n        @return         bool     Token transfer status\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        pirexRewards.userAccrue(this, from);\n        pirexRewards.userAccrue(this, to);\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    \u26a0\ufe0f NOTABLE PRIVILEGED METHODS \u26a0\ufe0f\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nstruct GlobalState {\n    uint32 lastUpdate;\n    uint224 lastSupply;\n    uint256 rewards;\n}\n\nstruct UserState {\n    uint32 lastUpdate;\n    uint224 lastBalance;\n    uint256 rewards;\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IAutoPxGlp {\n    function compound(\n        uint256 minUsdgAmount,\n        uint256 minGlpAmount,\n        bool optOutIncentive\n    )\n        external\n        returns (\n            uint256 wethAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        );\n}\n\n\n",
        "CodeNames": [
            "PxERC20.sol",
            "PirexRewards.sol",
            "AutoPxGlp.sol",
            "Common.sol",
            "PirexGmx.sol",
            "IAutoPxGlp.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "pxGMX",
                    "_globalAccrue()",
                    "_harvest()",
                    "pxGmxAmountOut",
                    "pxGLP",
                    "pxGmx",
                    "weth",
                    "compound()",
                    "_harvest(pxGmxAmountOut totalPxGmxFee)",
                    "owner",
                    "claim()",
                    "pxGmxAmountOut = pxGmx.balanceOf(address(this)) preClaimPxGmxAmount;",
                    "gmx",
                    "asset.safeTransfer(owner, totalPxGlpFee pxGlpIncentive)",
                    "totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;",
                    "uint"
                ],
                "Type": " fee loss in AutoPxGmx and AutoPxGlp and reward loss in AutoPxGlp by calling  PirexRewards.claim(pxGmx/pxGpl, AutoPx*)  directly which transfers rewards to  AutoPx* pool without compound logic get executed and fee calculation logic and pxGmx wouldn't be executed for those rewards",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/321), also found by bin2chen(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/247) and 0x52(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/143)*\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313\n\n\nFunction compound() in AutoPxGmx and AutoPxGlp contracts is for compounding pxGLP (and additionally pxGMX) rewards. it works by calling PirexGmx.claim(px*, this) to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to the claim() and by subtracting them finds the received reward amount) and deposit them in PirexGmx again for compounding and in doing so it calculates fee based on what it received and in AutoPxGlp case it calculates pxGMX rewards too based on the extra amount contract receives during the execution of claim(). But attacker can call PirexGmx.claim(px*, PirexGlp) directly and make PirexGmx contract to transfer (gmxBaseReward and pxGmx) rewards to AutoPxGlp and in this case the logics of fee calculation and reward calculation in compound() function won't get executed and contract won't get it's fee from rewards and users won't get their pxGmx reward. So this bug would cause fee loss in AutoPxGmx and AutoPxGlp for contract and pxGmx's reward loss for users in AutoPxGlp.\n\n\nThe bug in AutoPxGmx is similar to AutoPxGlp, so we only give Proof of Concept for AutoPxGlp.\n\nThis is compound() function code in AutoPxGlp contract:\n\n        function compound(\n            uint256 minUsdg,\n            uint256 minGlp,\n            bool optOutIncentive\n        )\n            public\n            returns (\n                uint256 gmxBaseRewardAmountIn,\n                uint256 pxGmxAmountOut,\n                uint256 pxGlpAmountOut,\n                uint256 totalPxGlpFee,\n                uint256 totalPxGmxFee,\n                uint256 pxGlpIncentive,\n                uint256 pxGmxIncentive\n            )\n        {\n            if (minUsdg == 0) revert InvalidParam();\n            if (minGlp == 0) revert InvalidParam();\n\n            uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n            uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n            PirexRewards(rewardsModule).claim(asset, address(this));\n            PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n            // Track the amount of rewards received\n            gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n            if (gmxBaseRewardAmountIn != 0) {\n                // Deposit received rewards for pxGLP\n                (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                    address(gmxBaseReward),\n                    gmxBaseRewardAmountIn,\n                    minUsdg,\n                    minGlp,\n                    address(this)\n                );\n            }\n\n            // Distribute fees if the amount of vault assets increased\n            uint256 newAssets = totalAssets() preClaimTotalAssets;\n            if (newAssets != 0) {\n                totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n                pxGlpIncentive = optOutIncentive\n                    ? 0\n                    : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n                if (pxGlpIncentive != 0)\n                    asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n                asset.safeTransfer(owner, totalPxGlpFee pxGlpIncentive);\n            }\n\n            // Track the amount of pxGMX received\n            pxGmxAmountOut = pxGmx.balanceOf(address(this)) preClaimPxGmxAmount;\n\n            if (pxGmxAmountOut != 0) {\n                // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n                totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n                pxGmxIncentive = optOutIncentive\n                    ? 0\n                    : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n                if (pxGmxIncentive != 0)\n                    pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n                pxGmx.safeTransfer(owner, totalPxGmxFee pxGmxIncentive);\n\n                // Update the pxGmx reward accrual\n                _harvest(pxGmxAmountOut totalPxGmxFee);\n            } else {\n                // Required to keep the globalState up-to-date\n                _globalAccrue();\n            }\n\n            emit Compounded(\n                msg.sender,\n                minGlp,\n                gmxBaseRewardAmountIn,\n                pxGmxAmountOut,\n                pxGlpAmountOut,\n                totalPxGlpFee,\n                totalPxGmxFee,\n                pxGlpIncentive,\n                pxGmxIncentive\n            );\n        }\n\nAs you can see contract collects rewards by calling PirexRewards.claim() and in the line uint256 newAssets = totalAssets() preClaimTotalAssets; contract calculates the received amount of rewards (by subtracting the balance after and before reward claim) and then calculates fee based on this amount totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR; and then sends the fee in the line asset.safeTransfer(owner, totalPxGlpFee pxGlpIncentive) for owner. \n\nThe logic for pxGmx rewards are the same. As you can see the calculation of the fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. So if AutoPxGpl receives rewards without compound() getting called then for those rewards fee won't be calculated and transferred and protocol would lose it's fee.\n\nIn the line _harvest(pxGmxAmountOut totalPxGmxFee) contract calls _harvest() function to update the pxGmx reward accrual and there is no call to _harvest() in any other place and this is the only place where pxGmx reward accrual gets updated. The contract uses pxGmxAmountOut which is the amount of gmx contract received during the call (code calculates it by subtracting the balance after and before reward claim: pxGmxAmountOut = pxGmx.balanceOf(address(this)) preClaimPxGmxAmount;) so contract only handles accrual rewards in this function call and if some pxGmx rewards claimed for contract without compund() logic execution then those rewards won't be used in _harvest() and _globalAccrue() calculation and users won't receive those rewards.\n\nAs mentioned attacker can call PirexRewards.claim(pxGmx, AutoPxGpl) directly and make PirexRewads contract to transfer AutoPxGpl rewards. This is claim() code in PirexRewards:\n\n        function claim(ERC20 producerToken, address user) external {\n            if (address(producerToken) == address(0)) revert ZeroAddress();\n            if (user == address(0)) revert ZeroAddress();\n\n            harvest();\n            userAccrue(producerToken, user);\n\n            ProducerToken storage p = producerTokens[producerToken];\n            uint256 globalRewards = p.globalState.rewards;\n            uint256 userRewards = p.userStates[user].rewards;\n\n            // Claim should be skipped and not reverted on zero global/user reward\n            if (globalRewards != 0 && userRewards != 0) {\n                ERC20[] memory rewardTokens = p.rewardTokens;\n                uint256 rLen = rewardTokens.length;\n\n                // Update global and user reward states to reflect the claim\n                p.globalState.rewards = globalRewards userRewards;\n                p.userStates[user].rewards = 0;\n\n                emit Claim(producerToken, user);\n\n                // Transfer the proportionate reward token amounts to the recipient\n                for (uint256 i; i < rLen; ++i) {\n                    ERC20 rewardToken = rewardTokens[i];\n                    address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                    address recipient = rewardRecipient != address(0)\n                        ? rewardRecipient\n                        : user;\n                    uint256 rewardState = p.rewardStates[rewardToken];\n                    uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                    if (amount != 0) {\n                        // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                        p.rewardStates[rewardToken] = rewardState amount;\n\n                        producer.claimUserReward(\n                            address(rewardToken),\n                            amount,\n                            recipient\n                        );\n                    }\n                }\n            }\n        }\n\nAs you can see it can be called by anyone for any user. So to perform this attack, attacker would perform these steps:\n\n1.  Suppose AutoPxGpl has pending rewards, for example 100 pxGmx and 100 weth.\n2.  Attacker would call  PirexRewards.claim(pxGmx, AutoPxGpl) and  PirexRewards.claim(pxGpl, AutoPxGpl) and PirexRewards contract would calculate and claim and transfer pxGmx rewards and weth rewards of AutoPxGpl address.\n3.  Then AutoPxGpl has no pending rewards but the balance of pxGmx and weth of contract has been increased.\n4.  If anyone calls AutoPxGpl.compound() because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call to compound() so contract wouldn't calculate any fee or reward accrual for those 1000 pxGmx and weth rewards.\n5.  owner of AutoPxGpl would lose his fee for those rewards and users of AutoPxGpl would lose their claims for those 1000 pxGmx rewards (because the calculation for them didn't happen).\n\nThis bug is because of the fact that the only logic handling rewards is in compound() function which is only handling receiving rewards by calling claim() during the call to compound() but it's possible to call claim() directly (PirexRewards contract allows this) and AutoPxGpl won't get notified about this new rewards and the related logics won't get executed.\n\n\nVIM\n\n",
                "Repair": "\nContract should keep track of it's previous balance when compound() get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call to compound().\n\nkphed (Redacted Cartel) confirmed(https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/321) \n\n*\n\n \n\n"
            }
        ]
    }
]