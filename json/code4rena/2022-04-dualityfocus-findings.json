[
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./external/TickOracle.sol\";\nimport \"./external/IUniV3LpVault.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n     * @notice Administrator for this contract\n     */\n    address public admin;\n\n    /**\n     * @notice Pending administrator for this contract\n     */\n    address public pendingAdmin;\n\n    /**\n     * @notice Active brains of Unitroller\n     */\n    address public comptrollerImplementation;\n\n    /**\n     * @notice Pending brains of Unitroller\n     */\n    address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n\n\n    /**\n     * @notice Tick oracle which gives the current tick of a given Uni V3 Pool\n     */\n    TickOracle public tickOracle;\n\n    /**\n     * @notice Vault which holds and values user's Uni V3 LP Collateral\n     */\n    IUniV3LpVault public uniV3LpVault;\n    /**\n     * @notice Mapping of which pools are supported for Uni V3 LP Collateral\n     */\n    mapping(address => bool) public isSupportedPool;\n    /**\n     * @notice Mapping of pools to their collateralFactors in mantissa\n     */\n    mapping(address => uint256) public poolCollateralFactors;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    /**\n     * @notice UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint256 internal maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n    struct Market {\n        /**\n         * @notice Whether or not this market is listed\n         */\n        bool isListed;\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /**\n         * @notice Per-market mapping of \"accounts in this asset\"\n         */\n        mapping(address => bool) accountMembership;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n    /// @notice A list of all markets\n    CToken[] public allMarkets;\n\n    /**\n     * @dev Maps borrowers to booleans indicating if they have entered any markets\n     */\n    mapping(address => bool) internal borrowers;\n\n    /// @notice A list of all borrowers who have entered markets\n    address[] public allBorrowers;\n\n    /// @notice Indexes of borrower account addresses in the `allBorrowers` array\n    mapping(address => uint256) internal borrowerIndexes;\n\n    /**\n     * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n     */\n    mapping(address => bool) public suppliers;\n\n    /// @notice All cTokens addresses mapped by their underlying token addresses\n    mapping(address => CToken) public cTokensByUnderlying;\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n    /**\n     * @dev Whether or not the implementation should be auto-upgraded.\n     */\n    bool public autoImplementation;\n\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint256) public borrowCaps;\n\n    /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint256) public supplyCaps;\n\n    /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n    bool internal _notEntered;\n\n    /// @dev Whether or not _notEntered has been initialized\n    bool internal _notEnteredInitialized;\n}\n\n\npragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Logic for Compound's JumpRateModel Contract V2.\n * @author Compound (modified by Dharma Labs, refactored by Arr00)\n * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n */\ncontract BaseJumpRateModelV2 {\n    using SafeMath for uint256;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink\n    );\n\n    /**\n     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n    address public owner;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint256 public constant blocksPerYear = 2102400;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_\n    ) internal {\n        owner = owner_;\n\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n\n        updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRateInternal(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint256 excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /**\n     * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\n        uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function updateJumpRateModelInternal(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(blocksPerYear.mul(kink_));\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n}\n\n\npragma solidity ^0.5.16;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint256 err = _setComptroller(comptroller_);\n        require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint256(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"setting reserve factor failed\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal returns (uint256) {\n        /* Fail if transfer not allowed */\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint256(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint256 allowanceNew;\n        uint256 srcTokensNew;\n        uint256 dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint256(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cTokenBalance = accountTokens[account];\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view returns (uint256) {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, totalReserves);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint256 blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(\n        uint256 currentBlockNumber,\n        uint256 cashPrior,\n        uint256 borrowRateMantissa,\n        uint256 blockDelta\n    ) private returns (uint256) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n        uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            totalReserves\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        // Attempt to add interest checkpoint\n        address(interestRateModel).call(abi.encodeWithSignature(\"checkpointInterest(uint256)\", borrowRateMantissa));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address minter, uint256 mintAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, minter, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is supplying the assets\n     * @param minter The address of the account under which supply is tracked\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(\n        address payer,\n        address minter,\n        uint256 mintAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if mint not allowed */\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalfInternal(address redeemer, uint256 redeemTokens)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalfInternal(address redeemer, uint256 redeemAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param to The address of the account which is redeeming the tokens\n     * @param redeemer The address of the account under which redemption is tracked\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(\n        address payable to,\n        address redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal returns (uint256) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, vars.redeemAmount);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalfInternal(address borrower, uint256 borrowAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == borrower,\n            \"only the LpVault may borrow against other's collateral\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrower, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol\n     * @param to The address of the account which is borrowing the tokens\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowFresh(\n        address payable to,\n        address borrower,\n        uint256 borrowAmount\n    ) internal returns (uint256) {\n        /* Fail if borrow not allowed */\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint256 cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, borrowAmount);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if repayBorrow not allowed */\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint256(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers Uni V3 LP collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Internal(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n        // liquidateBorrowUniV3Fresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowUniV3Fresh(msg.sender, borrower, repayAmount, collateralTokenId);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(cTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            address(this),\n            address(cTokenCollateral),\n            actualRepayAmount\n        );\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint256 seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Fresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowUniV3Allowed(\n            address(this),\n            collateralTokenId,\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n        // could reduce duplication of below checks and share w/ liquidateBorrowFresh\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        (\n            uint256 amountSeizeError,\n            uint256 seizeFeesToken0,\n            uint256 seizeFeesToken1,\n            uint256 seizeLiquidity\n        ) = comptroller.liquidateCalculateSeizeTokensUniV3(address(this), collateralTokenId, actualRepayAmount);\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n        comptroller.uniV3LpVault().seizeAssets(\n            liquidator,\n            borrower,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        // require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrowUniV3(\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external nonReentrant(true) returns (uint256) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint256 borrowerTokensNew;\n        uint256 liquidatorTokensNew;\n        uint256 liquidatorSeizeTokens;\n        uint256 protocolSeizeTokens;\n        uint256 protocolSeizeAmount;\n        uint256 exchangeRateMantissa;\n        uint256 totalReservesNew;\n        uint256 totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) internal returns (uint256) {\n        /* Fail if seize not allowed */\n        uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(\n            Exp({ mantissa: vars.exchangeRateMantissa }),\n            vars.protocolSeizeTokens\n        );\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() external returns (uint256) {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Internal function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint256) {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReservesInternal(uint256 addAmount) internal nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\n        // totalReserves + actualAddAmount\n        uint256 totalReservesNew;\n        uint256 actualAddAmount;\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n        totalReservesNew = totalReserves + actualAddAmount;\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint256(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        // Attempt to reset interest checkpoints on old IRM\n        if (address(oldInterestRateModel) != address(0))\n            address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n        // Attempt to add first interest checkpoint on new IRM\n        address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n        // Check caller is admin\n        require(msg.sender != admin, \"caller not admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint256 amount) internal;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n\n\npragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            reserveFactorMantissa_\n        );\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external returns (uint256) {\n        (uint256 err, ) = mintBehalfInternal(minter, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalf(address redeemer, uint256 redeemTokens) external returns (uint256) {\n        return redeemBehalfInternal(redeemer, redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalf(address redeemer, uint256 redeemAmount) external returns (uint256) {\n        return redeemUnderlyingBehalfInternal(redeemer, redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower the account with the debt being payed off\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalf(address borrower, uint256 borrowAmount) external returns (uint256) {\n        return borrowBehalfInternal(borrower, borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n        (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral UniV3 LP Position.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowUniV3(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowUniV3Internal(borrower, repayAmount, collateralTokenId);\n        return err;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) external {\n        require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount) external returns (uint256) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256) {\n        uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        _callOptionalReturn(\n            abi.encodeWithSelector(\n                EIP20NonStandardInterface(underlying).transferFrom.selector,\n                from,\n                address(this),\n                amount\n            ),\n            \"TOKEN_TRANSFER_IN_FAILED\"\n        );\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        _callOptionalReturn(\n            abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount),\n            \"TOKEN_TRANSFER_OUT_FAILED\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n        bytes memory returndata = _functionCall(underlying, data, errorMessage);\n        if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n    }\n}\n\n\n",
        "CodeNames": [
            "ComptrollerStorage.sol",
            "BaseJumpRateModelV2.sol",
            "CToken.sol",
            "CErc20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction _acceptAdmin() external returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n    // Clear the pending value\n    pendingAdmin = address(0);\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    return uint256(Error.NO_ERROR);\n}\n"
                ],
                "Type": " Dysfunctional  CToken._acceptAdmin  due to lack of function to assign  pendingAdmin ",
                "Description": "\nCToken.sol#L1379(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/CToken.sol#L1379)<br\n\nThe implementation of CToken in Duality introduced an _acceptAdmin function, which presumably should allow changing the admin. However, there does not exist a pairing proposePendingAdmin function that can propose a new pendingAdmin, thus pendingAdmin will never be set. This renders the _acceptAdmin function useless.\n\n\n_acceptAdmin requires msg.sender to equal pendingAdmin, however, since pendingAdmin can never be set, it will always be address(0), making this function unusable.\nsolidity\nfunction _acceptAdmin() external returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n    // Clear the pending value\n    pendingAdmin = address(0);\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    return uint256(Error.NO_ERROR);\n}\n\n\n\nvim, ganache-cli\n\n",
                "Repair": "\nAdd a proposePendingAdmin function where the current admin can propose successors.\nsolidity\nfunction _proposePendingAdmin(address newPendingAdmin) external {\n    if (msg.sender != admin) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);\n    }\n    address oldPendingAdmin = pendingAdmin;\n    pendingAdmin = newPendingAdmin;\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    return uint256(Error.NO_ERROR)\n}\n\n\n0xdramaone (Duality Focus) confirmed and commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/29#issuecomment-1094739902):\n  Acknowledged, we were aware this matches the behavior of actual compound when deployed with CErc20Immutable. We originally thought we would stick with this functionality, but have now opted for enabling admin transitions. \n\n0xdramaone (Duality Focus) resolved(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/29)\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./external/IUniV3LpVault.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when tick oracle is changed\n    event NewTickOracle(TickOracle oldTickOracle, TickOracle newTickOracle);\n\n    /// @notice Emitted when UniV3LpVault is changed\n    event NewUniV3LpVault(IUniV3LpVault oldVault, IUniV3LpVault newVault);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n     // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    constructor (address _admin) public {\n        admin = _admin;\n        _notEntered = true;\n        _notEnteredInitialized = true;    \n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint256[] memory) {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account\u2019s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n            allBorrowers.length--; // Reduce length by 1\n            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // deposits are automatically treated as collateral\n        if (!markets[cToken].accountMembership[minter]) {\n            // only cTokens may call mintAllowed if minter not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add minter to the market\n            Error err = addToMarketInternal(CToken(msg.sender), minter);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[minter]);\n        }\n\n        // Check supply cap\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves)\n            (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            uint256 nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            CToken(cToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        // Check borrow cap\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            CToken(cToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param collateralTokenId the tokenId of the Uni V3 NFT being used as collateral\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowUniV3Allowed(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        collateralTokenId;\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (uniV3LpVault.ownerOf(collateralTokenId) != borrower) {\n            return uint256(Error.TOKEN_ID_BORROWER_MISMATCH);\n        }\n\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * new seize function for Uni V3 vault\n     */\n    function seizeAllowedUniV3(\n        address lpVault,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        tokenId;\n        seizeFeesToken0;\n        seizeFeesToken1;\n        seizeLiquidity;\n\n        // check that the borrow token is listed in comptroller market\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // check that lpVault matches our LPVault\n        if (lpVault != address(uniV3LpVault)) {\n            return uint256(Error.LP_VAULT_MISMATCH);\n        }\n\n        // check that lpVault comptroller matches this comptroller\n        if (uniV3LpVault.comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(0),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(cTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            uint256 tokenId = uniV3LpVault.userTokens(account, i);\n            (\n                address token0,\n                address token1,\n                uint256 amountToken0Fees,\n                uint256 amountToken1Fees,\n                uint256 amountToken0Liquidity,\n                uint256 amountToken1Liquidity,\n\n            ) = tickOracle.getTokenBreakdownTWAP(tokenId);\n            CToken asset0 = cTokensByUnderlying[token0];\n            CToken asset1 = cTokensByUnderlying[token1];\n\n            {\n                // avoid stack too deep\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                uint256 collateralFactorMantissa = poolCollateralFactors[poolAddress];\n\n                vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n            }\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset0);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken0Fees, amountToken0Liquidity),\n                vars.sumCollateral\n            );\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset1);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken1Fees, amountToken1Liquidity),\n                vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // add all Uni V3 LP Collateral value\n        addNFTCollateral(account, vars);\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(\n                account\n            );\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint256(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint256 seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint256(Error.NO_ERROR), seizeTokens);\n    }\n\n    // to avoid stack-too-deep errors on `liquidateCalculateSeizeTokensUniV3`\n    struct LiquidationSeizeLocalVars {\n        uint256 amountToken0Fees;\n        uint256 amountToken1Fees;\n        uint256 amountToken0Liquidity;\n        uint256 amountToken1Liquidity;\n        uint256 amountLiquidity;\n        Exp borrowValue;\n        Exp feeValue;\n        Exp liquidityValue;\n    }\n\n    /**\n     * @notice Calculate amount of liquidity NFT to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowUniV3Fresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, percent of fees to be seized, amount of colalteralTokenId liquidity to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokensUniV3(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        uint256 actualRepayAmount\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint128,\n            uint128,\n            uint128\n        )\n    {\n        LiquidationSeizeLocalVars memory vars;\n\n        /*\n         * take the value in eth, convert it to borrow value. see what % the repay borrow + incentive.\n         * if % < 100, then return 0 on liquidity.\n         * If above 100%, take % - 100 to get value that should be removed from total liquidity.\n         * Then take that value, divided by the total value of the liquidity, and multiply by the amount of liquidity.\n         * Cap this liquidity amount at the total liquidity amount (since we've already liquidated everything)\n         */\n\n        address token0;\n        address token1;\n        (\n            token0,\n            token1,\n            vars.amountToken0Fees,\n            vars.amountToken1Fees,\n            vars.amountToken0Liquidity,\n            vars.amountToken1Liquidity,\n            vars.amountLiquidity\n        ) = tickOracle.getTokenBreakdownTWAP(collateralTokenId);\n\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 oraclePriceMantissa0 = oracle.price(token0);\n        uint256 oraclePriceMantissa1 = oracle.price(token1);\n        if (priceBorrowedMantissa == 0 || oraclePriceMantissa0 == 0 || oraclePriceMantissa1 == 0) {\n            return (uint256(Error.PRICE_ERROR), 0, 0, 0);\n        }\n\n        // TODO: custom liquidation incentive for LP shares\n        vars.borrowValue = mul_(\n            mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa })),\n            actualRepayAmount\n        );\n        vars.feeValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Fees),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Fees)\n        );\n        vars.liquidityValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Liquidity),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Liquidity)\n        );\n\n        require(\n            lessThanOrEqualExp(vars.borrowValue, add_(vars.feeValue, vars.liquidityValue)),\n            \"borrowValue greater than total collateral\"\n        );\n\n        if (lessThanExp(vars.borrowValue, vars.feeValue)) {\n            // only return from fees\n            uint128 seizeAmountToken0Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken0Fees)\n            );\n            uint128 seizeAmountToken1Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken1Fees)\n            );\n            return (uint256(Error.NO_ERROR), seizeAmountToken0Fees, seizeAmountToken1Fees, 0);\n        } else {\n            // only return from liquidity\n            uint128 seizeAmountLiquidity = uint128(\n                mul_ScalarTruncate(\n                    div_(sub_(vars.borrowValue, vars.feeValue), vars.liquidityValue),\n                    vars.amountLiquidity\n                )\n            );\n            return (\n                uint256(Error.NO_ERROR),\n                uint128(vars.amountToken0Fees),\n                uint128(vars.amountToken1Fees),\n                seizeAmountLiquidity\n            );\n        }\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setTickOracle(TickOracle newTickOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TICK_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        TickOracle oldTickOracle = tickOracle;\n\n        // Set comptroller's oracle to newOracle\n        tickOracle = newTickOracle;\n\n        // Emit NewTickOracle(oldTickOracle, newTickOracle)\n        emit NewTickOracle(oldTickOracle, newTickOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new UniV3LpVault for the comptroller\n     * @dev Admin function to set a new UniV3LpVault\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old vault for the comptroller\n        IUniV3LpVault oldVault = uniV3LpVault;\n\n        // Set comptroller's uniV3LpVault to newVault\n        uniV3LpVault = newVault;\n\n        // Emit NewUniV3LpVault(oldVault, newVault)\n        emit NewUniV3LpVault(oldVault, newVault);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n        }\n\n        // Check limits\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        // Set pool close factor to new close factor, remember old value\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        // Emit event\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Admin function to set per-market collateralFactor\n     * @param cToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(CToken cToken, uint256 newCollateralFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n        Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n        Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param cToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(CToken cToken) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        // Is market already listed?\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // Sanity check to make sure its really a CToken\n        require(cToken.isCToken(), \"marker method returned false\");\n\n        // Check cToken.comptroller == this\n        require(\n            address(cToken.comptroller()) == address(this),\n            \"Cannot support a market with a different Comptroller.\"\n        );\n\n        // Make sure market is not already listed\n        address underlying = CErc20(address(cToken)).underlying();\n\n        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // List market and emit event\n        markets[address(cToken)] = Market({ isListed: true, collateralFactorMantissa: 0 });\n        allMarkets.push(cToken);\n        cTokensByUnderlying[underlying] = cToken;\n        emit MarketListed(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removed a market from the markets mapping and sets it as unlisted\n     * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n     * @param cToken The address of the market (token) to unlist\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _unsupportMarket(CToken cToken) external returns (uint256) {\n        // Check admin rights\n        if (msg.sender != admin) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n        // Check if market is already unlisted\n        if (!markets[address(cToken)].isListed)\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n        // Check if market is in use\n        if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n        // Unlist market\n        delete markets[address(cToken)];\n\n        /* Delete cToken from allMarkets */\n        // load into memory for faster iteration\n        CToken[] memory _allMarkets = allMarkets;\n        uint256 len = _allMarkets.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (_allMarkets[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n        allMarkets.length--;\n\n        cTokensByUnderlying[CErc20(address(cToken)).underlying()] = CToken(address(0));\n        emit MarketUnlisted(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n     * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n     */\n    function _setMarketSupplyCaps(CToken[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set supply caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set borrow caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n        Comptroller(address(unitroller))._becomeImplementation();\n    }\n\n    function _becomeImplementation() external {\n        require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n        if (!_notEnteredInitialized) {\n            _notEntered = true;\n            _notEnteredInitialized = true;\n        }\n    }\n\n    /**\n     * @notice sets the state for many pools of whether or not they are supported as collateral\n     *              in actuality, just limits whether or not a pool can be deposited into the vault\n     * @param pools The addresses of Uni V3 Pools\n     * @param states The state of whether or not this pool is to be supported (corresponding by index to pools)\n     */\n    function _setSupportedPools(address[] calldata pools, bool[] calldata states) external {\n        require(msg.sender == admin, \"only admin can set supported pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(pools.length == states.length, \"Number of pools and states must be equal\");\n        for (uint256 i = 0; i < pools.length; i++) {\n            isSupportedPool[pools[i]] = states[i];\n        }\n    }\n\n    /**\n     * @notice sets the collateral factors for many pools\n     * @param pools The addresses of Uni V3 Pools\n     * @param collateralFactorsMantissa The collateral factors for LP positions of the pools\n     */\n    function _setPoolCollateralFactors(address[] calldata pools, uint256[] calldata collateralFactorsMantissa)\n        external\n    {\n        require(msg.sender == admin, \"only admin can set collateral factors for pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(\n            pools.length == collateralFactorsMantissa.length,\n            \"Number of pools and collateralFactors must be equal\"\n        );\n        for (uint256 i = 0; i < pools.length; i++) {\n            poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n        }\n    }\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Return all of the borrowers\n     * @dev The automatic getter may be used to access an individual borrower.\n     * @return The list of borrower account addresses\n     */\n    function getAllBorrowers() public view returns (address[] memory) {\n        return allBorrowers;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) public view returns (bool) {\n        return\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\n            borrowGuardianPaused[address(cToken)] == true &&\n            cToken.reserveFactorMantissa() == 1e18;\n    }\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    /**\n     * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _beforeNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_beforeNonReentrant: caller not listed as market or lpVault\"\n        );\n        require(_notEntered, \"re-entered across assets\");\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _afterNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_afterNonReentrant: caller not listed as market or lpVault\"\n        );\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n\n\npragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            reserveFactorMantissa_\n        );\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external returns (uint256) {\n        (uint256 err, ) = mintBehalfInternal(minter, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalf(address redeemer, uint256 redeemTokens) external returns (uint256) {\n        return redeemBehalfInternal(redeemer, redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalf(address redeemer, uint256 redeemAmount) external returns (uint256) {\n        return redeemUnderlyingBehalfInternal(redeemer, redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower the account with the debt being payed off\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalf(address borrower, uint256 borrowAmount) external returns (uint256) {\n        return borrowBehalfInternal(borrower, borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n        (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral UniV3 LP Position.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowUniV3(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowUniV3Internal(borrower, repayAmount, collateralTokenId);\n        return err;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) external {\n        require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount) external returns (uint256) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256) {\n        uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        _callOptionalReturn(\n            abi.encodeWithSelector(\n                EIP20NonStandardInterface(underlying).transferFrom.selector,\n                from,\n                address(this),\n                amount\n            ),\n            \"TOKEN_TRANSFER_IN_FAILED\"\n        );\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        _callOptionalReturn(\n            abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount),\n            \"TOKEN_TRANSFER_OUT_FAILED\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n        bytes memory returndata = _functionCall(underlying, data, errorMessage);\n        if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n    }\n}\n\n\n",
        "CodeNames": [
            "Comptroller.sol",
            "CErc20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {\n    ...\n    uniV3LpVault = newVault;\n    ...\n}\n",
                    "//solidity\ncontract UniV3LpVault is IUniV3LpVault {\n    ...\n    function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {\n        ...\n    }\n\n    modifier avoidsShortfall() {\n        _;\n        (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);\n        require(shortfall == 0, \"insufficient liquidity\");\n    }\n    ...\n}\n\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    ...\n    function getAccountLiquidity(address account) public view returns (...) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);\n        ...\n    }\n\n    function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {\n        ...\n        addNFTCollateral(account, vars);\n        ...\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            ...\n            {\n                ...\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                ...\n            }\n            ...\n        }\n        ...\n    }\n}\n"
                ],
                "Type": "  Comptroller._setUniV3LpVault  will always cause in-use uniswapV3 positions to become stuck in  UniV3LpVault ",
                "Description": "\nComptroller.sol#L1105(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/compound_rari_fork/Comptroller.sol#L1105)<br\n\nComptroller._setUniV3LpVault allows the admin of Comptroller to change the accompanying UniV3LpVault. However since actions including collateral calculation, uniswapV3 position withdrawal, uniswapV3 collateral liquidation all require Comptroller and UniV3LpVault to cooperate seamlessly, a change in Comptroller.uniV3LpVault would mean all the above actions are no longer performable on existing NFTs.\n\n\n_setUniV3LpVault allows changing of uniV3LpVault.\nsolidity\nfunction _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {\n    ...\n    uniV3LpVault = newVault;\n    ...\n}\n\n\nHowever, functions such as UniV3LpVault.withdrawToken require Comptroller to estimate NFT collateral value. This estimation can only be done when the address of UniV3LpVault matches Comptroller.uniV3LpVault as shown in addNFTCollateral below.\n\nsolidity\ncontract UniV3LpVault is IUniV3LpVault {\n    ...\n    function withdrawToken(...) external override nonReentrant(false) avoidsShortfall {\n        ...\n    }\n\n    modifier avoidsShortfall() {\n        _;\n        (, , uint256 shortfall) = comptroller.getAccountLiquidity(msg.sender);\n        require(shortfall == 0, \"insufficient liquidity\");\n    }\n    ...\n}\n\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    ...\n    function getAccountLiquidity(address account) public view returns (...) {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(...);\n        ...\n    }\n\n    function getHypotheticalAccountLiquidityInternal(...) internal view returns (...) {\n        ...\n        addNFTCollateral(account, vars);\n        ...\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            ...\n            {\n                ...\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                ...\n            }\n            ...\n        }\n        ...\n    }\n}\n\n\nThe mutual reliance causes NFT tokens to become stuck. In some cases users can solve this issue by depositing more collateral to cover the shortcoming caused by \"disappearing NFTs\". In other cases such as liquidation, the functionality becomes downright broken and unuseable..\n\n\nvim, ganache-cli\n\n",
                "Repair": "\nRemove the option to change Comptroller.uniV3LpVault altogether, as this functionality is not really helpful for the overall protocol.<br\nAnother way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states.\n\n0xdramaone (Duality Focus) confirmed and commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/28#issuecomment-1094736026):\n  We agree, should only allow one setting of the UniV3LpVault (no overwrites). Maintaining as med risk given that this would block user withdrawals.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/28#issuecomment-1097597994):\n  Good catch! Some sanity check is needed.\n\n0xdramaone (Duality Focus) resolved(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/28)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint256 err = _setComptroller(comptroller_);\n        require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint256(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // Set reserve factor\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n        require(err == uint256(Error.NO_ERROR), \"setting reserve factor failed\");\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferTokens(\n        address spender,\n        address src,\n        address dst,\n        uint256 tokens\n    ) internal returns (uint256) {\n        /* Fail if transfer not allowed */\n        uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint256(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        MathError mathErr;\n        uint256 allowanceNew;\n        uint256 srcTokensNew;\n        uint256 dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != uint256(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external nonReentrant(false) returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n        (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 cTokenBalance = accountTokens[account];\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) public view returns (uint256) {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n        /* Note: we do not assert that the market is up to date */\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant(false) returns (uint256) {\n        require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n        return result;\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     */\n    function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() public returns (uint256) {\n        /* Remember the initial block number */\n        uint256 currentBlockNumber = getBlockNumber();\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumber == currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Read the previous values out of storage */\n        uint256 cashPrior = getCashPrior();\n\n        /* Calculate the current borrow interest rate */\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, totalReserves);\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        (MathError mathErr, uint256 blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n        return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n    }\n\n    /**\n     * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n     */\n    function finishInterestAccrual(\n        uint256 currentBlockNumber,\n        uint256 cashPrior,\n        uint256 borrowRateMantissa,\n        uint256 blockDelta\n    ) private returns (uint256) {\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n         *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n        uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n        uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n            Exp({ mantissa: reserveFactorMantissa }),\n            interestAccumulated,\n            totalReserves\n        );\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        // Attempt to add interest checkpoint\n        address(interestRateModel).call(abi.encodeWithSignature(\"checkpointInterest(uint256)\", borrowRateMantissa));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintBehalfInternal(address minter, uint256 mintAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        return mintFresh(msg.sender, minter, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualMintAmount;\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param payer The address of the account which is supplying the assets\n     * @param minter The address of the account under which supply is tracked\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n     */\n    function mintFresh(\n        address payer,\n        address minter,\n        uint256 mintAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if mint not allowed */\n        uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n        }\n\n        MintLocalVars memory vars;\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr)), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualMintAmount,\n            Exp({ mantissa: vars.exchangeRateMantissa })\n        );\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         */\n        vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n        vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalfInternal(address redeemer, uint256 redeemTokens)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalfInternal(address redeemer, uint256 redeemAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == redeemer,\n            \"only the LpVault may redeem other's assets\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        return redeemFresh(msg.sender, redeemer, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param to The address of the account which is redeeming the tokens\n     * @param redeemer The address of the account under which redemption is tracked\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemFresh(\n        address payable to,\n        address redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal returns (uint256) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        RedeemLocalVars memory vars;\n\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n        }\n\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n                Exp({ mantissa: vars.exchangeRateMantissa }),\n                redeemTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n                redeemAmountIn,\n                Exp({ mantissa: vars.exchangeRateMantissa })\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /*\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         */\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /* Fail gracefully if protocol has insufficient cash */\n        if (getCashPrior() < vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, vars.redeemAmount);\n\n        /* We write previously calculated values into storage */\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        /* We emit a Transfer event, and a Redeem event */\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        /* We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalfInternal(address borrower, uint256 borrowAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256)\n    {\n        require(\n            msg.sender == address(comptroller.uniV3LpVault()) || msg.sender == borrower,\n            \"only the LpVault may borrow against other's collateral\"\n        );\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\n        return borrowFresh(msg.sender, borrower, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    /**\n     * @notice Users borrow assets from the protocol\n     * @param to The address of the account which is borrowing the tokens\n     * @param borrower The address of the account under which borrowing is tracked\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowFresh(\n        address payable to,\n        address borrower,\n        uint256 borrowAmount\n    ) internal returns (uint256) {\n        /* Fail if borrow not allowed */\n        uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        /* Fail gracefully if protocol has insufficient underlying cash */\n        uint256 cashPrior = getCashPrior();\n\n        if (cashPrior < borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         */\n        doTransferOut(to, borrowAmount);\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a Borrow event */\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n        internal\n        nonReentrant(false)\n        returns (uint256, uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    /**\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) internal returns (uint256, uint256) {\n        /* Fail if repayBorrow not allowed */\n        uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return (\n                failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed),\n                0\n            );\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        /* We remember the original borrowerIndex for verification purposes */\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        /* We fetch the amount the borrower owes, with accumulated interest */\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        /* If repayAmount == -1, repayAmount = accountBorrows */\n        if (repayAmount == uint256(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *   it returns the amount actually transferred, in case of a fee.\n         */\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n        /*\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\n         */\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n        /* We write the previously calculated values into storage */\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        /* We emit a RepayBorrow event */\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers Uni V3 LP collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Internal(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal nonReentrant(false) returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n        }\n        // liquidateBorrowUniV3Fresh emits borrow-specific logs on errors, so we don't need to\n        return liquidateBorrowUniV3Fresh(msg.sender, borrower, repayAmount, collateralTokenId);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowFresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\n            address(this),\n            address(cTokenCollateral),\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n\n        /* Verify cTokenCollateral market's block number equals current block number */\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We calculate the number of collateral tokens that will be seized */\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n            address(this),\n            address(cTokenCollateral),\n            actualRepayAmount\n        );\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n        /* Revert if borrower collateral token balance < seizeTokens */\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n        uint256 seizeError;\n        if (address(cTokenCollateral) == address(this)) {\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n        } else {\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        }\n\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n     */\n    function liquidateBorrowUniV3Fresh(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) internal returns (uint256, uint256) {\n        /* Fail if liquidate not allowed */\n        uint256 allowed = comptroller.liquidateBorrowUniV3Allowed(\n            address(this),\n            collateralTokenId,\n            liquidator,\n            borrower,\n            repayAmount\n        );\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n        }\n        // could reduce duplication of below checks and share w/ liquidateBorrowFresh\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n        }\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n        }\n        /* Fail if repayAmount = 0 */\n        if (repayAmount == 0) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n        }\n        /* Fail if repayAmount = -1 */\n        if (repayAmount == uint256(-1)) {\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n        }\n        /* Fail if repayBorrow fails */\n        (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint256(Error.NO_ERROR)) {\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        (\n            uint256 amountSeizeError,\n            uint256 seizeFeesToken0,\n            uint256 seizeFeesToken1,\n            uint256 seizeLiquidity\n        ) = comptroller.liquidateCalculateSeizeTokensUniV3(address(this), collateralTokenId, actualRepayAmount);\n        require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n        comptroller.uniV3LpVault().seizeAssets(\n            liquidator,\n            borrower,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n        // require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n        /* We emit a LiquidateBorrow event */\n        emit LiquidateBorrowUniV3(\n            liquidator,\n            borrower,\n            actualRepayAmount,\n            collateralTokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n        return (uint256(Error.NO_ERROR), actualRepayAmount);\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external nonReentrant(true) returns (uint256) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }\n\n    struct SeizeInternalLocalVars {\n        MathError mathErr;\n        uint256 borrowerTokensNew;\n        uint256 liquidatorTokensNew;\n        uint256 liquidatorSeizeTokens;\n        uint256 protocolSeizeTokens;\n        uint256 protocolSeizeAmount;\n        uint256 exchangeRateMantissa;\n        uint256 totalReservesNew;\n        uint256 totalSupplyNew;\n    }\n\n    /**\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function seizeInternal(\n        address seizerToken,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) internal returns (uint256) {\n        /* Fail if seize not allowed */\n        uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        /* Fail if borrower = liquidator */\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        SeizeInternalLocalVars memory vars;\n\n        /*\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         */\n        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n        vars.protocolSeizeAmount = mul_ScalarTruncate(\n            Exp({ mantissa: vars.exchangeRateMantissa }),\n            vars.protocolSeizeTokens\n        );\n\n        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);\n\n        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        totalReserves = vars.totalReservesNew;\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[borrower] = vars.borrowerTokensNew;\n        accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n        /* Emit a Transfer event */\n        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() external returns (uint256) {\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new comptroller for the market\n     * @dev Internal function to set a new comptroller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint256) {\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), \"marker method returned false\");\n\n        // Set market's comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n     * @dev Admin function to accrue interest and set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /**\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n     * @dev Admin function to set a new reserve factor\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor \u2264 maxReserveFactor\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReservesInternal(uint256 addAmount) internal nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n        (error, ) = _addReservesFresh(addAmount);\n        return error;\n    }\n\n    /**\n     * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256, uint256) {\n        // totalReserves + actualAddAmount\n        uint256 totalReservesNew;\n        uint256 actualAddAmount;\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n        }\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        /*\n         * We call doTransferIn for the caller and the addAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional addAmount of cash.\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n         *  it returns the amount actually transferred, in case of a fee.\n         */\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\n        totalReservesNew = totalReserves + actualAddAmount;\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\n        totalReserves = totalReservesNew;\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n        /* Return (NO_ERROR, actualAddAmount) */\n        return (uint256(Error.NO_ERROR), actualAddAmount);\n    }\n\n    /**\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReserves(uint256 reduceAmount) external nonReentrant(false) returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /**\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n        // totalReserves - reduceAmount\n        uint256 totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() < reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount \u2264 reserves[n] (totalReserves)\n        if (reduceAmount > totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        totalReservesNew = sub_(totalReserves, reduceAmount);\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n        doTransferOut(msg.sender, reduceAmount);\n\n        emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /**\n     * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market's block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market's current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        // Attempt to reset interest checkpoints on old IRM\n        if (address(oldInterestRateModel) != address(0))\n            address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n        // Attempt to add first interest checkpoint on new IRM\n        address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice updates the cToken ERC20 name and symbol\n     * @dev Admin function to update the cToken ERC20 name and symbol\n     * @param _name the new ERC20 token name to use\n     * @param _symbol the new ERC20 token symbol to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n        // Check caller is admin\n        require(msg.sender != admin, \"caller not admin\");\n\n        // Set ERC20 name and symbol\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256);\n\n    /**\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256);\n\n    /**\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n    function doTransferOut(address payable to, uint256 amount) internal;\n\n    /*** Reentrancy Guard ***/\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant(bool localOnly) {\n        _beforeNonReentrant(localOnly);\n        _;\n        _afterNonReentrant(localOnly);\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n     */\n    function _beforeNonReentrant(bool localOnly) private {\n        require(_notEntered, \"re-entered\");\n        if (!localOnly) comptroller._beforeNonReentrant();\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n     * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n     * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n     */\n    function _afterNonReentrant(bool localOnly) private {\n        _notEntered = true; // get a gas-refund post-Istanbul\n        if (!localOnly) comptroller._afterNonReentrant();\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.call(data);\n\n        if (!success) {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n\n        return returndata;\n    }\n}\n\n\n",
        "CodeNames": [
            "CToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nIERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n",
                    "//solidity\nIERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n",
                    "//solidity\nIERC20Detailed(params.asset).approve(msg.sender, owedBack);\n"
                ],
                "Type": " Not calling  approve(0)  before setting a new approval causes the call to revert when used with Tether (USDT)",
                "Description": "\nSome tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s approve() function will revert if the current approval is not zero, to protect against front-running changes of approvals.\n\n\nThe code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.\n\n\n1.  File: contracts/vault_and_oracles/FlashLoan.sol (line 48(https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48))\n\nsolidity\nIERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n\n\n2.  File: contracts/vault_and_oracles/FlashLoan.sol (line 58(https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58))\n\nsolidity\nIERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n\n\n3.  File: contracts/vault_and_oracles/UniV3LpVault.sol (line 418(https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418))\n\nsolidity\nIERC20Detailed(params.asset).approve(msg.sender, owedBack);\n\n\nThere are other calls to approve(), but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.\n\n",
                "Repair": "\nUse OpenZeppelin\u2019s SafeERC20's safeTransfer() instead.\n\n0xdramaone (Duality Focus) confirmed and commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/39#issuecomment-1094755628):\n  Agree that we should set approve 0 before all approvals to avoid approval protection reverting and to support assets such as USDT.\n\n0xdramaone (Duality Focus) resolved(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/39)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./external/IUniV3LpVault.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(CToken cToken);\n\n    /// @notice Emitted when an admin unsupports a market\n    event MarketUnlisted(CToken cToken);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(CToken cToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(CToken cToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when tick oracle is changed\n    event NewTickOracle(TickOracle oldTickOracle, TickOracle newTickOracle);\n\n    /// @notice Emitted when UniV3LpVault is changed\n    event NewUniV3LpVault(IUniV3LpVault oldVault, IUniV3LpVault newVault);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(CToken cToken, string action, bool pauseState);\n\n    /// @notice Emitted when supply cap for a cToken is changed\n    event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when borrow cap for a cToken is changed\n    event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n     // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    // No collateralFactorMantissa may exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    constructor (address _admin) public {\n        admin = _admin;\n        _notEntered = true;\n        _notEnteredInitialized = true;    \n    }\n\n    /*** Assets You Are In ***/\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\n        CToken[] memory assetsIn = accountAssets[account];\n\n        return assetsIn;\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\n        return markets[address(cToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] memory cTokens) public returns (uint256[] memory) {\n        uint256 len = cTokens.length;\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n        Market storage marketToJoin = markets[address(cToken)];\n\n        if (!marketToJoin.isListed) {\n            // market is not listed, cannot join\n            return Error.MARKET_NOT_LISTED;\n        }\n\n        if (marketToJoin.accountMembership[borrower] == true) {\n            // already joined\n            return Error.NO_ERROR;\n        }\n\n        // survived the gauntlet, add to list\n        // NOTE: we store these somewhat redundantly as a significant optimization\n        //  this avoids having to iterate through the list for the most common use cases\n        //  that is, only when we need to perform liquidity checks\n        //  and not whenever we want to check if an account is in a particular market\n        marketToJoin.accountMembership[borrower] = true;\n        accountAssets[borrower].push(cToken);\n\n        // Add to allBorrowers\n        if (!borrowers[borrower]) {\n            allBorrowers.push(borrower);\n            borrowers[borrower] = true;\n            borrowerIndexes[borrower] = allBorrowers.length - 1;\n        }\n\n        emit MarketEntered(cToken, borrower);\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing neccessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address cTokenAddress) external returns (uint256) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account\u2019s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.length--;\n\n        // If the user has exited all markets, remove them from the `allBorrowers` array\n        if (storedList.length == 0) {\n            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n            allBorrowers.length--; // Reduce length by 1\n            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n        }\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(\n        address cToken,\n        address minter,\n        uint256 mintAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n        // Shh - currently unused\n        minter;\n        mintAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // deposits are automatically treated as collateral\n        if (!markets[cToken].accountMembership[minter]) {\n            // only cTokens may call mintAllowed if minter not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add minter to the market\n            Error err = addToMarketInternal(CToken(msg.sender), minter);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[minter]);\n        }\n\n        // Check supply cap\n        uint256 supplyCap = supplyCaps[cToken];\n        // Supply cap of 0 corresponds to unlimited supplying\n        if (supplyCap != 0) {\n            uint256 totalCash = CToken(cToken).getCash();\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            uint256 totalReserves = CToken(cToken).totalReserves();\n\n            // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves)\n            (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            uint256 nextTotalUnderlyingSupply;\n            (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external returns (uint256) {\n        uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function redeemAllowedInternal(\n        address cToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) internal view returns (uint256) {\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n        if (!markets[cToken].accountMembership[redeemer]) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            redeemer,\n            CToken(cToken),\n            redeemTokens,\n            0\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(\n        address cToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemTokens\n    ) external {\n        // Shh - currently unused\n        cToken;\n        redeemer;\n\n        // Require tokens is zero or amount is also zero\n        if (redeemTokens == 0 && redeemAmount > 0) {\n            revert(\"redeemTokens zero\");\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(\n        address cToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (!markets[cToken].accountMembership[borrower]) {\n            // only cTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == cToken, \"sender must be cToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            // it should be impossible to break the important invariant\n            assert(markets[cToken].accountMembership[borrower]);\n        }\n\n        // Make sure oracle price is available\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n            return uint256(Error.PRICE_ERROR);\n        }\n\n        // Check borrow cap\n        uint256 borrowCap = borrowCaps[cToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint256 totalBorrows = CToken(cToken).totalBorrows();\n            (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n            if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        // Perform a hypothetical liquidity check to guard against shortfall\n        (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            CToken(cToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint256(err);\n        }\n        if (shortfall > 0) {\n            return uint256(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address cToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        payer;\n        borrower;\n        repayAmount;\n\n        // Make sure market is listed\n        if (!markets[cToken].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        liquidator;\n\n        // Make sure markets are listed\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Get borrowers's underlying borrow balance\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param collateralTokenId the tokenId of the Uni V3 NFT being used as collateral\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowUniV3Allowed(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external returns (uint256) {\n        // Shh - currently unused\n        collateralTokenId;\n        liquidator;\n\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        if (uniV3LpVault.ownerOf(collateralTokenId) != borrower) {\n            return uint256(Error.TOKEN_ID_BORROWER_MISMATCH);\n        }\n\n        uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* allow accounts to be liquidated if the market is deprecated */\n        if (isDeprecated(CToken(cTokenBorrowed))) {\n            require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n        } else {\n            /* The borrower must have shortfall in order to be liquidatable */\n            (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n            if (err != Error.NO_ERROR) {\n                return uint256(err);\n            }\n\n            if (shortfall == 0) {\n                return uint256(Error.INSUFFICIENT_SHORTFALL);\n            }\n\n            /* The liquidator may not repay more than what is allowed by the closeFactor */\n            uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n            if (repayAmount > maxClose) {\n                return uint256(Error.TOO_MUCH_REPAY);\n            }\n        }\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address cTokenCollateral,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        liquidator;\n        borrower;\n        seizeTokens;\n\n        // Make sure markets are listed\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // Make sure cToken Comptrollers are identical\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * new seize function for Uni V3 vault\n     */\n    function seizeAllowedUniV3(\n        address lpVault,\n        address cTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!seizeGuardianPaused, \"seize is paused\");\n\n        // Shh - currently unused\n        tokenId;\n        seizeFeesToken0;\n        seizeFeesToken1;\n        seizeLiquidity;\n\n        // check that the borrow token is listed in comptroller market\n        if (!markets[cTokenBorrowed].isListed) {\n            return uint256(Error.MARKET_NOT_LISTED);\n        }\n\n        // check that lpVault matches our LPVault\n        if (lpVault != address(uniV3LpVault)) {\n            return uint256(Error.LP_VAULT_MISMATCH);\n        }\n\n        // check that lpVault comptroller matches this comptroller\n        if (uniV3LpVault.comptroller() != CToken(cTokenBorrowed).comptroller()) {\n            return uint256(Error.COMPTROLLER_MISMATCH);\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(\n        address cToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external returns (uint256) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!transferGuardianPaused, \"transfer is paused\");\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n        if (allowed != uint256(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** Liquidity/Liquidation Calculations ***/\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowPlusEffects;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(0),\n            0,\n            0\n        );\n\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidityInternal(address account)\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            CToken(cTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint256(err), liquidity, shortfall);\n    }\n\n    function addNFTCollateral(address account, AccountLiquidityLocalVars memory vars) internal view {\n        uint256 userTokensLength = uniV3LpVault.getUserTokensLength(account);\n        for (uint256 i = 0; i < userTokensLength; i++) {\n            uint256 tokenId = uniV3LpVault.userTokens(account, i);\n            (\n                address token0,\n                address token1,\n                uint256 amountToken0Fees,\n                uint256 amountToken1Fees,\n                uint256 amountToken0Liquidity,\n                uint256 amountToken1Liquidity,\n\n            ) = tickOracle.getTokenBreakdownTWAP(tokenId);\n            CToken asset0 = cTokensByUnderlying[token0];\n            CToken asset1 = cTokensByUnderlying[token1];\n\n            {\n                // avoid stack too deep\n                address poolAddress = uniV3LpVault.getPoolAddress(tokenId);\n                uint256 collateralFactorMantissa = poolCollateralFactors[poolAddress];\n\n                vars.collateralFactor = Exp({ mantissa: collateralFactorMantissa });\n            }\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset0);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken0Fees, amountToken0Liquidity),\n                vars.sumCollateral\n            );\n\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset1);\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n            vars.tokensToDenom = mul_(vars.collateralFactor, vars.oraclePrice);\n\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                add_(amountToken1Fees, amountToken1Liquidity),\n                vars.sumCollateral\n            );\n        }\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidityInternal(\n        address account,\n        CToken cTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    )\n        internal\n        view\n        returns (\n            Error,\n            uint256,\n            uint256\n        )\n    {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        // add all Uni V3 LP Collateral value\n        addNFTCollateral(account, vars);\n\n        // For each asset the account is in\n        CToken[] memory assets = accountAssets[account];\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(\n                account\n            );\n            if (oErr != 0) {\n                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n                return (Error.SNAPSHOT_ERROR, 0, 0);\n            }\n            vars.collateralFactor = Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\n            vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            if (vars.oraclePriceMantissa == 0) {\n                return (Error.PRICE_ERROR, 0, 0);\n            }\n            vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrowPlusEffects\n            );\n\n            // Calculate effects of interacting with cTokenModify\n            if (asset == cTokenModify) {\n                // redeem effect\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.tokensToDenom,\n                    redeemTokens,\n                    vars.sumBorrowPlusEffects\n                );\n\n                // borrow effect\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n                    vars.oraclePrice,\n                    borrowAmount,\n                    vars.sumBorrowPlusEffects\n                );\n            }\n        }\n\n        // These are safe, as the underflow condition is checked first\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n        } else {\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n        }\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address cTokenBorrowed,\n        address cTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256, uint256) {\n        /* Read oracle prices for borrowed and collateral markets */\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n            return (uint256(Error.PRICE_ERROR), 0);\n        }\n\n        /*\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n         *  seizeTokens = seizeAmount / exchangeRate\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n         */\n        uint256 exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n        uint256 seizeTokens;\n        Exp memory numerator;\n        Exp memory denominator;\n        Exp memory ratio;\n\n        numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\n        denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n        ratio = div_(numerator, denominator);\n\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n        return (uint256(Error.NO_ERROR), seizeTokens);\n    }\n\n    // to avoid stack-too-deep errors on `liquidateCalculateSeizeTokensUniV3`\n    struct LiquidationSeizeLocalVars {\n        uint256 amountToken0Fees;\n        uint256 amountToken1Fees;\n        uint256 amountToken0Liquidity;\n        uint256 amountToken1Liquidity;\n        uint256 amountLiquidity;\n        Exp borrowValue;\n        Exp feeValue;\n        Exp liquidityValue;\n    }\n\n    /**\n     * @notice Calculate amount of liquidity NFT to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowUniV3Fresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, percent of fees to be seized, amount of colalteralTokenId liquidity to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokensUniV3(\n        address cTokenBorrowed,\n        uint256 collateralTokenId,\n        uint256 actualRepayAmount\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint128,\n            uint128,\n            uint128\n        )\n    {\n        LiquidationSeizeLocalVars memory vars;\n\n        /*\n         * take the value in eth, convert it to borrow value. see what % the repay borrow + incentive.\n         * if % < 100, then return 0 on liquidity.\n         * If above 100%, take % - 100 to get value that should be removed from total liquidity.\n         * Then take that value, divided by the total value of the liquidity, and multiply by the amount of liquidity.\n         * Cap this liquidity amount at the total liquidity amount (since we've already liquidated everything)\n         */\n\n        address token0;\n        address token1;\n        (\n            token0,\n            token1,\n            vars.amountToken0Fees,\n            vars.amountToken1Fees,\n            vars.amountToken0Liquidity,\n            vars.amountToken1Liquidity,\n            vars.amountLiquidity\n        ) = tickOracle.getTokenBreakdownTWAP(collateralTokenId);\n\n        uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n        uint256 oraclePriceMantissa0 = oracle.price(token0);\n        uint256 oraclePriceMantissa1 = oracle.price(token1);\n        if (priceBorrowedMantissa == 0 || oraclePriceMantissa0 == 0 || oraclePriceMantissa1 == 0) {\n            return (uint256(Error.PRICE_ERROR), 0, 0, 0);\n        }\n\n        // TODO: custom liquidation incentive for LP shares\n        vars.borrowValue = mul_(\n            mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa })),\n            actualRepayAmount\n        );\n        vars.feeValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Fees),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Fees)\n        );\n        vars.liquidityValue = add_(\n            mul_(Exp({ mantissa: oraclePriceMantissa0 }), vars.amountToken0Liquidity),\n            mul_(Exp({ mantissa: oraclePriceMantissa1 }), vars.amountToken1Liquidity)\n        );\n\n        require(\n            lessThanOrEqualExp(vars.borrowValue, add_(vars.feeValue, vars.liquidityValue)),\n            \"borrowValue greater than total collateral\"\n        );\n\n        if (lessThanExp(vars.borrowValue, vars.feeValue)) {\n            // only return from fees\n            uint128 seizeAmountToken0Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken0Fees)\n            );\n            uint128 seizeAmountToken1Fees = uint128(\n                mul_ScalarTruncate(div_(vars.borrowValue, vars.feeValue), vars.amountToken1Fees)\n            );\n            return (uint256(Error.NO_ERROR), seizeAmountToken0Fees, seizeAmountToken1Fees, 0);\n        } else {\n            // only return from liquidity\n            uint128 seizeAmountLiquidity = uint128(\n                mul_ScalarTruncate(\n                    div_(sub_(vars.borrowValue, vars.feeValue), vars.liquidityValue),\n                    vars.amountLiquidity\n                )\n            );\n            return (\n                uint256(Error.NO_ERROR),\n                uint128(vars.amountToken0Fees),\n                uint128(vars.amountToken1Fees),\n                seizeAmountLiquidity\n            );\n        }\n    }\n\n    /*** Admin Functions ***/\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setTickOracle(TickOracle newTickOracle) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TICK_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old oracle for the comptroller\n        TickOracle oldTickOracle = tickOracle;\n\n        // Set comptroller's oracle to newOracle\n        tickOracle = newTickOracle;\n\n        // Emit NewTickOracle(oldTickOracle, newTickOracle)\n        emit NewTickOracle(oldTickOracle, newTickOracle);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets a new UniV3LpVault for the comptroller\n     * @dev Admin function to set a new UniV3LpVault\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setUniV3LpVault(IUniV3LpVault newVault) public returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n        }\n\n        // Track the old vault for the comptroller\n        IUniV3LpVault oldVault = uniV3LpVault;\n\n        // Set comptroller's uniV3LpVault to newVault\n        uniV3LpVault = newVault;\n\n        // Emit NewUniV3LpVault(oldVault, newVault)\n        emit NewUniV3LpVault(oldVault, newVault);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n        }\n\n        // Check limits\n        Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n        Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n        }\n\n        // Set pool close factor to new close factor, remember old value\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n\n        // Emit event\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Admin function to set per-market collateralFactor\n     * @param cToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(CToken cToken, uint256 newCollateralFactorMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Check de-scaled min <= newLiquidationIncentive <= max\n        Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n        Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n        }\n\n        // Save current value for use in log\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param cToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(CToken cToken) external returns (uint256) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        // Is market already listed?\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // Sanity check to make sure its really a CToken\n        require(cToken.isCToken(), \"marker method returned false\");\n\n        // Check cToken.comptroller == this\n        require(\n            address(cToken.comptroller()) == address(this),\n            \"Cannot support a market with a different Comptroller.\"\n        );\n\n        // Make sure market is not already listed\n        address underlying = CErc20(address(cToken)).underlying();\n\n        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        // List market and emit event\n        markets[address(cToken)] = Market({ isListed: true, collateralFactorMantissa: 0 });\n        allMarkets.push(cToken);\n        cTokensByUnderlying[underlying] = cToken;\n        emit MarketListed(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Removed a market from the markets mapping and sets it as unlisted\n     * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n     * @param cToken The address of the market (token) to unlist\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _unsupportMarket(CToken cToken) external returns (uint256) {\n        // Check admin rights\n        if (msg.sender != admin) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n        // Check if market is already unlisted\n        if (!markets[address(cToken)].isListed)\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n        // Check if market is in use\n        if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n        // Unlist market\n        delete markets[address(cToken)];\n\n        /* Delete cToken from allMarkets */\n        // load into memory for faster iteration\n        CToken[] memory _allMarkets = allMarkets;\n        uint256 len = _allMarkets.length;\n        uint256 assetIndex = len;\n        for (uint256 i = 0; i < len; i++) {\n            if (_allMarkets[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n        allMarkets.length--;\n\n        cTokensByUnderlying[CErc20(address(cToken)).underlying()] = CToken(address(0));\n        emit MarketUnlisted(cToken);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n     * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n     */\n    function _setMarketSupplyCaps(CToken[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set supply caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n        require(\n            msg.sender == admin || msg.sender == borrowCapGuardian,\n            \"only admin or borrow cap guardian can set borrow caps\"\n        );\n\n        uint256 numMarkets = cTokens.length;\n        uint256 numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint256 i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n        // Save current value for inclusion in log\n        address oldBorrowCapGuardian = borrowCapGuardian;\n\n        // Store borrowCapGuardian with value newBorrowCapGuardian\n        borrowCapGuardian = newBorrowCapGuardian;\n\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        mintGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Mint\", state);\n        return state;\n    }\n\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        borrowGuardianPaused[address(cToken)] = state;\n        emit ActionPausedMarket(cToken, \"Borrow\", state);\n        return state;\n    }\n\n    function _setTransferPaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        transferGuardianPaused = state;\n        emit ActionPaused(\"Transfer\", state);\n        return state;\n    }\n\n    function _setSeizePaused(bool state) public returns (bool) {\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n        seizeGuardianPaused = state;\n        emit ActionPaused(\"Seize\", state);\n        return state;\n    }\n\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n\n        Comptroller(address(unitroller))._becomeImplementation();\n    }\n\n    function _becomeImplementation() external {\n        require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n        if (!_notEnteredInitialized) {\n            _notEntered = true;\n            _notEnteredInitialized = true;\n        }\n    }\n\n    /**\n     * @notice sets the state for many pools of whether or not they are supported as collateral\n     *              in actuality, just limits whether or not a pool can be deposited into the vault\n     * @param pools The addresses of Uni V3 Pools\n     * @param states The state of whether or not this pool is to be supported (corresponding by index to pools)\n     */\n    function _setSupportedPools(address[] calldata pools, bool[] calldata states) external {\n        require(msg.sender == admin, \"only admin can set supported pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(pools.length == states.length, \"Number of pools and states must be equal\");\n        for (uint256 i = 0; i < pools.length; i++) {\n            isSupportedPool[pools[i]] = states[i];\n        }\n    }\n\n    /**\n     * @notice sets the collateral factors for many pools\n     * @param pools The addresses of Uni V3 Pools\n     * @param collateralFactorsMantissa The collateral factors for LP positions of the pools\n     */\n    function _setPoolCollateralFactors(address[] calldata pools, uint256[] calldata collateralFactorsMantissa)\n        external\n    {\n        require(msg.sender == admin, \"only admin can set collateral factors for pools\");\n        require(pools.length > 0, \"must have at least one pool\");\n        require(\n            pools.length == collateralFactorsMantissa.length,\n            \"Number of pools and collateralFactors must be equal\"\n        );\n        for (uint256 i = 0; i < pools.length; i++) {\n            poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n        }\n    }\n\n    /*** Helper Functions ***/\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() public view returns (CToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Return all of the borrowers\n     * @dev The automatic getter may be used to access an individual borrower.\n     * @return The list of borrower account addresses\n     */\n    function getAllBorrowers() public view returns (address[] memory) {\n        return allBorrowers;\n    }\n\n    /**\n     * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n    function isDeprecated(CToken cToken) public view returns (bool) {\n        return\n            markets[address(cToken)].collateralFactorMantissa == 0 &&\n            borrowGuardianPaused[address(cToken)] == true &&\n            cToken.reserveFactorMantissa() == 1e18;\n    }\n\n    /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n    /**\n     * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _beforeNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_beforeNonReentrant: caller not listed as market or lpVault\"\n        );\n        require(_notEntered, \"re-entered across assets\");\n        _notEntered = false;\n    }\n\n    /**\n     * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n     * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n     */\n    function _afterNonReentrant() external {\n        require(\n            markets[msg.sender].isListed || msg.sender == address(uniV3LpVault),\n            \"Comptroller:_afterNonReentrant: caller not listed as market or lpVault\"\n        );\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n}\n\n\n",
        "CodeNames": [
            "Comptroller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "_setPoolCollateralFactors"
                ],
                "Type": " Undercollateralized loans possible",
                "Description": "\nComptroller.sol#L1491(https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/Comptroller.sol#L1491)<br\n\nThe _setPoolCollateralFactors function does not check that the collateral factor is < 100%.<br\nIt's possible that it's set to 200% and then borrows more than the collateral is worth, stealing from the pool.\n\n",
                "Repair": "\nDisable the possibility of ever having a collateral factor  100% by checking:\n\ndiff\nfor (uint256 i = 0; i < pools.length; i++) {\n+   require(collateralFactorsMantissa[i] <= 1e18, \"CF  100%\");\n    poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n}\n\n\n0xdramaone (Duality Focus) confirmed, but disagreed with Medium severity and commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/12#issuecomment-1094732426):\n  We agree, we should have a max setting for collateral factor of pools to provide confidence to users. That said, this would only be abusable by admins, and so we consider low risk (since controlled by multisig).\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/12#issuecomment-1097569137):\n  Good catch!\n \n Unbounded collateralFactor configuration made it possible for malicious/compromised privileged roles to rug the users, which I consider a real and very practical threat that should be addressed from the smart contract level.\n\n0xdramaone (Duality Focus) resolved(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/12)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../external/openzeppelin/token/ERC721/IERC721Receiver.sol\";\n\nimport \"../external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/ISwapRouter.sol\";\nimport { ComptrollerInterface } from \"./CompoundInterfaces.sol\";\nimport { IFlashLoanReceiver } from \"../external/aave/AaveInterfaces.sol\";\n\n/**\n * @title UniV3LpVault\n * @author Duality (h/t to Uniswap's UniswapV3Staker)\n */\ninterface IUniV3LpVault is IERC721Receiver {\n    /// @notice Emitted when a user deposits a supported Uni V3 LP Token\n    event TokenDeposited(address account, uint256 tokenId);\n\n    /// @notice Emitted when a token is withdrawn by a user\n    event TokenWithdrawn(address account, address to, uint256 tokenId);\n\n    /// @notice Emitted when a decreaseLiquidity call has been completed successfully\n    event LiquidityDecreased(address account, uint256 tokenId, uint128 liquidity);\n\n    /// @notice Emitted when a collectFee call has been completed successfully\n    event FeesCollected(address account, uint256 tokenId, uint256 amount0, uint256 amount1);\n\n    /// @notice Emitted when a compoundFees call has been completed successfully\n    event FeesCompounded(\n        address account,\n        uint256 tokenId,\n        uint256 amountDeposited0,\n        uint256 amountDeposited1,\n        uint256 amountReturned0,\n        uint256 amountReturned1\n    );\n\n    /// @notice Emitted when a moveRange call has been completed successfully\n    event RangeMoved(address account, uint256 oldTokenId, uint256 newTokenId, uint128 liquidityMoved, bool burned);\n\n    /// @notice Emitted when a FlashFocus call has been completed successfully\n    event FlashFocus(\n        address account,\n        uint256 tokenId,\n        address debtAsset,\n        uint256 debtAmount,\n        uint256 amountDeposited0,\n        uint256 amountDeposited1,\n        uint256 amountReturned0,\n        uint256 amountReturned1\n    );\n\n    /// @notice Emitted when a RepayDebt call has been completed successfully\n    event RepayDebt(\n        address account,\n        uint256 tokenId,\n        uint128 liquidity,\n        address debtCToken,\n        address underlying,\n        uint256 repayAmount,\n        uint256 amountReturned\n    );\n\n    /// @notice Emitted when a new flashLoanContract is set\n    event NewFlashLoanContract(address oldFlashLoanContract, address newFlashLoanContract);\n\n    /// @notice Emitted when a new userTokensMax is set\n    event NewUserTokensMax(uint256 oldUserTokenMax, uint256 newUserTokenMax);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice The Uniswap V3 Factory\n    function factory() external view returns (address);\n\n    /// @notice The nonfungible position manager address with which this staking contract is compatible\n    function nonfungiblePositionManager() external view returns (INonfungiblePositionManager);\n\n    /// @notice The nonfungible position manager address with which this staking contract is compatible\n    function swapRouter() external view returns (ISwapRouter);\n\n    /// @notice The comptroller that this contract is a vault for\n    function comptroller() external view returns (ComptrollerInterface);\n\n    function flashLoan() external view returns (IFlashLoanReceiver);\n\n    function flashLoanAuthorized(address user) external view returns (bool);\n\n    /// @notice Returns the owner of the deposited NFT\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /// @notice The max number of NFTs a user can deposit\n    function userTokensMax() external view returns (uint256);\n\n    /// @notice Withdraws a Uniswap V3 LP token `tokenId` from this contract to the recipient `to`\n    /// @param tokenId The unique identifier of an Uniswap V3 LP token\n    /// @param to The address where the LP token will be sent\n    /// @param data An optional data array that will be passed along to the `to` address via the NFT safeTransferFrom\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external;\n\n    // do we want a \"decreaseLiquidityAndCollect\" function? to avoid calling authorization / avoidShortfall funcs twice in multicall\n    function decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams calldata params) external;\n\n    function collectFees(INonfungiblePositionManager.CollectParams calldata params) external;\n\n    struct CompoundFeesParams {\n        uint256 tokenId;\n        uint256 expectedAmount0; // expected amount of token0 that we will deposit\n        uint256 expectedAmount1; // expected amount of token1 that we will deposit\n        uint256 amount0Min; // min amount of token0 deposited into range (price check)\n        uint256 amount1Min; // min amount of token1 deposited into range (price check)\n    }\n\n    // automatically compound fees back into range\n    function compoundFees(CompoundFeesParams calldata params) external;\n\n    struct MoveRangeParams {\n        uint256 tokenId;\n        uint128 liquidity; // can move partial liquidity\n        int24 newTickLower;\n        int24 newTickUpper;\n        uint256 expectedAmount0; // expected amount of token0 that we will deposit\n        uint256 expectedAmount1; // expected amount of token1 that we will deposit\n        uint256 amount0Min; // min amount of token0 deposited into range (price check)\n        uint256 amount1Min; // min amount of token1 deposited into range (price check)\n    }\n\n    function moveRange(MoveRangeParams calldata params) external returns (uint256 newTokenId);\n\n    struct FlashFocusParams {\n        uint256 tokenId;\n        address asset;\n        uint256 amount;\n        uint256 premium; // ignored from user side\n        uint256 expectedAmount0;\n        uint256 expectedAmount1;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bytes swapPath;\n    }\n\n    function flashFocus(FlashFocusParams calldata params) external;\n\n    function flashFocusCall(FlashFocusParams calldata params) external;\n\n    struct RepayDebtParams {\n        uint256 tokenId;\n        uint128 liquidity; // can move partial liquidity\n        uint256 repayAmount;\n        address debtCToken;\n        address underlying;\n        bytes swapPath0; // path to swap\n        bytes swapPath1;\n    }\n\n    function repayDebt(RepayDebtParams calldata params) external returns (uint256 amountRemaining);\n\n    function getUserTokensLength(address account) external view returns (uint256 length);\n\n    function getPoolAddress(uint256 tokenId) external view returns (address);\n\n    function seizeAssets(\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external;\n\n    function _pauseDeposits(bool state) external returns (bool);\n\n    function _pausePeripheryFunctions(bool state) external returns (bool);\n\n    function _setFlashLoan(address _flashLoan) external returns (address);\n\n    /**\n     * @notice set new userTokensMax as a contract admin\n     * @param _userTokensMax the new value for userTokensMax\n     */\n    function _setUserTokensMax(uint256 _userTokensMax) external returns (uint256);\n\n    function _sweep(\n        address token,\n        address to,\n        uint256 amount\n    ) external;\n\n    function _sweepNFT(\n        address nftContract,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\n\npragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        string memory name_,\n        string memory symbol_,\n        uint256 reserveFactorMantissa_\n    ) public {\n        // CToken initialize does the bulk of the work\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_,\n            reserveFactorMantissa_\n        );\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market on behalf of minter and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param minter The account minting the cTokens\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mintBehalf(address minter, uint256 mintAmount) external returns (uint256) {\n        (uint256 err, ) = mintBehalfInternal(minter, mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemBehalf(address redeemer, uint256 redeemTokens) external returns (uint256) {\n        return redeemBehalfInternal(redeemer, redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens on behalf of redeemer in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemer The account redeeming the cTokens\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlyingBehalf(address redeemer, uint256 redeemAmount) external returns (uint256) {\n        return redeemUnderlyingBehalfInternal(redeemer, redeemAmount);\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol on behalf of borrower\n     * @param borrower the account with the debt being payed off\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrowBehalf(address borrower, uint256 borrowAmount) external returns (uint256) {\n        return borrowBehalfInternal(borrower, borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n        (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral UniV3 LP Position.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param collateralTokenId The NFT tokenId to (partially) seize from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowUniV3(\n        address borrower,\n        uint256 repayAmount,\n        uint256 collateralTokenId\n    ) external returns (uint256) {\n        (uint256 err, ) = liquidateBorrowUniV3Internal(borrower, repayAmount, collateralTokenId);\n        return err;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) external {\n        require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount) external returns (uint256) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint256) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint256 amount) internal returns (uint256) {\n        uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        _callOptionalReturn(\n            abi.encodeWithSelector(\n                EIP20NonStandardInterface(underlying).transferFrom.selector,\n                from,\n                address(this),\n                amount\n            ),\n            \"TOKEN_TRANSFER_IN_FAILED\"\n        );\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint256 amount) internal {\n        _callOptionalReturn(\n            abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount),\n            \"TOKEN_TRANSFER_OUT_FAILED\"\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param errorMessage The revert string to return on failure.\n     */\n    function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n        bytes memory returndata = _functionCall(underlying, data, errorMessage);\n        if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n    }\n}\n\n\n",
        "CodeNames": [
            "IUniV3LpVault.sol",
            "CErc20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction flashFocusCall(FlashFocusParams calldata params) external override {\n    ...\n    {\n        ...\n        if (!tokenOfPool && params.swapPath.length  0) amountIn0 = _swap(params.swapPath, params.amount);\n        ...\n    }\n    ...\n}\n\nfunction flashFocus(FlashFocusParams calldata params)\n    external\n    override\n    nonReentrant(true)\n    isAuthorizedForToken(params.tokenId)\n    avoidsShortfall\n{\n    ...\n    flashLoan.LENDING_POOL().flashLoan(\n        receiverAddress,\n        assets,\n        amounts,\n        modes,\n        onBehalfOf,\n        newParams,\n        referralCode\n    );\n}\n\nfunction repayDebt(RepayDebtParams calldata params)\n    external\n    override\n    nonReentrant(true)\n    isAuthorizedForToken(params.tokenId)\n    avoidsShortfall\n    returns (uint256 amountReturned)\n{\n    ...\n    {\n        ...\n        if (amountOutFrom0 == 0 && params.swapPath0.length  0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n        if (amountOutFrom1 == 0 && params.swapPath1.length  0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n        ...\n    }\n    ...\n}\n"
                ],
                "Type": " Arbitrary contract call within  UniV3LpVault._swap  with controllable  swapPath ",
                "Description": "\nUniV3LpVault.sol#L621(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L621)<br\nUniV3LpVault.sol#L379(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L379)<br\nUniV3LpVault.sol#L520(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L520)<br\nUniV3LpVault.sol#L521(https://github.com/code-423n4/2022-04-dualityfocus/blob/main/contracts/vault_and_oracles/UniV3LpVault.sol#L521)<br\n\nUniV3LpVault._swap utilizes swapRouter.exactInput to perform swaps between two tokens. During swaps, transfer function of each token along the path will be called to propagate the assets.\n\nSince anyone can create a uniswap pair of arbitrary assets, it is possible to include intermediate hop with malicious tokens within the path. Thus UniV3LpVault._swap effectively grants users the ability to perform arbitrary contract calls during the swap process if swapPath is not validated properly.\n\nUsage of invalidated swapPath can be found in UniV3LpVault.flashFocusCall and UniV3LpVault.repayDebt.\n\n\nThe security of Comptroller and UniV3LpVault relies on validating all used tokens thoroughly. This is done by a whitelist mechanism where admin decides a predefined set of usable tokens, and users can only perform actions within the allowed range. This whitelist approach eliminates most of the attack surface regarding directly passing in malicious tokens as arguments.\n\nApart from passing malicious tokens directly, there are a few other potential weaknesses, the most obvious one is leveraging flash loans for collaterals. However, due to the adoption of AAVE LendingPool, the external validation within flash loan pool blocks this approach.\n\nUnfortunately, a more obscure path exists. Looking at the swapping mechanism, it is not hard to realize it is backed by uniswapV3. An interesting characteristic of uniswap pools is that anyone can create pools for any token pairs, thus if we don't fully validate each and every pool we are using, chances are there will be malicious entries hidden within them.\n\nThis is partially the case which we see here, the user gets to supply a path, where the source and target are validated against benign tokens, the intermediate ones are not. An example of utilizing path for arbitrary function call is illustrated below\n\n1.  Create malicious token tokenM\n2.  Create pools tokenS<-tokenM and tokenM<-tokenT where tokenS and tokenT are benign tokens\n3.  Supply path (tokenS, tokenM, tokenT) for swapping\n\nIn the above case, when transferring tokenM while doing swap, we have full control over code executed and can insert arbitrary contract calls within.\n\nNoticeably, while gaining arbitrary contract calls sounds dangerous, it does not necessarily mean the contract is exploitable. It still depends on the scenario in which an arbitrary call happens.\n\nIn the case of duality, the two locations where arbitrary swapPath can be provided is in flashFocusCall and repayDebt, both in which holds a local lock over UniV3LpVault. No global are applied to Comptroller or Ctokens while performing swaps.\n\nsolidity\nfunction flashFocusCall(FlashFocusParams calldata params) external override {\n    ...\n    {\n        ...\n        if (!tokenOfPool && params.swapPath.length  0) amountIn0 = _swap(params.swapPath, params.amount);\n        ...\n    }\n    ...\n}\n\nfunction flashFocus(FlashFocusParams calldata params)\n    external\n    override\n    nonReentrant(true)\n    isAuthorizedForToken(params.tokenId)\n    avoidsShortfall\n{\n    ...\n    flashLoan.LENDING_POOL().flashLoan(\n        receiverAddress,\n        assets,\n        amounts,\n        modes,\n        onBehalfOf,\n        newParams,\n        referralCode\n    );\n}\n\nfunction repayDebt(RepayDebtParams calldata params)\n    external\n    override\n    nonReentrant(true)\n    isAuthorizedForToken(params.tokenId)\n    avoidsShortfall\n    returns (uint256 amountReturned)\n{\n    ...\n    {\n        ...\n        if (amountOutFrom0 == 0 && params.swapPath0.length  0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n        if (amountOutFrom1 == 0 && params.swapPath1.length  0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n        ...\n    }\n    ...\n}\n\n\nThe lack of global locks here had us doubting whether an attack is possible. While we spent a considerable amount of time and failed to come up with any possible attack vectors, the complexity of the system held us back from concluding that an attack is impossible.\n\nThus we report this finding here in hope of inspiring developers either to prove the attack impossible or mitigate the attack surface.\n\n\nvim, ganache-cli\n\n",
                "Repair": "\nThe easiest way to mitigate this is to validate the entire path against a predefined whitelist while in _checkSwapPath. This approach is far from optimal and also limits the flexibility of swapping between tokens. However, before security is proved, this is the best approach we can come up with.\n\n0xdramaone (Duality Focus) confirmed and commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/31#issuecomment-1094752283):\n  Great issue raised!\n \n Agreed that it is safest to validate all tokens to avoid arbitrary transfer functionality, and we will also enforce global reentrancy lock wherever possible. Agree with severity.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/31#issuecomment-1097588986):\n  After some quick research on this issue, I also failed to find a valid attack vector. I agree that this is a noteworthy issue. A med severity seems fair given the detailed and honest issue description by the warden.\n\n0xdramaone (Duality Focus) resolved(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/31)\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 17 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/33) by defsec received the top score from the judge.\n\n*The following wardens also submitted reports: rayn(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/30), IllIllI(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/36), sorrynotsorry(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/26), cmichel(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/16), Dravee(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/43), robee(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/4), 0xDjango(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/32), 0x1f8b(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/8), 0v3rf10w(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/35), cccz(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/22), kebabsec(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/34), bugwriter001(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/23), CertoraInc(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/19), hyh(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/42), samruna(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/11), and reassor(https://github.com/code-423n4/2022-04-dualityfocus-findings/issues/41).*\n\n\n"
            }
        ]
    }
]