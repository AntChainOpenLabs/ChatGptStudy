[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract AccessController is AccessControl {\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  constructor() public {\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/IVaultsCore.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ncontract VaultsCore is IVaultsCore, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n\n  uint256 internal constant _MAX_INT = 2**256 - 1;\n\n  IAddressProvider public override a;\n  IWETH public override WETH;\n  IVaultsCoreState public override state;\n  IDebtNotifier public override debtNotifier;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));\n    _;\n  }\n\n  modifier onlyVaultOwner(uint256 _vaultId) {\n    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);\n    _;\n  }\n\n  constructor(\n    IAddressProvider _addresses,\n    IWETH _IWETH,\n    IVaultsCoreState _vaultsCoreState\n  ) public {\n    require(address(_addresses) != address(0));\n    require(address(_IWETH) != address(0));\n    require(address(_vaultsCoreState) != address(0));\n    a = _addresses;\n    WETH = _IWETH;\n    state = _vaultsCoreState;\n  }\n\n  // For a contract to receive ETH, it needs to have a payable fallback function\n  // https://ethereum.stackexchange.com/a/47415\n  receive() external payable {\n    require(msg.sender == address(WETH));\n  }\n\n  /*\n    Allow smooth upgrading of the vaultscore.\n    @dev this function approves token transfers to the new vaultscore of\n    both stablex and all configured collateral types\n    @param _newVaultsCore address of the new vaultscore\n  */\n  function upgrade(address payable _newVaultsCore) public override onlyManager {\n    require(address(_newVaultsCore) != address(0));\n    require(a.stablex().approve(_newVaultsCore, _MAX_INT));\n\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      IERC20 asset = IERC20(collateralType);\n      asset.safeApprove(_newVaultsCore, _MAX_INT);\n    }\n  }\n\n  /*\n    Allow smooth upgrading of the VaultsCore.\n    @dev this function transfers both PAR and all configured collateral\n    types to the new vaultscore.\n  */\n  function acceptUpgrade(address payable _oldVaultsCore) public override onlyManager {\n    IERC20 stableX = IERC20(a.stablex());\n    stableX.safeTransferFrom(_oldVaultsCore, address(this), stableX.balanceOf(_oldVaultsCore));\n\n    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {\n      address collateralType = a.config().collateralConfigs(i).collateralType;\n      IERC20 asset = IERC20(collateralType);\n      asset.safeTransferFrom(_oldVaultsCore, address(this), asset.balanceOf(_oldVaultsCore));\n    }\n  }\n\n  /**\n    Configure the debt notifier.\n    @param _debtNotifier the new DebtNotifier module address.\n  **/\n  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {\n    require(address(_debtNotifier) != address(0));\n    debtNotifier = _debtNotifier;\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral\n    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.\n    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _collateralType the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function deposit(address _collateralType, uint256 _amount) public override {\n    require(a.config().collateralIds(_collateralType) != 0);\n\n    IERC20 asset = IERC20(_collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVault(_collateralType, _amount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral\n    @dev A new vault is created if no WETH vault exists\n  **/\n  function depositETH() public payable override {\n    WETH.deposit{ value: msg.value }();\n    _addCollateralToVault(address(WETH), msg.value);\n  }\n\n  /**\n    Deposit an ERC20 token into the specified vault as collateral\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _vaultId the address of the collateral type to be deposited\n    @param _amount the amount of tokens to be deposited in WEI.\n  **/\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) public override {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(v.collateralType != address(0));\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    _addCollateralToVaultById(_vaultId, _amount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the specified vault as collateral\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.\n    @param _vaultId the address of the collateral type to be deposited\n  **/\n  function depositETHByVaultId(uint256 _vaultId) public payable override {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(v.collateralType == address(WETH));\n\n    WETH.deposit{ value: msg.value }();\n\n    _addCollateralToVaultById(_vaultId, msg.value);\n  }\n\n  /**\n    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see deposit() and borrow()\n    @param _collateralType the address of the collateral type to be deposited\n    @param _depositAmount the amount of tokens to be deposited in WEI.\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) public override {\n    deposit(_collateralType, _depositAmount);\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\n    borrow(vaultId, _borrowAmount);\n  }\n\n  /**\n    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI\n    @dev see depositETH() and borrow()\n    @param _borrowAmount the amount of borrowed StableX tokens in WEI.\n  **/\n  function depositETHAndBorrow(uint256 _borrowAmount) public payable override {\n    depositETH();\n    uint256 vaultId = a.vaultsData().vaultId(address(WETH), msg.sender);\n    borrow(vaultId, _borrowAmount);\n  }\n\n  function _addCollateralToVault(address _collateralType, uint256 _amount) internal {\n    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);\n    if (vaultId == 0) {\n      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);\n    }\n\n    _addCollateralToVaultById(vaultId, _amount);\n  }\n\n  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));\n\n    emit Deposited(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Withdraws ERC20 tokens from a vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.\n  **/\n  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    _removeCollateralFromVault(_vaultId, _amount);\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, _amount);\n  }\n\n  /**\n    Withdraws ETH from a WETH vault.\n    @dev Only the owner of a vault can withdraw collateral from it.\n    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to withdraw the collateral.\n    @param _amount the amount of ETH to be withdrawn in WEI.\n  **/\n  function withdrawETH(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    _removeCollateralFromVault(_vaultId, _amount);\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    require(v.collateralType == address(WETH));\n\n    WETH.withdraw(_amount);\n    msg.sender.transfer(_amount);\n  }\n\n  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n    require(_amount <= v.collateralBalance);\n    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);\n    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);\n    if (v.baseDebt > 0) {\n      // Save gas cost when withdrawing from 0 debt vault\n      state.refreshCollateral(v.collateralType);\n      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);\n      require(\n        a.liquidationManager().isHealthy(\n          newCollateralValue,\n          a.vaultsData().vaultDebt(_vaultId),\n          a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\n        )\n      );\n    }\n\n    emit Withdrawn(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Borrow new PAR tokens from a vault.\n    @dev Only the owner of a vault can borrow from it.\n    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.\n     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.\n    @param _vaultId the ID of the vault from which to borrow.\n    @param _amount the amount of borrowed PAR tokens in WEI.\n  **/\n  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    // Make sure current rate is up to date\n    state.refreshCollateral(v.collateralType);\n\n    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);\n    uint256 newDebt = _amount;\n    if (originationFeePercentage > 0) {\n      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));\n    }\n\n    // Increment vault borrow balance\n    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates(v.collateralType));\n\n    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));\n\n    bool isHealthy = a.liquidationManager().isHealthy(\n      collateralValue,\n      newVaultDebt,\n      a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio\n    );\n    require(isHealthy);\n\n    a.stablex().mint(msg.sender, _amount);\n    debtNotifier.debtChanged(_vaultId);\n    emit Borrowed(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Convenience function to repay all debt of a vault\n    @dev `repayAll()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the debt.\n  **/\n  function repayAll(uint256 _vaultId) public override {\n    repay(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Repay an outstanding PAR balance to a vault.\n    @dev `repay()` will update the outstanding vault debt to the current time.\n    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.\n    @param _amount the amount of PAR tokens in WEI to be repaid.\n  **/\n  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    // Make sure current rate is up to date\n    state.refreshCollateral(collateralType);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    // Decrement vault borrow balance\n    if (_amount >= currentVaultDebt) {\n      //full repayment\n      _amount = currentVaultDebt; //only pay back what's outstanding\n    }\n    _reduceVaultDebt(_vaultId, _amount);\n    a.stablex().burn(msg.sender, _amount);\n    debtNotifier.debtChanged(_vaultId);\n    emit Repaid(_vaultId, _amount, msg.sender);\n  }\n\n  /**\n    Internal helper function to reduce the debt of a vault.\n    @dev assumes cumulative rates for the vault's collateral type are up to date.\n    please call `refreshCollateral()` before calling this function.\n    @param _vaultId the ID of the vault for which to reduce the debt.\n    @param _amount the amount of debt to be reduced.\n  **/\n  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {\n    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);\n\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n    uint256 remainder = currentVaultDebt.sub(_amount);\n    uint256 cumulativeRate = cumulativeRates(collateralType);\n\n    if (remainder == 0) {\n      a.vaultsData().setBaseDebt(_vaultId, 0);\n    } else {\n      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);\n      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);\n    }\n  }\n\n  /**\n    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.\n    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. `liquidate()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n  **/\n  function liquidate(uint256 _vaultId) public override {\n    liquidatePartial(_vaultId, _MAX_INT);\n  }\n\n  /**\n    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.\n    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`\n    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.\n    This means that the change in outstanding debt can be smaller than the repaid amount.\n    `liquidatePartial()` can be called by anyone.\n    @param _vaultId the ID of the vault to be liquidated.\n    @param _amount the amount of debt+liquidationFee to repay.\n  **/\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {\n    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);\n\n    state.refreshCollateral(v.collateralType);\n\n    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);\n    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);\n\n    require(\n      !a.liquidationManager().isHealthy(\n        collateralValue,\n        currentVaultDebt,\n        a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio\n      )\n    );\n\n    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(\n      a.config().collateralLiquidationFee(v.collateralType)\n    );\n    uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);\n\n    uint256 repayAmount;\n\n    if (_amount > maxLiquiditionCost) {\n      _amount = maxLiquiditionCost;\n      repayAmount = currentVaultDebt;\n    } else {\n      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);\n    }\n\n    // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).\n    uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));\n    uint256 insuranceAmount = 0;\n    if (collateralValueToReceive >= collateralValue) {\n      // Not enough collateral for debt & liquidation fee\n      collateralValueToReceive = collateralValue;\n      uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(\n        v.collateralType,\n        collateralValue\n      );\n\n      if (currentVaultDebt > discountedCollateralValue) {\n        // Not enough collateral for debt alone\n        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);\n        require(a.stablex().balanceOf(address(this)) >= insuranceAmount);\n        a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt\n        emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);\n      }\n\n      repayAmount = currentVaultDebt.sub(insuranceAmount);\n      _amount = discountedCollateralValue;\n    }\n\n    // reduce the vault debt by repayAmount\n    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));\n    a.stablex().burn(msg.sender, _amount);\n\n    // send the claimed collateral to the liquidator\n    uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);\n    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));\n    IERC20 asset = IERC20(v.collateralType);\n    asset.safeTransfer(msg.sender, collateralToReceive);\n\n    debtNotifier.debtChanged(_vaultId);\n\n    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);\n  }\n\n  /**\n    Returns the cumulativeRate of a collateral type. This function exists for\n    backwards compatibility with the VaultsDataProvider.\n    @param _collateralType the address of the collateral type.\n  **/\n  function cumulativeRates(address _collateralType) public view override returns (uint256) {\n    return state.cumulativeRates(_collateralType);\n  }\n}\n\n\npragma solidity 0.6.12;\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IGenericMinerV2.sol\";\nimport \"../../dex/interfaces/IDexAddressProvider.sol\";\nimport \"../../interfaces/IVaultsDataProvider.sol\";\nimport \"../../libraries/ABDKMath64x64.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract PARMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IERC20 internal _par;\n  IGovernanceAddressProvider internal _a;\n  IDexAddressProvider internal immutable _dexAP;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n  uint256 internal _liquidateCallerReward;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider govAP,\n    IDexAddressProvider dexAP,\n    BoostConfig memory boostConfig\n  ) public {\n    require(address(govAP) != address(0), \"LM000\");\n    require(address(dexAP) != address(0), \"LM000\");\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _a = govAP;\n    _dexAP = dexAP;\n    _liquidateCallerReward = 200 ether;\n\n    _par = IERC20(govAP.parallel().stablex());\n    _par.approve(address(_a.parallel().core()), uint256(-1));\n\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets liquidation call reward amount\n    @dev can only be called by protocol manager\n    @param amount the amount to reward liquidate method callers with\n   */\n  function setLiquidateCallerReward(uint256 amount) external onlyManager {\n    _liquidateCallerReward = amount;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public {\n    _par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public {\n    _par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Liquidate a vault with a specific amount, and sell collaterall back to PAR\n    @param vaultId the ID of the vault to be liquidated\n    @param amount the amount of debt+liquidationFee to repay\n    @param dexIndex the index of dex in dex address provider mapping\n    @param dexTxData the tx data used to sell collateral back to PAR\n  **/\n  function liquidate(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 dexIndex,\n    bytes calldata dexTxData\n  ) public {\n    uint256 parBalanceBefore = _par.balanceOf(address(this));\n\n    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);\n    IERC20 collateralToken = IERC20(vault.collateralType);\n    _a.parallel().core().liquidatePartial(vaultId, amount);\n\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));\n    router.call(dexTxData);\n    _par.safeTransfer(msg.sender, _liquidateCallerReward);\n    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");\n    _refreshPAR(_totalStake);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo, _totalStake, false);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked\n  */\n  function restakePAR(address _user) public {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(_totalStake);\n    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pendingPAR);\n  }\n\n  /**\n    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  function liquidateCallerReward() public view returns (uint256) {\n    return _liquidateCallerReward;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be increased\n  */\n  function _increaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n\n    UserInfo memory _userInfo = _users[_user];\n\n    uint256 newTotalStake = _totalStake.add(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, true);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.add(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      _userInfo.stake = _userInfo.stake.add(pendingPAR);\n      _totalStake = _totalStake.add(pendingPAR);\n    }\n\n    _updateBoost(_user, _userInfo);\n\n    emit StakeIncreased(_user, _value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[_user];\n    require(_userInfo.stake >= _value, \"LM102\");\n\n    uint256 newTotalStake = _totalStake.sub(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, false);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.sub(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n\n    emit StakeDecreased(_user, _value);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function _releaseRewards(\n    address _user,\n    UserInfo memory _userInfo,\n    uint256 _newTotalStake,\n    bool _restakePAR\n  ) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    _refresh();\n    _refreshPAR(_newTotalStake);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingPAR > 0 && !_restakePAR) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens\n    @dev need to pass updated stake as arg because reward token and stake token are the same\n    @param newTotalStake updated total stake in PAR tokens\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(\n    uint256 accParAmountPerShare,\n    uint256 _userStakeWithBoost,\n    uint256 _userAccParAmountPerShare\n  ) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}\n\n\n",
        "CodeNames": [
            "AccessController.sol",
            "VaultsCore.sol",
            "IUniswapV2Router01.sol",
            "PARMinerV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "(bool success, ) = to.call{value: value}(new bytes(",
                    "liquidate()",
                    "PARMinerV",
                    "swapExactTokensForETH()",
                    "UniswapV"
                ],
                "Type": " User can call liquidate() and steal all collateral due to arbitrary router call",
                "Description": "\n<https://github.com/code-423n4/2022-04-mimo/blob/b18670f44d595483df2c0f76d1c57a7bfbfbc083/core/contracts/liquidityMining/v2/PARMinerV2.sol#L126\n\n<https://github.com/Uniswap/v2-periphery/blob/2efa12e0f2d808d9b49737927f0e416fafa5af68/contracts/UniswapV2Router02.sol#L299\n\n<https://github.com/Uniswap/solidity-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L47-L50\n\nA malicious user is able to steal all collateral of an unhealthy position in PARMinerV2.sol. The code for the liquidate() function is written so that the following steps are followed:\n\n*   User calls PARMinerV2.liquidate()\n*   PARMinerV2 performs the liquidation with _a.parallel().core().liquidatePartial()\n*   PARMinerV2 receives the liquidated collateral\n*   An arbitrary router function is called to swap the collateral to PAR\n*   Finally, PARMinerV2.liquidate() checks that PARMinerV2's PAR balance is higher than the balance at the beginning of the function call.\n\nThe exploit occurs with the arbitrary router call. The malicious user is able to supply the dexTxnData parameter which dictates the function call to the router. If the user supplied a function such as UniswapV2Router's swapExactTokenForETH(), then control flow will be given to the user, allowing them to perform the exploit.\n\nNote: The Mimo developers have stated that the routers used by the protocol will be DEX Aggregators such as 1inch and Paraswap, but this submission will be referring to UniswapV2Router for simplicity. It can be assumed that the dex aggregators currently allow swapping tokens for ETH.\n\nContinuing the exploit, once the attacker has gained control due to the ETH transfer, they are able to swap the ETH for PAR. Finally, they deposit the PAR with PARMinerV2.deposit(). This will cause the final check of liquidate() to pass because PARMinerV2's PAR balance will be larger than the start of the liquidation call.\n\nThe attacker is able to steal all collateral from every unhealthy position that they liquidate. In the most extreme case, the attacker is able to open their own risky positions with the hope that the position becomes unhealthy. They will borrow the PAR and then liquidate themselves to take back the collateral. Thus effectively stealing PAR.\n\n\nSteps for exploit:\n\n*   Attacker monitors unhealthy positions. Finds a position to liquidate.\n*   Attacker calls PARMinerV2.liquidate()\n*   Position liquidated. Collateral transferred back to PARMinerV2\n*   In the liquidate() function, attacker supplies bytes for UniswapV2Router.swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline). For to, they supply the attacker contract.\n*   swapExactTokensForETH() firstly swaps the collateral for ETH and then transfers the ETH to the user with TransferHelper.safeTransferETH(to, amounts[amounts.length 1]);\n*   TransferHelper.safeTransferETH() contains a call to the receiver via (bool success, ) = to.call{value: value}(new bytes(0));\n*   Therefore, the attacker contract will indeed gain control of execution.\n\nThe attacker contract will then perform the following steps:\n\n*   Swap the received ETH to PAR.\n*   Deposit the PAR in PARMinerV2\n*   Withdraw the deposited PAR.\n\n",
                "Repair": "\nThe arbitrary call to the router contracts is risky because of the various functions that they can contain. Perhaps a solution is to only allow certain calls such as swapping tokens to tokens, not ETH. This would require frequently updated knowledge of the router's functions, though would be beneficial for security.\n\nAlso, adding a check that the _totalStake variable has not increased during the liquidation call will mitigate the risk of the attacker depositing the PAR to increase the contract's balance. The attacker would have no option but to transfer the PAR to PARMinerV2 as is intended.\n\nm19 (Mimo Defi) disagreed with severity and commented(https://github.com/code-423n4/2022-04-mimo-findings/issues/83#issuecomment-1118331621):\n  We believe in theory this attack is actually possible, but highly unlikely to happen. It also begs the question of whether it's really worth it for an attacker to do this because they could just call VaultsCore.liquidate() themselves (for example with a flashloan) and stake all the PAR they profit that way directly.\n\nm19 (Mimo DeFi) confirmed and commented(https://github.com/code-423n4/2022-04-mimo-findings/issues/83#issuecomment-1120159996):\n  We misunderstood this exploit wrong and we confirm it. Basically, if the attacker was liquidating a 10,000 PAR position, he could potentially end up with a 10,000 PAR stake + liquidation profits. Our previous understanding was that he could only end up with the profits.\n \n At the very least we'll implement a check that totalStake hasn't changed, we will carefully consider if more changes are needed.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../libraries/WadRayMath.sol\";\nimport \"../interfaces/ISTABLEX.sol\";\nimport \"../interfaces/IFeeDistributor.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract FeeDistributor is IFeeDistributor, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  event PayeeAdded(address account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  uint256 public override lastReleasedAt;\n  IAddressProvider public override a;\n\n  uint256 public override totalShares;\n  mapping(address => uint256) public override shares;\n  address[] public payees;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Public function to release the accumulated fee income to the payees.\n    @dev anyone can call this.\n  */\n  function release() public override nonReentrant {\n    uint256 income = a.core().state().availableIncome();\n    require(income > 0, \"income is 0\");\n    require(payees.length > 0, \"Payees not configured yet\");\n    lastReleasedAt = now;\n\n    // Mint USDX to all receivers\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      _release(income, payee);\n    }\n    emit FeeReleased(income, lastReleasedAt);\n  }\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().state().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() public view override returns (address[] memory) {\n    return payees;\n  }\n\n  /**\n    Internal function to release a percentage of income to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\n    a.stablex().mint(_payee, payment);\n  }\n\n  /**\n    Internal function to add a new payee.\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\n    @param _payee The address of the payee to add.\n    @param _shares The number of shares owned by the payee.\n  */\n  function _addPayee(address _payee, uint256 _shares) internal {\n    require(_payee != address(0), \"payee is the zero address\");\n    require(_shares > 0, \"shares are 0\");\n    require(shares[_payee] == 0, \"payee already has shares\");\n\n    payees.push(_payee);\n    shares[_payee] = _shares;\n    totalShares = totalShares.add(_shares);\n    emit PayeeAdded(_payee, _shares);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"./interfaces/IAddressProvider.sol\";\nimport \"./interfaces/IGovernanceAddressProvider.sol\";\nimport \"./interfaces/IVaultsCore.sol\";\nimport \"./interfaces/IGenericMiner.sol\";\nimport \"./interfaces/IDexAddressProvider.sol\";\n\n/// @title A parallel protocol vault with added functionality\n/// @notice You can use this for collateral rebalancing\n/// @dev This contract should be cloned and initialized with a SuperVaultFactory contract\ncontract SuperVault is AccessControl, Initializable {\n  enum Operation {\n    LEVERAGE,\n    REBALANCE,\n    EMPTY\n  }\n\n  struct AggregatorRequest {\n    uint256 parToSell;\n    bytes dexTxData;\n    uint dexIndex;\n  }\n\n  IAddressProvider public a;\n  IGovernanceAddressProvider public ga;\n  IPool public lendingPool;\n  IDexAddressProvider internal _dexAP;\n\n  modifier onlyOwner() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"SV001\");\n    _;\n  }\n\n  ///@notice Initializes the Supervault contract\n  ///@dev This replaces the constructor function as in the factory design pattern\n  ///@param _a The address of the protocol's AddressProvider\n  ///@param _ga The address of the protocol's GovernanceAddressProvider\n  ///@param _lendingPool The address of the lendingPool from where flashLoans are taken\n  ///@param _owner The owner of this SuperVault contract\n  function initialize(\n    IAddressProvider _a,\n    IGovernanceAddressProvider _ga,\n    IPool _lendingPool,\n    address _owner,\n    IDexAddressProvider dexAP\n  ) external initializer {\n    require(address(_a) != address(0));\n    require(address(_ga) != address(0));\n    require(address(_lendingPool) != address(0));\n    require(address(dexAP) != address(0));\n\n    a = _a;\n    ga = _ga;\n    lendingPool = _lendingPool;\n    _dexAP = dexAP;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  ///@notice Routes a call from a flashloan pool to a leverage or rebalance operation\n  ///@dev This Integrates with AAVE V2 flashLoans\n  ///@dev This function is called by the lendingPool during execution of the leverage function\n  ///@param assets An address array with one element corresponding to the address of the leveraged or rebalanced asset\n  ///@param amounts A uint array with one element corresponding to the amount of the leveraged or rebalanced asset\n  ///@param premiums A uint array with one element corresponding to the flashLoan fees\n  ///@param params Bytes sent by the leverage or rebalance function that contains information on the aggregator swap\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address,\n    bytes calldata params\n  ) external returns (bool) {\n    require(msg.sender == address(lendingPool), \"SV002\");\n    (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));\n    IERC20 asset = IERC20(assets[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n    if (operation == Operation.LEVERAGE) {\n      leverageOperation(asset, flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.REBALANCE) {\n      rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n    if (operation == Operation.EMPTY) {\n      emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n    }\n\n    asset.approve(address(lendingPool), flashloanRepayAmount);\n    return true;\n  }\n\n  ///@notice Used by executeOperation to call an aggregator to swap and deposit the swapped asset into a vault\n  function leverageOperation(\n    IERC20 token,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    leverageSwap(params, token);\n\n    require(token.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n    a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);\n  }\n\n  ///@notice Leverage an asset using a flashloan to balance collateral\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param asset The address of the asset to leverage\n  ///@param depositAmount The initial starting amount, e.g. 1 ETH\n  ///@param borrowAmount The amount to be borrowed, e.g. 2 ETH, bringing the total to 3 ETH\n  ///@param parToSell The amount of PAR we'll borrow so we can repay the leverage\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index of the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function leverage(\n    address asset,\n    uint256 depositAmount, //\n    uint256 borrowAmount, //\n    uint256 parToSell, //\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    IERC20(asset).transferFrom(msg.sender, address(this), depositAmount);\n    bytes memory leverageParams = abi.encode(parToSell, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.LEVERAGE, leverageParams);\n    takeFlashLoan(asset, borrowAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to flashloan an asset, call an aggregator to swap for toAsset, and then rebalance the vault\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi\n      .decode(params, (uint256, address, uint256, bytes, uint ));\n    aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);\n\n    uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));\n\n    IERC20(toCollateral).approve(address(a.core()), depositAmount);\n\n    a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);\n    a.core().repay(vaultId, parAmount);\n\n    a.core().withdraw(vaultId, flashloanRepayAmount);\n\n    require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral\n  ///@notice Both collateral vaults must have been created by this contract using the depositToVault or depositAndBorrowFromVault functions\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to reduce the collateral of\n  ///@param toCollateral Address of the collateral to rebalance to\n  ///@param fromCollateral Address of the starting collateral that will be reduced\n  ///@param fromCollateralAmount Amount of starting collateral to deleverage\n  ///@param parAmount Amount of par that will be deposited to exchange for\n  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap\n  ///@param dexIndex DexAddressProvider index representing the aggregator to be used for selling PAR, either OneInch or Paraswap\n  function rebalance(\n    uint256 vaultId, // vaultId to deleverage\n    address toCollateral,\n    address fromCollateral, // save some gas by just passing in collateral type instead of querying VaultsDataProvider for it\n    uint256 fromCollateralAmount, // amount of collateral to reduce in main vault and borrow from Aave first\n    uint256 parAmount, // amount of PAR to repay and deleverage\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    bytes memory rebalanceParams = abi.encode(vaultId, toCollateral, parAmount, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.REBALANCE, rebalanceParams);\n\n    takeFlashLoan(fromCollateral, fromCollateralAmount, params);\n    checkAndSendMIMO();\n  }\n\n  ///@notice Used by executeOperation to repay all debt for a vault, withdraw collateral from the vault, and send the collateral back to the user\n  ///@notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 amount,\n    uint256 flashloanRepayAmount,\n    bytes memory params\n  ) internal {\n    // Use par to repay debt\n    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));\n\n    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan\n\n    IERC20 par = IERC20(a.stablex());\n    par.approve(address(a.core()), par.balanceOf(address(this)));\n\n    // Repay the par debt\n    a.core().repayAll(vaultId);\n    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);\n    // Withdraw all collateral\n    a.core().withdraw(vaultId, vaultBalance);\n\n    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, \"SV101\");\n  }\n\n  ///@notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n  ///@notice This vault must have been created by this contract\n  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation\n  ///@param vaultId The Id of the vault to empty\n  ///@param collateralType Address of the collateral of the vault\n  ///@param repayAmount Amount of par that needs to be repaid before all collateral can be withdrawn\n  ///@param dexTxData Bytes that contain the low-level call to swap the vault asset for par to repay the vault loan\n  ///@param dexIndex Index to use for swapping the vault collateral for par\n  function emptyVault(\n    uint256 vaultId,\n    address collateralType,\n    uint256 repayAmount, // Amount, in collateral type, needed to borrow to repay current vault debt\n    bytes calldata dexTxData,\n    uint dexIndex \n  ) external onlyOwner {\n    // Flashloan collateral and swap for par to repay any outstanding vault debt\n    bytes memory emptyVaultParams = abi.encode(vaultId, dexTxData, dexIndex);\n    bytes memory params = abi.encode(Operation.EMPTY, emptyVaultParams);\n    takeFlashLoan(collateralType, repayAmount, params);\n\n    checkAndSendMIMO();\n\n    // Send remaining par, mimo, and collateral back to the owner\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n\n    IERC20 collateral = IERC20(collateralType);\n    collateral.transfer(msg.sender, collateral.balanceOf(address(this)));\n  }\n\n  ///@notice Withdraw collateral from a vault\n  ///@notice Vault must have been created through leverage, depositToVault, or depositAndBorrowFromVault from this contract\n  ///@param vaultId The ID of the vault to withdraw from\n  ///@param amount The amount of collateral to withdraw\n  function withdrawFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().withdraw(vaultId, amount);\n    IERC20 asset = IERC20(a.vaultsData().vaultCollateralType(vaultId));\n    require(asset.transfer(msg.sender, amount));\n  }\n\n  ///@notice Borrow PAR from a vault\n  ///@param vaultId The ID of the vault to borrow from\n  ///@param amount The amount of PAR to borrow\n  function borrowFromVault(uint256 vaultId, uint256 amount) external onlyOwner {\n    a.core().borrow(vaultId, amount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Withdraw all of one type of collateral from this contract\n  ///@notice Can only be used on vaults which have been created by this contract\n  ///@param asset The address of the collateral type\n  function withdrawAsset(address asset) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    require(token.transfer(msg.sender, token.balanceOf(address(this))));\n  }\n\n  ///@notice Deposit collateral into a vault\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param amount Amount to deposit\n  function depositToVault(address asset, uint256 amount) external {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), amount);\n    token.transferFrom(msg.sender, address(this), amount);\n    a.core().deposit(asset, amount);\n  }\n\n  ///@notice Deposit collateral into a vault and borrow PAR\n  ///@notice Requires approval of asset for amount before calling\n  ///@param asset Address of the collateral type\n  ///@param depositAmount Amount to deposit\n  ///@param borrowAmount Amount of PAR to borrow after depositing\n  function depositAndBorrowFromVault(\n    address asset,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external onlyOwner {\n    IERC20 token = IERC20(asset);\n    token.approve(address(a.core()), depositAmount);\n    token.transferFrom(msg.sender, address(this), depositAmount);\n    a.core().depositAndBorrow(asset, depositAmount, borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Release MIMO from a MIMO miner to the owner\n  ///@param minerAddress The address of the MIMO miner\n  function releaseMIMO(address minerAddress) external payable onlyOwner {\n    IGenericMiner miner = IGenericMiner(minerAddress);\n    miner.releaseMIMO(address(this));\n    checkAndSendMIMO();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault\n  function depositETHToVault() external payable {\n    a.core().depositETH{ value: msg.value }();\n  }\n\n  ///@notice Wrap ETH and deposit WETH as collateral into a vault, then borrow PAR from vault\n  ///@param borrowAmount The amount of PAR to borrow after depositing ETH\n  function depositETHAndBorrowFromVault(uint256 borrowAmount) external payable onlyOwner {\n    a.core().depositETHAndBorrow{ value: msg.value }(borrowAmount);\n    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par\n    checkAndSendMIMO();\n  }\n\n  ///@notice Helper function to call an aggregator to swap PAR for a leveraged asset\n  ///@dev This helper function is used to limit the number of local variables in the leverageOperation function\n  ///@param params The params passed from the leverageOperation function for the aggregator call\n  ///@param token The leveraged asset to swap PAR for\n  function leverageSwap(bytes memory params, IERC20 token) internal {\n    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(\n      params,\n      (uint256, bytes, uint )\n    );\n    token.approve(address(a.core()), 2**256 - 1);\n    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);\n    IERC20 par = IERC20(a.stablex());\n    aggregatorSwap(dexIndex, par, parToSell, dexTxData);\n  }\n\n  ///@notice Helper function to approve and swap an asset using an aggregator\n  ///@param dexIndex The DexAddressProvider index of aggregator to use to swap\n  ///@param token The starting token to swap for another asset\n  ///@param amount The amount of starting token to swap for\n  ///@param dexTxData The low-level data to call the aggregator with\n  function aggregatorSwap(\n    uint256 dexIndex,\n    IERC20 token,\n    uint256 amount,\n    bytes memory dexTxData\n  ) internal {\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    require(proxy != address(0) && router != address(0), \"SV201\"); \n    token.approve(proxy, amount);\n    router.call(dexTxData);\n  }\n\n  ///@notice Helper function to format arguments to take a flashloan\n  ///@dev The flashloan call will call the executeOperation function on this contract\n  ///@param asset The address of the asset to loan\n  ///@param amount The amount to borrow\n  ///@param params The params that will be sent to executeOperation after the asset is borrowed\n  function takeFlashLoan(\n    address asset,\n    uint256 amount,\n    bytes memory params\n  ) internal {\n    uint8 referralCode;\n    address[] memory assets = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    uint256[] memory modes = new uint256[](1);\n    (assets[0], amounts[0]) = (asset, amount);\n    lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, referralCode);\n  }\n\n  ///@notice Helper function to transfer all MIMO owned by this contract to the Owner\n  function checkAndSendMIMO() internal {\n    if (ga.mimo().balanceOf(address(this)) > 0) {\n      require(ga.mimo().transfer(msg.sender, ga.mimo().balanceOf(address(this))));\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IGenericMinerV2.sol\";\nimport \"../../dex/interfaces/IDexAddressProvider.sol\";\nimport \"../../interfaces/IVaultsDataProvider.sol\";\nimport \"../../libraries/ABDKMath64x64.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract PARMinerV2 is IGenericMinerV2 {\n  using ABDKMath64x64 for int128;\n  using ABDKMath64x64 for uint256;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  IERC20 internal _par;\n  IGovernanceAddressProvider internal _a;\n  IDexAddressProvider internal immutable _dexAP;\n\n  BoostConfig internal _boostConfig;\n\n  mapping(address => UserInfo) internal _users;\n\n  uint256 internal _totalStake;\n  uint256 internal _totalStakeWithBoost;\n  uint256 internal _liquidateCallerReward;\n\n  uint256 internal _mimoBalanceTracker;\n  uint256 internal _accMimoAmountPerShare;\n\n  uint256 internal _parBalanceTracker;\n  uint256 internal _accParAmountPerShare;\n\n  modifier onlyManager {\n    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(\n    IGovernanceAddressProvider govAP,\n    IDexAddressProvider dexAP,\n    BoostConfig memory boostConfig\n  ) public {\n    require(address(govAP) != address(0), \"LM000\");\n    require(address(dexAP) != address(0), \"LM000\");\n    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, \"LM004\");\n    _a = govAP;\n    _dexAP = dexAP;\n    _liquidateCallerReward = 200 ether;\n\n    _par = IERC20(govAP.parallel().stablex());\n    _par.approve(address(_a.parallel().core()), uint256(-1));\n\n    _boostConfig = boostConfig;\n\n    emit BoostConfigSet(boostConfig);\n  }\n\n  /**\n    Sets new boost config\n    @dev can only be called by protocol manager\n    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}\n   */\n  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {\n    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, \"LM004\");\n    _boostConfig = newBoostConfig;\n\n    emit BoostConfigSet(_boostConfig);\n  }\n\n  /**\n    Sets liquidation call reward amount\n    @dev can only be called by protocol manager\n    @param amount the amount to reward liquidate method callers with\n   */\n  function setLiquidateCallerReward(uint256 amount) external onlyManager {\n    _liquidateCallerReward = amount;\n  }\n\n  /**\n    Deposit an ERC20 pool token for staking\n    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20\n    @param amount the amount of tokens to be deposited. Unit is in WEI\n  **/\n  function deposit(uint256 amount) public {\n    _par.safeTransferFrom(msg.sender, address(this), amount);\n    _increaseStake(msg.sender, amount);\n  }\n\n  /**\n    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked\n    @param amount the amount of tokens to be withdrawn. Unit is in WEI\n  **/\n  function withdraw(uint256 amount) public {\n    _par.safeTransfer(msg.sender, amount);\n    _decreaseStake(msg.sender, amount);\n  }\n\n  /**\n    Liquidate a vault with a specific amount, and sell collaterall back to PAR\n    @param vaultId the ID of the vault to be liquidated\n    @param amount the amount of debt+liquidationFee to repay\n    @param dexIndex the index of dex in dex address provider mapping\n    @param dexTxData the tx data used to sell collateral back to PAR\n  **/\n  function liquidate(\n    uint256 vaultId,\n    uint256 amount,\n    uint256 dexIndex,\n    bytes calldata dexTxData\n  ) public {\n    uint256 parBalanceBefore = _par.balanceOf(address(this));\n\n    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);\n    IERC20 collateralToken = IERC20(vault.collateralType);\n    _a.parallel().core().liquidatePartial(vaultId, amount);\n\n    (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));\n    router.call(dexTxData);\n    _par.safeTransfer(msg.sender, _liquidateCallerReward);\n    require(_par.balanceOf(address(this)) > parBalanceBefore, \"LM104\");\n    _refreshPAR(_totalStake);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function releaseRewards(address _user) public override {\n    UserInfo memory _userInfo = _users[_user];\n    _releaseRewards(_user, _userInfo, _totalStake, false);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n  }\n\n  /**\n    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake\n    @param _user the address of the user for which the PAR tokens will be restaked\n  */\n  function restakePAR(address _user) public {\n    UserInfo storage userInfo = _users[_user];\n    _refresh();\n    _refreshPAR(_totalStake);\n    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));\n    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    _increaseStake(_user, pendingPAR);\n  }\n\n  /**\n    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value\n  */\n  function updateBoost(address _user) public {\n    UserInfo memory userInfo = _users[_user];\n    _updateBoost(_user, userInfo);\n  }\n\n  /**\n    Returns the number of tokens a user has staked\n    @param _user the address of the user\n    @return number of staked tokens\n  */\n  function stake(address _user) public view override returns (uint256) {\n    return _users[_user].stake;\n  }\n\n  /**\n    Returns the number of tokens a user has staked with the boost\n    @param _user the address of the user\n    @return number of staked tokens with boost\n  */\n  function stakeWithBoost(address _user) public view override returns (uint256) {\n    return _users[_user].stakeWithBoost;\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @param _user the address of the user\n    @return number of MIMO tokens that the user can claim\n  */\n  function pendingMIMO(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @param _user the address of the user\n    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function pendingPAR(address _user) public view override returns (uint256) {\n    UserInfo memory _userInfo = _users[_user];\n    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);\n    uint256 reward = currentBalance.sub(_parBalanceTracker);\n    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n\n    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n  }\n\n  function par() public view override returns (IERC20) {\n    return _par;\n  }\n\n  function a() public view override returns (IGovernanceAddressProvider) {\n    return _a;\n  }\n\n  function boostConfig() public view override returns (BoostConfig memory) {\n    return _boostConfig;\n  }\n\n  function totalStake() public view override returns (uint256) {\n    return _totalStake;\n  }\n\n  function totalStakeWithBoost() public view override returns (uint256) {\n    return _totalStakeWithBoost;\n  }\n\n  function liquidateCallerReward() public view returns (uint256) {\n    return _liquidateCallerReward;\n  }\n\n  /**\n    Returns the userInfo stored of a user\n    @param _user the address of the user\n    @return `struct UserInfo {\n      uint256 stake;\n      uint256 stakeWithBoost;\n      uint256 accAmountPerShare;\n      uint256 accParAmountPerShare;\n    }`\n  **/\n  function userInfo(address _user) public view override returns (UserInfo memory) {\n    return _users[_user];\n  }\n\n  /**\n    Refreshes the global state and subsequently increases a user's stake\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be increased\n  */\n  function _increaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n\n    UserInfo memory _userInfo = _users[_user];\n\n    uint256 newTotalStake = _totalStake.add(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, true);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.add(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n\n    if (pendingPAR > 0) {\n      _userInfo.stake = _userInfo.stake.add(pendingPAR);\n      _totalStake = _totalStake.add(pendingPAR);\n    }\n\n    _updateBoost(_user, _userInfo);\n\n    emit StakeIncreased(_user, _value.add(pendingPAR));\n  }\n\n  /**\n    Refreshes the global state and subsequently decreases the stake a user has\n    This is an internal call and meant to be called within derivative contracts\n    @param _user the address of the user\n    @param _value the amount by which the stake will be reduced\n  */\n  function _decreaseStake(address _user, uint256 _value) internal {\n    require(_value > 0, \"LM101\");\n    UserInfo memory _userInfo = _users[_user];\n    require(_userInfo.stake >= _value, \"LM102\");\n\n    uint256 newTotalStake = _totalStake.sub(_value);\n\n    _releaseRewards(_user, _userInfo, newTotalStake, false);\n    _totalStake = newTotalStake;\n    _userInfo.stake = _userInfo.stake.sub(_value);\n    _userInfo.accAmountPerShare = _accMimoAmountPerShare;\n    _userInfo.accParAmountPerShare = _accParAmountPerShare;\n    _updateBoost(_user, _userInfo);\n\n    emit StakeDecreased(_user, _value);\n  }\n\n  /**\n    Releases outstanding rewards balances to the user\n    @param _user the address of the user for which the reward tokens will be released\n  */\n  function _releaseRewards(\n    address _user,\n    UserInfo memory _userInfo,\n    uint256 _newTotalStake,\n    bool _restakePAR\n  ) internal {\n    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);\n    _refresh();\n    _refreshPAR(_newTotalStake);\n    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);\n    if (_userInfo.stakeWithBoost > 0) {\n      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);\n      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);\n    }\n\n    if (pendingPAR > 0 && !_restakePAR) {\n      require(_par.transfer(_user, pendingPAR), \"LM100\");\n    }\n    if (pendingMIMO > 0) {\n      require(_a.mimo().transfer(_user, pendingMIMO), \"LM100\");\n    }\n  }\n\n  /**\n    Updates the internal state variables based on user's veMIMO hodlings\n    @param _user the address of the user\n   */\n  function _updateBoost(address _user, UserInfo memory _userInfo) internal {\n    // if user had a boost already, first remove it from the totalStakeWithBoost\n    if (_userInfo.stakeWithBoost > 0) {\n      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);\n    }\n    uint256 multiplier = _getBoostMultiplier(_user);\n    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);\n    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);\n    _users[_user] = _userInfo;\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received MIMO tokens\n  */\n  function _refresh() internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));\n    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);\n    _mimoBalanceTracker = currentMimoBalance;\n    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Updates the internal state variables after accounting for newly received PAR tokens\n    @dev need to pass updated stake as arg because reward token and stake token are the same\n    @param newTotalStake updated total stake in PAR tokens\n  */\n  function _refreshPAR(uint256 newTotalStake) internal {\n    if (_totalStake == 0) {\n      return;\n    }\n    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);\n    uint256 parReward = currentParBalance.sub(_parBalanceTracker);\n\n    _parBalanceTracker = currentParBalance;\n    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));\n  }\n\n  /**\n    Returns the number of tokens a user can claim via `releaseMIMO`\n    @return number of MIMO tokens that the user can claim\n  */\n  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    uint256 currentBalance = _a.mimo().balanceOf(address(this));\n    uint256 reward = currentBalance.sub(_mimoBalanceTracker);\n    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));\n    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));\n  }\n\n  /**\n    Returns the number of PAR tokens the user has earned as a reward\n    @return number of PAR tokens that will be sent automatically when staking/unstaking\n  */\n  function _pendingPAR(\n    uint256 accParAmountPerShare,\n    uint256 _userStakeWithBoost,\n    uint256 _userAccParAmountPerShare\n  ) internal view returns (uint256) {\n    if (_totalStakeWithBoost == 0) {\n      return 0;\n    }\n    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));\n  }\n\n  /**\n    Returns the boost multiplier the user is eligible for\n    @param _user the address of the user\n    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))\n   */\n  function _getBoostMultiplier(address _user) internal view returns (uint256) {\n    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);\n\n    if (veMIMO == 0) return 1e18;\n\n    // Convert boostConfig variables to signed 64.64-bit fixed point numbers\n    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);\n    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);\n    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);\n    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);\n    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);\n\n    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000\n    int128 e2 = e1.sub(e); // x/25000 - 6\n    int128 e3 = e2.neg(); // -(x/25000 - 6)\n    int128 e4 = e3.exp(); // e^-(x/25000 - 6)\n    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)\n    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))\n    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64\n    uint256 multiplier = uint256(e7); // convert to uint256\n\n    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, \"LM103\");\n\n    return multiplier;\n  }\n}\n\n\n",
        "CodeNames": [
            "FeeDistributor.sol",
            "SuperVault.sol",
            "PARMinerV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "aggregatorSwap()",
                    "dexTxData",
                    "params",
                    "executeOperation()",
                    "lendingPool",
                    "receiver"
                ],
                "Type": " Fund loss or theft by attacker with creating a flash loan and setting SuperVault as receiver so executeOperation() will be get called by lendingPool but with attackers specified params",
                "Description": "\nAccording to Aave documentation, when requesting flash-loan, it's possible to specify a receiver, so function executeOperation() of that receiver will be called by lendingPool.\n<https://docs.aave.com/developers/v/2.0/guides/flash-loans\nIn the SuperVault there is no check to prevent this attack so attacker can use this and perform  griefing attack and make miner contract lose all its funds. or he can create specifically crafted params so when executeOperation() is called by lendingPool, attacker could steal vault's user funds.\n\n\nTo exploit this attacker will do this steps:\n\n1.  will call Aave lendingPool to get a flash-loan and specify SuperVault as receiver of flash-loan. and also create a specific params that invoke Operation.REBALANCE action to change user vault's collateral.\n2.  lendingPool will call executeOperation() of SuperVault with attacker specified data.\n3.  executeOperation() will check msg.sender and will process the function call which will cause some dummy exchanges that will cost user exchange fee and flash-loan fee.\n4.  attacker will repeat this attack until user losses all his funds.\n\n<!----\n\n      function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address,\n        bytes calldata params\n      ) external returns (bool) {\n        require(msg.sender == address(lendingPool), \"SV002\");\n        (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));\n        IERC20 asset = IERC20(assets[0]);\n        uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n        if (operation == Operation.LEVERAGE) {\n          leverageOperation(asset, flashloanRepayAmount, operationParams);\n        }\n        if (operation == Operation.REBALANCE) {\n          rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n        }\n        if (operation == Operation.EMPTY) {\n          emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);\n        }\n\n        asset.approve(address(lendingPool), flashloanRepayAmount);\n        return true;\n      }\n\nTo steal user fund in SupperVault attacker needs more steps. in all these actions (Operation.REBALANCE, Operation.LEVERAGE, Operation.EMPTY) contract will call aggregatorSwap() with data that are controlled by attacker.\n\n      function aggregatorSwap(\n        uint256 dexIndex,\n        IERC20 token,\n        uint256 amount,\n        bytes memory dexTxData\n      ) internal {\n        (address proxy, address router) = _dexAP.dexMapping(dexIndex);\n        require(proxy != address(0) && router != address(0), \"SV201\"); \n        token.approve(proxy, amount);\n        router.call(dexTxData);\n      }\n\nAttacker can put special data in dexTxData that make contract to do an exchange with bad price. To do this, attacker will create a smart contract that will do this steps:\n\n1.  manipulate price in exchange with flash loan.\n2.  make a call to executeOperation() by Aave flash-loan with receiver and specific params so that SuperVault will make calls to manipulated exchange for exchanging.\n3.  do the reverse of #1 and pay the flash-loan and steal the user fund.\n\nThe details are:\nAttacker can manipulate swapping pool price with flash-loan, then Attacker will create specific params and perform steps 1 to 4. so contract will try to exchange tokens and because of attacker price manipulation and specific dexTxData, contract will have bad deals.\nAfter that, attacker can reverse the process of swap manipulation and get his  flash-loan tokens and some of SuperVault funds and. then pay the flash-loan.\n\n\nVIM\n\n",
                "Repair": "\nThere should be some state variable which stores the fact that SuperVault imitated flash-loan.\nWhen contract tries to start flash-loan, it sets the isFlash to True and executeOperation() only accepts calls if isFlash is True. and after the flash loan code will set isFlash to False.\n\nm19 (Mimo DeFi) confirmed and commented(https://github.com/code-423n4/2022-04-mimo-findings/issues/123#issuecomment-1117124780):\n  We definitely confirm this issue and intend to fix it.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]