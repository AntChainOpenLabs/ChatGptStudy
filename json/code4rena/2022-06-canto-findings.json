[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Anyone can set the  baseRatePerYear  after the  updateFrequency  has passed",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L118-L129\n\nThe updateBaseRate() function is public and lacks access control, so anyone can set the critical variable baseRatePerYear once the block delta has surpassed the updateFrequency variable. This will have negative effects on the borrow and supply rates used anywhere else in the protocol.\n\nThe updateFrequency is explained to default to 24 hours per the comments, so this vulnerability will be available every day. Important to note, the admin can fix the baseRatePerYear by calling the admin-only _setBaseRatePerYear() function. However, calling this function does not set the lastUpdateBlock so users will still be able to change the rate back after the 24 hours waiting period from the previous change.\n\n\n        function updateBaseRate(uint newBaseRatePerYear) public {\n            // check the current block number\n            uint blockNumber = block.number;\n            uint deltaBlocks = blockNumber.sub(lastUpdateBlock);\n\n\n            if (deltaBlocks  updateFrequency) {\n                // pass in a base rate per year\n                baseRatePerYear = newBaseRatePerYear;\n                lastUpdateBlock = blockNumber;\n                emit NewInterestParams(baseRatePerYear);\n            }\n        }\n\n",
                "Repair": "\nI have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the _setBaseRatePerYear() function seems sufficient. Otherwise, add access control for only trusted parties.\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/22)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/22#issuecomment-1205570803):\n  The warden has shown how, due to probably an oversight, a core function that has impact in determining the yearly interest rate was left open for anyone to change once every 24 hrs.\n \n Because the impact is:\n Potential bricking of integrating contracts\n Economic exploits\n \n And anyone can perform it\n \n I believe that High Severity is appropriate.\n \n Mitigation requires either deleting the function or adding access control.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [],
                "Type": "   AccountantDelegate :  sweepInterest  function will destroy the cnote in the contract.",
                "Description": "\nWhen the user borrows note tokens, the AccountantDelegate contract provides note tokens and gets cnote tokens. Later, when the user repays the note tokens, the cnote tokens are destroyed and the note tokens are transferred to the AccountantDelegate contract.\nHowever, in the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0. This will prevent the user from repaying the note tokens, and the sweepInterest function will not calculate the interest correctly later.\n\n\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92<br\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CToken.sol#L533\n\n",
                "Repair": "\n        function sweepInterest() external override returns(uint) {\n    \t\t\n    \t\tuint noteBalance = note.balanceOf(address(this));\n    \t\tuint CNoteBalance = cnote.balanceOf(address(this));\n\n    \t\tExp memory expRate = Exp({mantissa: cnote.exchangeRateStored()}); // obtain exchange Rate from cNote Lending Market as a mantissa (scaled by 1e18)\n    \t\tuint cNoteConverted = mul_ScalarTruncate(expRate, CNoteBalance); //calculate truncate(cNoteBalance* mantissa{expRate})\n    \t\tuint noteDifferential = sub_(note.totalSupply(), noteBalance); //cannot underflow, subtraction first to prevent against overflow, subtraction as integers\n\n    \t\trequire(cNoteConverted = noteDifferential, \"Note Loaned to LendingMarket must increase in value\");\n    \t\t\n    \t\tuint amtToSweep = sub_(cNoteConverted, noteDifferential);\n\n    \t\tnote.transfer(treasury, amtToSweep);\n\n    -\t\tcnote.transfer(address(0), CNoteBalance);\n\n    \t\treturn 0;\n        }\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/89)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/89#issuecomment-1205796186):\n  The warden has shown how, due to a programmer mistake, interest bearing Note will be burned.\n \n It is unclear why this decision was made, and I believe the sponsor should look into redeeming the cNote over destroying it.\n \n The sponsor confirmed, and because this finding shows unconditional loss of assets, I agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction getBorrowRate(uint cash, uint borrows, uint reserves) public view override returns (uint) {\n    // Gets the Note/gUSDC TWAP in a given interval, as a mantissa (scaled by 1e18)\n    // uint twapMantissa = getUnderlyingPrice(note);\n    uint rand = uint(keccak256(abi.encodePacked(msg.sender))) % 100;\n    uint ir = (100 rand).mul(adjusterCoefficient).add(baseRatePerYear).mul(1e16);\n    uint newRatePerYear = ir = 0 ? ir : 0;\n    // convert it to base rate per block\n    uint newRatePerBlock = newRatePerYear.div(blocksPerYear);\n    return newRatePerBlock;\n}\n"
                ],
                "Type": "  lending-market/NoteInterest.sol  Wrong implementation of  getBorrowRate() ",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/NoteInterest.sol#L92-L101<br\n\nsolidity\nfunction getBorrowRate(uint cash, uint borrows, uint reserves) public view override returns (uint) {\n    // Gets the Note/gUSDC TWAP in a given interval, as a mantissa (scaled by 1e18)\n    // uint twapMantissa = getUnderlyingPrice(note);\n    uint rand = uint(keccak256(abi.encodePacked(msg.sender))) % 100;\n    uint ir = (100 rand).mul(adjusterCoefficient).add(baseRatePerYear).mul(1e16);\n    uint newRatePerYear = ir = 0 ? ir : 0;\n    // convert it to base rate per block\n    uint newRatePerBlock = newRatePerYear.div(blocksPerYear);\n    return newRatePerBlock;\n}\n\n\nThe current implementation will return a random rate based on the caller's address and baseRatePerYear.\n\nThis makes some lucky addresses pay much lower and some addresses pay much higher rates.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/166#issuecomment-1205799947):\n  The warden has shown how, due to most likely a developer oversight, the unimplemented getBorrowRate returns a random value which can easily be gamed (and is not recommended for production).\n \n Because the contract is in scope, and the functionality is broken, I agree with High Severity.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n        ))));\n}\n"
                ],
                "Type": "  zeroswap/UniswapV2Library.sol  Wrong init code hash in  UniswapV2Library.pairFor()  will break  UniswapV2Oracle ,  UniswapV2Router02 ,  SushiRoll ",
                "Description": "\n<https://github.com/Plex-Engineer/zeroswap/blob/03507a80322112f4f3c723fc68bed0f138702836/contracts/uniswapv2/libraries/UniswapV2Library.sol#L20-L28<br\n\nsolidity\nfunction pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n        ))));\n}\n\n\nThe init code hash in UniswapV2Library.pairFor() should be updated since the code of UniswapV2Pair has been changed. Otherwise, the pair address calculated will be wrong, most likely non-existing address.\n\nThere are many other functions and other contracts across the codebase, including  UniswapV2Oracle, UniswapV2Router02, and SushiRoll, that rely on the UniswapV2Library.pairFor() function for the address of the pair, with the UniswapV2Library.pairFor() returning a wrong and non-existing address, these functions and contracts will malfunction.\n\n",
                "Repair": "\nUpdate the init code hash from hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' to the value of UniswapV2Factory.pairCodeHash().\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/164)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/164#issuecomment-1207488488):\n  Amazing catch, because the contract bytecode has been change, the init hash will be different.\n \n While the bug seems trivial, it's impact is a total bricking of all swapping functionality as the Library will cause all Periphery Contracts to call to the wrong addresses.\n \n Because of the impact, I agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [],
                "Type": " Accountant can't be initialized",
                "Description": "\nIt's not possible to initialize the accountant because of a mistake in the function's require statement.\n\nI rate it as MED since a key part of the protocol wouldn't be available until the contract is modified and redeployed.\n\n\nThe issue is the following require() statement: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29\n\nThere, the function checks whether the accountant has received the correct amount of tokens. But, it compares the accountant's balance with the _initialSupply. That value is always 0. So the require statement will always fail\n\nWhen the Note contract is initialized, _initialSupply is set to 0:\n\n*   <https://github.com/Plex-Engineer/lending-market/blob/main/deploy/canto/004_deploy_Note.ts#L14\n*   <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L9\n*   <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L32\n\nAfter _mint_to_Accountant() mints type(uint).max tokens to the accountant: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L18<br\nThat increases the totalSupply but not the _initialSupply: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L242\n\nThe _initialSupply value is only modified by the ERC20 contract's constructor.\n\n",
                "Repair": "\nChange the require statement to\n\nsol\nrequire(note.balanceOf(msg.sender) == note.totalSupply(), \"AccountantDelegate::initiatlize: Accountant has not received payment\");\n\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/53)\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-06-canto-findings/issues/53#issuecomment-1207501752):\n  The warden has shown how, due to an incorrect assumption, AccountantDelegate.initialize cannot work, meaning part of the protocol will never work without fixing this issue.\n \n While the change should be fairly trivial, the impact is pretty high, for those reasons am going to raise severity to High.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [],
                "Type": " Anyone can create Proposal Unigov  Proposal-Store.sol ",
                "Description": "\n<https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46<br\n<https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37\n\nProposal Store is used to store proposals that have already passed (<https://code4rena.com/contests/2022-06-new-blockchain-contest#unigov-module-615-sloc) \" Upon a proposal\u2019s passing, the proposalHandler either deploys the ProposalStore contract (if it is not already deployed) or appends the proposal into the ProposalStore\u2019s mapping ( uint \u21d2 Proposal)\"\n\nBut anyone can add proposals to the contract directly via AddProposal() function.\n\nUnigov proposals can be queued and executed by anyone in GovernorBravoDelegate contract<br\n<https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37\n\n\n<https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46\n\n",
                "Repair": "\nAuthorization checks for AddProposal, only governance module should be able to update.\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/26)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/26#issuecomment-1211337729):\n  The warden has shown how, due to a lack of checks, anyone can create, queue, and execute a proposal without any particular checks.\n \n Because governance normally is limited via:\n Voting on a proposal\n Access control to limit transactions\n \n And the finding shows how this is completely ignored; \n \n I believe High Severity to be appropriate.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-09",
                "Location": [],
                "Type": " WETH.sol computes the wrong  totalSupply() ",
                "Description": "\nAffected code:\n\n*   <https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47\n\nWETH.sol is almost copied from the infamous WETH contract that lives in mainnet. This contract is supposed to receive the native currency of the blockchain (for example ETH) and wrap it into a tokenized, ERC-20 form. This contract computes the totalSupply() using the balance of the contract itself stored in the balanceOf mapping, when instead it should be using the native balance function. This way, totalSupply() always returns zero as the WETH contract itself has no way of calling deposit to itself and increase its own balance\n\n\n1.  Alice transfers 100 ETH to WETH.sol\n2.  Alice calls balanceOf() for her address and it returns 100 WETH\n3.  Alice calls totalSupply(), expecting to see 100 WETH, but it returns 0\n\n\nEditor\n\n",
                "Repair": "\njsx\nfunction totalSupply() public view returns (uint) {\n    return address(this).balance\n}\n\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/191)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/191#issuecomment-1211349777):\n  The warden has shown how, due to a programming mistake, the WETH totalSupply will be incorrect.\n \n Mitigation seems straightforward, however, because the vulnerability would have causes totalSupply to return 0, and shows a broken functionality for a core contract, I think High Severity to be appropriate\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [],
                "Type": " Comptroller uses the wrong address for the WETH contract",
                "Description": "\nThe Comptroller contract uses a hardcoded address for the WETH contract which is not the correct one. Because of that, it will be impossible to claim COMP rewards. That results in a loss of funds so I rate it as HIGH.\n\n\nThe Comptroller's getWETHAddress() function: <https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469\n\nIt's a left-over from the original compound repo: <https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1469\n\nIt's used by the grantCompInternal() function: <https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1377\n\nThat function is called by claimComp(): <https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1365\n\nIf there is a contract stored in that address and it doesn't adhere to the interface (doesn't have a balanceOf() and transfer() function), the transaction will revert. If there is no contract, the call will succeed without having any effect. In both cases, the user doesn't get their COMP rewards.\n\n",
                "Repair": "\nThe WETH contract's address should be parsed to the Comptroller through the constructor or another function instead of being hardcoded.\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/46)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/46#issuecomment-1211353848):\n  The warden has shown how the address for WETH / comp is hardcoded and the address is pointing to Mainnet's COMP.\n \n This misconfiguration will guarantee that any function calling grantCompInternal as well as claimComp will revert.\n \n Because the functionality is hampered, I agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-11",
                "Location": [
                    "//solidity\nfunction _mint_to_Accountant(address accountantDelegator) external {\n    if (accountant == address(0)) {\n        _setAccountantAddress(msg.sender);\n    }\n    require(msg.sender == accountant, \"Note::_mint_to_Accountant: \");\n    _mint(msg.sender, type(uint).max);\n}\n\nfunction RetAccountant() public view returns(address) {\n    return accountant;\n}\n\nfunction _setAccountantAddress(address accountant_) internal {\n    if(accountant != address(0)) {\n        require(msg.sender == admin, \"Note::_setAccountantAddress: Only admin may call this function\");\n    }\n    accountant = accountant_;\n    admin = accountant;\n}\n"
                ],
                "Type": "  lending-market/Note.sol  Wrong implementation of access control",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Note.sol#L13-L31<br\n\nsolidity\nfunction _mint_to_Accountant(address accountantDelegator) external {\n    if (accountant == address(0)) {\n        _setAccountantAddress(msg.sender);\n    }\n    require(msg.sender == accountant, \"Note::_mint_to_Accountant: \");\n    _mint(msg.sender, type(uint).max);\n}\n\nfunction RetAccountant() public view returns(address) {\n    return accountant;\n}\n\nfunction _setAccountantAddress(address accountant_) internal {\n    if(accountant != address(0)) {\n        require(msg.sender == admin, \"Note::_setAccountantAddress: Only admin may call this function\");\n    }\n    accountant = accountant_;\n    admin = accountant;\n}\n\n\n_mint_to_Accountant() calls _setAccountantAddress() when accountant == address(0), which will always be the case when _mint_to_Accountant() is called for the first time.\n\nAnd _setAccountantAddress() only checks if msg.sender == admin when accountant != address(0) which will always be false, therefore the access control is not working.\n\nL17 will then check if msg.sender == accountant, now it will always be the case, because at L29, accountant was set to msg.sender.\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/173)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/173#issuecomment-1211378551):\n  The warden has shown how, due to a flaw in logic, via a front-run, anyone can become the accountant and mint all the totalSupply to themselves.\n \n While I'm not super confident on severity for the front-run as I'd argue the worst case is forcing a re-deploy, the warden has shown a lack of logic in the checks (msg.sender == admin) which breaks it's invariants.\n \n For that reason, I think High Severity to be appropriate.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-12",
                "Location": [],
                "Type": " In  ERC20 ,  TotalSupply  is broken",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L33\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L95\n\nFor an obscure reason as it\u2019s not commented, _totalSupply is not initialized to 0, leading to an inaccurate total supply, which could easily break integrations, computations of market cap, etc.\n\n\nIf the constructor is called with _initialSupply = 1000, then 1000 tokens are minted. The total supply will be 2000.\n\n",
                "Repair": "\nRemove _initialSupply.\n\ntkkwon1998 (Canto) disputed and commented(https://github.com/code-423n4/2022-06-canto-findings/issues/108#issuecomment-1163455701):\n  The explanation is not clear. We can't seem to reproduce this issue as we can't find a scenario where the totalSupply function returns an incorrect value. \n\nPicodes (warden) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/108#issuecomment-1165895330):\n  @tkkwon1998 to clarify:\n \n Deploy the ERC20 with totalSupply_ = 1000. \n \n Then totalSupply() returns 1000, which is incorrect.\n \n Then if someone mints 1000 tokens, there is 1000 tokens in the market but due to _totalSupply += amount;, totalSupply = 2000 which is still incorrect\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/108#issuecomment-1211392092):\n  I believe the submission could have benefitted by:\n A coded POC\n Recognizing a revert due to the finding\n \n However the finding is ultimately true in that, because totalSupply is a parameter passed in to the contract, and the ERC20 contract will not mint that amount, the totalSupply will end up not reflecting the total amounts of tokens minted.\n \n For this reason, I believe the finding to be valid and High Severity to be appropriate.\n \n I recommend the warden to err on the side of giving too much information to avoid getting their finding invalidated incorrectly.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/108#issuecomment-1212622241):\n  After further thinking, I still believe the finding is of high severity as the ERC20 standard is also broken. I do believe the submission could have been better developed, however, I think High is in place here.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-13",
                "Location": [],
                "Type": " It's not possible to execute governance proposals through the  GovernorBravoDelegate  contract",
                "Description": "\nIt's not possible to execute a proposal through the GovernorBravoDelegate contract because the executed property of it is set to true when it's queued up.\n\nSince this means that the governance contract is unusable, it might result in locked-up funds if those were transferred to the contract before the issue comes up. Because of that I'd rate it as HIGH.\n\n\nexecuted is set to true: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63\n\nHere, the execute() function checks whether the proposal's state is Queued: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87\n\nBut, since the execute property is true, the state() function will return Executed: <https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L117\n\nIn the original compound repo, executed is false when the proposal is queued up: <https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol#L111\n\n",
                "Repair": "\nJust delete the line where executed is set to true. Since the zero-value is false anyway, you'll save gas as well.\n\ntkkwon1998 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/39)\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2022-06-canto-findings/issues/39#issuecomment-1211409709):\n  The warden has shown how, due to a coding decision, no transaction can be executed from the Governor Contract.\n \n Because the functionality is broken, I agree with High Severity.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-14",
                "Location": [],
                "Type": "  WETH.allowance()  returns wrong result",
                "Description": "\n<https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L104\n\nWETH.allowance() returns wrong result.<br\nI can't find other contracts that use this function but WETH.sol is a base contract and it should be fixed properly.\n\n\nIn this function, the \"return\" keyword is missing and it will always output 0 in this case.\n\n\nSolidity Visual Developer of VSCode\n\n",
                "Repair": "\nL104 should be changed like below.\n\n    return _allowance[owner][spender];\n\nnivasan1 (Canto) confirmed(https://github.com/code-423n4/2022-06-canto-findings/issues/218)\n\nAlex the Entreprenerd (judge) increased severity to High and commented(https://github.com/code-423n4/2022-06-canto-findings/issues/218#issuecomment-1212631296):\n  The warden has found a minor developer oversight, which will cause the view function allowance to always return 0.\n \n Breaking of a core contract such as WETH is a non-starter.\n \n Because I've already raised severity of #191 for similar reasons, I think High Severity is appropriate in this case. \n\n\n\n*\n\n \n\n"
            }
        ]
    }
]