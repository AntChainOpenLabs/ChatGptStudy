[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin-0.7/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./ActionGuards.sol\";\nimport \"./math/SafeInt256.sol\";\nimport \"./stubs/BalanceHandler.sol\";\nimport \"./stubs/TokenHandler.sol\";\nimport \"./global/StorageLayoutV2.sol\";\nimport \"./global/Constants.sol\";\nimport \"interfaces/notional/NotionalTreasury.sol\";\nimport \"interfaces/compound/ComptrollerInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport {WETH9_07 as WETH9} from \"interfaces/WETH9_07.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n\n    /// @dev Emitted when treasury manager is updated\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\n    /// @dev Emitted when reserve buffer value is updated\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Caller is not the treasury manager\");\n        _;\n    }\n\n    /// @dev Checks if the currency ID is valid\n    function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8 \n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on \n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        // prettier-ignore\n        (int256 reserveBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Claims COMP incentives earned and transfers to the treasury manager contract.\n    /// @param cTokens a list of cTokens to claim incentives for\n    /// @return the balance of COMP claimed\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\n        // something we shouldn't.\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\n        // will never hold COMP balances directly. In this case we can always transfer all the COMP\n        // off of the contract.\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        // NOTE: TreasuryManager contract will emit a COMPHarvested event\n        return amountClaimed;\n    }\n\n    /// @notice redeems and transfers tokens to the treasury manager contract\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n\n        // This is the actual redeemed amount in underlying external precision\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n\n        // NOTE: cETH redeems to ETH, converting it to WETH\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract to be invested\n    /// into the sNOTE pool.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            // prettier-ignore\n            (int256 reserveInternal, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            // Redeems cTokens and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n}\n\n",
        "CodeNames": [
            "TreasuryAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction claimCOMPAndTransfer(address[] calldata cTokens)\n    external\n    override\n    onlyManagerContract\n    nonReentrant\n    returns (uint256)\n{\n    // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\n    // something we shouldn't.\n    uint256 balanceBefore = COMP.balanceOf(address(this));\n    // @audit anyone can claim COMP on behalf of this contract and then it's stuck. https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1328\n    COMPTROLLER.claimComp(address(this), cTokens);\n    // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\n    // will never hold COMP balances directly. In this case we can always transfer all the COMP\n    // off of the contract.\n    uint256 balanceAfter = COMP.balanceOf(address(this));\n    uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n    // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n    COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n    // NOTE: TreasuryManager contract will emit a COMPHarvested event\n    return amountClaimed;\n}\n"
                ],
                "Type": " Treasury cannot claim COMP tokens & COMP tokens are stuck",
                "Description": "\nThe TreasuryAction.claimCOMPAndTransfer function uses preand post-balances of the COMP token to check which ones to transfer:\n\nsolidity\nfunction claimCOMPAndTransfer(address[] calldata cTokens)\n    external\n    override\n    onlyManagerContract\n    nonReentrant\n    returns (uint256)\n{\n    // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\n    // something we shouldn't.\n    uint256 balanceBefore = COMP.balanceOf(address(this));\n    // @audit anyone can claim COMP on behalf of this contract and then it's stuck. https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1328\n    COMPTROLLER.claimComp(address(this), cTokens);\n    // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\n    // will never hold COMP balances directly. In this case we can always transfer all the COMP\n    // off of the contract.\n    uint256 balanceAfter = COMP.balanceOf(address(this));\n    uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n    // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n    COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n    // NOTE: TreasuryManager contract will emit a COMPHarvested event\n    return amountClaimed;\n}\n\n\nNote that anyone can claim COMP tokens on behalf of any address (see Comptroller.claimComp(https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1328)).\nAn attacker can claim COMP tokens on behalf of the contract and it'll never be able to claim any compound itself.\nThe COMP claimed by the attacker are stuck in the contract and cannot be retrieved.\n(One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through transferReserveToTreasury.)\n\n",
                "Repair": "\nDon't use pre-and post-balances, can you use the entire balance?\n\njeffywu (Notional) disagreed with severity and commented(https://github.com/code-423n4/2022-01-notional-findings/issues/192#issuecomment-1030843184):\n  Dispute as a high risk bug. Would categorize this as medium risk.\n \n There is no profit to be gained by doing this from the attacker besides denial of service. The protocol could simply upgrade to regain access to the tokens. We will fix this regardless.\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/192#issuecomment-1041504305):\n  Very good find. \n \n It is a tough decision if this should be classified as High or Medium severity. An exploiter cannot acquire those assets, and the contracts are upgradeable if necessary, however, I think this time I will leave it in favor of wardens who both are experienced enough and submitted this as of high severity:\n _3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals)._\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {BoringOwnable} from \"./utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport {IVault, IAsset} from \"interfaces/balancer/IVault.sol\";\nimport \"interfaces/balancer/IWeightedPool.sol\";\nimport \"interfaces/balancer/IPriceOracle.sol\";\n\ncontract sNOTE is ERC20Upgradeable, ERC20VotesUpgradeable, BoringOwnable, UUPSUpgradeable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    ERC20 public immutable NOTE;\n    ERC20 public immutable BALANCER_POOL_TOKEN;\n    ERC20 public immutable WETH;\n    bytes32 public immutable NOTE_ETH_POOL_ID;\n\n    /// @notice Maximum shortfall withdraw of 50%\n    uint256 public constant MAX_SHORTFALL_WITHDRAW = 50;\n    uint256 public constant BPT_TOKEN_PRECISION = 1e18;\n\n    /// @notice Redemption window in seconds\n    uint256 public constant REDEEM_WINDOW_SECONDS = 3 days;\n\n    /// @notice Tracks an account's redemption window\n    struct AccountCoolDown {\n        uint32 redeemWindowBegin;\n        uint32 redeemWindowEnd;\n    }\n\n    /// @notice Number of seconds that need to pass before sNOTE can be redeemed\n    uint32 public coolDownTimeInSeconds;\n\n    /// @notice Mapping between sNOTE holders and their current cooldown status\n    mapping(address => AccountCoolDown) public accountCoolDown;\n\n    /// @notice Emitted when a cool down begins\n    event CoolDownStarted(address account, uint256 redeemWindowBegin, uint256 redeemWindowEnd);\n\n    /// @notice Emitted when a cool down ends\n    event CoolDownEnded(address account);\n\n    /// @notice Emitted when cool down time is updated\n    event GlobalCoolDownUpdated(uint256 newCoolDownTimeSeconds);\n\n    /// @notice Constructor sets immutable contract addresses\n    constructor(\n        IVault _balancerVault,\n        bytes32 _noteETHPoolId,\n        ERC20 _note,\n        ERC20 _weth\n    ) initializer { \n        // Validate that the pool exists\n        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);\n        require(poolAddress != address(0));\n\n        WETH = _weth;\n        NOTE = _note;\n        NOTE_ETH_POOL_ID = _noteETHPoolId;\n        BALANCER_VAULT = _balancerVault;\n        BALANCER_POOL_TOKEN = ERC20(poolAddress);\n    }\n\n    /// @notice Initializes sNOTE ERC20 metadata and owner\n    function initialize(\n        address _owner,\n        uint32 _coolDownTimeInSeconds\n    ) external initializer {\n        string memory _name = \"Staked NOTE\";\n        string memory _symbol = \"sNOTE\";\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        owner = _owner;\n        NOTE.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /** Governance Methods **/\n\n    /// @notice Authorizes the DAO to upgrade this contract\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /// @notice Updates the required cooldown time to redeem\n    function setCoolDownTime(uint32 _coolDownTimeInSeconds) external onlyOwner {\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        emit GlobalCoolDownUpdated(_coolDownTimeInSeconds);\n    }\n\n    /// @notice Allows the DAO to extract up to 50% of the BPT tokens during a collateral shortfall event\n    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n        // revert here since there may be a delay between when governance issues the token amount and when\n        // the withdraw actually occurs.\n        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[0] = 0;\n        minAmountsOut[1] = 0;\n\n        BALANCER_VAULT.exitPool(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            payable(owner), // Owner will receive the NOTE and WETH\n            IVault.ExitPoolRequest(\n                assets,\n                minAmountsOut,\n                abi.encode(\n                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n    }\n\n    /// @notice Allows the DAO to set the swap fee on the BPT\n    function setSwapFeePercentage(uint256 swapFeePercentage) external onlyOwner {\n        IWeightedPool(address(BALANCER_POOL_TOKEN)).setSwapFeePercentage(swapFeePercentage);\n    }\n\n    /** User Methods **/\n\n    /// @notice Mints sNOTE from the underlying BPT token.\n    /// @param bptAmount is the amount of BPT to transfer from the msg.sender.\n    function mintFromBPT(uint256 bptAmount) external nonReentrant {\n        // _mint logic requires that tokens are transferred first\n        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount);\n        _mint(msg.sender, bptAmount);\n    }\n\n    /// @notice Mints sNOTE from some amount of NOTE tokens.\n    /// @param noteAmount amount of NOTE to transfer into the sNOTE contract\n    function mintFromNOTE(uint256 noteAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = 0;\n        maxAmountsIn[1] = noteAmount;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of ETH\n    function mintFromETH() payable external nonReentrant {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = msg.value;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of WETH\n    /// @param wethAmount amount of WETH to transfer into the sNOTE contract\n    function mintFromWETH(uint256 wethAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        WETH.safeTransferFrom(msg.sender, address(this), wethAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = wethAmount;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    function _mintFromAssets(IAsset[] memory assets, uint256[] memory maxAmountsIn) internal {\n        uint256 bptBefore = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // Set msgValue when joining via ETH\n        uint256 msgValue = assets[0] == IAsset(address(0)) ? maxAmountsIn[0] : 0;\n\n        BALANCER_VAULT.joinPool{value: msgValue}(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            address(this), // sNOTE will receive the BPT\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(\n                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    maxAmountsIn,\n                    0 // Accept however much BPT the pool will give us\n                ),\n                false // Don't use internal balances\n            )\n        );\n        uint256 bptAfter = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Balancer pool token amounts must increase\n        _mint(msg.sender, bptAfter - bptBefore);\n    }\n\n    /// @notice Begins a cool down period for the sender, this is required to redeem tokens\n    function startCoolDown() external {\n        // Cannot start a cool down if there is already one in effect\n        _requireAccountNotInCoolDown(msg.sender);\n        uint256 redeemWindowBegin = block.timestamp + coolDownTimeInSeconds;\n        uint256 redeemWindowEnd = redeemWindowBegin + REDEEM_WINDOW_SECONDS;\n\n        accountCoolDown[msg.sender] = AccountCoolDown(_safe32(redeemWindowBegin), _safe32(redeemWindowEnd));\n\n        emit CoolDownStarted(msg.sender, redeemWindowBegin, redeemWindowEnd);\n    }\n\n    /// @notice Stops a cool down for the sender\n    function stopCoolDown() public {\n        // Reset the cool down back to zero so that the account must initiate it again to redeem\n        delete accountCoolDown[msg.sender];\n        emit CoolDownEnded(msg.sender);\n    }\n\n    /// @notice Redeems some amount of sNOTE to underlying BPT tokens (which can then be sold for\n    /// NOTE or ETH). An account must have passed its cool down expiration before they can redeem\n    /// @param sNOTEAmount amount of sNOTE to redeem\n    function redeem(uint256 sNOTEAmount) external nonReentrant {\n        AccountCoolDown memory coolDown = accountCoolDown[msg.sender];\n        require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");\n        require(\n            coolDown.redeemWindowBegin != 0 &&\n            coolDown.redeemWindowBegin < block.timestamp &&\n            block.timestamp < coolDown.redeemWindowEnd,\n            \"Not in Redemption Window\"\n        );\n\n        uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);\n        _burn(msg.sender, bptToRedeem);\n\n        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);\n    }\n\n    /** External View Methods **/\n\n    /// @notice Returns how many Balancer pool tokens an sNOTE token amount has a claim on\n    function getPoolTokenShare(uint256 sNOTEAmount) public view returns (uint256 bptClaim) {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // BPT and sNOTE are both in 18 decimal precision so no conversion required\n        return (bptBalance * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Returns the pool token share of a specific account\n    function poolTokenShareOf(address account) public view returns (uint256 bptClaim) {\n        return getPoolTokenShare(balanceOf(account));\n    }\n\n    /// @notice Calculates voting power for a given amount of sNOTE\n    /// @param sNOTEAmount amount of sNOTE to calculate voting power for\n    /// @return corresponding NOTE voting power\n    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n        // Gets the BPT token price (in ETH)\n        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n        // Gets the NOTE token price (in ETH)\n        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n        \n        // Since both bptPrice and notePrice are denominated in ETH, we can use\n        // this formula to calculate noteAmount\n        // bptBalance * bptPrice = notePrice * noteAmount\n        // noteAmount = bptPrice/notePrice * bptBalance\n        uint256 priceRatio = bptPrice * 1e18 / notePrice;\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n        uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n        // Reduce precision down to 1e8 (NOTE token)\n        // priceRatio and bptBalance are both 1e18 (1e36 total)\n        // we divide by 1e28 to get to 1e8\n        noteAmount /= 1e28;\n\n        return (noteAmount * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Calculates voting power for a given account\n    /// @param account a given sNOTE holding account\n    /// @return corresponding NOTE voting power\n    function votingPowerOf(address account) external view returns (uint256) {\n        return getVotingPower(balanceOf(account));\n    }\n\n    /** Internal Methods **/\n\n    function _requireAccountNotInCoolDown(address account) internal view {\n        AccountCoolDown memory coolDown = accountCoolDown[account];\n        // An account is in cool down if the redeem window has begun and the window end has not\n        // passed yet.\n        bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);\n        require(!isInCoolDown, \"Account in Cool Down\");\n    }\n\n    /// @notice Burns sNOTE tokens when they are redeemed\n    /// @param account account to burn tokens on\n    /// @param bptToRedeem the number of BPT tokens being redeemed by the account\n    function _burn(address account, uint256 bptToRedeem) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        uint256 poolTokenShare = poolTokenShareOf(account);\n        require(bptToRedeem <= poolTokenShare, \"Invalid Redeem Amount\");\n\n        // Burns the portion of the sNOTE corresponding to the bptToRedeem\n        uint256 sNOTEToBurn = balanceOf(account) * bptToRedeem / poolTokenShare;\n        // Handles event emission, balance update and total supply update\n        super._burn(account, sNOTEToBurn);\n    }\n\n    /// @notice Mints sNOTE tokens given a bptAmount\n    /// @param account account to mint tokens to\n    /// @param bptAmount the number of BPT tokens being minted by the account\n    function _mint(address account, uint256 bptAmount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Cannot mint if a cooldown is already in effect. If an account mints during a cool down period then they will\n        // be able to redeem the tokens immediately, bypassing the cool down.\n        _requireAccountNotInCoolDown(account);\n\n        // Immediately after minting, we need to satisfy the equality:\n        // (sNOTEToMint * bptBalance) / (totalSupply + sNOTEToMint) == bptAmount\n\n        // Rearranging to get sNOTEToMint on one side:\n        // (sNOTEToMint * bptBalance) = (totalSupply + sNOTEToMint) * bptAmount\n        // (sNOTEToMint * bptBalance) = totalSupply * bptAmount + sNOTEToMint * bptAmount\n        // (sNOTEToMint * bptBalance) - (sNOTEToMint * bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint * (bptBalance - bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint = (totalSupply * bptAmount) / (bptBalance - bptAmount)\n\n        // NOTE: at this point the BPT has already been transferred into the sNOTE contract, so this\n        // bptBalance amount includes bptAmount.\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 sNOTEToMint;\n        if (_totalSupply == 0) {\n            sNOTEToMint = bptAmount;\n        } else {\n            sNOTEToMint = (_totalSupply * bptAmount) / (bptBalance - bptAmount);\n        }\n\n        // Handles event emission, balance update and total supply update\n        super._mint(account, sNOTEToMint);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable) {\n        // Cannot send or receive tokens if a cool down is in effect or else accounts\n        // can bypass the cool down. It's not clear if sending tokens can be used to bypass\n        // the cool down but we restrict it here anyway, there's no clear use case for sending\n        // sNOTE tokens during a cool down.\n        if (to != address(0)) {\n            // Run these checks only when we are not burning tokens. (OZ ERC20 does not allow transfers\n            // to address(0), to == address(0) only when _burn is called).\n            _requireAccountNotInCoolDown(from);\n            _requireAccountNotInCoolDown(to);\n        }\n\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Moves sNOTE checkpoints\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _safe32(uint256 x) internal pure returns (uint32) {\n        require (x <= type(uint32).max);\n        return uint32(x);\n    }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {WETH9} from \"interfaces/WETH9.sol\";\nimport {AggregatorV2V3Interface} from \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\ncontract EIP1271Wallet {\n    // 0x order encoding is implemented in _encodeEIP1271OrderWithHash\n    // https://github.com/0xProject/0x-monorepo/blob/development/contracts/exchange/contracts/src/MixinSignatureValidator.sol\n    uint256 internal constant ORDER_HASH_OFFSET = 36;\n    uint256 internal constant FEE_RECIPIENT_OFFSET = 144;\n    uint256 internal constant MAKER_AMOUNT_OFFSET = 196;\n    uint256 internal constant TAKER_AMOUNT_OFFSET = 228;\n    uint256 internal constant MAKER_TOKEN_OFFSET = 564;\n    uint256 internal constant TAKER_TOKEN_OFFSET = 660;\n    uint256 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n    uint256 internal constant ETH_PRECISION = 1e18;\n\n    bytes4 internal constant EIP1271_MAGIC_NUM = 0x20c13b0b;\n    bytes4 internal constant EIP1271_INVALID_SIG = 0xffffffff;\n    WETH9 public immutable WETH;\n    mapping(address => address) public priceOracles;\n    mapping(address => uint256) public slippageLimits;\n\n    event PriceOracleUpdated(address tokenAddress, address oracleAddress);\n    event SlippageLimitUpdated(address tokenAddress, uint256 slippageLimit);\n\n    constructor(WETH9 _weth) {\n        WETH = _weth;\n    }\n\n    function _toAddress(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (address)\n    {\n        // _bytes.length checked by the caller\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function _toUint256(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (uint256)\n    {\n        // _bytes.length checked by the caller\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function _toBytes32(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (bytes32)\n    {\n        // _bytes.length checked by the caller\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function _toUint(int256 x) private pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    /// @notice extracts order information from the encoded 0x order object\n    function _extractOrderInfo(bytes memory encoded)\n        private\n        pure\n        returns (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        )\n    {\n        require(\n            encoded.length >= TAKER_TOKEN_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n        feeRecipient = _toAddress(encoded, FEE_RECIPIENT_OFFSET);\n        makerAmount = _toUint256(encoded, MAKER_AMOUNT_OFFSET);\n        takerAmount = _toUint256(encoded, TAKER_AMOUNT_OFFSET);\n        makerToken = _toAddress(encoded, MAKER_TOKEN_OFFSET);\n        takerToken = _toAddress(encoded, TAKER_TOKEN_OFFSET);\n    }\n\n    /// @notice extracts the order hash from the encoded 0x order object\n    function _extractOrderHash(bytes memory encoded)\n        private\n        pure\n        returns (bytes32)\n    {\n        require(\n            encoded.length >= ORDER_HASH_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n\n        return _toBytes32(encoded, ORDER_HASH_OFFSET);\n    }\n\n    /// @notice sets the price oracle for a given token\n    function _setPriceOracle(address tokenAddress, address oracleAddress)\n        internal\n    {\n        priceOracles[tokenAddress] = oracleAddress;\n        emit PriceOracleUpdated(tokenAddress, oracleAddress);\n    }\n\n    /// @notice slippage limit sets the price floor of the maker token based on the oracle price\n    /// SLIPPAGE_LIMIT_PRECISION = 1e8 = 100% of the current oracle price\n    function _setSlippageLimit(address tokenAddress, uint256 slippageLimit)\n        internal\n    {\n        require(\n            slippageLimit <= SLIPPAGE_LIMIT_PRECISION,\n            \"invalid slippage limit\"\n        );\n        slippageLimits[tokenAddress] = slippageLimit;\n        emit SlippageLimitUpdated(tokenAddress, slippageLimit);\n    }\n\n    /// @notice make sure the order satisfies some pre-defined constraints\n    function _validateOrder(bytes memory order) private view {\n        (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        ) = _extractOrderInfo(order);\n\n        // No fee recipient allowed\n        require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n        // MakerToken should never be WETH\n        require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n        // TakerToken (proceeds) should always be WETH\n        require(takerToken == address(WETH), \"taker token must be WETH\");\n\n        address priceOracle = priceOracles[makerToken];\n\n        // Price oracle not defined\n        require(priceOracle != address(0), \"price oracle not defined\");\n\n        uint256 slippageLimit = slippageLimits[makerToken];\n\n        // Slippage limit not defined\n        require(slippageLimit != 0, \"slippage limit not defined\");\n\n        uint256 oraclePrice = _toUint(\n            AggregatorV2V3Interface(priceOracle).latestAnswer()\n        );\n\n        uint256 priceFloor = (oraclePrice * slippageLimit) /\n            SLIPPAGE_LIMIT_PRECISION;\n\n        uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n        // makerPrice = takerAmount / makerAmount\n        uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n        require(makerPrice >= priceFloor, \"slippage is too high\");\n    }\n\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     */\n    function _isValidSignature(\n        bytes calldata data,\n        bytes calldata signature,\n        address signer\n    ) internal view returns (bytes4) {\n        _validateOrder(data);\n\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _extractOrderHash(data)\n                )\n            ),\n            signature\n        );\n\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return EIP1271_MAGIC_NUM;\n        }\n\n        return EIP1271_INVALID_SIG;\n    }\n}\n\n\n",
        "CodeNames": [
            "sNOTE.sol",
            "EIP1271Wallet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice = priceFloor, \"slippage is too high\");\n}\n"
                ],
                "Type": " A Malicious Treasury Manager Can Burn Treasury Tokens By Setting  makerFee  To The Amount The Maker Receives",
                "Description": "\nThe treasury manager contract holds harvested assets/COMP from Notional which are used to perform NOTE buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to WETH which can then be deposited in the Balancer LP and distributed to sNOTE holders.\n\nHowever, _validateOrder does not validate that takerFee and makerFee are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as makerFee is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.\n\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188\nsolidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice = priceFloor, \"slippage is too high\");\n}\n\n\n",
                "Repair": "\nConsider checking that makerFee == 0 and takerFee == 0 in EIP1271Wallet._validateOrder s.t. the treasury manager cannot sign unfair orders which severely impact the TreasuryManager contract.\n\njeffywu (Notional) confirmed and commented(https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1030839051):\n  Confirmed, we will fix this.\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/230#issuecomment-1041560475):\n  Good job warden for identifying this issue with 0x integration.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"./global/StorageLayoutV1.sol\";\n\nabstract contract ActionGuards is StorageLayoutV1 {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(reentrancyStatus != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        reentrancyStatus = _NOT_ENTERED;\n    }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {WETH9} from \"interfaces/WETH9.sol\";\nimport {AggregatorV2V3Interface} from \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\ncontract EIP1271Wallet {\n    // 0x order encoding is implemented in _encodeEIP1271OrderWithHash\n    // https://github.com/0xProject/0x-monorepo/blob/development/contracts/exchange/contracts/src/MixinSignatureValidator.sol\n    uint256 internal constant ORDER_HASH_OFFSET = 36;\n    uint256 internal constant FEE_RECIPIENT_OFFSET = 144;\n    uint256 internal constant MAKER_AMOUNT_OFFSET = 196;\n    uint256 internal constant TAKER_AMOUNT_OFFSET = 228;\n    uint256 internal constant MAKER_TOKEN_OFFSET = 564;\n    uint256 internal constant TAKER_TOKEN_OFFSET = 660;\n    uint256 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n    uint256 internal constant ETH_PRECISION = 1e18;\n\n    bytes4 internal constant EIP1271_MAGIC_NUM = 0x20c13b0b;\n    bytes4 internal constant EIP1271_INVALID_SIG = 0xffffffff;\n    WETH9 public immutable WETH;\n    mapping(address => address) public priceOracles;\n    mapping(address => uint256) public slippageLimits;\n\n    event PriceOracleUpdated(address tokenAddress, address oracleAddress);\n    event SlippageLimitUpdated(address tokenAddress, uint256 slippageLimit);\n\n    constructor(WETH9 _weth) {\n        WETH = _weth;\n    }\n\n    function _toAddress(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (address)\n    {\n        // _bytes.length checked by the caller\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function _toUint256(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (uint256)\n    {\n        // _bytes.length checked by the caller\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function _toBytes32(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (bytes32)\n    {\n        // _bytes.length checked by the caller\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function _toUint(int256 x) private pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    /// @notice extracts order information from the encoded 0x order object\n    function _extractOrderInfo(bytes memory encoded)\n        private\n        pure\n        returns (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        )\n    {\n        require(\n            encoded.length >= TAKER_TOKEN_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n        feeRecipient = _toAddress(encoded, FEE_RECIPIENT_OFFSET);\n        makerAmount = _toUint256(encoded, MAKER_AMOUNT_OFFSET);\n        takerAmount = _toUint256(encoded, TAKER_AMOUNT_OFFSET);\n        makerToken = _toAddress(encoded, MAKER_TOKEN_OFFSET);\n        takerToken = _toAddress(encoded, TAKER_TOKEN_OFFSET);\n    }\n\n    /// @notice extracts the order hash from the encoded 0x order object\n    function _extractOrderHash(bytes memory encoded)\n        private\n        pure\n        returns (bytes32)\n    {\n        require(\n            encoded.length >= ORDER_HASH_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n\n        return _toBytes32(encoded, ORDER_HASH_OFFSET);\n    }\n\n    /// @notice sets the price oracle for a given token\n    function _setPriceOracle(address tokenAddress, address oracleAddress)\n        internal\n    {\n        priceOracles[tokenAddress] = oracleAddress;\n        emit PriceOracleUpdated(tokenAddress, oracleAddress);\n    }\n\n    /// @notice slippage limit sets the price floor of the maker token based on the oracle price\n    /// SLIPPAGE_LIMIT_PRECISION = 1e8 = 100% of the current oracle price\n    function _setSlippageLimit(address tokenAddress, uint256 slippageLimit)\n        internal\n    {\n        require(\n            slippageLimit <= SLIPPAGE_LIMIT_PRECISION,\n            \"invalid slippage limit\"\n        );\n        slippageLimits[tokenAddress] = slippageLimit;\n        emit SlippageLimitUpdated(tokenAddress, slippageLimit);\n    }\n\n    /// @notice make sure the order satisfies some pre-defined constraints\n    function _validateOrder(bytes memory order) private view {\n        (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        ) = _extractOrderInfo(order);\n\n        // No fee recipient allowed\n        require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n        // MakerToken should never be WETH\n        require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n        // TakerToken (proceeds) should always be WETH\n        require(takerToken == address(WETH), \"taker token must be WETH\");\n\n        address priceOracle = priceOracles[makerToken];\n\n        // Price oracle not defined\n        require(priceOracle != address(0), \"price oracle not defined\");\n\n        uint256 slippageLimit = slippageLimits[makerToken];\n\n        // Slippage limit not defined\n        require(slippageLimit != 0, \"slippage limit not defined\");\n\n        uint256 oraclePrice = _toUint(\n            AggregatorV2V3Interface(priceOracle).latestAnswer()\n        );\n\n        uint256 priceFloor = (oraclePrice * slippageLimit) /\n            SLIPPAGE_LIMIT_PRECISION;\n\n        uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n        // makerPrice = takerAmount / makerAmount\n        uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n        require(makerPrice >= priceFloor, \"slippage is too high\");\n    }\n\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     */\n    function _isValidSignature(\n        bytes calldata data,\n        bytes calldata signature,\n        address signer\n    ) internal view returns (bytes4) {\n        _validateOrder(data);\n\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _extractOrderHash(data)\n                )\n            ),\n            signature\n        );\n\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return EIP1271_MAGIC_NUM;\n        }\n\n        return EIP1271_INVALID_SIG;\n    }\n}\n\n\n",
        "CodeNames": [
            "ActionGuards.sol",
            "EIP1271Wallet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "EIP",
                    "latestAnswer"
                ],
                "Type": " Usage of deprecated ChainLink API in  EIP1271Wallet ",
                "Description": "\nThe Chainlink API (latestAnswer) used in the EIP1271Wallet contract is deprecated:\n\n This API is deprecated. Please see API Reference for the latest Price Feed API. Chainlink Docs(https://web.archive.org/web/20210304160150/https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference)\n\nThis function does not error if no answer has been reached but returns 0. Besides, the latestAnswer is reported with 18 decimals for crypto quotes but 8 decimals for FX quotes (See Chainlink FAQ for more details). A best practice is to get the decimals from the oracles instead of hard-coding them in the contract.\n\n",
                "Repair": "\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete, for example:\n\nsolidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = priceOracle.latestRoundData();\nrequire(answeredInRound = roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/197#issuecomment-1037191042):\n  Valid finding. I am hesitating whether this should be low or medium but decided to leave it as a medium because the likeliness is low but the impact would be huge, and all the wardens submitted this with a medium severity. Also: \"Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\"\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\naddress takerAddress;   // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n",
                    "//solidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice = priceFloor, \"slippage is too high\");\n}\n"
                ],
                "Type": "  _validateOrder  Does Not Allow Anyone To Be A Taker Of An Off-Chain Order",
                "Description": "\nThe EIP1271Wallet contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the TreasuryManager contract, which holds harvested assets/COMP from Notional. While the EIP1271Wallet._validateOrder function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the takerAddress and senderAddress are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in makerPrice, the manager is able to extract value from the treasury by maximising the allowed slippage.\n\nBy setting takerAddress to the zero address, any user can be the taker of an off-chain order. By setting senderAddress to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.\n\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66\nsolidity\naddress takerAddress;   // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250\n\n<https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188\nsolidity\nfunction _validateOrder(bytes memory order) private view {\n    (\n        address makerToken,\n        address takerToken,\n        address feeRecipient,\n        uint256 makerAmount,\n        uint256 takerAmount\n    ) = _extractOrderInfo(order);\n\n    // No fee recipient allowed\n    require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n    // MakerToken should never be WETH\n    require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n    // TakerToken (proceeds) should always be WETH\n    require(takerToken == address(WETH), \"taker token must be WETH\");\n\n    address priceOracle = priceOracles[makerToken];\n\n    // Price oracle not defined\n    require(priceOracle != address(0), \"price oracle not defined\");\n\n    uint256 slippageLimit = slippageLimits[makerToken];\n\n    // Slippage limit not defined\n    require(slippageLimit != 0, \"slippage limit not defined\");\n\n    uint256 oraclePrice = _toUint(\n        AggregatorV2V3Interface(priceOracle).latestAnswer()\n    );\n\n    uint256 priceFloor = (oraclePrice * slippageLimit) /\n        SLIPPAGE_LIMIT_PRECISION;\n\n    uint256 makerDecimals = 10ERC20(makerToken).decimals();\n\n    // makerPrice = takerAmount / makerAmount\n    uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n    require(makerPrice = priceFloor, \"slippage is too high\");\n}\n\n\n\nManual code review.\nDiscussions with Notional team.\n\n",
                "Repair": "\nConsider adding require(takerAddress == address(0), \"manager cannot set taker\"); and require(senderAddress == address(0), \"manager cannot set sender\"); statements to _validateOrder. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2022-01-notional-findings/issues/152)\n\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/152#issuecomment-1041564430):\n  Great find, I like when wardens understand and identify issues with integrated external protocols.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {BoringOwnable} from \"./utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport {IVault, IAsset} from \"interfaces/balancer/IVault.sol\";\nimport \"interfaces/balancer/IWeightedPool.sol\";\nimport \"interfaces/balancer/IPriceOracle.sol\";\n\ncontract sNOTE is ERC20Upgradeable, ERC20VotesUpgradeable, BoringOwnable, UUPSUpgradeable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    ERC20 public immutable NOTE;\n    ERC20 public immutable BALANCER_POOL_TOKEN;\n    ERC20 public immutable WETH;\n    bytes32 public immutable NOTE_ETH_POOL_ID;\n\n    /// @notice Maximum shortfall withdraw of 50%\n    uint256 public constant MAX_SHORTFALL_WITHDRAW = 50;\n    uint256 public constant BPT_TOKEN_PRECISION = 1e18;\n\n    /// @notice Redemption window in seconds\n    uint256 public constant REDEEM_WINDOW_SECONDS = 3 days;\n\n    /// @notice Tracks an account's redemption window\n    struct AccountCoolDown {\n        uint32 redeemWindowBegin;\n        uint32 redeemWindowEnd;\n    }\n\n    /// @notice Number of seconds that need to pass before sNOTE can be redeemed\n    uint32 public coolDownTimeInSeconds;\n\n    /// @notice Mapping between sNOTE holders and their current cooldown status\n    mapping(address => AccountCoolDown) public accountCoolDown;\n\n    /// @notice Emitted when a cool down begins\n    event CoolDownStarted(address account, uint256 redeemWindowBegin, uint256 redeemWindowEnd);\n\n    /// @notice Emitted when a cool down ends\n    event CoolDownEnded(address account);\n\n    /// @notice Emitted when cool down time is updated\n    event GlobalCoolDownUpdated(uint256 newCoolDownTimeSeconds);\n\n    /// @notice Constructor sets immutable contract addresses\n    constructor(\n        IVault _balancerVault,\n        bytes32 _noteETHPoolId,\n        ERC20 _note,\n        ERC20 _weth\n    ) initializer { \n        // Validate that the pool exists\n        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);\n        require(poolAddress != address(0));\n\n        WETH = _weth;\n        NOTE = _note;\n        NOTE_ETH_POOL_ID = _noteETHPoolId;\n        BALANCER_VAULT = _balancerVault;\n        BALANCER_POOL_TOKEN = ERC20(poolAddress);\n    }\n\n    /// @notice Initializes sNOTE ERC20 metadata and owner\n    function initialize(\n        address _owner,\n        uint32 _coolDownTimeInSeconds\n    ) external initializer {\n        string memory _name = \"Staked NOTE\";\n        string memory _symbol = \"sNOTE\";\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        owner = _owner;\n        NOTE.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /** Governance Methods **/\n\n    /// @notice Authorizes the DAO to upgrade this contract\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /// @notice Updates the required cooldown time to redeem\n    function setCoolDownTime(uint32 _coolDownTimeInSeconds) external onlyOwner {\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        emit GlobalCoolDownUpdated(_coolDownTimeInSeconds);\n    }\n\n    /// @notice Allows the DAO to extract up to 50% of the BPT tokens during a collateral shortfall event\n    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n        // revert here since there may be a delay between when governance issues the token amount and when\n        // the withdraw actually occurs.\n        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[0] = 0;\n        minAmountsOut[1] = 0;\n\n        BALANCER_VAULT.exitPool(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            payable(owner), // Owner will receive the NOTE and WETH\n            IVault.ExitPoolRequest(\n                assets,\n                minAmountsOut,\n                abi.encode(\n                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n    }\n\n    /// @notice Allows the DAO to set the swap fee on the BPT\n    function setSwapFeePercentage(uint256 swapFeePercentage) external onlyOwner {\n        IWeightedPool(address(BALANCER_POOL_TOKEN)).setSwapFeePercentage(swapFeePercentage);\n    }\n\n    /** User Methods **/\n\n    /// @notice Mints sNOTE from the underlying BPT token.\n    /// @param bptAmount is the amount of BPT to transfer from the msg.sender.\n    function mintFromBPT(uint256 bptAmount) external nonReentrant {\n        // _mint logic requires that tokens are transferred first\n        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount);\n        _mint(msg.sender, bptAmount);\n    }\n\n    /// @notice Mints sNOTE from some amount of NOTE tokens.\n    /// @param noteAmount amount of NOTE to transfer into the sNOTE contract\n    function mintFromNOTE(uint256 noteAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = 0;\n        maxAmountsIn[1] = noteAmount;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of ETH\n    function mintFromETH() payable external nonReentrant {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = msg.value;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of WETH\n    /// @param wethAmount amount of WETH to transfer into the sNOTE contract\n    function mintFromWETH(uint256 wethAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        WETH.safeTransferFrom(msg.sender, address(this), wethAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = wethAmount;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    function _mintFromAssets(IAsset[] memory assets, uint256[] memory maxAmountsIn) internal {\n        uint256 bptBefore = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // Set msgValue when joining via ETH\n        uint256 msgValue = assets[0] == IAsset(address(0)) ? maxAmountsIn[0] : 0;\n\n        BALANCER_VAULT.joinPool{value: msgValue}(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            address(this), // sNOTE will receive the BPT\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(\n                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    maxAmountsIn,\n                    0 // Accept however much BPT the pool will give us\n                ),\n                false // Don't use internal balances\n            )\n        );\n        uint256 bptAfter = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Balancer pool token amounts must increase\n        _mint(msg.sender, bptAfter - bptBefore);\n    }\n\n    /// @notice Begins a cool down period for the sender, this is required to redeem tokens\n    function startCoolDown() external {\n        // Cannot start a cool down if there is already one in effect\n        _requireAccountNotInCoolDown(msg.sender);\n        uint256 redeemWindowBegin = block.timestamp + coolDownTimeInSeconds;\n        uint256 redeemWindowEnd = redeemWindowBegin + REDEEM_WINDOW_SECONDS;\n\n        accountCoolDown[msg.sender] = AccountCoolDown(_safe32(redeemWindowBegin), _safe32(redeemWindowEnd));\n\n        emit CoolDownStarted(msg.sender, redeemWindowBegin, redeemWindowEnd);\n    }\n\n    /// @notice Stops a cool down for the sender\n    function stopCoolDown() public {\n        // Reset the cool down back to zero so that the account must initiate it again to redeem\n        delete accountCoolDown[msg.sender];\n        emit CoolDownEnded(msg.sender);\n    }\n\n    /// @notice Redeems some amount of sNOTE to underlying BPT tokens (which can then be sold for\n    /// NOTE or ETH). An account must have passed its cool down expiration before they can redeem\n    /// @param sNOTEAmount amount of sNOTE to redeem\n    function redeem(uint256 sNOTEAmount) external nonReentrant {\n        AccountCoolDown memory coolDown = accountCoolDown[msg.sender];\n        require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");\n        require(\n            coolDown.redeemWindowBegin != 0 &&\n            coolDown.redeemWindowBegin < block.timestamp &&\n            block.timestamp < coolDown.redeemWindowEnd,\n            \"Not in Redemption Window\"\n        );\n\n        uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);\n        _burn(msg.sender, bptToRedeem);\n\n        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);\n    }\n\n    /** External View Methods **/\n\n    /// @notice Returns how many Balancer pool tokens an sNOTE token amount has a claim on\n    function getPoolTokenShare(uint256 sNOTEAmount) public view returns (uint256 bptClaim) {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // BPT and sNOTE are both in 18 decimal precision so no conversion required\n        return (bptBalance * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Returns the pool token share of a specific account\n    function poolTokenShareOf(address account) public view returns (uint256 bptClaim) {\n        return getPoolTokenShare(balanceOf(account));\n    }\n\n    /// @notice Calculates voting power for a given amount of sNOTE\n    /// @param sNOTEAmount amount of sNOTE to calculate voting power for\n    /// @return corresponding NOTE voting power\n    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n        // Gets the BPT token price (in ETH)\n        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n        // Gets the NOTE token price (in ETH)\n        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n        \n        // Since both bptPrice and notePrice are denominated in ETH, we can use\n        // this formula to calculate noteAmount\n        // bptBalance * bptPrice = notePrice * noteAmount\n        // noteAmount = bptPrice/notePrice * bptBalance\n        uint256 priceRatio = bptPrice * 1e18 / notePrice;\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n        uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n        // Reduce precision down to 1e8 (NOTE token)\n        // priceRatio and bptBalance are both 1e18 (1e36 total)\n        // we divide by 1e28 to get to 1e8\n        noteAmount /= 1e28;\n\n        return (noteAmount * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Calculates voting power for a given account\n    /// @param account a given sNOTE holding account\n    /// @return corresponding NOTE voting power\n    function votingPowerOf(address account) external view returns (uint256) {\n        return getVotingPower(balanceOf(account));\n    }\n\n    /** Internal Methods **/\n\n    function _requireAccountNotInCoolDown(address account) internal view {\n        AccountCoolDown memory coolDown = accountCoolDown[account];\n        // An account is in cool down if the redeem window has begun and the window end has not\n        // passed yet.\n        bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);\n        require(!isInCoolDown, \"Account in Cool Down\");\n    }\n\n    /// @notice Burns sNOTE tokens when they are redeemed\n    /// @param account account to burn tokens on\n    /// @param bptToRedeem the number of BPT tokens being redeemed by the account\n    function _burn(address account, uint256 bptToRedeem) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        uint256 poolTokenShare = poolTokenShareOf(account);\n        require(bptToRedeem <= poolTokenShare, \"Invalid Redeem Amount\");\n\n        // Burns the portion of the sNOTE corresponding to the bptToRedeem\n        uint256 sNOTEToBurn = balanceOf(account) * bptToRedeem / poolTokenShare;\n        // Handles event emission, balance update and total supply update\n        super._burn(account, sNOTEToBurn);\n    }\n\n    /// @notice Mints sNOTE tokens given a bptAmount\n    /// @param account account to mint tokens to\n    /// @param bptAmount the number of BPT tokens being minted by the account\n    function _mint(address account, uint256 bptAmount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Cannot mint if a cooldown is already in effect. If an account mints during a cool down period then they will\n        // be able to redeem the tokens immediately, bypassing the cool down.\n        _requireAccountNotInCoolDown(account);\n\n        // Immediately after minting, we need to satisfy the equality:\n        // (sNOTEToMint * bptBalance) / (totalSupply + sNOTEToMint) == bptAmount\n\n        // Rearranging to get sNOTEToMint on one side:\n        // (sNOTEToMint * bptBalance) = (totalSupply + sNOTEToMint) * bptAmount\n        // (sNOTEToMint * bptBalance) = totalSupply * bptAmount + sNOTEToMint * bptAmount\n        // (sNOTEToMint * bptBalance) - (sNOTEToMint * bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint * (bptBalance - bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint = (totalSupply * bptAmount) / (bptBalance - bptAmount)\n\n        // NOTE: at this point the BPT has already been transferred into the sNOTE contract, so this\n        // bptBalance amount includes bptAmount.\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 sNOTEToMint;\n        if (_totalSupply == 0) {\n            sNOTEToMint = bptAmount;\n        } else {\n            sNOTEToMint = (_totalSupply * bptAmount) / (bptBalance - bptAmount);\n        }\n\n        // Handles event emission, balance update and total supply update\n        super._mint(account, sNOTEToMint);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable) {\n        // Cannot send or receive tokens if a cool down is in effect or else accounts\n        // can bypass the cool down. It's not clear if sending tokens can be used to bypass\n        // the cool down but we restrict it here anyway, there's no clear use case for sending\n        // sNOTE tokens during a cool down.\n        if (to != address(0)) {\n            // Run these checks only when we are not burning tokens. (OZ ERC20 does not allow transfers\n            // to address(0), to == address(0) only when _burn is called).\n            _requireAccountNotInCoolDown(from);\n            _requireAccountNotInCoolDown(to);\n        }\n\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Moves sNOTE checkpoints\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _safe32(uint256 x) internal pure returns (uint32) {\n        require (x <= type(uint32).max);\n        return uint32(x);\n    }\n}\n\n",
        "CodeNames": [
            "sNOTE.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nBALANCER_VAULT.joinPool{value: msgValue}(\n    NOTE_ETH_POOL_ID,\n    address(this),\n    address(this), // sNOTE will receive the BPT\n    IVault.JoinPoolRequest(\n        assets,\n        maxAmountsIn,\n        abi.encode(\n            IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            maxAmountsIn,\n            0 // Accept however much BPT the pool will give us\n        ),\n        false // Don't use internal balances\n    )\n);\n"
                ],
                "Type": "  sNOTE.sol#_mintFromAssets()  Lack of slippage control",
                "Description": "\nhttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209\n\nsolidity\nBALANCER_VAULT.joinPool{value: msgValue}(\n    NOTE_ETH_POOL_ID,\n    address(this),\n    address(this), // sNOTE will receive the BPT\n    IVault.JoinPoolRequest(\n        assets,\n        maxAmountsIn,\n        abi.encode(\n            IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            maxAmountsIn,\n            0 // Accept however much BPT the pool will give us\n        ),\n        false // Don't use internal balances\n    )\n);\n\n\nThe current implementation of mintFromNOTE() and mintFromETH() and mintFromWETH() (all are using _mintFromAssets() with minimumBPT hardcoded to 0) provides no parameter for slippage control, making it vulnerable to front-run attacks.\n\n",
                "Repair": "\nConsider adding a minAmountOut parameter for these functions.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2022-01-notional-findings/issues/181)\n\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/181#issuecomment-1037991707):\n  Great find, slippage should be configurable and not hardcoded to 0.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "coolDownTimeInSeconds"
                ],
                "Type": " No upper limit on  coolDownTimeInSeconds  allows funds to be locked sNOTE owner",
                "Description": "\nInability for sNOTE holders to exit the pool in the case of ownership over SNOTE contract being compromised/malicious.\n\n\nsNOTE works on a stkAAVE model where users have to wait a set cooldown period before being able to reclaim the underlying tokens. This cooldown period can be set to an arbitrary uint32 value in seconds by the owner of the sNOTE contract.\n\n<https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L94-L97\n\nBelow in the startCooldown() function, it's possible for the owner of the sNOTE contract to choose a value for coolDownTimeInSeconds which always causes this function to revert (_safe32 will always revert if coolDownTimeInSeconds = type(uint32).max).\n\n<https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L217-L226\n\nShould ownership over sNOTE become compromised then all of the users' assets may be locked indefinitely.\n\n",
                "Repair": "\nProvide a sensible upper limit to coolDownTimeInSeconds of, say, a month. This will give plenty of time for NOTE governance to withdraw funds in the event of a shortfall while giving confidence that a user's funds can't be locked forever.\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/40#issuecomment-1039169763):\n  Valid concern. I was thinking if this should be left as of medium or low severity, but decided this time in favor of wardens:\n _\"Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\"_\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [
                    "extractTokensForCollateralShortfall()"
                ],
                "Type": " MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced",
                "Description": "\nThe function extractTokensForCollateralShortfall() allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.\n\nPresumably, this 50% limit is in place to prevent the owner from \"rug-pulling\" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).\n\nHowever, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.\n\nAs the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk users may lose value not from an exploit, but from the lack of enforcing the 50% rule)\n\n\nSee above.\nThe code affected is here: <https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100\n\n",
                "Repair": "\nRewrite the logic and enforce a limit during a time period i.e. do not allow to withdraw over 50% *per week* (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2022-01-notional-findings/issues/209)\n\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/209#issuecomment-1040141667):\n  Great find, 50% withdrawal limit can be bypassed by invoking the function multiple times.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n    uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n    uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n    // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n    // revert here since there may be a delay between when governance issues the token amount and when\n    // the withdraw actually occurs.\n    uint256 bptExitAmount = requestedWithdraw  maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n    IAsset[] memory assets = new IAsset[(2);\n    assets[0] = IAsset(address(WETH));\n    assets[1] = IAsset(address(NOTE));\n    uint256[] memory minAmountsOut = new uint256[(2);\n    minAmountsOut[0] = 0;\n    minAmountsOut[1] = 0;\n\n    BALANCER_VAULT.exitPool(\n        NOTE_ETH_POOL_ID,\n        address(this),\n        payable(owner), // Owner will receive the NOTE and WETH\n        IVault.ExitPoolRequest(\n            assets,\n            minAmountsOut,\n            abi.encode(\n                IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                bptExitAmount\n            ),\n            false // Don't use internal balances\n        )\n    );\n}\n"
                ],
                "Type": "  sNOTE  Holders Are Not Incetivized To Vote On Proposals To Call  extractTokensForCollateralShortfall ",
                "Description": "\nAs sNOTE have governance voting rights equivalent to the token amount in NOTE, users who stake their NOTE are also able to vote on governance proposals. In the event a majority of NOTE is staked in the sNOTE contract, it doesn't seem likely that stakers would be willing to vote on a proposal which liquidates a portion of their staked position.\n\nHence, the protocol may be put into a state where stakers are unwilling to vote on a proposal to call extractTokensForCollateralShortfall, leaving Notional insolvent as stakers continue to dump their holdings.\n\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L99-L129\nsolidity\nfunction extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n    uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n    uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n    // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n    // revert here since there may be a delay between when governance issues the token amount and when\n    // the withdraw actually occurs.\n    uint256 bptExitAmount = requestedWithdraw  maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n    IAsset[] memory assets = new IAsset[(2);\n    assets[0] = IAsset(address(WETH));\n    assets[1] = IAsset(address(NOTE));\n    uint256[] memory minAmountsOut = new uint256[(2);\n    minAmountsOut[0] = 0;\n    minAmountsOut[1] = 0;\n\n    BALANCER_VAULT.exitPool(\n        NOTE_ETH_POOL_ID,\n        address(this),\n        payable(owner), // Owner will receive the NOTE and WETH\n        IVault.ExitPoolRequest(\n            assets,\n            minAmountsOut,\n            abi.encode(\n                IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                bptExitAmount\n            ),\n            false // Don't use internal balances\n        )\n    );\n}\n\n\n",
                "Repair": "\nConsider redesigning this mechanism to better align stakers with the health of the protocol. It might be useful to allocate a percentage of generated fees to an insurance fund which will be used to cover any collateral shortfall events. This fund can be staked to generate additional yield.\n\njeffywu (Notional) acknowledged and commented(https://github.com/code-423n4/2022-01-notional-findings/issues/229#issuecomment-1030839281):\n  Acknowledged, however, there are technical difficulties with programmatic collateral shortfall detection at this moment. We will look to develop a method that allows for programmatic detection in the future (these issues have been discussed with the warden).\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/229#issuecomment-1041536723):\n  A hypothetical but valid concern.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n    // Gets the BPT token price (in ETH)\n    uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n    // Gets the NOTE token price (in ETH)\n    uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n    \n    // Since both bptPrice and notePrice are denominated in ETH, we can use\n    // this formula to calculate noteAmount\n    // bptBalance * bptPrice = notePrice * noteAmount\n    // noteAmount = bptPrice/notePrice * bptBalance\n    uint256 priceRatio = bptPrice * 1e18 / notePrice;\n    uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n    // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n    uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n    // Reduce precision down to 1e8 (NOTE token)\n    // priceRatio and bptBalance are both 1e18 (1e36 total)\n    // we divide by 1e28 to get to 1e8\n    noteAmount /= 1e28;\n\n    return (noteAmount * sNOTEAmount) / totalSupply();\n}\n"
                ],
                "Type": "  getVotingPower  Is Not Equipped To Handle On-Chain Voting",
                "Description": "\nAs NOTE continues to be staked in the sNOTE contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power sNOTE has in terms of its equivalent NOTE amount.\n\ngetVotingPower is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their sNOTE to another account to then vote again.\n\n\n<https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293\nsolidity\nfunction getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n    // Gets the BPT token price (in ETH)\n    uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n    // Gets the NOTE token price (in ETH)\n    uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n    \n    // Since both bptPrice and notePrice are denominated in ETH, we can use\n    // this formula to calculate noteAmount\n    // bptBalance * bptPrice = notePrice * noteAmount\n    // noteAmount = bptPrice/notePrice * bptBalance\n    uint256 priceRatio = bptPrice * 1e18 / notePrice;\n    uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n    // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n    uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n    // Reduce precision down to 1e8 (NOTE token)\n    // priceRatio and bptBalance are both 1e18 (1e36 total)\n    // we divide by 1e28 to get to 1e8\n    noteAmount /= 1e28;\n\n    return (noteAmount * sNOTEAmount) / totalSupply();\n}\n\n\n",
                "Repair": "\nConsider implementing a getPriorVotingPower function which takes in a blockNumber argument and returns the correct balance at that specific block.\n\njeffywu (Notional) confirmed(https://github.com/code-423n4/2022-01-notional-findings/issues/165)\n\n\npauliax (judge) commented(https://github.com/code-423n4/2022-01-notional-findings/issues/165#issuecomment-1041539604):\n  Great find, voting power snapshots would also make the system more resilient to manipulation, e.g. by using flashloans.\n\n\n\n*\n\n\n"
            }
        ]
    }
]