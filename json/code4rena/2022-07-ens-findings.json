[
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/* This contract is a variation on ERC1155 with the additions of _setData, getData and _canTransfer and ownerOf. _setData and getData allows the use of the other 96 bits next to the address of the owner for extra data. We use this to store 'fuses' that control permissions that can be burnt. 32 bits are used for the fuses themselves and 64 bits are used for the expiry of the name. When a name has expired, its fuses will be be set back to 0 */\n\nerror OperationProhibited(bytes32 node);\n\nabstract contract ERC1155Fuse is ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => uint256) public _tokens;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**************************************************************************\n     * ERC721 methods\n     *************************************************************************/\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        (address owner, , ) = getData(id);\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        (address owner, , ) = getData(id);\n        if (owner == account) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev Returns the Name's owner address and fuses\n     */\n    function getData(uint256 tokenId)\n        public\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64 expiry\n        )\n    {\n        uint256 t = _tokens[tokenId];\n        owner = address(uint160(t));\n        expiry = uint64(t >> 192);\n        if (block.timestamp > expiry) {\n            fuses = 0;\n        } else {\n            fuses = uint32(t >> 160);\n        }\n    }\n\n    /**\n     * @dev Sets the Name's owner address and fuses\n     */\n    function _setData(\n        uint256 tokenId,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        _tokens[tokenId] =\n            uint256(uint160(owner)) |\n            (uint256(fuses) << 160) |\n            (uint256(expiry) << 192);\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            (address oldOwner, uint32 fuses, uint64 expiration) = getData(id);\n\n            if (!_canTransfer(fuses)) {\n                revert OperationProhibited(bytes32(id));\n            }\n\n            require(\n                amount == 1 && oldOwner == from,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _setData(id, to, fuses, expiration);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**************************************************************************\n     * Internal/private methods\n     *************************************************************************/\n\n    function _canTransfer(uint32 fuses) internal virtual returns (bool);\n\n    function _mint(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        uint256 tokenId = uint256(node);\n        address owner = ownerOf(tokenId);\n        require(owner == address(0), \"ERC1155: mint of existing token\");\n        require(newOwner != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            newOwner != address(this),\n            \"ERC1155: newOwner cannot be the NameWrapper contract\"\n        );\n\n        _setData(tokenId, newOwner, fuses, expiry);\n        emit TransferSingle(msg.sender, address(0x0), newOwner, tokenId, 1);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            newOwner,\n            tokenId,\n            1,\n            \"\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n        // Clear fuses and set owner to 0\n        _setData(tokenId, address(0x0), 0, 0);\n        emit TransferSingle(msg.sender, owner, address(0x0), tokenId, 1);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\n        if (oldOwner == to) {\n            return;\n        }\n\n        if (!_canTransfer(fuses)) {\n            revert OperationProhibited(bytes32(id));\n        }\n\n        require(\n            amount == 1 && oldOwner == from,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        _setData(id, to, fuses, expiry);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver(to).onERC1155Received.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant PARENT_CANNOT_CONTROL = 64;\nuint32 constant CAN_DO_EVERYTHING = 0;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 _expiry,\n        address resolver\n    ) external returns (uint64 expiry);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration,\n        uint64 expiry\n    ) external returns (uint256 expires);\n\n    function unwrap(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function setFuses(bytes32 node, uint32 fuses)\n        external\n        returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        external\n        returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external returns (address owner);\n\n    function getFuses(bytes32 node)\n        external\n        returns (uint32 fuses, uint64 expiry);\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        external\n        view\n        returns (bool);\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\n\n",
        "CodeNames": [
            "ERC1155Fuse.sol",
            "BaseRegistrarImplementation.sol",
            "INameWrapper.sol",
            "NameWrapper.sol",
            "ENS.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "_transferAndBurnFuses",
                    "onERC",
                    "setSubnodeRecord",
                    "setSubnodeOwner",
                    "PARENT_CANNOT_CONTROL",
                    "ERC"
                ],
                "Type": " It is possible to create fake ERC1155  NameWrapper  token for subdomain, which is not owned by  NameWrapper ",
                "Description": "*Submitted by panprog, also found by Aussie_Battlers, brgltd, cryptphi, peritoflores, and wastewa*\n\nNameWrapper.sol#L820-L821(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821)<br\nNameWrapper.sol#L524(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524)<br\nNameWrapper.sol#L572(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572)<br\n\nDue to re-entrancy possibility in NameWrapper._transferAndBurnFuses (called from setSubnodeOwner and setSubnodeRecord), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.\n\nFake token creation scenario:\n\n1.  Account1 registers and wraps test.eth domain\n2.  Account1 calls NameWrapper.setSubnodeOwner for sub.test.eth subdomain with Account1 as owner (to make NameWrapper owner of subdomain)\n3.  Contract1 smart contract is created, which calls unwrap in its onERC1155Received function, and a function to send sub.test.eth ERC1155 NameWrapper token back to Account1\n4.  Account1 calls NameWrapper.setSubnodeOwner for sub.test.eth with Contract1 as new owner, which unwraps domain back to Account1 but due to re-entrancy, NameWrapper sets fuses and ownership to Contract1\n5.  Account1 calls function to send ERC1155 token from Contract1 back to self.\n\nAfter this sequence of events, sub.test.eth subdomain is owned by Account1 both in ENS registry and in NameWrapper (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in NameWrapper will fail to execute for this subdomain, because they expect NameWrapper to have ownership of the domain in ENS, but some functions will still work, making it possible to make the impression of good domain.\n\nAt this point, ownership in NameWrapper is \"detached\" from ownership in ENS and Account1 can do all kinds of malcious stuff with its ERC1155 token. For example:\n\n1.  Sell subdomain to the other user, transfering ERC1155 to that user and burning PARENT_CANNOT_CONTROL to create impression that he can't control the domain. After receiving the payment, Account1 can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and Account1 ownership, effectively stealing domain back from unsuspecting user, who thought that ERC1155 gives him the right to the domain (and didn't expect that parent can clear fuses when PARENT_CANNOT_CONTROL is set).\n\n2.  Transfer subdomain to some other smart contract, which implements onERC1155Received, then take it back, fooling smart contract into believing that it has received the domain.\n\n\nCopy these to test/wrapper and run:<br\nyarn test test/wrapper/NameWrapperReentrancy.js\n\n<https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e\n\n",
                "Repair": "\nConsider adding nonReentrant modifiers with ReentrancyGuard implementation from openzeppelin. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving ERC1155 data and requiring it to match the data after transfer (restricting onERC1155Received to not change any data for the token received):\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        uint32 curFuses;\n        uint64 curExpiry;\n        (owner, curFuses, curExpiry) = getData(uint256(node));\n        require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\nArachnid (ENS) confirmed(https://github.com/code-423n4/2022-07-ens-findings/issues/84)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}\n\n\npragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\n        uint shortest = len;\n        if (otherlen < len)\n        shortest = otherlen;\n\n        uint selfptr;\n        uint otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                int diff = int(a & mask) - int(b & mask);\n                if (diff != 0)\n                return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int(len) - int(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)),  mask)\n        }\n    }\n\n    function memcpy(uint dest, uint src, uint len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint dest;\n        uint src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\n        require(len <= 52);\n\n        uint ret = 0;\n        uint8 decoded;\n        for(uint i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if(i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint bitlen = len * 5;\n        if(len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if(len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if(len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if(len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if(len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at \n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {\n        for(uint256 idx = off; idx < off + len; idx++) {\n            if(self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant PARENT_CANNOT_CONTROL = 64;\nuint32 constant CAN_DO_EVERYTHING = 0;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 _expiry,\n        address resolver\n    ) external returns (uint64 expiry);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration,\n        uint64 expiry\n    ) external returns (uint256 expires);\n\n    function unwrap(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function setFuses(bytes32 node, uint32 fuses)\n        external\n        returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        external\n        returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external returns (address owner);\n\n    function getFuses(bytes32 node)\n        external\n        returns (uint32 fuses, uint64 expiry);\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        external\n        view\n        returns (bool);\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\n\n",
        "CodeNames": [
            "BaseRegistrarImplementation.sol",
            "BytesUtils.sol",
            "INameWrapper.sol",
            "NameWrapper.sol",
            "ENS.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction _getDataAndNormaliseExpiry(\n    bytes32 parentNode,\n    bytes32 node,\n    uint64 expiry\n)\n    internal\n    view\n    returns (\n        address owner,\n        uint32 fuses,\n        uint64\n    )\n{\n    uint64 oldExpiry;\n    (owner, fuses, oldExpiry) = getData(uint256(node));\n    (, , uint64 maxExpiry) = getData(uint256(parentNode));\n    expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n    return (owner, fuses, expiry);\n}\n"
                ],
                "Type": " The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy",
                "Description": "*Submitted by PwnedNoMore*\n\nNameWrapper.sol#L504(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504)<br\nNameWrapper.sol#L356(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356)<br\n\nBy design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.\n\nWhen a parent node tries to setSubnodeOwner / setSubnodeRecord, the following code is used to guarantee that the new expiry can only be extended up to the current one.\n\nsolidity\nfunction _getDataAndNormaliseExpiry(\n    bytes32 parentNode,\n    bytes32 node,\n    uint64 expiry\n)\n    internal\n    view\n    returns (\n        address owner,\n        uint32 fuses,\n        uint64\n    )\n{\n    uint64 oldExpiry;\n    (owner, fuses, oldExpiry) = getData(uint256(node));\n    (, , uint64 maxExpiry) = getData(uint256(parentNode));\n    expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n    return (owner, fuses, expiry);\n}\n\n\nHowever, the problem shows when\n\n*   The sub-domain (e.g., sub1.base.eth) has its own sub-sub-domain (e.g., sub2.sub1.base.eth)\n*   The sub-domain is unwrapped later, and thus its oldExpiry becomes zero.\n*   When base.eth calls NameWrapper.setSubnodeOwner, there is not constraint of sub1.base.eth's expiry, since oldExpiry == 0. As a result, the new expiry of sub1.base.eth can be arbitrary and smaller than the one of sub2.sub1.base.eth\n\nThe point here is that the oldExpiry will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.\n\nSpecifically, considering the following scenario\n\n*   The hacker owns a domain (or a 2LD), e.g., base.eth\n*   The hacker assigns a sub-domain to himself, e.g., sub1.base.eth\n    *   The expiry should be as large as possible\n*   Hacker assigns a sub-sub-domain, e.g., sub2.sub1.base.eth\n    *   The expiry should be as large as possible\n*   The hacker unwraps his sub-domain, i.e., sub1.base.eth\n*   The hacker re-wraps his sub-domain via NameWrapper.setSubnodeOwner\n    *   The expiry can be small than the one of sub2.sub1.base.eth\n\nThe root cause *seems* that we should not zero out the expiry when burning a node if the node holds any subnode.\n\n\n*   Potential fix 1: auto-burn CANNOT_UNWRAP which thus lets expiry decide whether a node can be unwrapped.\n*   Potential fix 2: force the parent to have CANNOT_UNWRAP burnt if they want to set expiries on a child via setSubnodeOwner / setSubnodeRecord / setChildFuses\n\n\nFor full details, please see original warden submission(https://github.com/code-423n4/2022-07-ens-findings/issues/187).\n\nArachnid (ENS) confirmed(https://github.com/code-423n4/2022-07-ens-findings/issues/187)\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant PARENT_CANNOT_CONTROL = 64;\nuint32 constant CAN_DO_EVERYTHING = 0;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 _expiry,\n        address resolver\n    ) external returns (uint64 expiry);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration,\n        uint64 expiry\n    ) external returns (uint256 expires);\n\n    function unwrap(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function setFuses(bytes32 node, uint32 fuses)\n        external\n        returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        external\n        returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external returns (address owner);\n\n    function getFuses(bytes32 node)\n        external\n        returns (uint32 fuses, uint64 expiry);\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        external\n        view\n        returns (bool);\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC1155Fuse.sol\";\nimport \"./Controllable.sol\";\nimport \"./INameWrapper.sol\";\nimport \"./INameWrapperUpgrade.sol\";\nimport \"./IMetadataService.sol\";\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BytesUtil.sol\";\n\nerror Unauthorised(bytes32 node, address addr);\nerror NameNotFound();\nerror IncompatibleParent();\nerror IncompatibleName(bytes name);\nerror IncorrectTokenType();\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\nerror LabelTooShort();\nerror LabelTooLong(string label);\nerror IncorrectTargetOwner(address owner);\nerror CannotUpgrade();\nerror InvalidExpiry(bytes32 node, uint64 expiry);\n\ncontract NameWrapper is\n    Ownable,\n    ERC1155Fuse,\n    INameWrapper,\n    Controllable,\n    IERC721Receiver\n{\n    using BytesUtils for bytes;\n    ENS public immutable override ens;\n    IBaseRegistrar public immutable override registrar;\n    IMetadataService public override metadataService;\n    mapping(bytes32 => bytes) public override names;\n\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 private constant ROOT_NODE =\n        0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    //A contract address to a new upgraded contract if any\n    INameWrapperUpgrade public upgradeContract;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    constructor(\n        ENS _ens,\n        IBaseRegistrar _registrar,\n        IMetadataService _metadataService\n    ) {\n        ens = _ens;\n        registrar = _registrar;\n        metadataService = _metadataService;\n\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */\n\n        _setData(\n            uint256(ETH_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        _setData(\n            uint256(ROOT_NODE),\n            address(0),\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\n            MAX_EXPIRY\n        );\n        names[ROOT_NODE] = \"\\x00\";\n        names[ETH_NODE] = \"\\x03eth\\x00\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Fuse, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INameWrapper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /* ERC1155 */\n\n    function ownerOf(uint256 id)\n        public\n        view\n        override(ERC1155Fuse, INameWrapper)\n        returns (address owner)\n    {\n        return super.ownerOf(id);\n    }\n\n    /* Metadata service */\n\n    /**\n     * @notice Set the metadata service. Only the owner can do this\n     */\n\n    function setMetadataService(IMetadataService _newMetadataService)\n        public\n        onlyOwner\n    {\n        metadataService = _newMetadataService;\n    }\n\n    /**\n     * @notice Get the metadata uri\n     * @return String uri of the metadata service\n     */\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return metadataService.uri(tokenId);\n    }\n\n    /**\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\n     * to make the contract not upgradable.\n     * @param _upgradeAddress address of an upgraded contract\n     */\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)\n        public\n        onlyOwner\n    {\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), false);\n            ens.setApprovalForAll(address(upgradeContract), false);\n        }\n\n        upgradeContract = _upgradeAddress;\n\n        if (address(upgradeContract) != address(0)) {\n            registrar.setApprovalForAll(address(upgradeContract), true);\n            ens.setApprovalForAll(address(upgradeContract), true);\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is the owner or approved by the owner of a name\n     * @param node namehash of the name to check\n     */\n\n    modifier onlyTokenOwner(bytes32 node) {\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks if owner or approved by owner\n     * @param node namehash of the name to check\n     * @param addr which address to check permissions for\n     * @return whether or not is owner or approved\n     */\n\n    function isTokenOwnerOrApproved(bytes32 node, address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(uint256(node));\n        return owner == addr || isApprovedForAll(owner, addr);\n    }\n\n    /**\n     * @notice Gets fuse permissions for a specific name\n     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit\n     *      The interface has predefined fuses for all registry permissions, but additional\n     *      fuses can be added for other use cases\n     *      Also returns expiry, which is when the fuses are set to expire.\n     * @param node namehash of the name to check\n     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp\n     * @return expiry Unix time of when the name expires and fuses are to expire\n     */\n    function getFuses(bytes32 node)\n        public\n        view\n        override\n        returns (uint32 fuses, uint64 expiry)\n    {\n        (, fuses, expiry) = getData(uint256(node));\n        if (fuses == 0 && expiry == 0) {\n            bytes memory name = names[node];\n            if (name.length == 0) {\n                revert NameNotFound();\n            }\n        }\n    }\n\n    /**\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\n     * @param label label as a string of the .eth domain to wrap\n     * @param wrappedOwner Owner of the name in this contract\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @param resolver resolver contract address\n     */\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public override returns (uint64) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        address registrant = registrar.ownerOf(tokenId);\n        if (\n            registrant != msg.sender &&\n            !isApprovedForAll(registrant, msg.sender) &&\n            !registrar.isApprovedForAll(registrant, msg.sender)\n        ) {\n            revert Unauthorised(\n                _makeNode(ETH_NODE, bytes32(tokenId)),\n                msg.sender\n            );\n        }\n\n        // transfer the token from the user to this contract\n        registrar.transferFrom(registrant, address(this), tokenId);\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(tokenId, address(this));\n\n        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Registers a new .eth second-level domain and wraps it.\n     *      Only callable by authorised controllers.\n     * @param label The label to register (Eg, 'foo' for 'foo.eth').\n     * @param wrappedOwner The owner of the wrapped name.\n     * @param duration The duration, in seconds, to register the name for.\n     * @param resolver The resolver address to set on the ENS registry (optional).\n     * @param fuses initial fuses to set\n     * @param expiry when the fuses will expire\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\n     */\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint32 fuses,\n        uint64 expiry\n    ) external override onlyController returns (uint256 registrarExpiry) {\n        uint256 tokenId = uint256(keccak256(bytes(label)));\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\n        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);\n    }\n\n    /**\n     * @dev Renews a .eth second-level domain.\n     *      Only callable by authorised controllers.\n     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').\n     * @param duration The number of seconds to renew the name for.\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\n     */\n    function renew(\n        uint256 tokenId,\n        uint256 duration,\n        uint64 expiry\n    ) external override onlyController returns (uint256 expires) {\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\n\n        expires = registrar.renew(tokenId, duration);\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));\n\n        _setData(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\n     * @param name The name to wrap, in DNS format\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract address\n     */\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) public override {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n\n        address owner = ens.owner(node);\n\n        if (\n            owner != msg.sender &&\n            !isApprovedForAll(owner, msg.sender) &&\n            !ens.isApprovedForAll(owner, msg.sender)\n        ) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        ens.setOwner(node, address(this));\n\n        _wrap(node, name, wrappedOwner, 0, 0);\n    }\n\n    /**\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param labelhash labelhash of the .eth domain\n     * @param newRegistrant sets the owner in the .eth registrar to this address\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n        registrar.transferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n\n    /**\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param newController sets the owner in the registry to this address\n     */\n\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {\n        if (parentNode == ETH_NODE) {\n            revert IncompatibleParent();\n        }\n        _unwrap(_makeNode(parentNode, labelhash), newController);\n    }\n\n    /**\n     * @notice Sets fuses of a name\n     * @param node namehash of the name\n     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)\n     */\n\n    function setFuses(bytes32 node, uint32 fuses)\n        public\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_BURN_FUSES)\n        returns (uint32)\n    {\n        if (fuses & PARENT_CANNOT_CONTROL != 0) {\n            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\n            uint256(node)\n        );\n\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n        return fuses;\n    }\n\n    /**\n     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract\n     *     and burning the token of this contract\n     * @dev Can be called by the owner of the name in this contract\n     * @param label Label as a string of the .eth name to upgrade\n     * @param wrappedOwner The owner of the wrapped name\n     */\n\n    function upgradeETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n\n        upgradeContract.wrapETH2LD(\n            label,\n            wrappedOwner,\n            fuses,\n            expiry,\n            resolver\n        );\n    }\n\n    /**\n     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\n     * @dev Can be called by the owner or an authorised caller\n     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names\n     * @param parentNode namehash of the parent name\n     * @param label Label as a string of the name to upgrade\n     * @param wrappedOwner Owner of the name in this contract\n     * @param resolver resolver contract for this name\n     */\n\n    function upgrade(\n        bytes32 parentNode,\n        string calldata label,\n        address wrappedOwner,\n        address resolver\n    ) public {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);\n        upgradeContract.setSubnodeRecord(\n            parentNode,\n            label,\n            wrappedOwner,\n            resolver,\n            0,\n            fuses,\n            expiry\n        );\n    }\n\n    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name\n     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')\n     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')\n     * @param fuses fuses to burn\n     * @param expiry when the fuses will expire\n     */\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n        uint64 maxExpiry;\n        if (parentNode == ETH_NODE) {\n            if (!isTokenOwnerOrApproved(node, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n            // max expiry is set to the expiry on the registrar\n            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n        } else {\n            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {\n                revert Unauthorised(node, msg.sender);\n            }\n\n            // max expiry is set to the expiry of the parent\n            (, , maxExpiry) = getData(uint256(parentNode));\n        }\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\n        if (\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\n            oldFuses | fuses != oldFuses\n        ) {\n            revert OperationProhibited(node);\n        }\n        fuses |= oldFuses;\n        _setFuses(node, owner, fuses, expiry);\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry when the fuses will expire\n     */\n\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n        returns (bytes32 node)\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\n     * @param parentNode parent namehash of the subdomain\n     * @param label label of the subdomain as a string\n     * @param newOwner newOwner in the registry\n     * @param resolver resolver contract in the registry\n     * @param ttl ttl in the regsitry\n     * @param fuses initial fuses for the wrapped subdomain\n     * @param expiry expiry date for the domain\n     */\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    )\n        public\n        onlyTokenOwner(parentNode)\n        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))\n    {\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(parentNode, labelhash);\n        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);\n        if (ens.owner(node) != address(this)) {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);\n        } else {\n            ens.setSubnodeRecord(\n                parentNode,\n                labelhash,\n                address(this),\n                resolver,\n                ttl\n            );\n            _transferAndBurnFuses(node, newOwner, fuses, expiry);\n        }\n    }\n\n    /**\n     * @notice Sets records for the name in the ENS Registry\n     * @param node namehash of the name to set a record for\n     * @param owner newOwner in the registry\n     * @param resolver the resolver contract\n     * @param ttl ttl in the registry\n     */\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    )\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(\n            node,\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\n        )\n    {\n        ens.setRecord(node, address(this), resolver, ttl);\n        (address oldOwner, , ) = getData(uint256(node));\n        _transfer(oldOwner, owner, uint256(node), 1, \"\");\n    }\n\n    /**\n     * @notice Sets resolver contract in the registry\n     * @param node namehash of the name\n     * @param resolver the resolver contract\n     */\n\n    function setResolver(bytes32 node, address resolver)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_RESOLVER)\n    {\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @notice Sets TTL in the registry\n     * @param node namehash of the name\n     * @param ttl TTL in the registry\n     */\n\n    function setTTL(bytes32 node, uint64 ttl)\n        public\n        override\n        onlyTokenOwner(node)\n        operationAllowed(node, CANNOT_SET_TTL)\n    {\n        ens.setTTL(node, ttl);\n    }\n\n    /**\n     * @dev Allows an operation only if none of the specified fuses are burned.\n     * @param node The namehash of the name to check fuses on.\n     * @param fuseMask A bitmask of fuses that must not be burned.\n     */\n\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\n        (, uint32 fuses, ) = getData(uint256(node));\n        if (fuses & fuseMask != 0) {\n            revert OperationProhibited(node);\n        }\n        _;\n    }\n\n    /**\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\n     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\n     *      setSubnodeOwner\n     * @param node namehash of the name to check\n     * @param labelhash labelhash of the name to check\n     */\n\n    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {\n        bytes32 subnode = _makeNode(node, labelhash);\n        address owner = ens.owner(subnode);\n\n        if (owner == address(0)) {\n            (, uint32 fuses, ) = getData(uint256(node));\n            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {\n                revert OperationProhibited(node);\n            }\n        } else {\n            (, uint32 subnodeFuses, ) = getData(uint256(subnode));\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\n                revert OperationProhibited(node);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Checks all Fuses in the mask are burned for the node\n     * @param node namehash of the name\n     * @param fuseMask the fuses you want to check\n     * @return Boolean of whether or not all the selected fuses are burned\n     */\n\n    function allFusesBurned(bytes32 node, uint32 fuseMask)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (, uint32 fuses, ) = getData(uint256(node));\n        return fuses & fuseMask == fuseMask;\n    }\n\n    function onERC721Received(\n        address to,\n        address,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override returns (bytes4) {\n        //check if it's the eth registrar ERC721\n        if (msg.sender != address(registrar)) {\n            revert IncorrectTokenType();\n        }\n\n        (\n            string memory label,\n            address owner,\n            uint32 fuses,\n            uint64 expiry,\n            address resolver\n        ) = abi.decode(data, (string, address, uint32, uint64, address));\n\n        bytes32 labelhash = bytes32(tokenId);\n        bytes32 labelhashFromData = keccak256(bytes(label));\n\n        if (labelhashFromData != labelhash) {\n            revert LabelMismatch(labelhashFromData, labelhash);\n        }\n\n        // transfer the ens record back to the new owner (this contract)\n        registrar.reclaim(uint256(labelhash), address(this));\n\n        _wrapETH2LD(label, owner, fuses, expiry, resolver);\n\n        return IERC721Receiver(to).onERC721Received.selector;\n    }\n\n    /***** Internal functions */\n\n    function _canTransfer(uint32 fuses) internal pure override returns (bool) {\n        return fuses & CANNOT_TRANSFER == 0;\n    }\n\n    function _makeNode(bytes32 node, bytes32 labelhash)\n        private\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n\n    function _addLabel(string memory label, bytes memory name)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        if (bytes(label).length < 1) {\n            revert LabelTooShort();\n        }\n        if (bytes(label).length > 255) {\n            revert LabelTooLong(label);\n        }\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\n    }\n\n    function _mint(\n        bytes32 node,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal override {\n        address oldWrappedOwner = ownerOf(uint256(node));\n        _canFusesBeBurned(node, fuses);\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        super._mint(node, wrappedOwner, fuses, expiry);\n    }\n\n    function _wrap(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        names[node] = name;\n        _mint(node, wrappedOwner, fuses, expiry);\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\n    }\n\n    function _addLabelAndWrap(\n        bytes32 parentNode,\n        bytes32 node,\n        string memory label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        bytes memory name = _addLabel(label, names[parentNode]);\n        _wrap(node, name, newOwner, fuses, expiry);\n    }\n\n    function _prepareUpgrade(bytes32 node)\n        private\n        returns (uint32 fuses, uint64 expiry)\n    {\n        if (address(upgradeContract) == address(0)) {\n            revert CannotUpgrade();\n        }\n\n        if (!isTokenOwnerOrApproved(node, msg.sender)) {\n            revert Unauthorised(node, msg.sender);\n        }\n\n        (fuses, expiry) = getFuses(node);\n\n        // burn token and fuse data\n        _burn(uint256(node));\n    }\n\n    function _transferAndBurnFuses(\n        bytes32 node,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        (address owner, , ) = getData(uint256(node));\n        _transfer(owner, newOwner, uint256(node), 1, \"\");\n        _setFuses(node, newOwner, fuses, expiry);\n    }\n\n    // wrapper function for stack limit\n    function _getDataAndNormaliseExpiry(\n        bytes32 parentNode,\n        bytes32 node,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _getETH2LDDataAndNormaliseExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    )\n        internal\n        view\n        returns (\n            address owner,\n            uint32 fuses,\n            uint64\n        )\n    {\n        uint64 oldExpiry;\n        (owner, fuses, oldExpiry) = getData(uint256(node));\n        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));\n\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\n        return (owner, fuses, expiry);\n    }\n\n    function _normaliseExpiry(\n        uint64 expiry,\n        uint64 oldExpiry,\n        uint64 maxExpiry\n    ) internal pure returns (uint64) {\n        // Expiry cannot be more than maximum allowed\n        // .eth names will check registrar, non .eth check parent\n        if (expiry > maxExpiry) {\n            expiry = maxExpiry;\n        }\n        // Expiry cannot be less than old expiry\n        if (expiry < oldExpiry) {\n            expiry = oldExpiry;\n        }\n\n        return expiry;\n    }\n\n    function _wrapETH2LD(\n        string memory label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) private returns (uint64) {\n        // Mint a new ERC1155 token with fuses\n        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD\n        bytes32 labelhash = keccak256(bytes(label));\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\n\n        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(\n            node,\n            labelhash,\n            expiry\n        );\n\n        _addLabelAndWrap(\n            ETH_NODE,\n            node,\n            label,\n            wrappedOwner,\n            fuses | PARENT_CANNOT_CONTROL,\n            expiry\n        );\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n\n        return expiry;\n    }\n\n    function _unwrap(bytes32 node, address newOwner) private {\n        if (newOwner == address(0x0) || newOwner == address(this)) {\n            revert IncorrectTargetOwner(newOwner);\n        }\n\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\n            revert OperationProhibited(node);\n        }\n\n        // Burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\n\n    function _setFuses(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _setData(node, owner, fuses, expiry);\n        emit FusesSet(node, fuses, expiry);\n    }\n\n    function _setData(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal {\n        _canFusesBeBurned(node, fuses);\n        super._setData(uint256(node), owner, fuses, expiry);\n    }\n\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\n        if (\n            fuses & ~PARENT_CANNOT_CONTROL != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }\n    }\n}\n\n\npragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}\n\n\n",
        "CodeNames": [
            "INameWrapper.sol",
            "NameWrapper.sol",
            "BaseRegistrarImplementation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "expiry",
                    "wrap(victim",
                    "wrap",
                    "PARENT_CANNOT_CONTROL",
                    "CANNOT_UNWRAP"
                ],
                "Type": "  PARENT_CANNOT_CONTROL  can be bypassed by maliciously unwrapping parent node",
                "Description": "*Submitted by PwnedNoMore, also found by panprog, and zzzitron*\n\nNameWrapper.sol#L356(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356)<br\nNameWrapper.sol#L295(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295)<br\nENSRegistry.sol#L74(https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74)<br\n\nBy design, for any subdomain, as long as its PARENT_CANNOT_CONTROL fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.\n\nHowever, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking NameWrapper.wrap can rewrite the fuses and wrapper owner of the given subdoamin.\n\nConsidering the following attack scenario:\n\n*   Someone owns a domain (or a 2LD), e.g., *poc.eth*\n*   The domain owner assigns a sub-domain to the hacker, e.g., *hack.poc.eth*\n    *   This sub-domain should not burn CANNOT_UNWRAP\n    *   This sub-domain can burn PARENT_CANNOT_CONTROL\n*   Hacker assigns a sub-sub-domain to a victim user, e.g., *victim.hack.poc.eth*\n*   The victim user burns arbitrary fuses, including PARENT_CANNOT_CONTROL\n    *   The hacker should not be able to change the owner and the fuses of victim.hack.poc.eth ideally\n*   However, the hacker then unwraps his sub-domain, i.e., *hack.poc.eth*\n*   The hacker invokes ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim) on the sub-sub-domain\n    *   He can reassign himself as the owner of the *victim.hack.poc.eth*\n*   The hacker invokes NameWrapper.wrap(victim.hacker.poc.eth) to over-write the fuses and owner of the sub-sub-domain, i.e., *victim.hacker.poc.eth*\n\nThe root cause here is that, for any node, when one of its subdomains burns PARENT_CANNOT_CONTROL, the node itself fails to burn CANNOT_UNWRAP. Theoretically, this should check to the root, which however is very gas-consuming.\n\n\n*   Potential fix 1: auto-burn CANNOT_UNWRAP which thus lets expiry decide whether a node can be unwrapped.\n*   Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.\n\n\nFor full details, please see original warden submission(https://github.com/code-423n4/2022-07-ens-findings/issues/173).\n\nArachnid (ENS) confirmed(https://github.com/code-423n4/2022-07-ens-findings/issues/173)\n\n\n\n*\n\n \n\n",
                "Repair": ""
            }
        ]
    }
]