[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AdminMultisigBase is EternalStorage {\n    error NotAdmin();\n    error AlreadyVoted();\n    error InvalidAdmins();\n    error InvalidAdminThreshold();\n    error DuplicateAdmin(address admin);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');\n\n    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');\n    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');\n    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');\n    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');\n    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');\n    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');\n\n    modifier onlyAdmin() {\n        uint256 adminEpoch = _adminEpoch();\n\n        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();\n\n        bytes32 topic = keccak256(msg.data);\n\n        // Check that admin has not voted, then record that they have voted.\n        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();\n\n        _setHasVoted(adminEpoch, topic, msg.sender, true);\n\n        // Determine the new vote count and update it.\n        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);\n        _setVoteCount(adminEpoch, topic, adminVoteCount);\n\n        // Do not proceed with operation execution if insufficient votes.\n        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;\n\n        _;\n\n        // Clear vote count and voted booleans.\n        _setVoteCount(adminEpoch, topic, uint256(0));\n\n        uint256 adminCount = _getAdminCount(adminEpoch);\n\n        for (uint256 i; i < adminCount; i++) {\n            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);\n        }\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));\n    }\n\n    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));\n    }\n\n    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));\n    }\n\n    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));\n    }\n\n    function _getAdminVotedKey(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));\n    }\n\n    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _adminEpoch() internal view returns (uint256) {\n        return getUint(KEY_ADMIN_EPOCH);\n    }\n\n    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {\n        return getAddress(_getAdminKey(adminEpoch, index));\n    }\n\n    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminCountKey(adminEpoch));\n    }\n\n    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {\n        return getUint(_getAdminThresholdKey(adminEpoch));\n    }\n\n    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {\n        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));\n    }\n\n    function _hasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account\n    ) internal view returns (bool) {\n        return getBool(_getAdminVotedKey(adminEpoch, topic, account));\n    }\n\n    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {\n        return getBool(_getIsAdminKey(adminEpoch, account));\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setAdminEpoch(uint256 adminEpoch) internal {\n        _setUint(KEY_ADMIN_EPOCH, adminEpoch);\n    }\n\n    function _setAdmin(\n        uint256 adminEpoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getAdminKey(adminEpoch, index), account);\n    }\n\n    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {\n        _setUint(_getAdminCountKey(adminEpoch), adminCount);\n    }\n\n    function _setAdmins(\n        uint256 adminEpoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 adminLength = accounts.length;\n\n        if (adminLength < threshold) revert InvalidAdmins();\n\n        if (threshold == uint256(0)) revert InvalidAdminThreshold();\n\n        _setAdminThreshold(adminEpoch, threshold);\n        _setAdminCount(adminEpoch, adminLength);\n\n        for (uint256 i; i < adminLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an admin for this epoch.\n            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);\n\n            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).\n            _setAdmin(adminEpoch, i, account);\n            _setIsAdmin(adminEpoch, account, true);\n        }\n    }\n\n    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {\n        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);\n    }\n\n    function _setVoteCount(\n        uint256 adminEpoch,\n        bytes32 topic,\n        uint256 voteCount\n    ) internal {\n        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);\n    }\n\n    function _setHasVoted(\n        uint256 adminEpoch,\n        bytes32 topic,\n        address account,\n        bool voted\n    ) internal {\n        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);\n    }\n\n    function _setIsAdmin(\n        uint256 adminEpoch,\n        address account,\n        bool isAdmin\n    ) internal {\n        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);\n    }\n}\n\n\n",
        "CodeNames": [
            "AdminMultisigBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "revert"
                ],
                "Type": " Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded",
                "Description": "\nSmart contract calls often revert. In such cases any ether sent along with the transaction is returned and sometimes the remaining gas (depending on whether an assert caused the reversion or not).\n\nFor contracts involving ERC20 tokens it is also expected that, should a contract call fail, one's tokens are not lost/transferred elsewhere.\n\nThe callContractWithToken(https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGateway.sol#L98-L115) function does not appear to take contract call failure on the destination chain into account, even though this could be quite a common occurrence.\n\nTokens are burned on line 105(https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/AxelarGateway.sol#L105) but there is no mechanism in the code base to return these burned tokens in the case that the contract call fails on the destination chain.\n\nThe impact is that users of the Axelar Network can lose funds.\n\n\nI have put together an executable Proof of Concept in a fork of the repo.\nFile DestinationChainContractCallFails.js(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/test/DestinationChainContractCallFails.js#L127) implements a test that attempts to call a token swap function on the destination chain. The swap(https://github.com/code-423n4/2022-04-axelar/blob/dee2f2d352e8f20f20027977d511b19bfcca23a3/src/test/TokenSwapper.sol#L16-L33) function was provided as part of the competition repo. Given a certain amount of token A it returns twice as much of token B.\n\nIn the test I have provided the contract call on the destination chain fails because there is simply not enough of token B in the TokenSwapper contract to transfer to the user. This might be rare in practice -since adequate liquidity would generally be provided by the contract -but cross-chain contract calls are unlikely to be limited to token swaps only! I specifically chose this example to show that cross-chain contract calls can fail *even in the cases that Axelar have already considered* in their test suite.\n\nIn the unit test(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/test/DestinationChainContractCallFails.js#L129) you will find:\n\n*   Lines of note have been prefixed with sseefried:\n*   The test is a little strange in that it *succeeds* because it expects a revert. This happens on line 380(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/test/DestinationChainContractCallFails.js#L380)\n*   I took the liberty of modifying the TokenSwapper contract slightly here(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/src/test/TokenSwapper.sol#L37), in order to show that the contract call reverts because of a lack of token B.\n*   The amount of token A on line 201(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/test/DestinationChainContractCallFails.js#L201) can be modified to be a smaller value. Doing so, and re-running the test, will result in a *test failure* which means that the contract call did *not* revert i.e. the contract call on the destination chain succeeded. This shows that, before the change, the revert was due to a lack of token B in the TokenSwapper contract.\n*   Lines 388-389(https://github.com/sseefried/axelar-2022-04/blob/025078cda30e2da561f80166d8f2274c94a0f814/test/DestinationChainContractCallFails.js#L388-L389) show that, in the case of a revert on the destination chain, the tokens remain burnt on the source chain.\n\n",
                "Repair": "\nWhen making a credit card purchase it is common for transactions to remain in a \"pending\" state until eventually finalised. Often one's *available* bank balance will decrease the moment the purchase has been approved. Then one of\ntwo things happens:\n\n*   the transaction is finalised and the balance becomes the same as the available balance\n*   the transaction fails and the amount is refunded\n\nI suggest a similar design for cross-chain contract calls, with one major difference: the token should still be burned on the source chain but it should be re-minted and refunded in case of a contract call failure on the destination chain. The steps would be roughly this:\n\n*   User calls AxelarGateway.callContractWithToken() and tokens are burned\n*   Steps 3 8 from the competition page(https://code4rena.com/contests/2022-04-axelar-network-contest#cross-chain-smart-contract-call) occur as normal.\n*   However, the call to executeWithToken in step 8 now fails. This is monitored by the Axelar Network and a new event e.g. ContractCalledFailed is emitted on the *destination chain*.\n*   One the *source chain* the Axelar Network emits a new event e.g. ContractCallFailedWithRefund. This causes a re-minting of the tokens and a refund to the user to occur. The event should also be observable by the user. It should contain a reason for the contract call failure so that they are informed as to why it failed\n\ndeluca-mike (Axelar) acknowledged and commented(https://github.com/code-423n4/2022-04-axelar-findings/issues/35#issuecomment-1103612251):\n  In this situation, the validators can still mint/transfer the user back their tokens on the source chain, so there is no real loss. There does lack an \"official\" way to alert the validators of this, but it can be handled entirely by off-chain micro-services and whatnot. In the future, as ERC20 transfers are pushed out of the contract as handled as separate application on top of the generic cross-chain calls, a mechanism can be implemented to send a message back to the source chain to release/mint the tokens back to the user.\n\n0xean (judge) increased severity to High and commented(https://github.com/code-423n4/2022-04-axelar-findings/issues/35#issuecomment-1107532494):\n  Upgrading this issue from Medium to High Severity \n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n \n While the sponsor does mention there is a possible way that this could be handled in the future, currently this risk exists in the system today and doesn't have a proper or official mitigation in place.\n\n\n\n*\n \n\n"
            }
        ]
    }
]