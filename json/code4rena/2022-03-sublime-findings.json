[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "jsx\nfunction _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}\n",
                    "jsx\n_borrowedTokens = 99_000\n_totalLiquidityWithdrawable = 99_000 0 = 99_000\n_principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000\n"
                ],
                "Type": "  LenderPool : Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee",
                "Description": "\nLenderPool.sol#L594-L599(https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L594-L599)<br\nLenderPool.sol#L399-L404(https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L399-L404)<br\n\nThe _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.\n\njsx\nfunction _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}\n\n\n\nAssume the following conditions:\n\n*   Alice, the sole lender, provided 100_000 tokens: totalSupply[_id] = 100_000\n*   borrowLimit = 99_000 because of a 1% startFee\n*   Borrower borrowed zero amount\n\nWhen Alice attempts to withdraw her tokens, the _principalWithdrawable amount is calculated as\n\njsx\n_borrowedTokens = 99_000\n_totalLiquidityWithdrawable = 99_000 0 = 99_000\n_principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000\n\n\nThis is more than the available principal amount of 99_000, so the withdrawal will fail.\n\n",
                "Repair": "\nOne hack-ish way is to save the initial supply in minBorrowAmount (perhaps rename the variable to minInitialSupply) when the credit line is accepted, and replace totalSupply[_id] with it.\n\nThe other places where minBorrowAmount are used will not be affected by the change because:\n\n*   startTime has been zeroed, so start() cannot be invoked (revert with error S1)\n*   credit line status would have been changed to ACTIVE and cannot be changed back to REQUESTED, meaning the check below will be false regardless of the value of minBorrowAmount.\n\n    jsx\n    _status == PooledCreditLineStatus.REQUESTED &&\n    block.timestamp  pooledCLConstants[_id].startTime &&\n    totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount\n    \n\nCode amendment example:\n\njsx\n\nfunction _accept(uint256 _id, uint256 _amount) internal {\n  ...\n  // replace delete pooledCLConstants[_id].minBorrowAmount; with the following:\n  pooledCLConstants[_id].minInitialSupply = totalSupply[_id];\n}\n\n// update comment in _withdrawLiquidity\n// Case 1: Pooled credit line never started because desired amount wasn't reached\n// state will never revert back to REQUESTED if credit line is accepted so this case is never run\n\nfunction _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  // totalSupply[id] replaced with minInitialSupply\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(minInitialSupply);\n  return _principalWithdrawable;\n}\n\n\nIn terminate(), the shares withdrawable can simply be _sharesHeld.\n\njsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2022-03-sublime-findings/issues/19)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "jsx\n// _notBorrowed = borrowAsset amount that isn't borrowed\n// totalSupply[_id] = ERC1155 total supply of _id\n// _borrowedTokens = borrower's specified borrowLimit\nuint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);\n\nSAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false);\n"
                ],
                "Type": "  PooledCreditLine : termination likely fails because  _principleWithdrawable  is treated as shares",
                "Description": "\nLenderPool.sol#L404-L406(https://github.com/sublime-finance/sublime-v1/blob/46536a6d25df4264c1b217bd3232af30355dcb95/contracts/PooledCreditLine/LenderPool.sol#L404-L406)<br\n\n_principalWithdrawable is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.\n\njsx\n// _notBorrowed = borrowAsset amount that isn't borrowed\n// totalSupply[_id] = ERC1155 total supply of _id\n// _borrowedTokens = borrower's specified borrowLimit\nuint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);\n\nSAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false);\n\n\n",
                "Repair": "\nThe amount of shares to withdraw can simply be _sharesHeld.\n\nNote that this comes with the assumption that terminate() is only called when the credit line is ACTIVE or EXPIRED (consider ensuring this condition on-chain), because _sharesHeld excludes principal withdrawals, so the function will fail once a lender withdraws his principal.\n\njsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n\n\nritik99 (Sublime) confirmed(https://github.com/code-423n4/2022-03-sublime-findings/issues/21)\n\n\n\n*\n \n\n"
            }
        ]
    }
]