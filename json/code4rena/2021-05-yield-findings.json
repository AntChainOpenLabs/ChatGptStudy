[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "art",
                    "stir",
                    "ink",
                    "balances[to] = balancesTo"
                ],
                "Type": " Duplication of Balance",
                "Description": "\nIt is possible to duplicate currently held ink or art within a Cauldron, thereby breaking the contract's accounting system and minting units out of thin air.\n\nThe stir function of the Cauldron, which can be invoked via a Ladle operation, caches balances in memory before decrementing and incrementing. As a result, if a transfer to self is performed, the assignment balances[to] = balancesTo will contain the added-to balance instead of the neutral balance.\n\nThis allows one to duplicate any number of ink or art units at will, thereby severely affecting the protocol's integrity. A similar attack was exploited in the third bZx hack resulting in a roughly 8 million loss.\n\n",
                "Repair": "Recommend that a require check should be imposed prohibiting the from and to variables to be equivalent.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/16#issuecomment-852044133):\n  It is a good finding and a scary one. It will be fixed. Duplicated with #7.\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "build()"
                ],
                "Type": " Potential griefing with DoS by front-running vault creation with same  vaultID ",
                "Description": "\nThe vaultID for a new vault being built is required to be specified by the user building a vault via the build() function (instead of being assigned by the Cauldron/protocol). An attacker can observe a build() as part of a batch transaction in the mempool, identify the vaultID being requested, and front-run that by constructing a malicious batch transaction with only the build operation with that same vaultID. The protocol would create a vault with that vaultID and assign the attacker as its owner. More importantly, the valid batch transaction in the mempool, which was front-run, will later fail to create its vault because that vaultID already exists, as per the check on Line180 of Cauldron.sol. As a result, the valid batch transaction fails entirely because of the attacker front-running with the observed vaultID.\n\nWhile the attacker gains nothing except the ownership of an empty vault after spending the gas, this could grief the protocol's real users by preventing them from opening a vault and interacting with the protocol in any manner.\n\nThe rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because valid vaults from the Yield front-end will never be successfully created and will lead to a DoS against the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.\n\nAlice uses Yield's front-end to create a valid batch transaction. Evil Eve observes that in the mempool and identifies the vaultID of the vault being built by Alice. Eve submits her own batch transaction (without using the front-end) with only a build operation using Alice's vaultID. She uses a higher gas price to front-run Alice's transaction and get's the protocol to assign that vaultID to herself. Alice's batch transaction later fails because the vaultID she requested is already assigned to Eve. Eve can do this for any valid transaction to grief protocol users by wasting her gas to cause DoS.\n\n",
                "Repair": "Recommend mitigating this DoS vector by having the Cauldron assign the vaultID instead of the user specifying it in the build() operation. This would likely require the build() to be a separate non-batch transaction followed by other operations that use the vaultID assigned in build(). Consider the pros/cons of this approach because it will significantly affect the batching/caching logic in Ladle.\n\nAlternatively, consider adding validation logic in Ladle's batching to revert batches that have only build or a subset of the operations that do not make sense to the protocol's operations per valid recipes, which could be an attacker's signature pattern.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/43#issuecomment-853368593):\n  Good find. Fix(https://github.com/yieldprotocol/vault-v2/pull/210)\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "auctionInterval",
                    "setAuctionInterval()",
                    "grab()",
                    "auctionInterval_"
                ],
                "Type": " Uninitialized or Incorrectly set  auctionInterval  may lead to liquidation engine livelock",
                "Description": "\nThe grab() function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an auctionInterval threshold to give a reasonable window to a liquidation engine that has grabbed the vault.\n\nThe grab() function has a comment on Line 354: \"// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\" indicating a requirement of the auctionInterval being equal to one day. This can happen only if the auctionInterval is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on setAuctionInterval() being called with the appropriate auctionInterval_ value, which is also not validated.\n\nDiscussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize auctionInterval at declaration to a safe default value instead of the current 0, which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check-in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.\n\nThe rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.\n\nSee Issue page(https://github.com/code-423n4/2021-05-yield-findings/issues/44) for proof of concept and referenced code.\n\n",
                "Repair": "Recommend:\n1. Initialize auctionInterval  at declaration with a reasonable default value.\n2. Add a threshold check in setAuctionInterval() to ensure the new value meets/exceeds a reasonable default value.\n\nalbertocuestacanada (Yield) confirmed but disagreed with severity(https://github.com/code-423n4/2021-05-yield-findings/issues/44#issuecomment-853373915):\n  While we support multiple liquidation engines, we are going live with only one, and only one is in the scope of the contest.\n\n Zero is an acceptable value for auctionInterval using just one liquidation engine (the Witch). The issue can be solved with better natspec and better documentation; therefore, a severity of 0 is suggested.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/44#issuecomment-853494087):\n  Actually, if we forget to set auctionInterval to a reasonable value, an attacker could repeatedly call grab with just one Witch, stopping auctions from dropping down in price until an emergency governance action is taken.\n\n Therefore, I would suggest the severity be reduced to 1 instead of zero.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./interfaces/yieldspace/IPool.sol\";\nimport \"./interfaces/external/IERC20.sol\";\nimport \"./interfaces/external/IERC2612.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./utils/token/TransferHelper.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./LadleStorage.sol\";\n\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\ncontract Ladle is LadleStorage, AccessControl() {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    IWETH9 public immutable weth;\n\n    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {\n        weth = weth_;\n    }\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    function getOwnedVault(bytes12 vaultId)\n        internal view returns(DataTypes.Vault memory vault)\n    {\n        vault = cauldron.vaults(vaultId);\n        require (vault.owner == msg.sender, \"Only vault owner\");\n    }\n\n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal view returns(DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require (series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId)\n        internal view returns(IJoin join)\n    {\n        join = joins[assetId];\n        require (join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId)\n        internal view returns(IPool pool)\n    {\n        pool = pools[seriesId];\n        require (pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join)\n        external\n        auth\n    {\n        address asset = cauldron.assets(assetId);\n        require (asset != address(0), \"Asset not found\");\n        require (join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool)\n        external\n        auth\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require (fyToken == pool.fyToken(), \"Mismatched pool fyToken and series\");\n        require (fyToken.underlying() == address(pool.base()), \"Mismatched pool base and series\");\n        pools[seriesId] = pool;\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    function setModule(address module, bool set)\n        external\n        auth\n    {\n        modules[module] = set;\n        emit ModuleSet(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee)\n        public\n        auth    \n    {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Batching ----\n\n\n    /// @dev Submit a series of calls for execution.\n    /// Unlike `batch`, this function calls private functions, saving a CALL per function.\n    /// It also caches the vault, which is useful in `build` + `pour` and `build` + `serve` combinations.\n    function batch(\n        Operation[] calldata operations,\n        bytes[] calldata data\n    ) external payable {\n        require(operations.length == data.length, \"Mismatched operation data\");\n        bytes12 cachedId;\n        DataTypes.Vault memory vault;\n\n        // Execute all operations in the batch. Conditionals ordered by expected frequency.\n        for (uint256 i = 0; i < operations.length; i += 1) {\n\n            Operation operation = operations[i];\n\n            if (operation == Operation.BUILD) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                (cachedId, vault) = (vaultId, _build(vaultId, seriesId, ilkId));   // Cache the vault that was just built\n            \n            } else if (operation == Operation.FORWARD_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, uint8, bytes32, bytes32));\n                _forwardPermit(id, isAsset, spender, amount, deadline, v, r, s);\n            \n            } else if (operation == Operation.JOIN_ETHER) {\n                (bytes6 etherId) = abi.decode(data[i], (bytes6));\n                _joinEther(etherId);\n            \n            } else if (operation == Operation.POUR) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _pour(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.SERVE) {\n                (bytes12 vaultId, address to, uint128 ink, uint128 base, uint128 max) = abi.decode(data[i], (bytes12, address, uint128, uint128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _serve(vaultId, vault, to, ink, base, max);\n\n            } else if (operation == Operation.ROLL) {\n                (bytes12 vaultId, bytes6 newSeriesId, uint8 loan, uint128 max) = abi.decode(data[i], (bytes12, bytes6, uint8, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                (vault,) = _roll(vaultId, vault, newSeriesId, loan, max);\n            \n            } else if (operation == Operation.FORWARD_DAI_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, bool, uint8, bytes32, bytes32));\n                _forwardDaiPermit(id, isAsset, spender, nonce, deadline, allowed, v, r, s);\n            \n            } else if (operation == Operation.TRANSFER_TO_POOL) {\n                (bytes6 seriesId, bool base, uint128 wad) =\n                    abi.decode(data[i], (bytes6, bool, uint128));\n                IPool pool = getPool(seriesId);\n                _transferToPool(pool, base, wad);\n            \n            } else if (operation == Operation.ROUTE) {\n                (bytes6 seriesId, bytes memory poolCall) =\n                    abi.decode(data[i], (bytes6, bytes));\n                IPool pool = getPool(seriesId);\n                _route(pool, poolCall);\n            \n            } else if (operation == Operation.EXIT_ETHER) {\n                (address to) = abi.decode(data[i], (address));\n                _exitEther(payable(to));\n            \n            } else if (operation == Operation.CLOSE) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _close(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.REPAY) {\n                (bytes12 vaultId, address to, int128 ink, uint128 min) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repay(vaultId, vault, to, ink, min);\n            \n            } else if (operation == Operation.REPAY_VAULT) {\n                (bytes12 vaultId, address to, int128 ink, uint128 max) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayVault(vaultId, vault, to, ink, max);\n\n            } else if (operation == Operation.REPAY_LADLE) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayLadle(vaultId, vault);\n\n            } else if (operation == Operation.RETRIEVE) {\n                (bytes6 assetId, bool isAsset, address to) = abi.decode(data[i], (bytes6, bool, address));\n                _retrieve(assetId, isAsset, to);\n\n            } else if (operation == Operation.TRANSFER_TO_FYTOKEN) {\n                (bytes6 seriesId, uint256 amount) = abi.decode(data[i], (bytes6, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _transferToFYToken(fyToken, amount);\n            \n            } else if (operation == Operation.REDEEM) {\n                (bytes6 seriesId, address to, uint256 amount) = abi.decode(data[i], (bytes6, address, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _redeem(fyToken, to, amount);\n            \n            } else if (operation == Operation.STIR) {\n                (bytes12 from, bytes12 to, uint128 ink, uint128 art) = abi.decode(data[i], (bytes12, bytes12, uint128, uint128));\n                _stir(from, to, ink, art);  // Too complicated to use caching here\n            \n            } else if (operation == Operation.TWEAK) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _tweak(vaultId, seriesId, ilkId);\n\n            } else if (operation == Operation.GIVE) {\n                (bytes12 vaultId, address to) = abi.decode(data[i], (bytes12, address));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _give(vaultId, to);\n                delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore\n                cachedId = bytes12(0);\n\n            } else if (operation == Operation.DESTROY) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _destroy(vaultId);\n                delete vault;   // Clear the cache\n                cachedId = bytes12(0);\n            \n            } else if (operation == Operation.MODULE) {\n                (address module, bytes memory moduleCall) = abi.decode(data[i], (address, bytes));\n                _moduleCall(module, moduleCall);\n            \n            }\n        }\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function _build(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Change a vault series or collateral.\n    function _tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        return cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function _destroy(bytes12 vaultId)\n        private\n    {\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function _stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        private\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, \"Only origin vault owner\");\n        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, \"Only destination vault owner\");\n        return cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function _serve(bytes12 vaultId, DataTypes.Vault memory vault, address to, uint128 ink, uint128 base, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        IPool pool = getPool(vault.seriesId);\n        \n        art = pool.buyBasePreview(base);\n        balances = _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function _close(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        require (art < 0, \"Only repay debt\");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art));\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, amt);\n    }\n\n    /// @dev Calculate a debt amount for a series in base terms\n    function _debtInBase(bytes6 seriesId, DataTypes.Series memory series, uint128 art)\n        private\n        returns (uint128 amt)\n    {\n        if (uint32(block.timestamp) >= series.maturity) {\n            amt = uint256(art).wmul(cauldron.accrual(seriesId)).u128();\n        } else {\n            amt = art;\n        }\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function _repay(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 min)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        balances = _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function _repayVault(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 base)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        balances = _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function _roll(bytes12 vaultId, DataTypes.Vault memory vault, bytes6 newSeriesId, uint8 loan, uint128 max)\n        private\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        \n        uint128 newDebt;\n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 amt = _debtInBase(vault.seriesId, series, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), amt * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), amt, max);\n            baseJoin.join(address(baseJoin), amt);                  // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (amt * loan) - newDebt);    // Burn the surplus\n        }\n\n        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series\n\n        return cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt.\n    function _repayLadle(bytes12 vaultId, DataTypes.Vault memory vault)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        balances = cauldron.balances(vaultId);\n        \n        uint256 amount = series.fyToken.balanceOf(address(this));\n        amount = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, 0, -(amount.u128().i128()));\n        series.fyToken.burn(address(this), amount);\n    }\n\n    /// @dev Retrieve any asset or fyToken in the Ladle\n    function _retrieve(bytes6 id, bool isAsset, address to) \n        private\n        returns (uint256 amount)\n    {\n        IERC20 token = IERC20(findToken(id, isAsset));\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    // ---- Liquidations ----\n\n    /// @dev Allow liquidation contracts to move assets to wind down vaults\n    function settle(bytes12 vaultId, address user, uint128 ink, uint128 art)\n        external\n        auth\n    {\n        DataTypes.Vault memory vault = getOwnedVault(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n\n        cauldron.slurp(vaultId, ink, art);                                                  // Remove debt and collateral from the vault\n\n        if (ink != 0) {                                                                     // Give collateral to the user\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {                                                                     // Take underlying from user\n            IJoin baseJoin = getJoin(series.baseId);\n            baseJoin.join(user, art);\n        }\n    }\n\n    // ---- Permit management ----\n\n    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken\n    function findToken(bytes6 id, bool isAsset)\n        private view returns (address token)\n    {\n        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);\n        require (token != address(0), \"Token not found\");\n    }\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken\n    function _forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        IERC2612 token = IERC2612(findToken(id, isAsset));\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken\n    function _forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        DaiAbstract token = DaiAbstract(findToken(id, isAsset));\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable { }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function _joinEther(bytes6 etherId)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo`\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function _exitEther(address payable to)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo`\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Pool router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToPool(IPool pool, bool base, uint128 wad)\n        private\n    {\n        IERC20 token = base ? pool.base() : pool.fyToken();\n        token.safeTransferFrom(msg.sender, address(pool), wad);\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function _route(IPool pool, bytes memory data)\n        private\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = address(pool).call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- FYToken router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToFYToken(IFYToken fyToken, uint256 wad)\n        private\n    {\n        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function _redeem(IFYToken fyToken, address to, uint256 wad)\n        private\n        returns (uint256)\n    {\n        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));\n    }\n\n    // ---- Module router ----\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    function _moduleCall(address module, bytes memory moduleCall)\n        private\n        returns (bool success, bytes memory result)\n    {\n        require (modules[module], \"Unregistered module\");\n        (success, result) = module.delegatecall(moduleCall);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "Ladle.sol",
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "_moduleCall",
                    "(unique)"
                ],
                "Type": " auth collision possible",
                "Description": "\nThe auth mechanism of AccessControl.sol uses function selectors (msg.sig) as a (unique) role definition. Also the _moduleCall allows the code to be extended.\n\nSuppose an attacker wants to add the innocent-looking function \"left_branch_block(uint32) \"in a new module. Suppose this module is added via _moduleCall, and the attacker gets authorization for the innocent function.\n\nThis function happens to have a signature of 0x00000000, which is equal to the root authorization. In this way, the attacker could get authorization for the entire project.\n\nNote: it's pretty straightforward to generate function names for any signature value; you can just brute force it because it's only 4 bytes.\n\n",
                "Repair": "Recommend not allowing third parties to define or suggest new modules and double-checking the function signatures of new functions of a new module for collisions.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/5#issuecomment-852035261):\n  The execution of any auth function will only happen after a governance process or by a contract that has gone through a thorough review and governance process.\n\n We are aware that new modules can have complete control of the Ladle, and for that reason, the addition of new modules would be subject to the highest level of scrutiny. Checking for signature collisions is a good item to add to that process.\n\n In addition to that, I would implement two changes in AccessControl.sol so that giving ROOT access is explicit.\n\nsolidity\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\n        require(role != ROOT, \"Not ROOT role\");\n        _grantRole(role, account);\n    }\n\n    function grantRoot(address account) external virtual admin(ROOT) {\n        _grantRole(ROOT, account);\n    }\n\n However, given that this could be exploited only through a malicious governance exploit, I would reduce the risk to \"Low.\"\n\nalbertocuestacanada (Yield) acknowledged(https://github.com/code-423n4/2021-05-yield-findings/issues/5#issuecomment-864995915):\n  After further thinking, instead of preventing auth collisions in the smart contracts, we will add CI checks for this specific issue instead.\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [
                    "public",
                    "_moduleCall",
                    "auth"
                ],
                "Type": " auth only works well with external functions",
                "Description": "<!-appended to end of section --\n\nThe auth modifier of AccessControl.sol doesn't work as you would expect.\nIt checks if you are authorized for msg.sig. However, msg.sig is the signature of the first function you have called (not the current function). So, if you call function A, which calls function B, the \"auth\" modifier of function B checks if you are authorized for function A!\n\nThere is a difference between external and public functions. For external functions, this works as expected because a fresh call (with a new msg.sig) is always made.\nHowever, with public functions called from within the same contract, this doesn't happen as the problem described above occurs.\n\nSee the issue page for proof of concept, which shows the problem. In the code, several functions have public and auth combined; see also in the proof of concept.\n\nIn the current codebase, I couldn't find a problem situation; however, this could be accidentally introduced with future changes.\nIt could also be introduced via the _moduleCall of Ladle.sol, which allows functions to be defined which might call the public functions.\n\nSee issue #4 page(https://github.com/code-423n4/2021-05-yield-findings/issues/69#issuecomment-854498235) for proof of concept and a list of occurrences of public auth.\n\n",
                "Repair": "Recommend making sure all auth functions use external (still error-prone)\nOr, recommend changing the modifier to something like:\nsolidity\nmodifier auth(bytes4 fs) {\nrequire (msg.sig == fs,\"Wrong selector\");\nrequire (_hasRole(msg.sig, msg.sender), \"Access denied\");\n_;\n}\n\nsolidity\nfunction setFee(uint256) public auth(this.setFee.selector) {\n   .....\n}\n\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/4#issuecomment-852042973):\n  While many governance functions have been marked public instead of external throughout the code, they are never called from any other function in the same contract, and they should never be.\n\n In all contracts of the protocol, auth functions are only called by other contracts or by EOAs, with the latter being governance actions.\n\n The suggestion of changing all public auth functions to external auth will be applied; however, no changes will be made to AccessControl.sol, and the suggested severity is 1.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >= 0.8.0;\n\nimport \"./Math64x64.sol\";\n\nlibrary Exp64x64 {\n  /**\n   * Raise given number x into power specified as a simple fraction y/z and then\n   * multiply the result by the normalization factor 2^(128 * (1 - y/z)).\n   * Revert if z is zero, or if both x and y are zeros.\n   *\n   * @param x number to raise into given power y/z\n   * @param y numerator of the power to raise x into\n   * @param z denominator of the power to raise x into\n   * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))\n   */\n  function pow(uint128 x, uint128 y, uint128 z)\n  internal pure returns(uint128) {\n    unchecked {\n      require(z != 0);\n\n      if(x == 0) {\n        require(y != 0);\n        return 0;\n      } else {\n        uint256 l =\n          uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2(x)) * y / z;\n        if(l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;\n        else return pow_2(uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l));\n      }\n    }\n  }\n\n  /**\n   * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert\n   * in case x is zero.\n   *\n   * @param x number to calculate base 2 logarithm of\n   * @return base 2 logarithm of x, multiplied by 2^121\n   */\n  function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      if(b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\n      if(b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\n      if(b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\n      if(b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\n      if(b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\n      if(b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\n\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;} /*\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }\n\n  /**\n   * Calculate 2 raised into given power.\n   *\n   * @param x power to raise 2 into, multiplied by 2^121\n   * @return 2 raised into given power\n   */\n  function pow_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      uint r = 0x80000000000000000000000000000000;\n      if(x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\n      if(x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\n      if(x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\n      if(x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\n      if(x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\n      if(x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\n      if(x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\n      if(x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\n      if(x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\n      if(x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\n      if(x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\n      if(x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\n      if(x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\n      if(x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\n      if(x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\n      if(x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\n      if(x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\n      if(x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\n      if(x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\n      if(x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\n      if(x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\n      if(x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\n      if(x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\n      if(x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\n      if(x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\n      if(x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\n      if(x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\n      if(x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\n      if(x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\n      if(x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\n      if(x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\n      if(x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\n      if(x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\n      if(x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\n      if(x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\n      if(x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\n      if(x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\n      if(x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\n      if(x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\n      if(x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\n      if(x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\n      if(x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\n      if(x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\n      if(x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\n      if(x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\n      if(x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\n      if(x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\n      if(x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\n      if(x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\n      if(x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\n      if(x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\n      if(x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\n      if(x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\n      if(x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\n      if(x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\n      if(x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\n      if(x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127; /*\n      if(x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\n      if(x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\n      if(x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\n      if(x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\n      if(x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\n      if(x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\n      if(x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\n      if(x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\n      if(x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\n      if(x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\n      if(x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\n      if(x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\n      if(x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\n      if(x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\n      if(x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\n      if(x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\n      if(x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\n      if(x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\n      if(x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\n      if(x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\n      if(x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\n      if(x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\n      if(x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\n      if(x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\n      if(x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\n      if(x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\n      if(x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\n      if(x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\n      if(x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\n      if(x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\n      if(x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\n      if(x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\n      if(x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\n      if(x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\n      if(x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\n      if(x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\n      if(x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\n      if(x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\n      if(x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\n      if(x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\n      if(x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\n      if(x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\n      if(x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\n      if(x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\n      if(x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\n      if(x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\n      if(x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\n      if(x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\n      if(x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\n      if(x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\n      if(x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\n      if(x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\n      if(x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\n      if(x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\n      if(x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\n      if(x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\n      if(x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\n      if(x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\n      if(x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\n      if(x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\n      if(x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\n      if(x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\n      if(x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\n      if(x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127; */\n\n      r >>= 127 -(x >> 121);\n\n      return uint128(r);\n    }\n  }\n}\n\n/**\n * Ethereum smart contract library implementing Yield Math model.\n */\nlibrary YieldMath {\n  using Math64x64 for int128;\n  using Math64x64 for uint128;\n  using Math64x64 for int256;\n  using Math64x64 for uint256;\n  using Exp64x64 for uint128;\n\n  uint128 public constant ONE = 0x10000000000000000; // In 64.64\n  uint256 public constant MAX = type(uint128).max;   // Used for overflow checks\n\n  /**\n   * Calculate the amount of fyToken a user would get for given amount of Base.\n   * https://www.desmos.com/calculator/5nf2xuy6yb\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user would get for given amount of Base\n   */\n  function fyTokenOutForBaseIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves + baseAmount\n      uint256 zx = uint256(baseReserves) + uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base in\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient fyToken reserves\");\n\n      // result = fyTokenReserves - (sum ** (1/a))\n      uint256 result = uint256(fyTokenReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would get for certain amount of fyToken.\n   * https://www.desmos.com/calculator/6jlrre7ybt\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of Base a user would get for given amount of fyToken\n   */\n  function baseOutForFYTokenIn(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = fyDayReserves + fyTokenAmount\n      uint256 yx = uint256(fyTokenReserves) + uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken in\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Insufficient base reserves\");\n\n      // result = baseReserves - (sum ** (1/a))\n      uint256 result = uint256(baseReserves) - uint256(uint128(sum).pow(ONE, a));\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result > 1e12 ? result - 1e12 : 0; // Subtract error guard, flooring the result at zero\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of fyToken a user could sell for given amount of Base.\n   * https://www.desmos.com/calculator/0rgnmtckvy\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param baseAmount Base amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of fyToken a user could sell for given amount of Base\n   */\n  function fyTokenInForBaseOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // zx = baseReserves - baseAmount\n      uint256 zx = uint256(baseReserves) - uint256(baseAmount);\n      require(zx <= MAX, \"YieldMath: Too much base out\");\n\n      // zxa = zx ** a\n      uint256 zxa = uint128(zx).pow(a, ONE);\n\n      // sum = za + ya - zxa\n      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting fyToken reserves too high\");\n\n      // result = (sum ** (1/a)) - fyTokenReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(fyTokenReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  /**\n   * Calculate the amount of base a user would have to pay for certain amount of fyToken.\n   * https://www.desmos.com/calculator/ws5oqj8x5i\n   * @param baseReserves Base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param fyTokenAmount fyToken amount to be traded\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param g fee coefficient, multiplied by 2^64\n   * @return the amount of base a user would have to pay for given amount of\n   *         fyToken\n   */\n  function baseInForFYTokenOut(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,\n    uint128 timeTillMaturity, int128 k, int128 g)\n  public pure returns(uint128) {\n    unchecked {\n      uint128 a = _computeA(timeTillMaturity, k, g);\n\n      // za = baseReserves ** a\n      uint256 za = baseReserves.pow(a, ONE);\n\n      // ya = fyTokenReserves ** a\n      uint256 ya = fyTokenReserves.pow(a, ONE);\n\n      // yx = baseReserves - baseAmount\n      uint256 yx = uint256(fyTokenReserves) - uint256(fyTokenAmount);\n      require(yx <= MAX, \"YieldMath: Too much fyToken out\");\n\n      // yxa = yx ** a\n      uint256 yxa = uint128(yx).pow(a, ONE);\n\n      // sum = za + ya - yxa\n      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\n      require(sum <= MAX, \"YieldMath: Resulting base reserves too high\");\n\n      // result = (sum ** (1/a)) - baseReserves\n      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(baseReserves);\n      require(result <= MAX, \"YieldMath: Rounding induced error\");\n\n      result = result < MAX - 1e12 ? result + 1e12 : MAX; // Add error guard, ceiling the result at max\n\n      return uint128(result);\n    }\n  }\n\n  function _computeA(uint128 timeTillMaturity, int128 k, int128 g) private pure returns (uint128) {\n    unchecked {\n      // t = k * timeTillMaturity\n      int128 t = k.mul(timeTillMaturity.fromUInt());\n      require(t >= 0, \"YieldMath: t must be positive\"); // Meaning neither T or k can be negative\n\n      // a = (1 - gt)\n      int128 a = int128(ONE).sub(g.mul(t));\n      require(a > 0, \"YieldMath: Too far from maturity\");\n      require(a <= int128(ONE), \"YieldMath: g must be positive\");\n\n      return uint128(a);\n    }\n  }\n\n  /**\n   * Estimate in Base the value of reserves at protocol initialization time.\n   *\n   * @param baseReserves base reserves amount\n   * @param fyTokenReserves fyToken reserves amount\n   * @param timeTillMaturity time till maturity in seconds\n   * @param k time till maturity coefficient, multiplied by 2^64\n   * @param c0 price of base in terms of Base, multiplied by 2^64\n   * @return estimated value of reserves\n   */\n  function initialReservesValue(\n    uint128 baseReserves, uint128 fyTokenReserves, uint128 timeTillMaturity,\n    int128 k, int128 c0)\n  external pure returns(uint128) {\n    unchecked {\n      uint256 normalizedBaseReserves = c0.mulu(baseReserves);\n      require(normalizedBaseReserves <= MAX);\n\n      // a = (1 - k * timeTillMaturity)\n      int128 a = int128(ONE).sub(k.mul(timeTillMaturity.fromUInt()));\n      require(a > 0);\n\n      uint256 sum =\n        uint256(uint128(normalizedBaseReserves).pow(uint128(a), ONE)) +\n        uint256(fyTokenReserves.pow(uint128(a), ONE)) >> 1;\n      require(sum <= MAX);\n\n      uint256 result = uint256(uint128(sum).pow(ONE, uint128(a))) << 1;\n      require(result <= MAX);\n\n      return uint128(result);\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "CodeNames": [
            "YieldMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction log_2 (uint128 x)\n...\nb = b * b  127; if (b = 0x100000000000000000000000000000000) {b = 1; l |= 0x1000000000000000000000000000000;}\n",
                    "//solidity\nfunction log_2(uint128 x)\n...\nb = b * b  127; if(b  0x100000000000000000000000000000000) {b = 1; l |= 0x1000000000000000000000000000000;}\n"
                ],
                "Type": " YieldMath.sol / Log2: >= or > ?",
                "Description": "\nThe V1 version of YieldMath.sol contains \"=\" (larger or equal), while the V2 version of YieldMath.sol contains \"\" (larger) in the log_2 function.\nThis change doesn't seem logical and might lead to miss calculations.\nThe difference is present in several adjacent lines.\nsolidity\nfunction log_2 (uint128 x)\n...\nb = b * b  127; if (b = 0x100000000000000000000000000000000) {b = 1; l |= 0x1000000000000000000000000000000;}\n\nand\n\nsolidity\nfunction log_2(uint128 x)\n...\nb = b * b  127; if(b  0x100000000000000000000000000000000) {b = 1; l |= 0x1000000000000000000000000000000;}\n\n\n",
                "Repair": "Recommend checking which version is the correct version and fix the incorrect version.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/2#issuecomment-852039365):\n  That's entirely my fault, and this is a scary one. We might be having a slightly different or impredictable curve in Pool.sol, and we might notice only after a long while with the Pools being slowly drained. We might never even have found this was the issue.\n\n I would suggest increasing the severity of this issue to High.\n\nalbertocuestacanada (Yield) Resolved(https://github.com/code-423n4/2021-05-yield-findings/issues/2#issuecomment-854621275):\n  Fix(https://github.com/yieldprotocol/yieldspace-v2/pull/108)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\nimport \"./IUniswapV3PoolImmutables.sol\";\n// This for the real deal\n// import \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\nimport \"../../mocks/oracles/uniswap/UniswapV3OracleLibraryMock.sol\";\n\n/**\n * @title UniswapV3Oracle\n */\ncontract UniswapV3Oracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SecondsAgoSet(uint32 indexed secondsAgo);\n    event SourceSet(bytes6 indexed base, bytes6 indexed quote, address indexed source);\n\n    struct Source {\n        address source;\n        bool inverse;\n    }\n\n    struct SourceData {\n        address factory;\n        address baseToken;\n        address quoteToken;\n        uint24 fee;\n    }\n\n    uint32 public secondsAgo;\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n    mapping(address => SourceData) public sourcesData;\n\n    /**\n     * @notice Set or reset the number of seconds Uniswap will use for its Time Weighted Average Price computation\n     */\n    function setSecondsAgo(uint32 secondsAgo_) public auth {\n        require(secondsAgo_ != 0, \"Uniswap must look into the past.\");\n        secondsAgo = secondsAgo_;\n        emit SecondsAgoSet(secondsAgo_);\n    }\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) public auth {\n        sources[base][quote] = Source(source, false);\n        sources[quote][base] = Source(source, true);\n        sourcesData[source] = SourceData(\n            IUniswapV3PoolImmutables(source).factory(),\n            IUniswapV3PoolImmutables(source).token0(),\n            IUniswapV3PoolImmutables(source).token1(),\n            IUniswapV3PoolImmutables(source).fee()\n        );\n        emit SourceSet(base, quote, source);\n        emit SourceSet(quote, base, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth {\n        require(bases.length == quotes.length && quotes.length == sources_.length, \"Mismatched inputs\");\n        for (uint256 i = 0; i < bases.length; i++) {\n            setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function _peek(bytes6 base, bytes6 quote, uint256 amount) public virtual view returns (uint256 value, uint256 updateTime) {\n        Source memory source = sources[base][quote];\n        SourceData memory sourceData;\n        require(source.source != address(0), \"Source not found\");\n        sourceData = sourcesData[source.source];\n        if (source.inverse) {\n            value = UniswapV3OracleLibraryMock.consult(sourceData.factory, sourceData.quoteToken, sourceData.baseToken, sourceData.fee, amount, secondsAgo);\n        } else {\n            value = UniswapV3OracleLibraryMock.consult(sourceData.factory, sourceData.baseToken, sourceData.quoteToken, sourceData.fee, amount, secondsAgo);\n        }\n        updateTime = block.timestamp - secondsAgo;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        return _peek(base.b6(), quote.b6(), amount);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        return _peek(base.b6(), quote.b6(), amount);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "UniswapV3Oracle.sol",
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "@uniswap/v",
                    "set"
                ],
                "Type": " Uniswap Oracle uses wrong prices",
                "Description": "\nThe Uniswap oracle uses a mock contract with hard-coded prices to retrieve the price, which is not feasible in production. Also, note that even when using the \"real deal\" @uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol... it does not, in fact, return the prices.\n\nThe price could change from the set price. Meanwhile, always updating new prices with set will be too slow and gas expensive.\n\n",
                "Repair": "Recommend using cumulativeTicks = pool.observe([secondsAgo, 0]) // a_t1, a_t2] and applying equation 5.5(https://uniswap.org/whitepaper-v3.pdf) from the Uniswap V3 whitepaper to compute the token0 TWAP.\nNote that even the official .consult call(https://github.com/Uniswap/uniswap-v3-periphery/blob/b55e7e81a803082c0328e2826592327da373ab00/contracts/libraries/OracleLibrary.sol#L27) seems to only return the averaged cumulative ticks; you'd still need to compute the 1.0001^timeWeightedAverageTick in the function.\n\nalbertocuestacanada (Yield) acknowledged(https://github.com/code-423n4/2021-05-yield-findings/issues/26#issuecomment-852872017):\n  We probably should have not included this contract; it's too confusing since, at the time, the Uniswap v3 OracleLibrary was still a mock, and this hasn't gone real testing.\n\n The price source in a production version would be a Uniswap v3 pool, not one of our mock oracle sources. We never expected to call set in production, but to retrieve the prices from a Uniswap v3 pool using the mentioned library (which was not even merged into main at the start of the contest).\n\n We will check with the Uniswap team what is the recommended way of using their oracles. The equation 5.5 in the whitepaper is problematic because an exponentiation of two fractional numbers in Solidity is neither trivial nor cheap. Our understanding is that one of the goals of the OracleLibrary was to provide a consistent implementation to this formula.\n\n From a conversation with @moodysalem, I understand that the code in getQuoteAtTick might achieve the same result as the 5.5 equation, so maybe we need to retrieve the average tick with consult, and then the actual price with getQuoteAtTick.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/26#issuecomment-852872737):\n  I'm using the acknowledged label for findings that require further investigation to assess.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./utils/access/AccessControl.sol\";\nimport \"./interfaces/vault/ILadle.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/WDivUp.sol\";\nimport \"./math/CastU256U128.sol\";\n\n\ncontract Witch is AccessControl() {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n\n    event AuctionTimeSet(uint128 indexed auctionTime);\n    event InitialProportionSet(uint128 indexed initialProportion);\n    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);\n  \n    uint128 public auctionTime = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.\n    uint128 public initialProportion = 5e17;  // Proportion of collateral that is sold at auction start.\n\n    ICauldron immutable public cauldron;\n    ILadle immutable public ladle;\n    mapping(bytes12 => address) public vaultOwners;\n\n    constructor (ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Set the auction time to calculate liquidation prices\n    function setAuctionTime(uint128 auctionTime_) public auth {\n        auctionTime = auctionTime_;\n        emit AuctionTimeSet(auctionTime_);\n    }\n\n    /// @dev Set the proportion of the collateral that will be sold at auction start\n    function setInitialProportion(uint128 initialProportion_) public auth {\n        require (initialProportion_ <= 1e18, \"Only at or under 100%\");\n        initialProportion = initialProportion_;\n        emit InitialProportionSet(initialProportion_);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function grab(bytes12 vaultId) public {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        vaultOwners[vaultId] = vault.owner;\n        cauldron.grab(vaultId, address(this));\n    }\n\n    /// @dev Buy an amount of collateral off a vault in liquidation, paying at most `max` underlying.\n    function buy(bytes12 vaultId, uint128 art, uint128 min) public {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        uint256 elapsed = uint32(block.timestamp) - cauldron.auctions(vaultId);           // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n        uint256 price;\n        {\n            // Price of a collateral unit, in underlying, at the present moment, for a given vault\n            //\n            //                ink                     min(auction, elapsed)\n            // price = 1 / (------- * (p + (1 - p) * -----------------------))\n            //                art                          auction\n            (uint256 auctionTime_, uint256 initialProportion_) = (auctionTime, initialProportion);\n            uint256 term1 = uint256(balances_.ink).wdiv(balances_.art);\n            uint256 dividend2 = auctionTime_ < elapsed ? auctionTime_ : elapsed;\n            uint256 divisor2 = auctionTime_;\n            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2));\n            price = uint256(1e18).wdiv(term1.wmul(term2));\n        }\n        uint256 ink = uint256(art).wdivup(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n        require (ink >= min, \"Not enough bought\");\n\n        ladle.settle(vaultId, msg.sender, ink.u128(), art);                                        // Move the assets\n        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, vaultOwners[vaultId]);\n            delete vaultOwners[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "Witch.sol",
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "auctionInterval",
                    "",
                    "vaultOwners[vaultId]",
                    "auctions",
                    "grab"
                ],
                "Type": " Witch can't give back vault after 2x grab",
                "Description": "\nThe witch.sol contract gets access to a vault via the grab function in case of liquidation. If the witch.sol contract can't sell the debt within a certain amount of time, a second grab can occur.\n\nAfter the second grab, the information of the original owner of the vault is lost, and the vault can't be returned to the original owner once the debt has been sold.\n\nThe grab function stores the previous owner in vaultOwners[vaultId], and then the contract itself is the new owner (via cauldron.grab and cauldron._give).\nThe vaultOwners[vaultId] is overwritten at the second grab\n\nThe function buy of Witch.sol tried to give the vault back to the original owner, which won't succeed after a second grab. See the issue page for proof of concept and referenced code(https://github.com/code-423n4/2021-05-yield-findings/issues/8)\n\nAssuming it's useful to give back the vault to the original owner,  recommend making a stack/array of previous owners if multiple instances of the witch.sol contract would be used. Or, check if the witch is already the owner (in the grab function) and keep the vaultOwners[vaultId] if that is the case.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/8#issuecomment-852009841):\n  This is a good finding and a vulnerability that we will fix. I anticipate that we will store the original owner in Cauldron.auctions along with the time at which the auction was started.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/8#issuecomment-853405752):\n  Actually, we might remove some overengineering by taking out the feature of allowing multiple competing liquidation engines.\n\n That would allow us to:\n 1. Move the auctions mapping to the Witch.\n 2. Remove the auctionInterval setting\n 3. Simplify grab\n 3. Stop worrying about more than one grab.\n\nEditors note: An alternative submission for this bug was not included in this report but can be found in Issue #30(https://github.com/code-423n4/2021-05-yield-findings/issues/30).\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../ISourceMock.sol\";\n\n\ncontract CTokenChiMock is ISourceMock {\n    uint public exchangeRateStored;\n\n    function set(uint chi) external override {\n        exchangeRateStored = chi;\n    }\n\n    function exchangeRateCurrent() public view returns (uint) {\n        return exchangeRateStored;\n    }\n}\n\n\n",
        "CodeNames": [
            "CTokenChiMock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "exchangeRateStored",
                    "CToken"
                ],
                "Type": " User can redeem more tokens by artificially increasing the chi accrual",
                "Description": "\nA user can artificially increase the chi accrual (after maturity) by flash borrow on Compound, which affects the exchange rate used by the chi oracle. As a result, the user redeems more underlying tokens with the same amount of fyTokens since the accrual is larger than before.\n\nThe exchangeRateStored used by chi oracle is calculated based on the totalBorrows of CToken, which can be artificially increased by a large amount of borrow operated on Compound. Consider a user performing the following steps in a single transaction (assuming that the fyToken is matured):\n\n1. Deposits a large amount of collateral (whether from flash loans or not) and borrow from Compound\n2. Burns his fyToken by calling redeem.\n3. Repays the borrow to Compound\n\nThe user only needs to pay for the gas fees of borrowing and repaying (since they happen in the same transaction) but can redeem more underlying tokens than a regular redeem.\n\nReferenced code:\nCompoundMultiOracle.sol#L46(https://github.com/code-423n4/2021-05-yield/blob/main/contracts/oracles/compound/CompoundMultiOracle.sol#L46)\nFYToken.sol#L125(https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L125)\nFYToken.sol#L132-L143(https://github.com/code-423n4/2021-05-yield/blob/main/contracts/FYToken.sol#L132-L143)\n\n",
                "Repair": "Recommend making the chi accrual time-weighted to mitigate the manipulation caused by flash borrow and repay.\n\nalbertocuestacanada (Yield) acknowledged(https://github.com/code-423n4/2021-05-yield-findings/issues/69#issuecomment-854498235):\n  If this is true, that means that we don't understand how exchangeRateStored works (quite likely).\n\n Our understanding was that exchangeRateStored is an increasing accumulator, same as chi in MakerDAO, which is both an exchange rate and an accumulator.\n\n If exchangeRateStored can go down in value, as well as up, we might have to revisit how we source it.\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [],
                "Type": " Violation of implicit constraints in batched operations may break protocol assumptions",
                "Description": "\nThe Ladle batching of operations is a complex task (as noted by the project lead) with implicit constraints on what operations can be bundled together in a batch. Operations can/have to appear how many times and in what order/sequence etc. Some examples of these constraints are: Join Ether should be the first operation, Exit Ether the last, and only one Join Ether per batch.\n\nAll this complexity is managed currently by anticipating all interactions to happen via their authorized front-end, which uses validated (and currently only revealed on-demand) recipes that adhere to these constraints. There is a plan to open the design up to other front-ends and partner integrating protocols that will also test their batch recipes or integrations for these constraints.\n\nBreaking some of these constraints opens up the protocol to failing transactions, undefined behavior, or potentially loss/lock of funds. Defensive programming suggests enforcing such batch operation constraints in the code and documentation and onboarding checks for defense-in-depth. Relying on documentation or external validation may not be sufficient for arguably the most critical aspect of batched operations which is the only authorized way to interact with the protocol.\n\nThe rationale for assigning medium-severity is that, while the likelihood of this may be low because of controlled/validated onboarding on new front-ends or integrating protocols, the impact of accidental deviation from implicit constraints is high. This may result in a transaction failing, or tokens getting locked/lost, thus impact the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.\n\n1. A new front-end project comes up claiming to provide a better user interface than the project's authorized front-end. It does not use the recipe book (correctly) and makes Ladle batches with incorrect operations, thus failing the constraints and leading to protocol failures and token lock/loss.\n2. An integrating protocol goes through the approved onboarding and validation but has missed bugs in its recipe for batches, thus failing the constraints and leading to protocol failures and token lock/loss.\n\n",
                "Repair": "Recommend enforcing batch operation constraints explicitly in the code (e.g., with tracking counters/booleans for operations) along with documentation and onboarding validation. This may increase the complexity of the batching code but adds fail-safe defense-in-depth for any mistakes in onboarding validation of implicit constraints, which may affect protocol operations significantly.\n\nalbertocuestacanada (Yield) disputed(https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-853371363):\n  I don't think implementing the suggested checks is worth the added complexity and deployment gas.\n\n Given that this is an issue disclosed by the sponsor and widely discussed, I would find it unfair to the other wardens if accepted.\n\ndmvt (Judge) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-860962920):\n  The warden brings up a valid concern. As to the sponsor's objection, the sponsor has written, \"The Ladle is a complex contract, with wide-ranging powers over the protocol. It is the riskiest contract, and at the same time, the one that has more room for a bug to hide. It is of the highest importance to find as many bugs as we can in it.\" (emphasis mine). I highly recommend the issue be addressed by the sponsor.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/45#issuecomment-862419851):\n  I still disagree. I disclosed this issue myself first in the C4 discord, and it is a design choice.\n\n Users are not expected to build batches themselves and won't be provided with any tools to do so. If a user decides to ignore all advice and go to the extreme length of interacting with the smart contracts himself or via an unauthorized front-end, it's completely on him if he loses funds.\n\n It is impossible that a user will execute a non-reverting batch without careful research on the batching system. To do that, he would need to exactly match one or more action codes with abi-encoded arrays of parameters of the right types.\n\n My concerns on the batching system are not on users or integrators building a bad batch and losing their funds.\n\n My concerns are that the batching system is complex, and there could be the chance that a batch could be built with a negative effect on the protocol or for other users. Since the Ladle has sweeping powers over the protocol, that would be a real issue. Such a batch has not been found.\n\n So, to reiterate. The issue being brought up was brought up in the discord by myself, and it is a conscious trade-off we made of usability for flexibility. No undisclosed issue has been found.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >= 0.8.0;\n\nimport \"./interfaces/vault/IJoinFactory.sol\";\nimport \"./Join.sol\";\n\n\n/// @dev The JoinFactory can deterministically create new join instances.\ncontract JoinFactory is IJoinFactory {\n  /// Pre-hashing the bytecode allows calculateJoinAddress to be cheaper, and\n  /// makes client-side address calculation easier\n  bytes32 public constant override JOIN_BYTECODE_HASH = keccak256(type(Join).creationCode);\n\n  address private _nextAsset;\n\n  /// @dev Returns true if `account` is a contract.\n  function isContract(address account) internal view returns (bool) {\n      // This method relies on extcodesize, which returns 0 for contracts in\n      // construction, since the code is only stored at the end of the\n      // constructor execution.\n\n      uint256 size;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { size := extcodesize(account) }\n      return size > 0;\n  }\n\n  /// @dev Calculate the deterministic addreess of a join, based on the asset token.\n  /// @param asset Address of the asset token.\n  /// @return The calculated join address.\n  function calculateJoinAddress(address asset) external view override returns (address) {\n    return _calculateJoinAddress(asset);\n  }\n\n  /// @dev Create2 calculation\n  function _calculateJoinAddress(address asset)\n    private view returns (address calculatedAddress)\n  {\n    calculatedAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n      bytes1(0xff),\n      address(this),\n      keccak256(abi.encodePacked(asset)),\n      JOIN_BYTECODE_HASH\n    )))));\n  }\n\n  /// @dev Calculate the address of a join, and return address(0) if not deployed.\n  /// @param asset Address of the asset token.\n  /// @return join The deployed join address.\n  function getJoin(address asset) external view override returns (address join) {\n    join = _calculateJoinAddress(asset);\n\n    if(!isContract(join)) {\n      join = address(0);\n    }\n  }\n\n  /// @dev Deploys a new join.\n  /// The asset address is written to a temporary storage slot to allow for simpler\n  /// address calculation, while still allowing the Join contract to store the values as\n  /// immutable.\n  /// @param asset Address of the asset token.\n  /// @return join The join address.\n  function createJoin(address asset) external override returns (address) {\n    _nextAsset = asset;\n    Join join = new Join{salt: keccak256(abi.encodePacked(asset))}();\n    _nextAsset = address(0);\n\n    join.grantRole(join.ROOT(), msg.sender);\n    join.renounceRole(join.ROOT(), address(this));\n    \n    emit JoinCreated(asset, address(join));\n\n    return address(join);\n  }\n\n  /// @dev Only used by the Join constructor.\n  /// @return The address token for the currently-constructing join.\n  function nextAsset() external view override returns (address) {\n    return _nextAsset;\n  }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "JoinFactory.sol",
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nJoin join = new Join{salt: keccak256(abi.encodePacked(asset))}();\n"
                ],
                "Type": " Possible DoS attack when creating  Joins  in  Wand ",
                "Description": "\nIt is possible for an attacker to intendedly create a fake Join corresponding to a specific token beforehand to make Wand unable to deploy the actual Join, causing a DoS attack.\n\nThe address of Join corresponding to an underlying asset is determined as follows and thus unique:\n\nsolidity\nJoin join = new Join{salt: keccak256(abi.encodePacked(asset))}();\n\n\nBesides, the function createJoin in the contract JoinFactory is permissionless: Anyone can create the Join corresponding to the asset. An attacker could then deploy many Joins with different common underlying assets (e.g., DAI, USDC, ETH) before the Wand deploying them. The attempt of deploying these Joins by Wand would fail since the attacker had occupied the desired addresses with fake Joins, resulting in a DoS attack.\n\nMoreover, the attacker can also perform DoS attacks on newly added assets: He monitors the mempool to find transactions calling the function addAsset of Wand and front-runs them to create the corresponding Join to make the benign transaction fail.\n\nReferenced code:\nJoinFactory.sol#L64-L75(https://github.com/code-423n4/2021-05-yield/blob/main/contracts/JoinFactory.sol#L64-L75)\nWand.sol#L53(https://github.com/code-423n4/2021-05-yield/blob/main/contracts/Wand.sol#L53)\n\n",
                "Repair": "Recommend enabling access control in createJoin (e.g., adding the auth modifier) and allowing Wand to call it.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/70#issuecomment-854503335):\n  The issue exists, and we appreciate raising it.\n\n The solution can't be adding auth to createJoin, since anyone can use CREATE2 to deploy a Join with their own factory, but with our Join bytecode, occupying the same address we would.\n\n The proper mitigation, in our opinion, is to ditch CREATE2 and deploy Joins using CREATE instead.\n\n As for the risk, such a DoS attack wouldn't cause a loss of funds or an interruption on user service. It would cause a governance action to revert, which would be quickly fixed by deploying a new JoinFactory and replacing the Wand. Fortunately, no contract uses the Wand as a Join registry (maybe we should!).\n\n I suggest the risk is downgraded to 1.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"./utils/access/AccessControl.sol\";\nimport \"./interfaces/vault/ILadle.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/WDivUp.sol\";\nimport \"./math/CastU256U128.sol\";\n\n\ncontract Witch is AccessControl() {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n\n    event AuctionTimeSet(uint128 indexed auctionTime);\n    event InitialProportionSet(uint128 indexed initialProportion);\n    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);\n  \n    uint128 public auctionTime = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.\n    uint128 public initialProportion = 5e17;  // Proportion of collateral that is sold at auction start.\n\n    ICauldron immutable public cauldron;\n    ILadle immutable public ladle;\n    mapping(bytes12 => address) public vaultOwners;\n\n    constructor (ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Set the auction time to calculate liquidation prices\n    function setAuctionTime(uint128 auctionTime_) public auth {\n        auctionTime = auctionTime_;\n        emit AuctionTimeSet(auctionTime_);\n    }\n\n    /// @dev Set the proportion of the collateral that will be sold at auction start\n    function setInitialProportion(uint128 initialProportion_) public auth {\n        require (initialProportion_ <= 1e18, \"Only at or under 100%\");\n        initialProportion = initialProportion_;\n        emit InitialProportionSet(initialProportion_);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function grab(bytes12 vaultId) public {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        vaultOwners[vaultId] = vault.owner;\n        cauldron.grab(vaultId, address(this));\n    }\n\n    /// @dev Buy an amount of collateral off a vault in liquidation, paying at most `max` underlying.\n    function buy(bytes12 vaultId, uint128 art, uint128 min) public {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        uint256 elapsed = uint32(block.timestamp) - cauldron.auctions(vaultId);           // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n        uint256 price;\n        {\n            // Price of a collateral unit, in underlying, at the present moment, for a given vault\n            //\n            //                ink                     min(auction, elapsed)\n            // price = 1 / (------- * (p + (1 - p) * -----------------------))\n            //                art                          auction\n            (uint256 auctionTime_, uint256 initialProportion_) = (auctionTime, initialProportion);\n            uint256 term1 = uint256(balances_.ink).wdiv(balances_.art);\n            uint256 dividend2 = auctionTime_ < elapsed ? auctionTime_ : elapsed;\n            uint256 divisor2 = auctionTime_;\n            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2));\n            price = uint256(1e18).wdiv(term1.wmul(term2));\n        }\n        uint256 ink = uint256(art).wdivup(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n        require (ink >= min, \"Not enough bought\");\n\n        ladle.settle(vaultId, msg.sender, ink.u128(), art);                                        // Move the assets\n        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, vaultOwners[vaultId]);\n            delete vaultOwners[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IJoin.sol\";\nimport \"./interfaces/vault/ICauldron.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./interfaces/yieldspace/IPool.sol\";\nimport \"./interfaces/external/IERC20.sol\";\nimport \"./interfaces/external/IERC2612.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./utils/token/TransferHelper.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/CastU256U128.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./LadleStorage.sol\";\n\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\ncontract Ladle is LadleStorage, AccessControl() {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    IWETH9 public immutable weth;\n\n    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {\n        weth = weth_;\n    }\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    function getOwnedVault(bytes12 vaultId)\n        internal view returns(DataTypes.Vault memory vault)\n    {\n        vault = cauldron.vaults(vaultId);\n        require (vault.owner == msg.sender, \"Only vault owner\");\n    }\n\n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal view returns(DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require (series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId)\n        internal view returns(IJoin join)\n    {\n        join = joins[assetId];\n        require (join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId)\n        internal view returns(IPool pool)\n    {\n        pool = pools[seriesId];\n        require (pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join)\n        external\n        auth\n    {\n        address asset = cauldron.assets(assetId);\n        require (asset != address(0), \"Asset not found\");\n        require (join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool)\n        external\n        auth\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require (fyToken == pool.fyToken(), \"Mismatched pool fyToken and series\");\n        require (fyToken.underlying() == address(pool.base()), \"Mismatched pool base and series\");\n        pools[seriesId] = pool;\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    function setModule(address module, bool set)\n        external\n        auth\n    {\n        modules[module] = set;\n        emit ModuleSet(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee)\n        public\n        auth    \n    {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Batching ----\n\n\n    /// @dev Submit a series of calls for execution.\n    /// Unlike `batch`, this function calls private functions, saving a CALL per function.\n    /// It also caches the vault, which is useful in `build` + `pour` and `build` + `serve` combinations.\n    function batch(\n        Operation[] calldata operations,\n        bytes[] calldata data\n    ) external payable {\n        require(operations.length == data.length, \"Mismatched operation data\");\n        bytes12 cachedId;\n        DataTypes.Vault memory vault;\n\n        // Execute all operations in the batch. Conditionals ordered by expected frequency.\n        for (uint256 i = 0; i < operations.length; i += 1) {\n\n            Operation operation = operations[i];\n\n            if (operation == Operation.BUILD) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                (cachedId, vault) = (vaultId, _build(vaultId, seriesId, ilkId));   // Cache the vault that was just built\n            \n            } else if (operation == Operation.FORWARD_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, uint8, bytes32, bytes32));\n                _forwardPermit(id, isAsset, spender, amount, deadline, v, r, s);\n            \n            } else if (operation == Operation.JOIN_ETHER) {\n                (bytes6 etherId) = abi.decode(data[i], (bytes6));\n                _joinEther(etherId);\n            \n            } else if (operation == Operation.POUR) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _pour(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.SERVE) {\n                (bytes12 vaultId, address to, uint128 ink, uint128 base, uint128 max) = abi.decode(data[i], (bytes12, address, uint128, uint128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _serve(vaultId, vault, to, ink, base, max);\n\n            } else if (operation == Operation.ROLL) {\n                (bytes12 vaultId, bytes6 newSeriesId, uint8 loan, uint128 max) = abi.decode(data[i], (bytes12, bytes6, uint8, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                (vault,) = _roll(vaultId, vault, newSeriesId, loan, max);\n            \n            } else if (operation == Operation.FORWARD_DAI_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, bool, uint8, bytes32, bytes32));\n                _forwardDaiPermit(id, isAsset, spender, nonce, deadline, allowed, v, r, s);\n            \n            } else if (operation == Operation.TRANSFER_TO_POOL) {\n                (bytes6 seriesId, bool base, uint128 wad) =\n                    abi.decode(data[i], (bytes6, bool, uint128));\n                IPool pool = getPool(seriesId);\n                _transferToPool(pool, base, wad);\n            \n            } else if (operation == Operation.ROUTE) {\n                (bytes6 seriesId, bytes memory poolCall) =\n                    abi.decode(data[i], (bytes6, bytes));\n                IPool pool = getPool(seriesId);\n                _route(pool, poolCall);\n            \n            } else if (operation == Operation.EXIT_ETHER) {\n                (address to) = abi.decode(data[i], (address));\n                _exitEther(payable(to));\n            \n            } else if (operation == Operation.CLOSE) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _close(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.REPAY) {\n                (bytes12 vaultId, address to, int128 ink, uint128 min) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repay(vaultId, vault, to, ink, min);\n            \n            } else if (operation == Operation.REPAY_VAULT) {\n                (bytes12 vaultId, address to, int128 ink, uint128 max) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayVault(vaultId, vault, to, ink, max);\n\n            } else if (operation == Operation.REPAY_LADLE) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayLadle(vaultId, vault);\n\n            } else if (operation == Operation.RETRIEVE) {\n                (bytes6 assetId, bool isAsset, address to) = abi.decode(data[i], (bytes6, bool, address));\n                _retrieve(assetId, isAsset, to);\n\n            } else if (operation == Operation.TRANSFER_TO_FYTOKEN) {\n                (bytes6 seriesId, uint256 amount) = abi.decode(data[i], (bytes6, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _transferToFYToken(fyToken, amount);\n            \n            } else if (operation == Operation.REDEEM) {\n                (bytes6 seriesId, address to, uint256 amount) = abi.decode(data[i], (bytes6, address, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _redeem(fyToken, to, amount);\n            \n            } else if (operation == Operation.STIR) {\n                (bytes12 from, bytes12 to, uint128 ink, uint128 art) = abi.decode(data[i], (bytes12, bytes12, uint128, uint128));\n                _stir(from, to, ink, art);  // Too complicated to use caching here\n            \n            } else if (operation == Operation.TWEAK) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _tweak(vaultId, seriesId, ilkId);\n\n            } else if (operation == Operation.GIVE) {\n                (bytes12 vaultId, address to) = abi.decode(data[i], (bytes12, address));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _give(vaultId, to);\n                delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore\n                cachedId = bytes12(0);\n\n            } else if (operation == Operation.DESTROY) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _destroy(vaultId);\n                delete vault;   // Clear the cache\n                cachedId = bytes12(0);\n            \n            } else if (operation == Operation.MODULE) {\n                (address module, bytes memory moduleCall) = abi.decode(data[i], (address, bytes));\n                _moduleCall(module, moduleCall);\n            \n            }\n        }\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function _build(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Change a vault series or collateral.\n    function _tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        return cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function _destroy(bytes12 vaultId)\n        private\n    {\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function _stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        private\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, \"Only origin vault owner\");\n        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, \"Only destination vault owner\");\n        return cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function _serve(bytes12 vaultId, DataTypes.Vault memory vault, address to, uint128 ink, uint128 base, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        IPool pool = getPool(vault.seriesId);\n        \n        art = pool.buyBasePreview(base);\n        balances = _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function _close(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        require (art < 0, \"Only repay debt\");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art));\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, amt);\n    }\n\n    /// @dev Calculate a debt amount for a series in base terms\n    function _debtInBase(bytes6 seriesId, DataTypes.Series memory series, uint128 art)\n        private\n        returns (uint128 amt)\n    {\n        if (uint32(block.timestamp) >= series.maturity) {\n            amt = uint256(art).wmul(cauldron.accrual(seriesId)).u128();\n        } else {\n            amt = art;\n        }\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function _repay(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 min)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        balances = _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function _repayVault(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 base)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        balances = _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function _roll(bytes12 vaultId, DataTypes.Vault memory vault, bytes6 newSeriesId, uint8 loan, uint128 max)\n        private\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        \n        uint128 newDebt;\n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 amt = _debtInBase(vault.seriesId, series, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), amt * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), amt, max);\n            baseJoin.join(address(baseJoin), amt);                  // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (amt * loan) - newDebt);    // Burn the surplus\n        }\n\n        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series\n\n        return cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt.\n    function _repayLadle(bytes12 vaultId, DataTypes.Vault memory vault)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        balances = cauldron.balances(vaultId);\n        \n        uint256 amount = series.fyToken.balanceOf(address(this));\n        amount = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, 0, -(amount.u128().i128()));\n        series.fyToken.burn(address(this), amount);\n    }\n\n    /// @dev Retrieve any asset or fyToken in the Ladle\n    function _retrieve(bytes6 id, bool isAsset, address to) \n        private\n        returns (uint256 amount)\n    {\n        IERC20 token = IERC20(findToken(id, isAsset));\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    // ---- Liquidations ----\n\n    /// @dev Allow liquidation contracts to move assets to wind down vaults\n    function settle(bytes12 vaultId, address user, uint128 ink, uint128 art)\n        external\n        auth\n    {\n        DataTypes.Vault memory vault = getOwnedVault(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n\n        cauldron.slurp(vaultId, ink, art);                                                  // Remove debt and collateral from the vault\n\n        if (ink != 0) {                                                                     // Give collateral to the user\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {                                                                     // Take underlying from user\n            IJoin baseJoin = getJoin(series.baseId);\n            baseJoin.join(user, art);\n        }\n    }\n\n    // ---- Permit management ----\n\n    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken\n    function findToken(bytes6 id, bool isAsset)\n        private view returns (address token)\n    {\n        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);\n        require (token != address(0), \"Token not found\");\n    }\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken\n    function _forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        IERC2612 token = IERC2612(findToken(id, isAsset));\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken\n    function _forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        DaiAbstract token = DaiAbstract(findToken(id, isAsset));\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable { }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function _joinEther(bytes6 etherId)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo`\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function _exitEther(address payable to)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo`\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Pool router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToPool(IPool pool, bool base, uint128 wad)\n        private\n    {\n        IERC20 token = base ? pool.base() : pool.fyToken();\n        token.safeTransferFrom(msg.sender, address(pool), wad);\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function _route(IPool pool, bytes memory data)\n        private\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = address(pool).call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- FYToken router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToFYToken(IFYToken fyToken, uint256 wad)\n        private\n    {\n        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function _redeem(IFYToken fyToken, address to, uint256 wad)\n        private\n        returns (uint256)\n    {\n        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));\n    }\n\n    // ---- Module router ----\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    function _moduleCall(address module, bytes memory moduleCall)\n        private\n        returns (bool success, bytes memory result)\n    {\n        require (modules[module], \"Unregistered module\");\n        (success, result) = module.delegatecall(moduleCall);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"./interfaces/vault/IFYToken.sol\";\nimport \"./interfaces/vault/IOracle.sol\";\nimport \"./interfaces/vault/DataTypes.sol\";\nimport \"./utils/access/AccessControl.sol\";\nimport \"./math/WMul.sol\";\nimport \"./math/WDiv.sol\";\nimport \"./math/CastU128I128.sol\";\nimport \"./math/CastI128U128.sol\";\nimport \"./math/CastU256U32.sol\";\nimport \"./math/CastU256I256.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require (y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\n\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n\n",
        "CodeNames": [
            "Witch.sol",
            "Ladle.sol",
            "Cauldron.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "vaultId",
                    "GIVE",
                    "batch",
                    "buy",
                    "elapsed"
                ],
                "Type": " Users can avoid paying borrowing interest after the fyToken matures",
                "Description": "\nAccording to the protocol design, users have to pay borrowing interest when repaying the debt with underlying tokens after maturity. However, a user can give his vault to Witch and then buy all his collateral using underlying tokens to avoid paying the interest. Besides, this bug could make users less incentivized to repay the debt before maturity and hold the underlying tokens until liquidation.\n\n1. A user creates a new vault and opens a borrowing position as usual.\n2. The maturity date passed. If the user wants to close the position using underlying tokens, he has to pay a borrowing interest (line 350 in Ladle), which is his debt multiplied by the rate accrual (line 373).\n3. Now, the user wants to avoid paying the borrowing interest. He gives his vault to Witch by calling the function batch of Ladle with the operation GIVE.\n4. He then calls the function buy of Witch with the corresponding vaultId to buy all his collateral using underlying tokens.\n\nIn the last step, the elapsed time (line 61) is equal to the current timestamp since the vault is never grabbed by Witch before, and thus the auction time of the vault, cauldron.auctions(vaultId), is 0 (the default mapping value). Therefore, the collateral is sold at a price of balances_.art/balances_.ink (line 74). The user can buy balances_.ink amount of collateral using balances_.art but not paying for borrowing fees.\n\n",
                "Repair": "Recommend not allowing users to give vaults to Witch. And to be more careful, requiring vaultOwners[vaultId] and cauldron.auctions(vaultId) to be non-zero at the beginning of function buy.\n\nalbertocuestacanada (Yield) confirmed(https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856589289):\n  That's a good catch. The mitigation steps are right to avoid this being exploited by malicious users, but it would be better to fix the underlying issue.\n\n The problem is that the Witch always applies a 1:1 exchange rate between underlying and fyToken, which is not true after maturity. As long as this is not fixed, the protocol will lose money after maturity liquidations.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856599112):\n  More specifically, _debtInBase should be a Cauldron public function, and return (debtInFYToken, debtInBase). The Ladle would save a bit in deployment gas; the Witch would use it to determine the underlying / fyToken exchange rate.\n\nalbertocuestacanada (Yield) commented(https://github.com/code-423n4/2021-05-yield-findings/issues/71#issuecomment-856614042):\n  However, since grab wouldn't be called on the Witch, the vault owner wouldn't be registered. With the liquidation being a Dutch auction, the vault owner would only get a portion of his collateral back after paying all the debt. The vault with the remaining collateral would be given to address(0).\n\n There is a small protocol loss from miscalculated vault debt on vaults liquidated after maturity, but no user funds would be at risk.\n\n I would propose a severity of 2, given there are monetary losses, however slight, to the protocol. The attack described can't happen, but it revealed a real issue.\n\n\n"
            }
        ]
    }
]