[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.14;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ILadle.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/src/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/src/DataTypes.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\n\n/// @title  The Witch is a DataTypes.Auction/Liquidation Engine for the Yield protocol\n/// @notice The Witch grabs uncollateralized vaults, replacing the owner by itself. Then it sells\n/// the vault collateral in exchange for underlying to pay its debt. The amount of collateral\n/// given increases over time, until it offers to sell all the collateral for underlying to pay\n/// all the debt. The auction is held open at the final price indefinitely.\n/// @dev After the debt is settled, the Witch returns the vault to its original owner.\ncontract Witch is AccessControl {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n\n    // ==================== User events ====================\n\n    error VaultAlreadyUnderAuction(bytes12 vaultId, address witch);\n    error VaultNotLiquidable(bytes12 vaultId, bytes6 ilkId, bytes6 baseId);\n    error AuctioneerRewardTooHigh(uint128 max, uint128 actual);\n\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n    event Cancelled(bytes12 indexed vaultId);\n    event Ended(bytes12 indexed vaultId);\n    event Bought(\n        bytes12 indexed vaultId,\n        address indexed buyer,\n        uint256 ink,\n        uint256 art\n    );\n\n    // ==================== Governance events ====================\n\n    event Point(bytes32 indexed param, address indexed value);\n    event LineSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    );\n    event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);\n    event AnotherWitchSet(address indexed value, bool isWitch);\n    event IgnoredPairSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        bool ignore\n    );\n    event AuctioneerRewardSet(uint128 auctioneerReward);\n\n    ICauldron public immutable cauldron;\n    ILadle public ladle;\n\n    // Reward given to whomever calls `auction`. It represents a % of the bought collateral\n    uint128 public auctioneerReward = 0.01e18;\n\n    mapping(bytes12 => DataTypes.Auction) public auctions;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Line)) public lines;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Limits)) public limits;\n    mapping(address => bool) public otherWitches;\n    mapping(bytes6 => mapping(bytes6 => bool)) public ignoredPairs;\n\n    constructor(ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    // ======================================================================\n    // =                        Governance functions                        =\n    // ======================================================================\n\n    /// @dev Point to a different ladle\n    /// @param param Name of parameter to set (must be \"ladle\")\n    /// @param value Address of new ladle\n    function point(bytes32 param, address value) external auth {\n        require(param == \"ladle\", \"Unrecognized\");\n        ladle = ILadle(value);\n        emit Point(param, value);\n    }\n\n    /// @dev Governance function to set the parameters that govern how much collateral is sold over time.\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param duration Time that auctions take to go to minimal price\n    /// @param proportion Vault proportion that is set for auction each time\n    /// @param initialOffer Proportion of collateral that is sold at auction start (1e18 = 100%)\n    function setLine(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    ) external auth {\n        require(initialOffer <= 1e18, \"InitialOffer above 100%\");\n        require(proportion <= 1e18, \"Proportion above 100%\");\n        require(\n            initialOffer == 0 || initialOffer >= 0.01e18,\n            \"InitialOffer below 1%\"\n        );\n        require(proportion >= 0.01e18, \"Proportion below 1%\");\n        lines[ilkId][baseId] = DataTypes.Line({\n            duration: duration,\n            proportion: proportion,\n            initialOffer: initialOffer\n        });\n        emit LineSet(ilkId, baseId, duration, proportion, initialOffer);\n    }\n\n    /// @dev Governance function to set auction limits.\n    ///  - the auction duration to calculate liquidation prices\n    ///  - the proportion of the collateral that will be sold at auction start\n    ///  - the maximum collateral that can be auctioned at the same time\n    ///  - the minimum collateral that must be left when buying, unless buying all\n    ///  - The decimals for maximum and minimum\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param max Maximum concurrent auctioned collateral\n    function setLimit(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint128 max\n    ) external auth {\n        limits[ilkId][baseId] = DataTypes.Limits({\n            max: max,\n            sum: limits[ilkId][baseId].sum // sum is initialized at zero, and doesn't change when changing any ilk parameters\n        });\n        emit LimitSet(ilkId, baseId, max);\n    }\n\n    /// @dev Governance function to set other liquidation contracts that may have taken vaults already.\n    /// @param value The address that may be set/unset as another witch\n    /// @param isWitch Is this address a witch or not\n    function setAnotherWitch(address value, bool isWitch) external auth {\n        otherWitches[value] = isWitch;\n        emit AnotherWitchSet(value, isWitch);\n    }\n\n    /// @dev Governance function to ignore pairs that can't be liquidated\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param ignore Should this pair be ignored for liquidation\n    function setIgnoredPair(\n        bytes6 ilkId,\n        bytes6 baseId,\n        bool ignore\n    ) external auth {\n        ignoredPairs[ilkId][baseId] = ignore;\n        emit IgnoredPairSet(ilkId, baseId, ignore);\n    }\n\n    /// @dev Governance function to set the % paid to whomever starts an auction\n    /// @param auctioneerReward_ New % to be used, must have 18 dec precision\n    function setAuctioneerReward(uint128 auctioneerReward_) external auth {\n        if (auctioneerReward_ > 1e18) {\n            revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);\n        }\n        auctioneerReward = auctioneerReward_;\n        emit AuctioneerRewardSet(auctioneerReward_);\n    }\n\n    // ======================================================================\n    // =                    Auction management functions                    =\n    // ======================================================================\n\n    /// @dev Put an undercollateralized vault up for liquidation\n    /// @param vaultId Id of vault to liquidate\n    /// @param to Receiver of the auctioneer reward\n    function auction(bytes12 vaultId, address to)\n        external\n        returns (DataTypes.Auction memory auction_)\n    {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        if (vault.owner == address(this) || otherWitches[vault.owner]) {\n            revert VaultAlreadyUnderAuction(vaultId, vault.owner);\n        }\n        DataTypes.Series memory series = cauldron.series(vault.seriesId);\n        if (ignoredPairs[vault.ilkId][series.baseId]) {\n            revert VaultNotLiquidable(vaultId, vault.ilkId, series.baseId);\n        }\n\n        require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        DataTypes.Debt memory debt = cauldron.debt(series.baseId, vault.ilkId);\n\n        // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n        // If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n        // This avoids the scenario where some vaults might be too large to be auctioned.\n        DataTypes.Limits memory limits_ = limits[vault.ilkId][\n            series.baseId\n        ];\n        require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n\n        auction_ = _calcAuction(vault, series, to, balances, debt);\n\n        limits_.sum += auction_.ink;\n        limits[vault.ilkId][series.baseId] = limits_;\n\n        auctions[vaultId] = auction_;\n\n        _auctionStarted(vaultId);\n    }\n\n    /// @dev Moves the vault ownership to the witch.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionStarted(bytes12 vaultId) internal virtual {\n        // The Witch is now in control of the vault under auction\n        cauldron.give(vaultId, address(this));\n        emit Auctioned(vaultId, uint32(block.timestamp));\n    }\n\n    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed\n    /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer\n    /// use `_calcPayout`\n    function _calcAuction(\n        DataTypes.Vault memory vault,\n        DataTypes.Series memory series,\n        address to,\n        DataTypes.Balances memory balances,\n        DataTypes.Debt memory debt\n    ) internal view returns (DataTypes.Auction memory) {\n        // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.\n        DataTypes.Line storage line = lines[vault.ilkId][series.baseId];\n        uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n        if (art < debt.min * (10**debt.dec)) art = balances.art;\n        uint128 ink = (art == balances.art)\n            ? balances.ink\n            : uint256(balances.ink).wmul(line.proportion).u128();\n\n        return\n            DataTypes.Auction({\n                owner: vault.owner,\n                start: uint32(block.timestamp), // Overflow is fine\n                seriesId: vault.seriesId,\n                baseId: series.baseId,\n                ilkId: vault.ilkId,\n                art: art,\n                ink: ink,\n                auctioneer: to\n            });\n    }\n\n    /// @dev Cancel an auction for a vault that isn't undercollateralized anymore\n    /// @param vaultId Id of vault to return\n    function cancel(bytes12 vaultId) external {\n        DataTypes.Auction storage auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n        require(cauldron.level(vaultId) >= 0, \"Undercollateralized\");\n\n        // Update concurrent collateral under auction\n        limits[auction_.ilkId][auction_.baseId].sum -= auction_.ink;\n\n        _auctionEnded(vaultId, auction_.owner);\n\n        emit Cancelled(vaultId);\n    }\n\n    /// @dev Moves the vault ownership back to the original owner & clean internal state.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionEnded(bytes12 vaultId, address owner) internal virtual {\n        cauldron.give(vaultId, owner);\n        delete auctions[vaultId];\n        emit Ended(vaultId);\n    }\n\n    // ======================================================================\n    // =                          Bidding functions                         =\n    // ======================================================================\n\n    /// @dev Pay at most `maxBaseIn` of the debt in a vault in liquidation, getting at least `minInkOut` collateral.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver of the collateral bought\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @param maxBaseIn Maximum amount of base that the liquidator will pay\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return baseIn Amount of underlying taken\n    function payBase(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxBaseIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 baseIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Find out how much debt is being repaid\n        uint128 artIn = uint128(\n            cauldron.debtFromBase(auction_.seriesId, maxBaseIn)\n        );\n\n        // If offering too much base, take only the necessary.\n        artIn = artIn > auction_.art ? auction_.art : artIn;\n        baseIn = cauldron.debtToBase(auction_.seriesId, artIn);\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (baseIn != 0) {\n            // Take underlying from liquidator\n            IJoin baseJoin = ladle.joins(auction_.baseId);\n            require(baseJoin != IJoin(address(0)), \"Join not found\");\n            baseJoin.join(msg.sender, baseIn.u128());\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.\n    /// @notice If too much fyToken are offered, only the necessary amount are taken.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver for the collateral bought\n    /// @param maxArtIn Maximum amount of fyToken that will be paid\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return artIn Amount of fyToken taken\n    function payFYToken(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxArtIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // If offering too much fyToken, take only the necessary.\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (artIn != 0) {\n            // Burn fyToken from liquidator\n            cauldron.series(auction_.seriesId).fyToken.burn(msg.sender, artIn);\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)\n    function _payInk(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 liquidatorCut,\n        uint256 auctioneerCut\n    ) internal {\n        // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check\n        if (liquidatorCut > 0) {\n            IJoin ilkJoin = ladle.joins(auction_.ilkId);\n            require(ilkJoin != IJoin(address(0)), \"Join not found\");\n\n            // Pay auctioneer's cut if necessary\n            if (auctioneerCut > 0) {\n                ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());\n            }\n\n            // Give collateral to the liquidator\n            ilkJoin.exit(to, liquidatorCut.u128());\n        }\n    }\n\n    /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.\n    /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.\n    function _updateAccounting(\n        bytes12 vaultId,\n        DataTypes.Auction memory auction_,\n        uint256 inkOut,\n        uint256 artIn\n    ) internal {\n        // Duplicate check, but guarantees data integrity\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Update concurrent collateral under auction\n        DataTypes.Limits memory limits_ = limits[auction_.ilkId][\n            auction_.baseId\n        ];\n\n        // Update local auction\n        {\n            if (auction_.art == artIn) {\n                // If there is no debt left, return the vault with the collateral to the owner\n                _auctionEnded(vaultId, auction_.owner);\n\n                // Update limits - reduce it by the whole auction\n                limits_.sum -= auction_.ink;\n            } else {\n                // Ensure enough dust is left\n                DataTypes.Debt memory debt = cauldron.debt(\n                    auction_.baseId,\n                    auction_.ilkId\n                );\n                require(\n                    auction_.art - artIn >= debt.min * (10**debt.dec),\n                    \"Leaves dust\"\n                );\n\n                // Update the auction\n                auction_.ink -= inkOut.u128();\n                auction_.art -= artIn.u128();\n\n                // Store auction changes\n                auctions[vaultId] = auction_;\n\n                // Update limits - reduce it by whatever was bought\n                limits_.sum -= inkOut.u128();\n            }\n        }\n\n        // Store limit changes\n        limits[auction_.ilkId][auction_.baseId] = limits_;\n\n        // Update accounting at Cauldron\n        cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n    }\n\n    /// @dev Logs that a certain amount of a vault was liquidated\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _collateralBought(\n        bytes12 vaultId,\n        address buyer,\n        uint256 ink,\n        uint256 art\n    ) internal virtual {\n        emit Bought(vaultId, buyer, ink, art);\n    }\n\n    // ======================================================================\n    // =                         Quoting functions                          =\n    // ======================================================================\n\n    /*\n\n       x x x\n     x      x    Hi Fren!\n    x  .  .  x   I want to buy this vault under auction!  I'll pay\n    x        x   you in the same `base` currency of the debt, or in fyToken, but\n    x        x   I want no less than `uint min` of the collateral, ok?\n    x   ===  x\n    x       x\n      xxxxx\n        x                             __  Ok Fren!\n        x     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  _(\\    |@@|\n        xxxxxx\u2502 BASE BUCKS \u2502 (__/\\__ \\--/ __\n        x     \u2502     OR     \u2502    \\___|----|  |   __\n        x     \u2502   FYTOKEN  \u2502        \\ }{ /\\ )_ / _\\\n       x x    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        /\\__/\\ \\__O (__\n                                   (--/\\--)    \\__/\n                            \u2502      _)(  )(_\n                            \u2502     `---''---`\n                            \u25bc\n      _______\n     /  12   \\  First lets check how much time `t` is left on the auction\n    |    |    | because that helps us determine the price we will accept\n    |9   |   3| for the debt! Yay!\n    |     \\   |                       p + (1 - p) * t\n    |         |\n     \\___6___/          (p is the auction starting price!)\n\n                            \u2502\n                            \u2502\n                            \u25bc                  (\\\n                                                \\ \\\n    Then the Cauldron updates our internal    __    \\/ ___,.-------..__        __\n    accounting by slurping up the debt      //\\\\ _,-'\\\\               `'--._ //\\\\\n    and the collateral from the vault!      \\\\ ;'      \\\\                   `: //\n                                            `(          \\\\                   )'\n    The Join  then dishes out the collateral   :.          \\\\,----,         ,;\n    to you, dear user. And the debt is          `.`--.___   (    /  ___.--','\n    settled with the base join or debt fyToken.   `.     ``-----'-''     ,'\n                                                    -.               ,-\n                                                       `-._______.-'gpyy\n\n\n    */\n    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount\n    /// Works for both Auctioned and ToBeAuctioned vaults\n    /// @param vaultId The vault to get a quote for\n    /// @param to Address that would get the collateral bought\n    /// @param maxArtIn How much of the vault debt will be paid. GT than available art means all\n    /// @return liquidatorCut How much collateral the liquidator is expected to get\n    /// @return auctioneerCut How much collateral the auctioneer is expected to get. 0 if liquidator == auctioneer\n    /// @return artIn How much debt the liquidator is expected to pay\n    function calcPayout(\n        bytes12 vaultId,\n        address to,\n        uint256 maxArtIn\n    )\n        external\n        view\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n\n        // If the vault hasn't been auctioned yet, we calculate what values it'd have if it was started right now\n        if (auction_.start == 0) {\n            DataTypes.Series memory series = cauldron.series(vault.seriesId);\n            DataTypes.Balances memory balances = cauldron.balances(vaultId);\n            DataTypes.Debt memory debt = cauldron.debt(\n                series.baseId,\n                vault.ilkId\n            );\n            auction_ = _calcAuction(vault, series, to, balances, debt);\n        }\n\n        // GT check is to cater for partial buys right before this method executes\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n    }\n\n    /// @notice Return how much collateral should be given out.\n    function _calcPayout(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 artIn\n    ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) {\n        // Calculate how much collateral to give for paying a certain amount of debt, at a certain time, for a certain vault.\n        // inkOut = (artIn / totalArt) * totalInk * (p + (1 - p) * t)\n        DataTypes.Line memory line_ = lines[auction_.ilkId][\n            auction_.baseId\n        ];\n        uint256 duration = line_.duration;\n        uint256 initialProportion = line_.initialOffer;\n\n        // If the world has not turned to ashes and darkness, auctions will malfunction on\n        // the 7th of February 2106, at 06:28:16 GMT\n        // TODO: Replace this contract before then \ud83d\ude30\n        // UPDATE: Added reminder to Google calendar \u2705\n        uint256 elapsed;\n        uint256 proportionNow;\n        unchecked {\n            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine\n        }\n        if (duration == type(uint32).max) {     // Interpreted as infinite duration\n            proportionNow = initialProportion;\n        } else if (elapsed > duration) {\n            proportionNow = 1e18;\n        } else {\n            proportionNow =\n                uint256(initialProportion) +\n                uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));\n        }\n\n        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);\n        liquidatorCut = inkAtEnd.wmul(proportionNow);\n        if (auction_.auctioneer != to) {\n            auctioneerCut = liquidatorCut.wmul(auctioneerReward);\n            liquidatorCut -= auctioneerCut;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Witch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "jsx\nif (auctioneerCut  0) {\n    ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());\n}\n"
                ],
                "Type": "  Someone can create non-liquidatable auction if the collateral asset fails on transferring to  address(0) ",
                "Description": "\nWitch.sol#L176(https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L176)<br\nWitch.sol#L399(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L399)<br\n\nMight lead to systematic debt. Cause errors for liquidators to run normally.\n\n\nIn the function auction, there is an input validation around whether the to is address(0) or not. And if the auctioneerReward is set to an value  0 (as default),  each liquidate call will call Join module to pay out to auctioneer with the following line:\n\njsx\nif (auctioneerCut  0) {\n    ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());\n}\n\n\nThis line will revert if auctioneer is set to address(0) on some tokens (revert on transferring to address(0) is a default behaviour of the OpenZeppelin template(https://www.notion.so/Yield-Witch-555e6981c26b41008d03a504077b4770)). So if someone start an auction with to = address(0), this auction becomes un-liquidatable.\n\nA malicious user can run a bot to monitor his own vault, and if they got underwater and they don\u2019t have enough collateral to top up, they can immediately start an auction on their own vault and set actioneer to 0 to avoid actually being liquidated, which breaks the design of the system.\n\n",
                "Repair": "\nAdd check while starting an auction:\n\njsx\nfunction auction(bytes12 vaultId, address to)\n    external\n    returns (DataTypes.Auction memory auction_)\n{\n    require (to != address(0), \"invalid auctioneer\");\n\t\t...\n}\t\t\n\n\nalcueca (Yield) confirmed and commented(https://github.com/code-423n4/2022-07-yield-findings/issues/116#issuecomment-1191312612):\n  Best finding of the contest :trophy: \n\nPierrickGT (judge) commented(https://github.com/code-423n4/2022-07-yield-findings/issues/116#issuecomment-1204165927):\n  Most critical vulnerability found during the audit since a malicious user could open a vault and never get liquidated, it would force the protocol to take on bad debts.\n The warden did a great job of describing the issue and providing the sponsor with a detailed fix.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "cancel()"
                ],
                "Type": " Vaults that are over-collateralised after partial liquidation are possibly subject to further liquidations",
                "Description": "\nIf a vault becomes over-collateralised after a partial liquidation, it is still subject to further liquidation as the auction isn\u2019t closed. The vault owner has to call cancel() himself, or trust other altruistic actors to perform this action on his behalf. Liquidators will unlikely do it because they are economically incentivised not to do so.\n\nOne can however argue that this is mitigated by the fact that protocol (governance) sets the vault proportion that can be auctioned. Regardless of whether the fact that the vault is over-collateralised after partial liquidations, the liquidators arguably are given the right to carry out further liquidations up to the proportion set.\n\nNevertheless, a reason for a revised liquidations witch contract is that \u201cMore often than not, liquidated users have lost all their collateral as we have failed to make liquidations competitive.\u201d. Hence, it might make sense to ensure that users need not lose more collateral than necessary.\n\n",
                "Repair": "\nConsider checking if the vault is over-collateralized (maybe in _updateAccounting()) and close the auction if it is. This however adds complexity to the liquidation logic, as you have to update the cauldron first cauldron.slurp() before checking and updating the collateralization status. It will also break the CEI pattern, which might be unfavourable.\n\n\n"
            },
            {
                "Name": "-02",
                "Location": [
                    "diff\nelse if (elapsed  duration)\n+ else if (elapsed = duration)\n",
                    "//solidity\nproportionNow =\n  uint256(initialProportion) +\n  uint256(1e18 initialProportion).wmul(elapsed.wdiv(duration));\n\n// = initialProportion + (1e18 initialProportion).wmul(1e18)\n// = initialProportion + (1e18 initialProportion) * 1e18 / 1e18\n// = initialProportion + 1e18 initialProportion\n// = 1e18\n"
                ],
                "Type": " Comparison in  _calcPayout()  should include equality",
                "Description": "\nWitch.sol#L586(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586)<br\n\n\ndiff\nelse if (elapsed  duration)\n+ else if (elapsed = duration)\n\n\n\nIn the case where elapsed == duration, proportionNow evaluates to 1e18, which is the same result when elapsed  duration. Proof below.\n\nsolidity\nproportionNow =\n  uint256(initialProportion) +\n  uint256(1e18 initialProportion).wmul(elapsed.wdiv(duration));\n\n// = initialProportion + (1e18 initialProportion).wmul(1e18)\n// = initialProportion + (1e18 initialProportion) * 1e18 / 1e18\n// = initialProportion + 1e18 initialProportion\n// = 1e18\n\n\nOf slightly greater importance, this handles the edge case when elapsed = duration = 0, ie. the liquidation transaction is included in the same block / has the same timestamp as the auction initialization transaction\n\n",
                "Repair": "\nAs per the TLDR.\n\n### P.S. Regarding zero duration auctions\n\nSince the proportion given for zero duration auctions is 1e18, it is equivalent to an auction of infinite duration with 100% initial offer: duration == type(uint32).max and line_.initialOffer = 1e18.\n\n\n"
            },
            {
                "Name": "-03",
                "Location": [
                    "auctioneerCut",
                    "auction()"
                ],
                "Type": " Incorrect description for  auctioneerCut ",
                "Description": "\nWitch.sol#L284(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284)<br\n\nWitch.sol#L342(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342)<br\n\n\nTechnically, the auctioneerCut goes to the to address specified by the auctioneer when auction() is called, which, while unlikely, may not be the auctioneer himself. Also, the comparison is done against the to address specified, not the caller / msg.sender as the comment implies.\n\n",
                "Repair": "\ndiff\nAmount paid to whomever started the auction. 0 if it's the same address that's calling this method\n+ Amount paid to address specified by whomever started the auction. 0 if it's the same as the to address\n\n\n\n"
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\n///  the auction duration to calculate liquidation prices\n///  the proportion of the collateral that will be sold at auction start\n///  the maximum collateral that can be auctioned at the same time\n///  the minimum collateral that must be left when buying, unless buying all\n///  The decimals for maximum and minimum\n"
                ],
                "Type": " Incorrect natspec for  setLimit() ",
                "Description": "\nWitch.sol#L118-L122(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122)<br\n\n\nThe comments seem outdated as the only parameter that is updated by the function is the maximum collateral that can be concurrently auctioned off.\n\nsolidity\n///  the auction duration to calculate liquidation prices\n///  the proportion of the collateral that will be sold at auction start\n///  the maximum collateral that can be auctioned at the same time\n///  the minimum collateral that must be left when buying, unless buying all\n///  The decimals for maximum and minimum\n\n\n",
                "Repair": "\nSuggest removing / updating the referenced comments.\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [],
                "Type": " Incorrect amount of Collateral moves for Auction",
                "Description": "\nIt was observed that the debt and collateral which moves for Auction is calculated incorrectly. In case where line.proportion is set to small value, chances are art will become lower than min debt. This causes whole collateral to go for auction, which was not expected.\n\n\n1.  Assume line.proportion is set to 10% which is a valid value(https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L108)\n\n2.  Auction is started on Vault associated with collateral & base representing line from Step 1\n\n3.  Now debt and collateral to be sold are calculated in _calcAuction(https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L223)\n\n<!----\n\n    uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n            if (art < debt.min * (10debt.dec)) art = balances.art;\n            uint128 ink = (art == balances.art)\n                ? balances.ink\n                : uint256(balances.ink).wmul(line.proportion).u128();\n\n4.  Now lets say debt (art) on this vault was amount 10, collateral (ink) was amount 9, debt.min &ast; (10&ast;&ast;debt.dec) was amount 2\n\n5.  Below calculation occurs\n\n<!----\n\n    uint128 art = uint256(balances.art).wmul(line.proportion).u128(); // which makes art = 10*10% =1\n            if (art < debt.min * (10debt.dec)) art = balances.art;   // since 1<2 so art=10\n            uint128 ink = (art == balances.art)                                 // Since art is 10 so ink=9\n                ? balances.ink\n                : uint256(balances.ink).wmul(line.proportion).u128();\n\n6.  So full collateral and full debt are placed for Auction even though only 10% was meant for Auction. Even if it was lower than min debt, auction amount should have only increased up to the point where minimum debt limit is reached\n\n",
                "Repair": "\nRevise the calculation like below\n\n    uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n    uint128 ink=0;\n            if (art < debt.min * (10debt.dec)) \n    {\n    art = debt.min * (10debt.dec);\n    (balances.ink<art) ? (ink=balances.ink) : (ink=art)\n    } else {\n    ink=uint256(balances.ink).wmul(line.proportion).u128();\n    }\n\nhickuphh3 (warden) commented(https://github.com/code-423n4/2022-07-yield-findings/issues/123#issuecomment-1187535362):\n   debt.min * (10debt.dec) was amount 2\n \n Only way for this to happen is for the token's decimals to be 0, which is an edge case. \n \n Anyway, the issue is invalid because it is intended for the full collateral to be offered if it is below the minimum debt amount, ie. vault proportion is to be disregarded: // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.(https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L230)\n\nalcueca (Yield) confirmed and commented(https://github.com/code-423n4/2022-07-yield-findings/issues/123#issuecomment-1191350641):\n  The finding is valid, but it is a bit complicated.\n \n The behaviour should be:\n  1. If the part of the vault for auction is below dust, increase to dust.\n  2. If the remaining part of the vault is below dust, increase to 100%.\n\nPierrickGT (judge) commented(https://github.com/code-423n4/2022-07-yield-findings/issues/123#issuecomment-1204201695):\n  This is the second most critical vulnerability found during the audit.<br\n This issue is less critical than H-01 (#116)(https://github.com/code-423n4/2022-07-yield-findings/issues/116) since the protocol would not take on bad debts but users may lose their entire collateral when only part of their collateral should have been put to auction.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 40 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-07-yield-findings/issues/33) by hickuphh3 received the top score from the judge.\n\n*The following wardens also submitted reports: horsefacts(https://github.com/code-423n4/2022-07-yield-findings/issues/111), IllIllI(https://github.com/code-423n4/2022-07-yield-findings/issues/48), 0x29A(https://github.com/code-423n4/2022-07-yield-findings/issues/64), Waze(https://github.com/code-423n4/2022-07-yield-findings/issues/50), ak1(https://github.com/code-423n4/2022-07-yield-findings/issues/102), 0xNazgul(https://github.com/code-423n4/2022-07-yield-findings/issues/42), wastewa(https://github.com/code-423n4/2022-07-yield-findings/issues/52), rajatbeladiya(https://github.com/code-423n4/2022-07-yield-findings/issues/37), Meera(https://github.com/code-423n4/2022-07-yield-findings/issues/100), &#95;&#95;141345&#95;&#95;(https://github.com/code-423n4/2022-07-yield-findings/issues/76), hyh(https://github.com/code-423n4/2022-07-yield-findings/issues/28), peritoflores(https://github.com/code-423n4/2022-07-yield-findings/issues/166), simon135(https://github.com/code-423n4/2022-07-yield-findings/issues/119), Chom(https://github.com/code-423n4/2022-07-yield-findings/issues/135), rbserver(https://github.com/code-423n4/2022-07-yield-findings/issues/86), ladboy233(https://github.com/code-423n4/2022-07-yield-findings/issues/80), 0x52(https://github.com/code-423n4/2022-07-yield-findings/issues/40), kenzo(https://github.com/code-423n4/2022-07-yield-findings/issues/91), exd0tpy(https://github.com/code-423n4/2022-07-yield-findings/issues/75), hansfriese(https://github.com/code-423n4/2022-07-yield-findings/issues/54), Trumpero(https://github.com/code-423n4/2022-07-yield-findings/issues/103), karanctf(https://github.com/code-423n4/2022-07-yield-findings/issues/105), c3phas(https://github.com/code-423n4/2022-07-yield-findings/issues/147), csanuragjain(https://github.com/code-423n4/2022-07-yield-findings/issues/144), asutorufos(https://github.com/code-423n4/2022-07-yield-findings/issues/136), rokinot(https://github.com/code-423n4/2022-07-yield-findings/issues/177), Deivitto(https://github.com/code-423n4/2022-07-yield-findings/issues/176), cRat1st0s(https://github.com/code-423n4/2022-07-yield-findings/issues/72), reassor(https://github.com/code-423n4/2022-07-yield-findings/issues/89), TomJ(https://github.com/code-423n4/2022-07-yield-findings/issues/93), delfin454000(https://github.com/code-423n4/2022-07-yield-findings/issues/94), hake(https://github.com/code-423n4/2022-07-yield-findings/issues/27), kyteg(https://github.com/code-423n4/2022-07-yield-findings/issues/87), ReyAdmirado(https://github.com/code-423n4/2022-07-yield-findings/issues/31), ElKu(https://github.com/code-423n4/2022-07-yield-findings/issues/96), pashov(https://github.com/code-423n4/2022-07-yield-findings/issues/58), Funen(https://github.com/code-423n4/2022-07-yield-findings/issues/107), fatherOfBlocks(https://github.com/code-423n4/2022-07-yield-findings/issues/18), and SooYa(https://github.com/code-423n4/2022-07-yield-findings/issues/174).*\n\n## Codebase Impressions & Summary\n\n### Functionality\n\nThe revised witch (liquidation engine) contract includes the following improvements over the previous version. As stated in the README, they are:\n\n1.  Greater flexibility in exploring different liquidation models.\n2.  Making liquidations more profitable for liquidators by allowing payments in fyToken.\n3.  Introduce a mechanism to reward starting an auction.\n4.  Allow fine-tuning of all parameters for any collateral/underlying pair.\n5.  Correct bugs.\n\nThe liquidations flow was quite easy to follow as it consists of the following:\n\n1.  Liquidation parameters are defined by governance functions (auction duration, vault proportion, auctioneer reward etc.)\n2.  Starting an auction: auction()\n3.  Liquidators executing the liquidations: payBase() and payFYToken()\n4.  Either the entire vault collateral has been auctioned off, or cancel() is called to prematurely end the auction\n\n### Documentation\n\nThe README was very extensive and thorough, and succinctly explained design considerations made. Flow diagrams were provided to help visualise the interactions required between different contracts. Inline comments were appropriate too, aided in understanding the functionality.\n\n### Tests\n\nAll foundry tests passed as expected. One area of improvement is to have mainnet forking tests, since mocking is used for the external contracts. Running forge coverage unfortunately didn\u2019t work. I suspect it is due to the instability of the feature rather than the fault of the tests.\n\n### Gas Optimizations\n\nCasting could be avoided if input / output params were defined appropriately. For instance, inkOut, artIn in _updateAccounting(), and liquidatorCut and auctioneerCut could have been uint128 instead of uint256.\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n// There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n// If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n// This avoids the scenario where some vaults might be too large to be auctioned.\n"
                ],
                "Type": " Modify comment to soft limit check for clarity",
                "Description": "\nWitch.sol#L194-L196(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196)<br\n\nWitch.sol#L200(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200)<br\n\nWitch.sol#L204(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204)<br\n\n\nThe limit check is done before the summation to the total collateral allowable for liquidation. One may consider this to be a bug, but the README explains why this is the case:\n\n\nNote that the first auction to reach the limit is allowed to pass it, so that there is never the situation where a vault would be too big to ever be auctioned.\n\n\nThe inline comments have this as well, but isn\u2019t as clearly put as the README.\n\nsolidity\n// There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n// If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n// This avoids the scenario where some vaults might be too large to be auctioned.\n\n\n",
                "Repair": "\nFor greater clarity, I would suggesting modifying the inline comment to be worded similar as the README.\n\ndiff\n// There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n// If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n+ // The first auction to reach or exceed the limit is allowed to pass it, but subsequently, no more vaults of that collateral can be put for auction.\n// This avoids the scenario where some vaults might be too large to be auctioned.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.14;\n\nimport \"forge-std/src/Test.sol\";\nimport \"./utils/TestConstants.sol\";\nimport \"./utils/Mocks.sol\";\n\nimport \"@yield-protocol/vault-interfaces/src/IWitch.sol\";\nimport \"../Witch.sol\";\n\nabstract contract WitchStateZero is Test, TestConstants {\n    using Mocks for *;\n\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n    event Cancelled(bytes12 indexed vaultId);\n    event Ended(bytes12 indexed vaultId);\n    event Bought(\n        bytes12 indexed vaultId,\n        address indexed buyer,\n        uint256 ink,\n        uint256 art\n    );\n    event LineSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    );\n    event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);\n    event Point(bytes32 indexed param, address indexed value);\n    event AnotherWitchSet(address indexed a, bool isWitch);\n    event IgnoredPairSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        bool ignore\n    );\n    event AuctioneerRewardSet(uint128 auctioneerReward);\n\n    bytes12 internal constant VAULT_ID = \"vault\";\n    bytes6 internal constant ILK_ID = ETH;\n    bytes6 internal constant BASE_ID = USDC;\n    bytes6 internal constant SERIES_ID = FYETH2206;\n    uint32 internal constant AUCTION_DURATION = 1 hours;\n\n    // address internal admin;\n    address internal deployer = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;\n    address internal ada = address(0xada);\n    address internal bob = address(0xb0b);\n    address internal bot = address(0xb07);\n    address internal bad = address(0xbad);\n    address internal cool = address(0xc001);\n\n    ICauldron internal cauldron;\n    ILadle internal ladle;\n\n    Witch internal witch;\n    IWitch internal iWitch;\n\n    function setUp() public virtual {\n        cauldron = ICauldron(Mocks.mock(\"Cauldron\"));\n        ladle = ILadle(Mocks.mock(\"Ladle\"));\n\n        vm.startPrank(ada);\n        witch = new Witch(cauldron, ladle);\n        witch.grantRole(Witch.point.selector, ada);\n        witch.grantRole(Witch.setLine.selector, ada);\n        witch.grantRole(Witch.setLimit.selector, ada);\n        witch.grantRole(Witch.setAnotherWitch.selector, ada);\n        witch.grantRole(Witch.setIgnoredPair.selector, ada);\n        witch.grantRole(Witch.setAuctioneerReward.selector, ada);\n        vm.stopPrank();\n\n        vm.label(ada, \"ada\");\n        vm.label(bob, \"bob\");\n\n        iWitch = IWitch(address(witch));\n    }\n}\n\ncontract WitchStateZeroTest is WitchStateZero {\n    function testPointRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.point(\"ladle\", bad);\n    }\n\n    function testPointRequiresLadle() public {\n        vm.prank(ada);\n        vm.expectRevert(\"Unrecognized\");\n        witch.point(\"cauldron\", bad);\n    }\n\n    function testPoint() public {\n        vm.expectEmit(true, true, false, true);\n        emit Point(\"ladle\", cool);\n\n        vm.prank(ada);\n        witch.point(\"ladle\", cool);\n\n        assertEq(address(witch.ladle()), cool);\n    }\n\n    function testSetLineRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.setLine(\"\", \"\", 0, 0, 0);\n    }\n\n    function testSetLineRequiresInitialOfferTooHigh() public {\n        vm.prank(ada);\n        vm.expectRevert(\"InitialOffer above 100%\");\n        witch.setLine(\"\", \"\", 0, 0, 1e18 + 1);\n    }\n\n    function testSetLineRequiresProportionTooHigh() public {\n        vm.prank(ada);\n        vm.expectRevert(\"Proportion above 100%\");\n        witch.setLine(\"\", \"\", 0, 1e18 + 1, 0);\n    }\n\n    function testSetLineRequiresInitialOfferTooLow() public {\n        vm.prank(ada);\n        vm.expectRevert(\"InitialOffer below 1%\");\n        witch.setLine(\"\", \"\", 0, 0, 0.01e18 - 1);\n    }\n\n    function testSetLineRequiresProportionTooLow() public {\n        vm.prank(ada);\n        vm.expectRevert(\"Proportion below 1%\");\n        witch.setLine(\"\", \"\", 0, 0.01e18 - 1, 0);\n    }\n\n    function testSetLine() public {\n        uint64 proportion = 0.5e18;\n        uint64 initialOffer = 0.75e18;\n\n        vm.expectEmit(true, true, false, true);\n        emit LineSet(\n            ILK_ID,\n            BASE_ID,\n            AUCTION_DURATION,\n            proportion,\n            initialOffer\n        );\n\n        vm.prank(ada);\n        witch.setLine(\n            ILK_ID,\n            BASE_ID,\n            AUCTION_DURATION,\n            proportion,\n            initialOffer\n        );\n\n        (uint32 _duration, uint64 _proportion, uint64 _initialOffer) = witch\n            .lines(ILK_ID, BASE_ID);\n\n        assertEq(_duration, AUCTION_DURATION);\n        assertEq(_proportion, proportion);\n        assertEq(_initialOffer, initialOffer);\n    }\n\n    function testSetLimitRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.setLimit(\"\", \"\", 0);\n    }\n\n    function testSetLimit() public {\n        uint96 max = 1;\n\n        vm.expectEmit(true, true, false, true);\n        emit LimitSet(ILK_ID, BASE_ID, max);\n\n        vm.prank(ada);\n        witch.setLimit(ILK_ID, BASE_ID, max);\n\n        (uint128 _max, uint128 _sum) = witch.limits(ILK_ID, BASE_ID);\n\n        assertEq(_max, max);\n        assertEq(_sum, 0);\n    }\n\n    function testSetAnotherWitchRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.setAnotherWitch(address(0), true);\n    }\n\n    function testSetAnotherWitch() public {\n        address anotherWitch = Mocks.mock(\"anotherWitch\");\n\n        vm.expectEmit(true, true, false, true);\n        emit AnotherWitchSet(anotherWitch, true);\n\n        vm.prank(ada);\n        witch.setAnotherWitch(anotherWitch, true);\n\n        assertTrue(witch.otherWitches(anotherWitch));\n    }\n\n    function testSetIgnoredPairRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.setIgnoredPair(\"\", \"\", true);\n    }\n\n    function testSetIgnoredPair() public {\n        vm.expectEmit(true, true, false, true);\n        emit IgnoredPairSet(ILK_ID, BASE_ID, true);\n\n        vm.prank(ada);\n        witch.setIgnoredPair(ILK_ID, BASE_ID, true);\n\n        assertTrue(witch.ignoredPairs(ILK_ID, BASE_ID));\n    }\n\n    function testSetAuctioneerRewardRequiresAuth() public {\n        vm.prank(bob);\n        vm.expectRevert(\"Access denied\");\n        witch.setAuctioneerReward(0);\n    }\n\n    function testSetAuctioneerRewardTooHigh() public {\n        vm.prank(ada);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Witch.AuctioneerRewardTooHigh.selector,\n                1e18,\n                1.00001e18\n            )\n        );\n        witch.setAuctioneerReward(1.00001e18);\n    }\n\n    function testSetAuctioneerReward() public {\n        vm.expectEmit(true, true, false, true);\n        emit AuctioneerRewardSet(0.02e18);\n\n        vm.prank(ada);\n        witch.setAuctioneerReward(0.02e18);\n\n        assertEq(witch.auctioneerReward(), 0.02e18);\n    }\n}\n\nabstract contract WitchWithMetadata is WitchStateZero {\n    using Mocks for *;\n\n    DataTypes.Vault vault;\n    DataTypes.Series series;\n    DataTypes.Balances balances;\n    DataTypes.Debt debt;\n\n    uint96 max = 100e18;\n    uint24 dust = 5000;\n    uint8 dec = 6;\n\n    uint64 proportion = 0.5e18;\n    uint64 initialOffer = 0.714e18;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vault = DataTypes.Vault({\n            owner: bob,\n            seriesId: SERIES_ID,\n            ilkId: ILK_ID\n        });\n\n        series = DataTypes.Series({\n            fyToken: IFYToken(Mocks.mock(\"FYToken\")),\n            baseId: BASE_ID,\n            maturity: uint32(block.timestamp + 30 days)\n        });\n\n        balances = DataTypes.Balances({art: 100_000e6, ink: 100 ether});\n\n        debt = DataTypes.Debt({\n            max: 0, // Not used by the Witch\n            min: dust, // Witch uses the cauldron min debt as dust\n            dec: dec,\n            sum: 0 // Not used by the Witch\n        });\n\n        cauldron.vaults.mock(VAULT_ID, vault);\n        cauldron.series.mock(SERIES_ID, series);\n        cauldron.balances.mock(VAULT_ID, balances);\n        cauldron.debt.mock(BASE_ID, ILK_ID, debt);\n\n        vm.startPrank(ada);\n        witch.setLimit(ILK_ID, BASE_ID, max);\n        witch.setLine(\n            ILK_ID,\n            BASE_ID,\n            AUCTION_DURATION,\n            proportion,\n            initialOffer\n        );\n        vm.stopPrank();\n    }\n}\n\ncontract WitchWithMetadataTest is WitchWithMetadata {\n    using Mocks for *;\n\n    function testCalcPayout() public {\n        // 100 * 0.5 * 0.714 = 35.7\n        // (ink * proportion * initialOffer)\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 artIn) = witch\n            .calcPayout(VAULT_ID, bot, 50_000e6);\n        assertEq(liquidatorCut, 35.7 ether);\n        // on a non-started auction it's always assumed that liquidator == auctioneer\n        assertEq(auctioneerCut, 0);\n        assertEq(artIn, 50_000e6);\n\n        skip(5 minutes);\n        // Nothing changes as auction was never started\n        (liquidatorCut, auctioneerCut, artIn) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 35.7 ether);\n        assertEq(auctioneerCut, 0);\n        assertEq(artIn, 50_000e6);\n    }\n\n    function testCalcPayoutEdgeCases() public {\n        (uint256 liquidatorCut, , uint256 artIn) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            0\n        );\n        assertEq(liquidatorCut, 0);\n        assertEq(artIn, 0);\n\n        (liquidatorCut, , artIn) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            type(uint256).max\n        );\n        assertEq(liquidatorCut, 35.7 ether);\n        assertEq(artIn, 50_000e6);\n    }\n\n    function testCalcPayoutFuzzArtIn(uint256 maxArtIn) public {\n        (uint256 liquidatorCut, , uint256 artIn) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            maxArtIn\n        );\n\n        assertLe(liquidatorCut, 35.7 ether);\n        assertGe(liquidatorCut, 0);\n\n        assertGe(artIn, 0);\n        assertLe(artIn, 50_000e6);\n    }\n\n    function testCalcPayoutFuzzInitialOffer(uint64 io) public {\n        vm.assume(io <= 1e18 && io >= 0.01e18);\n\n        vm.prank(ada);\n        witch.setLine(ILK_ID, BASE_ID, AUCTION_DURATION, proportion, io);\n\n        (uint256 liquidatorCut, , ) = witch.calcPayout(VAULT_ID, bot, 50_000e6);\n\n        assertLe(liquidatorCut, 50 ether);\n        assertGe(liquidatorCut, 0.5 ether);\n    }\n\n    function testCalcPayoutFuzzElapsed(uint16 elapsed) public {\n        skip(elapsed);\n\n        (uint256 liquidatorCut, , ) = witch.calcPayout(VAULT_ID, bot, 50_000e6);\n\n        assertLe(liquidatorCut, 50 ether);\n    }\n\n    function testVaultNotUndercollateralised() public {\n        cauldron.level.mock(VAULT_ID, 0);\n        vm.expectRevert(\"Not undercollateralized\");\n        witch.auction(VAULT_ID, bot);\n    }\n\n    function testVaultBelongsToAnotherWitch() public {\n        // Given\n        address anotherWitch = Mocks.mock(\"anotherWitch\");\n        vm.prank(ada);\n        witch.setAnotherWitch(anotherWitch, true);\n\n        // anotherWitch got to auction first\n        vault.owner = anotherWitch;\n        cauldron.vaults.mock(VAULT_ID, vault);\n\n        // When\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Witch.VaultAlreadyUnderAuction.selector,\n                VAULT_ID,\n                anotherWitch\n            )\n        );\n        witch.auction(VAULT_ID, bot);\n    }\n\n    function testVaultIsMadeOfAnIgnoredPair() public {\n        // Given\n        vm.prank(ada);\n        witch.setIgnoredPair(ILK_ID, BASE_ID, true);\n\n        // When\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Witch.VaultNotLiquidable.selector,\n                VAULT_ID,\n                ILK_ID,\n                BASE_ID\n            )\n        );\n        witch.auction(VAULT_ID, bot);\n    }\n\n    function testCanAuctionVault() public {\n        cauldron.level.mock(VAULT_ID, -1);\n        cauldron.give.mock(VAULT_ID, address(witch), vault);\n        cauldron.give.verify(VAULT_ID, address(witch));\n\n        vm.expectEmit(true, true, true, true);\n        emit Auctioned(VAULT_ID, uint32(block.timestamp));\n\n        DataTypes.Auction memory auction = witch.auction(VAULT_ID, bot);\n\n        assertEq(auction.owner, vault.owner);\n        assertEq(auction.start, uint32(block.timestamp));\n        assertEq(auction.baseId, series.baseId);\n        // 100,000 / 2\n        assertEq(auction.art, 50_000e6);\n        // 100 * 0.5\n        assertEq(auction.ink, 50 ether);\n\n        DataTypes.Auction memory auction_ = iWitch.auctions(VAULT_ID);\n        assertEq(auction_.owner, auction.owner);\n        assertEq(auction_.start, auction.start);\n        assertEq(auction_.baseId, auction.baseId);\n        assertEq(auction_.art, auction.art);\n        assertEq(auction_.ink, auction.ink);\n\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 50 ether);\n    }\n\n    function testCancelNonExistentAuction() public {\n        vm.expectRevert(\"Vault not under auction\");\n        witch.cancel(VAULT_ID);\n    }\n\n    function testPayBaseNonExistingAuction() public {\n        vm.expectRevert(\"Vault not under auction\");\n        witch.payBase(VAULT_ID, address(0), 0, 0);\n    }\n\n    function testPayFYTokenNonExistingAuction() public {\n        vm.expectRevert(\"Vault not under auction\");\n        witch.payFYToken(VAULT_ID, address(0), 0, 0);\n    }\n}\n\ncontract WitchWithAuction is WitchWithMetadata {\n    using Mocks for *;\n    using WMul for uint256;\n    using WMul for uint128;\n\n    bytes12 internal constant VAULT_ID_2 = \"vault2\";\n    DataTypes.Auction auction;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        cauldron.level.mock(VAULT_ID, -1);\n        cauldron.give.mock(VAULT_ID, address(witch), vault);\n        vm.prank(bot);\n        auction = witch.auction(VAULT_ID, bot);\n        vault.owner = address(witch);\n        // Mocks are not pass by reference, so we need to re-mock\n        cauldron.vaults.mock(VAULT_ID, vault);\n    }\n\n    struct StubVault {\n        bytes12 vaultId;\n        uint128 ink;\n        uint128 art;\n        int256 level;\n    }\n\n    function _stubVault(StubVault memory params) internal {\n        DataTypes.Vault memory v = DataTypes.Vault({\n            owner: bob,\n            seriesId: SERIES_ID,\n            ilkId: ILK_ID\n        });\n        DataTypes.Balances memory b = DataTypes.Balances(\n            params.art,\n            params.ink\n        );\n        cauldron.vaults.mock(params.vaultId, v);\n        cauldron.balances.mock(params.vaultId, b);\n        cauldron.level.mock(params.vaultId, params.level);\n        cauldron.give.mock(params.vaultId, address(witch), v);\n    }\n\n    function testCalcPayoutAfterAuctionForAuctioneer() public {\n        // 100 * 0.5 * 0.714 = 35.7\n        // (ink * proportion * initialOffer)\n        (uint256 liquidatorCut, uint256 auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 35.7 ether);\n        assertEq(auctioneerCut, 0);\n\n        skip(5 minutes);\n        // 100 * 0.5 * (0.714 + (1 - 0.714) * 300/3600) = 36.8916666667\n        // (ink * proportion * (initialOffer + (1 - initialOffer) * timeElapsed)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 36.89166666666666665 ether);\n        assertEq(auctioneerCut, 0);\n\n        skip(25 minutes);\n        // 100 * 0.5 * (0.714 + (1 - 0.714) * 1800/3600) = 42.85\n        // (ink * proportion * (initialOffer + (1 - initialOffer) * timeElapsed)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 42.85 ether);\n        assertEq(auctioneerCut, 0);\n\n        // Right at auction end\n        skip(30 minutes);\n        // 100 * 0.5 = 50\n        // (ink * proportion)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 50 ether);\n        assertEq(auctioneerCut, 0);\n\n        // After the auction ends the value is fixed\n        skip(1 hours);\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 50 ether);\n        assertEq(auctioneerCut, 0);\n    }\n\n    function testCalcPayoutAfterAuctionForNonAuctioneer() public {\n        address bot2 = address(0xb072);\n\n        // liquidatorCut = 100  * 0.5        * 0.714        * 0.99                       = 35.343\n        //                 (ink * proportion * initialOffer * (1 - auctioneerReward))\n        // auctioneerCut = 100  * 0.5        * 0.714        * 0.01                       = 0.357\n        //                 (ink * proportion * initialOffer * auctioneerReward)\n        (uint256 liquidatorCut, uint256 auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 35.343 ether, \"liquidatorCut\");\n        assertEq(auctioneerCut, 0.357 ether, \"auctioneerCut\");\n\n        skip(5 minutes);\n        // 100 * 0.5 * (0.714 + (1 - 0.714) * 300/3600) = 36.8916666667\n        // (ink * proportion * (initialOffer + (1 - initialOffer) * timeElapsed)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            50_000e6\n        );\n        // 36.8916666667 * 0.99\n        assertEq(liquidatorCut, 36.522749999999999984 ether);\n        // 36.8916666667 * 0.01\n        assertEq(auctioneerCut, 0.368916666666666666 ether);\n\n        skip(25 minutes);\n        // 100 * 0.5 * (0.714 + (1 - 0.714) * 1800/3600) = 42.85\n        // (ink * proportion * (initialOffer + (1 - initialOffer) * timeElapsed)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            50_000e6\n        );\n        // 42.85 * 0.99\n        assertEq(liquidatorCut, 42.4215 ether);\n        // 42.85 * 0.01\n        assertEq(auctioneerCut, 0.4285 ether);\n\n        // Right at auction end\n        skip(30 minutes);\n        // 100 * 0.5 = 50\n        // (ink * proportion)\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            50_000e6\n        );\n        // 50 * 0.99\n        assertEq(liquidatorCut, 49.5 ether);\n        // 50 * 0.01\n        assertEq(auctioneerCut, 0.5 ether);\n\n        // After the auction ends the value is fixed\n        skip(1 hours);\n        (liquidatorCut, auctioneerCut, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            50_000e6\n        );\n        assertEq(liquidatorCut, 49.5 ether);\n        assertEq(auctioneerCut, 0.5 ether);\n    }\n\n    function testAuctionAlreadyExists() public {\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Witch.VaultAlreadyUnderAuction.selector,\n                VAULT_ID,\n                address(witch)\n            )\n        );\n        witch.auction(VAULT_ID, bot);\n    }\n\n    function testCollateralLimits() public {\n        // Given\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 50 ether);\n\n        _stubVault(\n            StubVault({\n                vaultId: VAULT_ID_2,\n                ink: 101 ether,\n                art: 100_000e6,\n                level: -1\n            })\n        );\n\n        // When\n        witch.auction(VAULT_ID_2, bot);\n\n        // Then\n        (, sum) = witch.limits(ILK_ID, BASE_ID);\n        // Max is 100, but the position could be auctioned due to the soft limit\n        // Next position will fail\n        assertEq(sum, 100.5 ether);\n\n        // Given\n        bytes12 otherVaultId = \"other vault\";\n        _stubVault(\n            StubVault({\n                vaultId: otherVaultId,\n                ink: 10 ether,\n                art: 20_000e6,\n                level: -1\n            })\n        );\n\n        // Expect\n        vm.expectRevert(\"Collateral limit reached\");\n\n        // When\n        witch.auction(otherVaultId, bot);\n    }\n\n    function testDustLimit() public {\n        // Half of this vault would be less than the min of 5k\n        _stubVault(\n            StubVault({\n                vaultId: VAULT_ID_2,\n                ink: 5 ether,\n                art: 9999e6,\n                level: -1\n            })\n        );\n\n        DataTypes.Auction memory auction2 = witch.auction(VAULT_ID_2, bot);\n\n        assertEq(auction2.owner, address(0xb0b));\n        assertEq(auction2.start, uint32(block.timestamp));\n        assertEq(auction2.baseId, series.baseId);\n        // 100% of the vault was put for liquidation\n        assertEq(auction2.art, 9999e6);\n        assertEq(auction2.ink, 5 ether);\n    }\n\n    function testUpdateLimit() public {\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 50 ether);\n\n        vm.prank(ada);\n        witch.setLimit(ILK_ID, BASE_ID, 1);\n\n        (uint128 _max, uint128 _sum) = witch.limits(ILK_ID, BASE_ID);\n\n        assertEq(_max, 1);\n        // Sum is copied from old values\n        assertEq(_sum, 50 ether);\n    }\n\n    function testCancelUndercollateralisedAuction() public {\n        vm.expectRevert(\"Undercollateralized\");\n        witch.cancel(VAULT_ID);\n    }\n\n    function testCancelAuction() public {\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 50 ether);\n\n        cauldron.level.mock(VAULT_ID, 0);\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Cancelled(VAULT_ID);\n\n        witch.cancel(VAULT_ID);\n\n        // sum is reduced by the auction.ink\n        (, sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0);\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayBaseNotEnoughBought() public {\n        // Bot tries to get all collateral but auction just started\n        uint128 minInkOut = 50 ether;\n        uint128 maxBaseIn = 50_000e6;\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        vm.expectRevert(\"Not enough bought\");\n        witch.payBase(VAULT_ID, bot, minInkOut, maxBaseIn);\n    }\n\n    function testPayBaseLeavesDust() public {\n        // Bot tries to pay an amount that'd leaves dust\n        uint128 maxBaseIn = auction.art - 4999e6;\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        vm.expectRevert(\"Leaves dust\");\n        witch.payBase(VAULT_ID, bot, 0, maxBaseIn);\n    }\n\n    function testPayBasePartial() public {\n        // Bot Will pay 40% of the debt (for some reason)\n        uint128 maxBaseIn = uint128(auction.art.wmul(0.4e18));\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxBaseIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxBaseIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxBaseIn);\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        IJoin baseJoin = IJoin(Mocks.mock(\"BaseJoin\"));\n        ladle.joins.mock(series.baseId, baseJoin);\n        baseJoin.join.mock(bot, maxBaseIn, maxBaseIn);\n        baseJoin.join.verify(bot, maxBaseIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxBaseIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payBase(VAULT_ID, bot, minInkOut, maxBaseIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxBaseIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, auction.ink - minInkOut, \"sum\");\n\n        _auctionWasUpdated(VAULT_ID, maxBaseIn, minInkOut);\n    }\n\n    function testPayBasePartialOnPartiallyLiquidatedVault() public {\n        // liquidate 40% of the vault\n        testPayBasePartial();\n        // Refresh auction copy\n        auction = iWitch.auctions(VAULT_ID);\n\n        // Bot Will pay another 20% of the debt (for some reason)\n        uint128 maxBaseIn = uint128(auction.art.wmul(0.2e18));\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxBaseIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxBaseIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxBaseIn);\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        IJoin baseJoin = IJoin(Mocks.mock(\"BaseJoin\"));\n        ladle.joins.mock(series.baseId, baseJoin);\n        baseJoin.join.mock(bot, maxBaseIn, maxBaseIn);\n        baseJoin.join.verify(bot, maxBaseIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxBaseIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payBase(VAULT_ID, bot, minInkOut, maxBaseIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxBaseIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, auction.ink - minInkOut, \"sum\");\n\n        _auctionWasUpdated(VAULT_ID, maxBaseIn, minInkOut);\n    }\n\n    function testPayBaseAll() public {\n        uint128 maxBaseIn = uint128(auction.art);\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxBaseIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxBaseIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxBaseIn);\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        IJoin baseJoin = IJoin(Mocks.mock(\"BaseJoin\"));\n        ladle.joins.mock(series.baseId, baseJoin);\n        baseJoin.join.mock(bot, maxBaseIn, maxBaseIn);\n        baseJoin.join.verify(bot, maxBaseIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxBaseIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payBase(VAULT_ID, bot, minInkOut, maxBaseIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxBaseIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayBaseAllOnPartiallyLiquidatedVault() public {\n        // liquidate 40% of the vault\n        testPayBasePartial();\n        // Refresh auction copy\n        auction = iWitch.auctions(VAULT_ID);\n\n        uint128 maxBaseIn = uint128(auction.art);\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxBaseIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxBaseIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxBaseIn);\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        IJoin baseJoin = IJoin(Mocks.mock(\"BaseJoin\"));\n        ladle.joins.mock(series.baseId, baseJoin);\n        baseJoin.join.mock(bot, maxBaseIn, maxBaseIn);\n        baseJoin.join.verify(bot, maxBaseIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxBaseIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payBase(VAULT_ID, bot, minInkOut, maxBaseIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxBaseIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayBaseOnAnAuctionStartedBySomeoneElse() public {\n        address bot2 = address(0xb072);\n\n        uint128 maxBaseIn = uint128(auction.art);\n        vm.prank(bot2);\n        (uint256 liquidatorCut_, uint256 auctioneerCut_, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            maxBaseIn\n        );\n        uint128 liquidatorCut = uint128(liquidatorCut_);\n        uint128 auctioneerCut = uint128(auctioneerCut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(\n            VAULT_ID,\n            liquidatorCut + auctioneerCut,\n            maxBaseIn,\n            balances\n        );\n        cauldron.slurp.verify(\n            VAULT_ID,\n            liquidatorCut + auctioneerCut,\n            maxBaseIn\n        );\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        // make fyToken 1:1 with base to make things simpler\n        cauldron.debtFromBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n        cauldron.debtToBase.mock(vault.seriesId, maxBaseIn, maxBaseIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n\n        // Liquidator share\n        ilkJoin.exit.mock(bot2, liquidatorCut, liquidatorCut);\n        ilkJoin.exit.verify(bot2, liquidatorCut);\n        // Auctioneer share\n        ilkJoin.exit.mock(bot, auctioneerCut, auctioneerCut);\n        ilkJoin.exit.verify(bot, auctioneerCut);\n\n        IJoin baseJoin = IJoin(Mocks.mock(\"BaseJoin\"));\n        ladle.joins.mock(series.baseId, baseJoin);\n        baseJoin.join.mock(bot2, maxBaseIn, maxBaseIn);\n        baseJoin.join.verify(bot2, maxBaseIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot2, liquidatorCut + auctioneerCut, maxBaseIn);\n\n        vm.prank(bot2);\n        (uint256 _liquidatorCut, uint256 _auctioneerCut, uint256 baseIn) = witch\n            .payBase(VAULT_ID, bot2, liquidatorCut, maxBaseIn);\n        assertEq(_liquidatorCut, liquidatorCut);\n        assertEq(_auctioneerCut, auctioneerCut);\n        assertEq(baseIn, maxBaseIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayFYTokenNotEnoughBought() public {\n        // Bot tries to get all collateral but auction just started\n        uint128 minInkOut = 50 ether;\n        uint128 maxArtIn = 50_000e6;\n\n        vm.expectRevert(\"Not enough bought\");\n        witch.payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n    }\n\n    function testPayFYTokenLeavesDust() public {\n        // Bot tries to pay an amount that'd leaves dust\n        uint128 maxArtIn = auction.art - 4999e6;\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxArtIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        vm.expectRevert(\"Leaves dust\");\n        witch.payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n    }\n\n    function testPayFYTokenPartial() public {\n        // Bot Will pay 40% of the debt (for some reason)\n        uint128 maxArtIn = uint128(auction.art.wmul(0.4e18));\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxArtIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxArtIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxArtIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        series.fyToken.burn.mock(bot, maxArtIn);\n        series.fyToken.burn.verify(bot, maxArtIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxArtIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 artIn) = witch\n            .payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(artIn, maxArtIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, auction.ink - minInkOut, \"sum\");\n\n        _auctionWasUpdated(VAULT_ID, maxArtIn, minInkOut);\n    }\n\n    function testPayFYTokenPartialOnPartiallyLiquidatedVault() public {\n        // liquidate 40% of the vault\n        testPayFYTokenPartial();\n        // Refresh auction copy\n        auction = iWitch.auctions(VAULT_ID);\n\n        // Bot Will pay another 20% of the debt (for some reason)\n        uint128 maxArtIn = uint128(auction.art.wmul(0.2e18));\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxArtIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxArtIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxArtIn);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        series.fyToken.burn.mock(bot, maxArtIn);\n        series.fyToken.burn.verify(bot, maxArtIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxArtIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 artIn) = witch\n            .payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(artIn, maxArtIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, auction.ink - minInkOut, \"sum\");\n\n        _auctionWasUpdated(VAULT_ID, maxArtIn, minInkOut);\n    }\n\n    function testPayFYTokenAllStartedBySomeoneElse() public {\n        address bot2 = address(0xb072);\n\n        uint128 maxArtIn = uint128(auction.art);\n        vm.prank(bot2);\n        (uint256 liquidatorCut_, uint256 auctioneerCut_, ) = witch.calcPayout(\n            VAULT_ID,\n            bot2,\n            maxArtIn\n        );\n        uint128 liquidatorCut = uint128(liquidatorCut_);\n        uint128 auctioneerCut = uint128(auctioneerCut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(\n            VAULT_ID,\n            liquidatorCut + auctioneerCut,\n            maxArtIn,\n            balances\n        );\n        cauldron.slurp.verify(\n            VAULT_ID,\n            liquidatorCut + auctioneerCut,\n            maxArtIn\n        );\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n\n        // Liquidator share\n        ilkJoin.exit.mock(bot2, liquidatorCut, liquidatorCut);\n        ilkJoin.exit.verify(bot2, liquidatorCut);\n        // Auctioneer share\n        ilkJoin.exit.mock(bot, auctioneerCut, auctioneerCut);\n        ilkJoin.exit.verify(bot, auctioneerCut);\n\n        series.fyToken.burn.mock(bot2, maxArtIn);\n        series.fyToken.burn.verify(bot2, maxArtIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot2, liquidatorCut + auctioneerCut, maxArtIn);\n\n        vm.prank(bot2);\n        (uint256 _liquidatorCut, uint256 _auctioneerCut, uint256 baseIn) = witch\n            .payFYToken(VAULT_ID, bot2, liquidatorCut, maxArtIn);\n        assertEq(_liquidatorCut, liquidatorCut);\n        assertEq(_auctioneerCut, auctioneerCut);\n        assertEq(baseIn, maxArtIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayFYTokenAll() public {\n        uint128 maxArtIn = uint128(auction.art);\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxArtIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxArtIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxArtIn);\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        series.fyToken.burn.mock(bot, maxArtIn);\n        series.fyToken.burn.verify(bot, maxArtIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxArtIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxArtIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function testPayFYTokenAllOnPartiallyLiquidatedVault() public {\n        // liquidate 40% of the vault\n        testPayFYTokenPartial();\n        // Refresh auction copy\n        auction = iWitch.auctions(VAULT_ID);\n        uint128 maxArtIn = uint128(auction.art);\n        vm.prank(bot);\n        (uint256 minInkOut_, , ) = witch.calcPayout(VAULT_ID, bot, maxArtIn);\n        uint128 minInkOut = uint128(minInkOut_);\n\n        // Reduce balances on tha vault\n        cauldron.slurp.mock(VAULT_ID, minInkOut, maxArtIn, balances);\n        cauldron.slurp.verify(VAULT_ID, minInkOut, maxArtIn);\n        // Vault returns to it's owner after all the liquidation is done\n        cauldron.give.mock(VAULT_ID, bob, vault);\n        cauldron.give.verify(VAULT_ID, bob);\n\n        IJoin ilkJoin = IJoin(Mocks.mock(\"IlkJoin\"));\n        ladle.joins.mock(vault.ilkId, ilkJoin);\n        ilkJoin.exit.mock(bot, minInkOut, minInkOut);\n        ilkJoin.exit.verify(bot, minInkOut);\n\n        series.fyToken.burn.mock(bot, maxArtIn);\n        series.fyToken.burn.verify(bot, maxArtIn);\n\n        vm.expectEmit(true, true, true, true);\n        emit Ended(VAULT_ID);\n        vm.expectEmit(true, true, true, true);\n        emit Bought(VAULT_ID, bot, minInkOut, maxArtIn);\n\n        vm.prank(bot);\n        (uint256 liquidatorCut, uint256 auctioneerCut, uint256 baseIn) = witch\n            .payFYToken(VAULT_ID, bot, minInkOut, maxArtIn);\n        assertEq(liquidatorCut, minInkOut);\n        assertEq(auctioneerCut, 0);\n        assertEq(baseIn, maxArtIn);\n\n        // sum is reduced by the auction.ink\n        (, uint128 sum) = witch.limits(ILK_ID, BASE_ID);\n        assertEq(sum, 0, \"sum\");\n\n        _auctionWasDeleted(VAULT_ID);\n    }\n\n    function _auctionWasDeleted(bytes12 vaultId) internal {\n        DataTypes.Auction memory auction_ = iWitch.auctions(vaultId);\n        assertEq(auction_.owner, address(0));\n        assertEq(auction_.start, 0);\n        assertEq(auction_.baseId, \"\");\n        assertEq(auction_.art, 0);\n        assertEq(auction_.ink, 0);\n    }\n\n    function _auctionWasUpdated(\n        bytes12 vaultId,\n        uint128 art,\n        uint128 ink\n    ) internal {\n        DataTypes.Auction memory auction_ = iWitch.auctions(vaultId);\n        assertEq(auction_.owner, auction.owner, \"owner\");\n        assertEq(auction_.start, auction.start, \"start\");\n        assertEq(auction_.baseId, auction.baseId, \"baseId\");\n        assertEq(auction_.art, auction.art - art, \"art\");\n        assertEq(auction_.ink, auction.ink - ink, \"ink\");\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.14;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ILadle.sol\";\nimport \"@yield-protocol/vault-interfaces/src/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/src/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/src/DataTypes.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\n\n/// @title  The Witch is a DataTypes.Auction/Liquidation Engine for the Yield protocol\n/// @notice The Witch grabs uncollateralized vaults, replacing the owner by itself. Then it sells\n/// the vault collateral in exchange for underlying to pay its debt. The amount of collateral\n/// given increases over time, until it offers to sell all the collateral for underlying to pay\n/// all the debt. The auction is held open at the final price indefinitely.\n/// @dev After the debt is settled, the Witch returns the vault to its original owner.\ncontract Witch is AccessControl {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n\n    // ==================== User events ====================\n\n    error VaultAlreadyUnderAuction(bytes12 vaultId, address witch);\n    error VaultNotLiquidable(bytes12 vaultId, bytes6 ilkId, bytes6 baseId);\n    error AuctioneerRewardTooHigh(uint128 max, uint128 actual);\n\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n    event Cancelled(bytes12 indexed vaultId);\n    event Ended(bytes12 indexed vaultId);\n    event Bought(\n        bytes12 indexed vaultId,\n        address indexed buyer,\n        uint256 ink,\n        uint256 art\n    );\n\n    // ==================== Governance events ====================\n\n    event Point(bytes32 indexed param, address indexed value);\n    event LineSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    );\n    event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);\n    event AnotherWitchSet(address indexed value, bool isWitch);\n    event IgnoredPairSet(\n        bytes6 indexed ilkId,\n        bytes6 indexed baseId,\n        bool ignore\n    );\n    event AuctioneerRewardSet(uint128 auctioneerReward);\n\n    ICauldron public immutable cauldron;\n    ILadle public ladle;\n\n    // Reward given to whomever calls `auction`. It represents a % of the bought collateral\n    uint128 public auctioneerReward = 0.01e18;\n\n    mapping(bytes12 => DataTypes.Auction) public auctions;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Line)) public lines;\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Limits)) public limits;\n    mapping(address => bool) public otherWitches;\n    mapping(bytes6 => mapping(bytes6 => bool)) public ignoredPairs;\n\n    constructor(ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    // ======================================================================\n    // =                        Governance functions                        =\n    // ======================================================================\n\n    /// @dev Point to a different ladle\n    /// @param param Name of parameter to set (must be \"ladle\")\n    /// @param value Address of new ladle\n    function point(bytes32 param, address value) external auth {\n        require(param == \"ladle\", \"Unrecognized\");\n        ladle = ILadle(value);\n        emit Point(param, value);\n    }\n\n    /// @dev Governance function to set the parameters that govern how much collateral is sold over time.\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param duration Time that auctions take to go to minimal price\n    /// @param proportion Vault proportion that is set for auction each time\n    /// @param initialOffer Proportion of collateral that is sold at auction start (1e18 = 100%)\n    function setLine(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint32 duration,\n        uint64 proportion,\n        uint64 initialOffer\n    ) external auth {\n        require(initialOffer <= 1e18, \"InitialOffer above 100%\");\n        require(proportion <= 1e18, \"Proportion above 100%\");\n        require(\n            initialOffer == 0 || initialOffer >= 0.01e18,\n            \"InitialOffer below 1%\"\n        );\n        require(proportion >= 0.01e18, \"Proportion below 1%\");\n        lines[ilkId][baseId] = DataTypes.Line({\n            duration: duration,\n            proportion: proportion,\n            initialOffer: initialOffer\n        });\n        emit LineSet(ilkId, baseId, duration, proportion, initialOffer);\n    }\n\n    /// @dev Governance function to set auction limits.\n    ///  - the auction duration to calculate liquidation prices\n    ///  - the proportion of the collateral that will be sold at auction start\n    ///  - the maximum collateral that can be auctioned at the same time\n    ///  - the minimum collateral that must be left when buying, unless buying all\n    ///  - The decimals for maximum and minimum\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param max Maximum concurrent auctioned collateral\n    function setLimit(\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint128 max\n    ) external auth {\n        limits[ilkId][baseId] = DataTypes.Limits({\n            max: max,\n            sum: limits[ilkId][baseId].sum // sum is initialized at zero, and doesn't change when changing any ilk parameters\n        });\n        emit LimitSet(ilkId, baseId, max);\n    }\n\n    /// @dev Governance function to set other liquidation contracts that may have taken vaults already.\n    /// @param value The address that may be set/unset as another witch\n    /// @param isWitch Is this address a witch or not\n    function setAnotherWitch(address value, bool isWitch) external auth {\n        otherWitches[value] = isWitch;\n        emit AnotherWitchSet(value, isWitch);\n    }\n\n    /// @dev Governance function to ignore pairs that can't be liquidated\n    /// @param ilkId Id of asset used for collateral\n    /// @param baseId Id of asset used for underlying\n    /// @param ignore Should this pair be ignored for liquidation\n    function setIgnoredPair(\n        bytes6 ilkId,\n        bytes6 baseId,\n        bool ignore\n    ) external auth {\n        ignoredPairs[ilkId][baseId] = ignore;\n        emit IgnoredPairSet(ilkId, baseId, ignore);\n    }\n\n    /// @dev Governance function to set the % paid to whomever starts an auction\n    /// @param auctioneerReward_ New % to be used, must have 18 dec precision\n    function setAuctioneerReward(uint128 auctioneerReward_) external auth {\n        if (auctioneerReward_ > 1e18) {\n            revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);\n        }\n        auctioneerReward = auctioneerReward_;\n        emit AuctioneerRewardSet(auctioneerReward_);\n    }\n\n    // ======================================================================\n    // =                    Auction management functions                    =\n    // ======================================================================\n\n    /// @dev Put an undercollateralized vault up for liquidation\n    /// @param vaultId Id of vault to liquidate\n    /// @param to Receiver of the auctioneer reward\n    function auction(bytes12 vaultId, address to)\n        external\n        returns (DataTypes.Auction memory auction_)\n    {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        if (vault.owner == address(this) || otherWitches[vault.owner]) {\n            revert VaultAlreadyUnderAuction(vaultId, vault.owner);\n        }\n        DataTypes.Series memory series = cauldron.series(vault.seriesId);\n        if (ignoredPairs[vault.ilkId][series.baseId]) {\n            revert VaultNotLiquidable(vaultId, vault.ilkId, series.baseId);\n        }\n\n        require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        DataTypes.Debt memory debt = cauldron.debt(series.baseId, vault.ilkId);\n\n        // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n        // If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n        // This avoids the scenario where some vaults might be too large to be auctioned.\n        DataTypes.Limits memory limits_ = limits[vault.ilkId][\n            series.baseId\n        ];\n        require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n\n        auction_ = _calcAuction(vault, series, to, balances, debt);\n\n        limits_.sum += auction_.ink;\n        limits[vault.ilkId][series.baseId] = limits_;\n\n        auctions[vaultId] = auction_;\n\n        _auctionStarted(vaultId);\n    }\n\n    /// @dev Moves the vault ownership to the witch.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionStarted(bytes12 vaultId) internal virtual {\n        // The Witch is now in control of the vault under auction\n        cauldron.give(vaultId, address(this));\n        emit Auctioned(vaultId, uint32(block.timestamp));\n    }\n\n    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed\n    /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer\n    /// use `_calcPayout`\n    function _calcAuction(\n        DataTypes.Vault memory vault,\n        DataTypes.Series memory series,\n        address to,\n        DataTypes.Balances memory balances,\n        DataTypes.Debt memory debt\n    ) internal view returns (DataTypes.Auction memory) {\n        // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.\n        DataTypes.Line storage line = lines[vault.ilkId][series.baseId];\n        uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n        if (art < debt.min * (10**debt.dec)) art = balances.art;\n        uint128 ink = (art == balances.art)\n            ? balances.ink\n            : uint256(balances.ink).wmul(line.proportion).u128();\n\n        return\n            DataTypes.Auction({\n                owner: vault.owner,\n                start: uint32(block.timestamp), // Overflow is fine\n                seriesId: vault.seriesId,\n                baseId: series.baseId,\n                ilkId: vault.ilkId,\n                art: art,\n                ink: ink,\n                auctioneer: to\n            });\n    }\n\n    /// @dev Cancel an auction for a vault that isn't undercollateralized anymore\n    /// @param vaultId Id of vault to return\n    function cancel(bytes12 vaultId) external {\n        DataTypes.Auction storage auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n        require(cauldron.level(vaultId) >= 0, \"Undercollateralized\");\n\n        // Update concurrent collateral under auction\n        limits[auction_.ilkId][auction_.baseId].sum -= auction_.ink;\n\n        _auctionEnded(vaultId, auction_.owner);\n\n        emit Cancelled(vaultId);\n    }\n\n    /// @dev Moves the vault ownership back to the original owner & clean internal state.\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _auctionEnded(bytes12 vaultId, address owner) internal virtual {\n        cauldron.give(vaultId, owner);\n        delete auctions[vaultId];\n        emit Ended(vaultId);\n    }\n\n    // ======================================================================\n    // =                          Bidding functions                         =\n    // ======================================================================\n\n    /// @dev Pay at most `maxBaseIn` of the debt in a vault in liquidation, getting at least `minInkOut` collateral.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver of the collateral bought\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @param maxBaseIn Maximum amount of base that the liquidator will pay\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return baseIn Amount of underlying taken\n    function payBase(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxBaseIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 baseIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Find out how much debt is being repaid\n        uint128 artIn = uint128(\n            cauldron.debtFromBase(auction_.seriesId, maxBaseIn)\n        );\n\n        // If offering too much base, take only the necessary.\n        artIn = artIn > auction_.art ? auction_.art : artIn;\n        baseIn = cauldron.debtToBase(auction_.seriesId, artIn);\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (baseIn != 0) {\n            // Take underlying from liquidator\n            IJoin baseJoin = ladle.joins(auction_.baseId);\n            require(baseJoin != IJoin(address(0)), \"Join not found\");\n            baseJoin.join(msg.sender, baseIn.u128());\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.\n    /// @notice If too much fyToken are offered, only the necessary amount are taken.\n    /// @param vaultId Id of vault to buy\n    /// @param to Receiver for the collateral bought\n    /// @param maxArtIn Maximum amount of fyToken that will be paid\n    /// @param minInkOut Minimum amount of collateral that must be received\n    /// @return liquidatorCut Amount paid to `to`.\n    /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method\n    /// @return artIn Amount of fyToken taken\n    function payFYToken(\n        bytes12 vaultId,\n        address to,\n        uint128 minInkOut,\n        uint128 maxArtIn\n    )\n        external\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // If offering too much fyToken, take only the necessary.\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        // Calculate the collateral to be sold\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n        require(liquidatorCut >= minInkOut, \"Not enough bought\");\n\n        // Update Cauldron and local auction data\n        _updateAccounting(\n            vaultId,\n            auction_,\n            liquidatorCut + auctioneerCut,\n            artIn\n        );\n\n        // Move the assets\n        _payInk(auction_, to, liquidatorCut, auctioneerCut);\n        if (artIn != 0) {\n            // Burn fyToken from liquidator\n            cauldron.series(auction_.seriesId).fyToken.burn(msg.sender, artIn);\n        }\n\n        _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);\n    }\n\n    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)\n    function _payInk(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 liquidatorCut,\n        uint256 auctioneerCut\n    ) internal {\n        // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check\n        if (liquidatorCut > 0) {\n            IJoin ilkJoin = ladle.joins(auction_.ilkId);\n            require(ilkJoin != IJoin(address(0)), \"Join not found\");\n\n            // Pay auctioneer's cut if necessary\n            if (auctioneerCut > 0) {\n                ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());\n            }\n\n            // Give collateral to the liquidator\n            ilkJoin.exit(to, liquidatorCut.u128());\n        }\n    }\n\n    /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.\n    /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.\n    function _updateAccounting(\n        bytes12 vaultId,\n        DataTypes.Auction memory auction_,\n        uint256 inkOut,\n        uint256 artIn\n    ) internal {\n        // Duplicate check, but guarantees data integrity\n        require(auction_.start > 0, \"Vault not under auction\");\n\n        // Update concurrent collateral under auction\n        DataTypes.Limits memory limits_ = limits[auction_.ilkId][\n            auction_.baseId\n        ];\n\n        // Update local auction\n        {\n            if (auction_.art == artIn) {\n                // If there is no debt left, return the vault with the collateral to the owner\n                _auctionEnded(vaultId, auction_.owner);\n\n                // Update limits - reduce it by the whole auction\n                limits_.sum -= auction_.ink;\n            } else {\n                // Ensure enough dust is left\n                DataTypes.Debt memory debt = cauldron.debt(\n                    auction_.baseId,\n                    auction_.ilkId\n                );\n                require(\n                    auction_.art - artIn >= debt.min * (10**debt.dec),\n                    \"Leaves dust\"\n                );\n\n                // Update the auction\n                auction_.ink -= inkOut.u128();\n                auction_.art -= artIn.u128();\n\n                // Store auction changes\n                auctions[vaultId] = auction_;\n\n                // Update limits - reduce it by whatever was bought\n                limits_.sum -= inkOut.u128();\n            }\n        }\n\n        // Store limit changes\n        limits[auction_.ilkId][auction_.baseId] = limits_;\n\n        // Update accounting at Cauldron\n        cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n    }\n\n    /// @dev Logs that a certain amount of a vault was liquidated\n    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties\n    function _collateralBought(\n        bytes12 vaultId,\n        address buyer,\n        uint256 ink,\n        uint256 art\n    ) internal virtual {\n        emit Bought(vaultId, buyer, ink, art);\n    }\n\n    // ======================================================================\n    // =                         Quoting functions                          =\n    // ======================================================================\n\n    /*\n\n       x x x\n     x      x    Hi Fren!\n    x  .  .  x   I want to buy this vault under auction!  I'll pay\n    x        x   you in the same `base` currency of the debt, or in fyToken, but\n    x        x   I want no less than `uint min` of the collateral, ok?\n    x   ===  x\n    x       x\n      xxxxx\n        x                             __  Ok Fren!\n        x     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  _(\\    |@@|\n        xxxxxx\u2502 BASE BUCKS \u2502 (__/\\__ \\--/ __\n        x     \u2502     OR     \u2502    \\___|----|  |   __\n        x     \u2502   FYTOKEN  \u2502        \\ }{ /\\ )_ / _\\\n       x x    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        /\\__/\\ \\__O (__\n                                   (--/\\--)    \\__/\n                            \u2502      _)(  )(_\n                            \u2502     `---''---`\n                            \u25bc\n      _______\n     /  12   \\  First lets check how much time `t` is left on the auction\n    |    |    | because that helps us determine the price we will accept\n    |9   |   3| for the debt! Yay!\n    |     \\   |                       p + (1 - p) * t\n    |         |\n     \\___6___/          (p is the auction starting price!)\n\n                            \u2502\n                            \u2502\n                            \u25bc                  (\\\n                                                \\ \\\n    Then the Cauldron updates our internal    __    \\/ ___,.-------..__        __\n    accounting by slurping up the debt      //\\\\ _,-'\\\\               `'--._ //\\\\\n    and the collateral from the vault!      \\\\ ;'      \\\\                   `: //\n                                            `(          \\\\                   )'\n    The Join  then dishes out the collateral   :.          \\\\,----,         ,;\n    to you, dear user. And the debt is          `.`--.___   (    /  ___.--','\n    settled with the base join or debt fyToken.   `.     ``-----'-''     ,'\n                                                    -.               ,-\n                                                       `-._______.-'gpyy\n\n\n    */\n    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount\n    /// Works for both Auctioned and ToBeAuctioned vaults\n    /// @param vaultId The vault to get a quote for\n    /// @param to Address that would get the collateral bought\n    /// @param maxArtIn How much of the vault debt will be paid. GT than available art means all\n    /// @return liquidatorCut How much collateral the liquidator is expected to get\n    /// @return auctioneerCut How much collateral the auctioneer is expected to get. 0 if liquidator == auctioneer\n    /// @return artIn How much debt the liquidator is expected to pay\n    function calcPayout(\n        bytes12 vaultId,\n        address to,\n        uint256 maxArtIn\n    )\n        external\n        view\n        returns (\n            uint256 liquidatorCut,\n            uint256 auctioneerCut,\n            uint256 artIn\n        )\n    {\n        DataTypes.Auction memory auction_ = auctions[vaultId];\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n\n        // If the vault hasn't been auctioned yet, we calculate what values it'd have if it was started right now\n        if (auction_.start == 0) {\n            DataTypes.Series memory series = cauldron.series(vault.seriesId);\n            DataTypes.Balances memory balances = cauldron.balances(vaultId);\n            DataTypes.Debt memory debt = cauldron.debt(\n                series.baseId,\n                vault.ilkId\n            );\n            auction_ = _calcAuction(vault, series, to, balances, debt);\n        }\n\n        // GT check is to cater for partial buys right before this method executes\n        artIn = maxArtIn > auction_.art ? auction_.art : maxArtIn;\n\n        (liquidatorCut, auctioneerCut) = _calcPayout(auction_, to, artIn);\n    }\n\n    /// @notice Return how much collateral should be given out.\n    function _calcPayout(\n        DataTypes.Auction memory auction_,\n        address to,\n        uint256 artIn\n    ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) {\n        // Calculate how much collateral to give for paying a certain amount of debt, at a certain time, for a certain vault.\n        // inkOut = (artIn / totalArt) * totalInk * (p + (1 - p) * t)\n        DataTypes.Line memory line_ = lines[auction_.ilkId][\n            auction_.baseId\n        ];\n        uint256 duration = line_.duration;\n        uint256 initialProportion = line_.initialOffer;\n\n        // If the world has not turned to ashes and darkness, auctions will malfunction on\n        // the 7th of February 2106, at 06:28:16 GMT\n        // TODO: Replace this contract before then \ud83d\ude30\n        // UPDATE: Added reminder to Google calendar \u2705\n        uint256 elapsed;\n        uint256 proportionNow;\n        unchecked {\n            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine\n        }\n        if (duration == type(uint32).max) {     // Interpreted as infinite duration\n            proportionNow = initialProportion;\n        } else if (elapsed > duration) {\n            proportionNow = 1e18;\n        } else {\n            proportionNow =\n                uint256(initialProportion) +\n                uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));\n        }\n\n        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);\n        liquidatorCut = inkAtEnd.wmul(proportionNow);\n        if (auction_.auctioneer != to) {\n            auctioneerCut = liquidatorCut.wmul(auctioneerReward);\n            liquidatorCut -= auctioneerCut;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport \"forge-std/src/Test.sol\";\nimport \"@yield-protocol/vault-interfaces/src/DataTypes.sol\";\n\n//common utilities for forge tests\nlibrary Mocks  {\n    Vm public constant vm = Vm(address(bytes20(uint160(uint256(keccak256('hevm cheat code'))))));\n\n    function mock(string memory label) external returns (address mock_) {\n        mock_ = address(new StrictMock());\n        vm.label(mock_, label);\n    }\n\n    function lenientMock(string memory label) external returns (address mock_) {\n        mock_ = address(new LenientMock());\n        vm.label(mock_, label);\n    }\n\n    function mockAt(address where, string memory label) external returns (address) {\n        vm.etch(where, vm.getCode(\"Mocks.sol:StrictMock\"));\n        vm.label(where, label);\n        return where;\n    }\n\n    // ===================================== mock =====================================\n\n    function mock(function (address) external f, address param1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(0)\n        );\n    }\n\n    function mock(function () external returns(uint256) f, uint256 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function () external returns(uint32) f, uint32 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function () external returns(int128) f, int128 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector),\n            abi.encode(returned1)\n        );\n    }\n    \n    function mock(function () external returns(uint112, uint112, uint32) f, uint112 returned1, uint112 returned2, uint32 returned3) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector),\n            abi.encode(returned1, returned2, returned3)\n        );\n    }\n\n    function mock(function (address) external returns(uint256) f, address param1, uint256 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes12) external returns(int) f, bytes12 param1, int returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes12) external view returns(DataTypes.Vault memory) f, bytes12 param1, DataTypes.Vault memory returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes12, address) external returns(DataTypes.Vault memory) f, bytes12 param1, address param2, DataTypes.Vault memory returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2),\n            abi.encode(returned1)\n        );\n    }\n    \n    function mock(function (bytes12) external view returns(DataTypes.Balances memory) f, bytes12 param1, DataTypes.Balances memory returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes12, uint128, uint128) external returns(DataTypes.Balances memory) f, bytes12 param1, uint128 param2, uint128 param3, DataTypes.Balances memory returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2, param3),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (address, bytes12, bytes6, bytes6) external returns(DataTypes.Vault memory) f, address p1, bytes12 p2, bytes6 p3, bytes6 p4, DataTypes.Vault memory r1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, p1, p2, p3, p4),\n            abi.encode(r1)\n        );\n    }\n\n    function mock(function (bytes6, bytes6) external returns(DataTypes.Debt memory) f, bytes6 p1, bytes6 p2, DataTypes.Debt memory r1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, p1, p2),\n            abi.encode(r1)\n        );\n    }\n\n    function mock(function (bytes6) external view returns(DataTypes.Series memory) f, bytes6 param1, DataTypes.Series memory returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes6) external view returns(IJoin) f, bytes6 param1, IJoin returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (bytes6, uint128) external returns(uint128) f, bytes6 param1, uint128 param2, uint128 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (address, uint128) external returns(uint128) f, address param1, uint128 param2, uint128 returned1) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2),\n            abi.encode(returned1)\n        );\n    }\n\n    function mock(function (address, uint256) external f, address param1, uint256 param2) internal {\n        vm.mockCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2),\n            abi.encode(0)\n        );\n    }\n\n    // ===================================== verify =====================================\n\n    function verify(function (address) external f, address param1) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1)\n        );\n    }\n\n    function verify(function (bytes12, address) external returns(DataTypes.Vault memory) f, bytes12 param1, address param2) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2)\n        );\n    }\n\n    function verify(function (address, uint128) external returns(uint128) f, address param1, uint128 param2) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2)\n        );\n    }\n\n     function verify(function (bytes12, uint128, uint128) external returns(DataTypes.Balances memory) f, bytes12 param1, uint128 param2, uint128 param3) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2, param3)\n        );\n    }\n\n     function verify(function (address, uint256) external f, address param1, uint256 param2) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, param1, param2)\n        );\n    }\n\n    function verify(function (address, bytes12, bytes6, bytes6) external returns(DataTypes.Vault memory) f, address p1, bytes12 p2, bytes6 p3, bytes6 p4) internal {\n        vm.expectCall(\n            f.address,\n            abi.encodeWithSelector(f.selector, p1, p2, p3, p4)\n        );\n    }\n}\n\ncontract StrictMock {\n    fallback() external payable {\n        revert(\"Not mocked!\");\n    }\n}\n\ncontract LenientMock {\n    fallback() external payable {}\n}\n\n\n",
        "CodeNames": [
            "Witch.t.sol",
            "Witch.sol",
            "Mocks.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "diff\nbellow\n+ below\n\ndifferente\n+ different\n\n// Extra spacing\nThe Join  then dishes out\n+ The Join then dishes out\n\nquoutes hoy much ink\n+ quotes how much ink\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n66        mapping(bytes6 = mapping(bytes6 = DataTypes.Line)) public lines;\n67        mapping(bytes6 = mapping(bytes6 = DataTypes.Limits)) public limits;\n68        mapping(address = bool) public otherWitches;\n69:       mapping(bytes6 = mapping(bytes6 = bool)) public ignoredPairs;\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n197           DataTypes.Limits memory limits_ = limits[vault.ilkId][\n198               series.baseId\n199:          ];\n\n",
                    "diff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..ccf9822 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -194,15 +194,15 @@ contract Witch is AccessControl {\n         // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n         // If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n         // This avoids the scenario where some vaults might be too large to be auctioned.\n       DataTypes.Limits memory limits_ = limits[vault.ilkId][\n+        DataTypes.Limits storage limits_ = limits[vault.ilkId][\n             series.baseId\n         ];\n       require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n+        uint128 lsum_ = limits_.sum;\n+        require(lsum_ <= limits_.max, \"Collateral limit reached\");\n \n         auction_ = _calcAuction(vault, series, to, balances, debt);\n \n       limits_.sum += auction_.ink;\n       limits[vault.ilkId][series.baseId] = limits_;\n+        limits_.sum = lsum_ + auction_.ink;\n \n         auctions[vaultId] = auction_;\n \n",
                    "diff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..749b496 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,11 +3,11 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3062982                            \u2506 15591           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 auction                            \u2506 4219            \u2506 70111 \u2506 81848  \u2506 91148 \u2506 30      \u2502\n+\u2502 auction                            \u2506 4219            \u2506 69956 \u2506 81665  \u2506 90965 \u2506 30      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctioneerReward                   \u2506 426             \u2506 426   \u2506 426    \u2506 426   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n/// @audit inkOut.u128()\n450:                  limits_.sum -= inkOut.u128();\n\n/// @audit inkOut.u128()\n/// @audit artIn.u128()\n458:          cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n\n",
                    "diff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..c2196e8 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -421,6 +421,7 @@ contract Witch is AccessControl {\n         ];\n \n         // Update local auction\n+        uint128 io128_;\n         {\n             if (auction_.art == artIn) {\n                 // If there is no debt left, return the vault with the collateral to the owner\n@@ -428,6 +429,7 @@ contract Witch is AccessControl {\n \n                 // Update limits reduce it by the whole auction\n                 limits_.sum -= auction_.ink;\n+                io128_ = inkOut.u128();\n             } else {\n                 // Ensure enough dust is left\n                 DataTypes.Debt memory debt = cauldron.debt(\n@@ -439,15 +441,16 @@ contract Witch is AccessControl {\n                     \"Leaves dust\"\n                 );\n \n+                io128_ = inkOut.u128();\n                 // Update the auction\n               auction_.ink -= inkOut.u128();\n+                auction_.ink -= io128_;\n                 auction_.art -= artIn.u128();\n \n                 // Store auction changes\n                 auctions[vaultId] = auction_;\n \n                 // Update limits reduce it by whatever was bought\n               limits_.sum -= inkOut.u128();\n+                limits_.sum -= io128_;\n             }\n         }\n \n@@ -455,7 +458,7 @@ contract Witch is AccessControl {\n         limits[auction_.ilkId][auction_.baseId] = limits_;\n \n         // Update accounting at Cauldron\n       cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n+        cauldron.slurp(vaultId, io128_, artIn.u128());\n     }\n \n     /// @dev Logs that a certain amount of a vault was liquidated\n",
                    "diff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..7867bad 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,7 +3,7 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3075198                            \u2506 15652           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n@@ -29,9 +29,9 @@\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 otherWitches                       \u2506 570             \u2506 570   \u2506 570    \u2506 570   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 payBase                            \u2506 7632            \u2506 20431 \u2506 22355  \u2506 26694 \u2506 10      \u2502\n+\u2502 payBase                            \u2506 7632            \u2506 20373 \u2506 22357  \u2506 26544 \u2506 10      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 payFYToken                         \u2506 7507            \u2506 19219 \u2506 20648  \u2506 27910 \u2506 10      \u2502\n+\u2502 payFYToken                         \u2506 7504            \u2506 19161 \u2506 20654  \u2506 27760 \u2506 10      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 point                              \u2506 2934            \u2506 5098  \u2506 2942   \u2506 9420  \u2506 3       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n/// @audit point(), setLine(), setLimit(), setAnotherWitch(), setIgnoredPair(), setAuctioneerReward(), auction(), cancel(), payBase(), payFYToken(), calcPayout()\n19:   contract Witch is AccessControl {\n\n",
                    "//solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n68:       mapping(address = bool) public otherWitches;\n\n69:       mapping(bytes6 = mapping(bytes6 = bool)) public ignoredPairs;\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n308:          artIn = artIn  auction_.art ? auction_.art : artIn;\n\n361:          artIn = maxArtIn  auction_.art ? auction_.art : maxArtIn;\n\n556:          artIn = maxArtIn  auction_.art ? auction_.art : maxArtIn;\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n/// @audit uint128 art\n233:          if (art < debt.min * (10debt.dec)) art = balances.art;\n\n/// @audit uint128 artIn\n308:          artIn = artIn  auction_.art ? auction_.art : artIn;\n\n",
                    "diff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..066e912 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -229,11 +229,11 @@ contract Witch is AccessControl {\n     ) internal view returns (DataTypes.Auction memory) {\n         // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.\n         DataTypes.Line storage line = lines[vault.ilkId][series.baseId];\n       uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n+        uint256 art = uint256(balances.art).wmul(line.proportion);\n         if (art < debt.min * (10debt.dec)) art = balances.art;\n       uint128 ink = (art == balances.art)\n+        uint256 ink = (art == balances.art)\n             ? balances.ink\n           : uint256(balances.ink).wmul(line.proportion).u128();\n+            : uint256(balances.ink).wmul(line.proportion);\n \n         return\n             DataTypes.Auction({\n@@ -242,8 +242,8 @@ contract Witch is AccessControl {\n                 seriesId: vault.seriesId,\n                 baseId: series.baseId,\n                 ilkId: vault.ilkId,\n               art: art,\n               ink: ink,\n+                art: art.u128(),\n+                ink: ink.u128(),\n                 auctioneer: to\n             });\n     }\n",
                    "diff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..4f7212a 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,17 +3,17 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3077398                            \u2506 15663           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 auction                            \u2506 4219            \u2506 70111 \u2506 81848  \u2506 91148 \u2506 30      \u2502\n+\u2502 auction                            \u2506 4219            \u2506 70086 \u2506 81815  \u2506 91115 \u2506 30      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctioneerReward                   \u2506 426             \u2506 426   \u2506 426    \u2506 426   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctions                           \u2506 1244            \u2506 1244  \u2506 1244   \u2506 1244  \u2506 20      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 calcPayout                         \u2506 3627            \u2506 10420 \u2506 14603  \u2506 19151 \u2506 29      \u2502\n+\u2502 calcPayout                         \u2506 3627            \u2506 10415 \u2506 14603  \u2506 19118 \u2506 29      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 cancel                             \u2506 2736            \u2506 9683  \u2506 5675   \u2506 20639 \u2506 3       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n/// @audit expensive op on line 105\n108:          require(proportion = 0.01e18, \"Proportion below 1%\");\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n84:           require(param == \"ladle\", \"Unrecognized\");\n\n102:          require(initialOffer <= 1e18, \"InitialOffer above 100%\");\n\n103:          require(proportion <= 1e18, \"Proportion above 100%\");\n\n104           require(\n105               initialOffer == 0 || initialOffer = 0.01e18,\n106               \"InitialOffer below 1%\"\n107:          );\n\n108:          require(proportion = 0.01e18, \"Proportion below 1%\");\n\n189:          require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n200:          require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n\n255:          require(auction_.start  0, \"Vault not under auction\");\n\n256:          require(cauldron.level(vaultId) = 0, \"Undercollateralized\");\n\n300:          require(auction_.start  0, \"Vault not under auction\");\n\n313:          require(liquidatorCut = minInkOut, \"Not enough bought\");\n\n328:              require(baseJoin != IJoin(address(0)), \"Join not found\");\n\n358:          require(auction_.start  0, \"Vault not under auction\");\n\n365:          require(liquidatorCut = minInkOut, \"Not enough bought\");\n\n395:              require(ilkJoin != IJoin(address(0)), \"Join not found\");\n\n416:          require(auction_.start  0, \"Vault not under auction\");\n\n437                   require(\n438                       auction_.art artIn = debt.min * (10debt.dec),\n439                       \"Leaves dust\"\n440:                  );\n\n",
                    "//solidity\nFile: contracts/Witch.sol\n\n83:       function point(bytes32 param, address value) external auth {\n\n95        function setLine(\n96            bytes6 ilkId,\n97            bytes6 baseId,\n98            uint32 duration,\n99            uint64 proportion,\n100           uint64 initialOffer\n101:      ) external auth {\n\n126       function setLimit(\n127           bytes6 ilkId,\n128           bytes6 baseId,\n129           uint128 max\n130:      ) external auth {\n\n141:      function setAnotherWitch(address value, bool isWitch) external auth {\n\n150       function setIgnoredPair(\n151           bytes6 ilkId,\n152           bytes6 baseId,\n153           bool ignore\n154:      ) external auth {\n\n161:      function setAuctioneerReward(uint128 auctioneerReward_) external auth {\n\n"
                ],
                "Type": " Typos",
                "Description": "\ndiff\nbellow\n+ below\n\ndifferente\n+ different\n\n// Extra spacing\nThe Join  then dishes out\n+ The Join then dishes out\n\nquoutes hoy much ink\n+ quotes how much ink\n\n\nalcueca (Yield) confirmed and commented(https://github.com/code-423n4/2022-07-yield-findings/issues/33#issuecomment-1192606755):\n  This is a great QA report :heart: \n\nPierrickGT (judge) commented(https://github.com/code-423n4/2022-07-yield-findings/issues/33#issuecomment-1213319030):\n  Best QA report of this contest with clear description of the problems and comprehensive suggestions provided.\n \n L-01] Vaults that are over-collateralised after partial liquidation are possibly subject to further liquidations<br\n \n Great suggestion and explanation of the risks induced by the smart contract architecture and design of the Witch contract.\n As mentioned by the warden, their suggestion may complexify the code but they did a good job of outlining the risks and the sponsor can now decide to implement or not the suggestion.\n \n L-02] Comparison in _calcPayout() should include equality<br\n \n Great find and recommendation that will cover the edge case when elapsed = duration = 0.\n \n L-03] Incorrect description for auctioneerCut<br\n \n The comment was indeed not entirely clear and the suggestion provided by the warden should avoid any confusion in the future.\n \n L-04] Incorrect natspec for setLimit()<br\n \n Good recommendation, it's always best to write up to date Natspect documentations to avoid any confusion during a future refactor of the code.\n \n N-01] Modify comment to soft limit check for clarity<br\n \n Not critical, but the suggestion from the warden adds a bit of clarity to the comment.\n \n N-02] Typos<br\n \n It's always best to avoid typos in the documentation of the code.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 50 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-07-yield-findings/issues/47) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: hake(https://github.com/code-423n4/2022-07-yield-findings/issues/26), Meera(https://github.com/code-423n4/2022-07-yield-findings/issues/99), antonttc(https://github.com/code-423n4/2022-07-yield-findings/issues/117), joestakey(https://github.com/code-423n4/2022-07-yield-findings/issues/60), m&#95;Rassska(https://github.com/code-423n4/2022-07-yield-findings/issues/56), csanuragjain(https://github.com/code-423n4/2022-07-yield-findings/issues/148), TomJ(https://github.com/code-423n4/2022-07-yield-findings/issues/92), gogo(https://github.com/code-423n4/2022-07-yield-findings/issues/113), rbserver(https://github.com/code-423n4/2022-07-yield-findings/issues/97), Limbooo(https://github.com/code-423n4/2022-07-yield-findings/issues/137), MadWookie(https://github.com/code-423n4/2022-07-yield-findings/issues/173), hickuphh3(https://github.com/code-423n4/2022-07-yield-findings/issues/34), kyteg(https://github.com/code-423n4/2022-07-yield-findings/issues/78), ak1(https://github.com/code-423n4/2022-07-yield-findings/issues/98), 0xKitsune(https://github.com/code-423n4/2022-07-yield-findings/issues/79), defsec(https://github.com/code-423n4/2022-07-yield-findings/issues/149), Waze(https://github.com/code-423n4/2022-07-yield-findings/issues/49), ElKu(https://github.com/code-423n4/2022-07-yield-findings/issues/95), samruna(https://github.com/code-423n4/2022-07-yield-findings/issues/2), c3phas(https://github.com/code-423n4/2022-07-yield-findings/issues/145), JC(https://github.com/code-423n4/2022-07-yield-findings/issues/170), rajatbeladiya(https://github.com/code-423n4/2022-07-yield-findings/issues/38), cRat1st0s(https://github.com/code-423n4/2022-07-yield-findings/issues/71), JohnSmith(https://github.com/code-423n4/2022-07-yield-findings/issues/51), robee(https://github.com/code-423n4/2022-07-yield-findings/issues/14), sashik&#95;eth(https://github.com/code-423n4/2022-07-yield-findings/issues/156), &#95;&#95;141345&#95;&#95;(https://github.com/code-423n4/2022-07-yield-findings/issues/77), simon135(https://github.com/code-423n4/2022-07-yield-findings/issues/120), Aymen0909(https://github.com/code-423n4/2022-07-yield-findings/issues/152), fatherOfBlocks(https://github.com/code-423n4/2022-07-yield-findings/issues/20), Deivitto(https://github.com/code-423n4/2022-07-yield-findings/issues/162), tofunmi(https://github.com/code-423n4/2022-07-yield-findings/issues/29), 0xNazgul(https://github.com/code-423n4/2022-07-yield-findings/issues/41), ajtra(https://github.com/code-423n4/2022-07-yield-findings/issues/151), 0x1f8b(https://github.com/code-423n4/2022-07-yield-findings/issues/61), ReyAdmirado(https://github.com/code-423n4/2022-07-yield-findings/issues/32), pashov(https://github.com/code-423n4/2022-07-yield-findings/issues/59), bulej93(https://github.com/code-423n4/2022-07-yield-findings/issues/68), Trumpero(https://github.com/code-423n4/2022-07-yield-findings/issues/104), Sm4rty(https://github.com/code-423n4/2022-07-yield-findings/issues/125), Rohan16(https://github.com/code-423n4/2022-07-yield-findings/issues/131), rokinot(https://github.com/code-423n4/2022-07-yield-findings/issues/165), ignacio(https://github.com/code-423n4/2022-07-yield-findings/issues/9), durianSausage(https://github.com/code-423n4/2022-07-yield-findings/issues/45), 0x29A(https://github.com/code-423n4/2022-07-yield-findings/issues/65), karanctf(https://github.com/code-423n4/2022-07-yield-findings/issues/101), Kaiziron(https://github.com/code-423n4/2022-07-yield-findings/issues/167), Chom(https://github.com/code-423n4/2022-07-yield-findings/issues/143), and SooYa(https://github.com/code-423n4/2022-07-yield-findings/issues/168).*\n\n## Summary\n\n|        | Issue                                                                                                                      | Instances |\n| -----| :------------------------------------------------------------------------------------------------------------------------| :-------: |\n| G\u201101] | Multiple address/ID mappings can be combined into a single mapping of an address/ID to a struct, where appropriate |     1     |\n| G\u201102] | Using storage instead of memory for structs/arrays saves gas                                                           |     1     |\n| G\u201103] | The result of external function calls should be cached rather than re-calling the function                                 |     3     |\n| G\u201104] | Optimize names to save gas                                                                                                 |     1     |\n| G\u201105] | Using bools for storage incurs overhead                                                                                  |     2     |\n| G\u201106] | = costs less gas than                                                                                                |     3     |\n| G\u201107] | Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead                                                   |     2     |\n| G\u201108] | require() or revert() statements that check input arguments should be at the top of the function                       |     1     |\n| G\u201109] | Use custom errors rather than revert()/require() strings to save gas                                                   |     17    |\n| G\u201110] | Functions guaranteed to revert when called by normal users can be marked payable                                         |     6     |\n\nTotal: 37 instances over 10 issues\n\n## [G\u201101]  Multiple address/ID mappings can be combined into a single mapping of an address/ID to a struct, where appropriate\n\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to recalculate the key's keccak256 hash(https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 30 gas) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n66        mapping(bytes6 = mapping(bytes6 = DataTypes.Line)) public lines;\n67        mapping(bytes6 = mapping(bytes6 = DataTypes.Limits)) public limits;\n68        mapping(address = bool) public otherWitches;\n69:       mapping(bytes6 = mapping(bytes6 = bool)) public ignoredPairs;\n\n\n\nWitch.sol#L66-L69(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L66-L69)<br\n\n## [G\u201102]  Using storage instead of memory for structs/arrays saves gas\n\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n197           DataTypes.Limits memory limits_ = limits[vault.ilkId][\n198               series.baseId\n199:          ];\n\n\n\nWitch.sol#L197-L199(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L197-L199)<br\n\ndiff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..ccf9822 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -194,15 +194,15 @@ contract Witch is AccessControl {\n         // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit.\n         // If the limit has been surpassed, no more vaults of that collateral can be put for auction.\n         // This avoids the scenario where some vaults might be too large to be auctioned.\n       DataTypes.Limits memory limits_ = limits[vault.ilkId][\n+        DataTypes.Limits storage limits_ = limits[vault.ilkId][\n             series.baseId\n         ];\n       require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n+        uint128 lsum_ = limits_.sum;\n+        require(lsum_ <= limits_.max, \"Collateral limit reached\");\n \n         auction_ = _calcAuction(vault, series, to, balances, debt);\n \n       limits_.sum += auction_.ink;\n       limits[vault.ilkId][series.baseId] = limits_;\n+        limits_.sum = lsum_ + auction_.ink;\n \n         auctions[vaultId] = auction_;\n \n\n\ndiff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..749b496 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,11 +3,11 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3062982                            \u2506 15591           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 auction                            \u2506 4219            \u2506 70111 \u2506 81848  \u2506 91148 \u2506 30      \u2502\n+\u2502 auction                            \u2506 4219            \u2506 69956 \u2506 81665  \u2506 90965 \u2506 30      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctioneerReward                   \u2506 426             \u2506 426   \u2506 426    \u2506 426   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\n\n## [G\u201103]  The result of a function call should be cached rather than re-calling the function\n\nThe instances below point to the second+ call of the function within a single function\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n/// @audit inkOut.u128()\n450:                  limits_.sum -= inkOut.u128();\n\n/// @audit inkOut.u128()\n/// @audit artIn.u128()\n458:          cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n\n\n\nWitch.sol#L450(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L450)<br\n\ndiff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..c2196e8 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -421,6 +421,7 @@ contract Witch is AccessControl {\n         ];\n \n         // Update local auction\n+        uint128 io128_;\n         {\n             if (auction_.art == artIn) {\n                 // If there is no debt left, return the vault with the collateral to the owner\n@@ -428,6 +429,7 @@ contract Witch is AccessControl {\n \n                 // Update limits reduce it by the whole auction\n                 limits_.sum -= auction_.ink;\n+                io128_ = inkOut.u128();\n             } else {\n                 // Ensure enough dust is left\n                 DataTypes.Debt memory debt = cauldron.debt(\n@@ -439,15 +441,16 @@ contract Witch is AccessControl {\n                     \"Leaves dust\"\n                 );\n \n+                io128_ = inkOut.u128();\n                 // Update the auction\n               auction_.ink -= inkOut.u128();\n+                auction_.ink -= io128_;\n                 auction_.art -= artIn.u128();\n \n                 // Store auction changes\n                 auctions[vaultId] = auction_;\n \n                 // Update limits reduce it by whatever was bought\n               limits_.sum -= inkOut.u128();\n+                limits_.sum -= io128_;\n             }\n         }\n \n@@ -455,7 +458,7 @@ contract Witch is AccessControl {\n         limits[auction_.ilkId][auction_.baseId] = limits_;\n \n         // Update accounting at Cauldron\n       cauldron.slurp(vaultId, inkOut.u128(), artIn.u128());\n+        cauldron.slurp(vaultId, io128_, artIn.u128());\n     }\n \n     /// @dev Logs that a certain amount of a vault was liquidated\n\n\ndiff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..7867bad 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,7 +3,7 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3075198                            \u2506 15652           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n@@ -29,9 +29,9 @@\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 otherWitches                       \u2506 570             \u2506 570   \u2506 570    \u2506 570   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 payBase                            \u2506 7632            \u2506 20431 \u2506 22355  \u2506 26694 \u2506 10      \u2502\n+\u2502 payBase                            \u2506 7632            \u2506 20373 \u2506 22357  \u2506 26544 \u2506 10      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 payFYToken                         \u2506 7507            \u2506 19219 \u2506 20648  \u2506 27910 \u2506 10      \u2502\n+\u2502 payFYToken                         \u2506 7504            \u2506 19161 \u2506 20654  \u2506 27760 \u2506 10      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 point                              \u2506 2934            \u2506 5098  \u2506 2942   \u2506 9420  \u2506 3       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\n\n\n## [G\u201104]  Optimize names to save gas\n\npublic/external function names and public member variable names can be optimized to save gas. See this(https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save 128 gas each during deployment, and renaming functions to have lower method IDs will save 22 gas per call, per sorted position shifted(https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n/// @audit point(), setLine(), setLimit(), setAnotherWitch(), setIgnoredPair(), setAuctioneerReward(), auction(), cancel(), payBase(), payFYToken(), calcPayout()\n19:   contract Witch is AccessControl {\n\n\n\nWitch.sol#L19(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L19)<br\n\n## [G\u201105]  Using bools for storage incurs overhead\n\nsolidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n\nOpenZeppelin/ReentrancyGuard.sol#L23-L27(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)<br\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess ([100 gas(https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from false to true, after having been true in the past\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n68:       mapping(address = bool) public otherWitches;\n\n69:       mapping(bytes6 = mapping(bytes6 = bool)) public ignoredPairs;\n\n\n\nWitch.sol#L68(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L68)<br\n\n## [G\u201106]  = costs less gas than \n\nThe compiler uses opcodes GT and ISZERO for solidity code that uses , but only requires LT for =, which saves 3 gas(https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n308:          artIn = artIn  auction_.art ? auction_.art : artIn;\n\n361:          artIn = maxArtIn  auction_.art ? auction_.art : maxArtIn;\n\n556:          artIn = maxArtIn  auction_.art ? auction_.art : maxArtIn;\n\n\n\nWitch.sol#L308(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L308)<br\n\n## [G\u201107]  Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead\n\n When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html<br\nEach operation involving a uint8 costs an extra 28 gas(https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) as compared to ones involving uint256, due to the compiler having to clear the higher bits of the memory word before operating on the uint8, as well as the associated stack operations of doing so. Use a larger size then downcast where needed\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n/// @audit uint128 art\n233:          if (art < debt.min * (10debt.dec)) art = balances.art;\n\n/// @audit uint128 artIn\n308:          artIn = artIn  auction_.art ? auction_.art : artIn;\n\n\n\nWitch.sol#L233(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L233)<br\n\ndiff\ndiff --git a/contracts/Witch.sol b/contracts/Witch.sol\nindex f98dd6a..066e912 100644\n--a/contracts/Witch.sol\n+++ b/contracts/Witch.sol\n@@ -229,11 +229,11 @@ contract Witch is AccessControl {\n     ) internal view returns (DataTypes.Auction memory) {\n         // We store the proportion of the vault to auction, which is the whole vault if the debt would be below dust.\n         DataTypes.Line storage line = lines[vault.ilkId][series.baseId];\n       uint128 art = uint256(balances.art).wmul(line.proportion).u128();\n+        uint256 art = uint256(balances.art).wmul(line.proportion);\n         if (art < debt.min * (10debt.dec)) art = balances.art;\n       uint128 ink = (art == balances.art)\n+        uint256 ink = (art == balances.art)\n             ? balances.ink\n           : uint256(balances.ink).wmul(line.proportion).u128();\n+            : uint256(balances.ink).wmul(line.proportion);\n \n         return\n             DataTypes.Auction({\n@@ -242,8 +242,8 @@ contract Witch is AccessControl {\n                 seriesId: vault.seriesId,\n                 baseId: series.baseId,\n                 ilkId: vault.ilkId,\n               art: art,\n               ink: ink,\n+                art: art.u128(),\n+                ink: ink.u128(),\n                 auctioneer: to\n             });\n     }\n\n\ndiff\ndiff --git a/gas_before b/gas_after\nindex 68d894d..4f7212a 100644\n--a/gas_before\n+++ b/gas_after\n@@ -3,17 +3,17 @@\n \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n \u2502 Deployment Cost                    \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 3076398                            \u2506 15658           \u2506       \u2506        \u2506       \u2506         \u2502\n+\u2502 3077398                            \u2506 15663           \u2506       \u2506        \u2506       \u2506         \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 Function Name                      \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 auction                            \u2506 4219            \u2506 70111 \u2506 81848  \u2506 91148 \u2506 30      \u2502\n+\u2502 auction                            \u2506 4219            \u2506 70086 \u2506 81815  \u2506 91115 \u2506 30      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctioneerReward                   \u2506 426             \u2506 426   \u2506 426    \u2506 426   \u2506 1       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 auctions                           \u2506 1244            \u2506 1244  \u2506 1244   \u2506 1244  \u2506 20      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n-\u2502 calcPayout                         \u2506 3627            \u2506 10420 \u2506 14603  \u2506 19151 \u2506 29      \u2502\n+\u2502 calcPayout                         \u2506 3627            \u2506 10415 \u2506 14603  \u2506 19118 \u2506 29      \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n \u2502 cancel                             \u2506 2736            \u2506 9683  \u2506 5675   \u2506 20639 \u2506 3       \u2502\n \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\n\n\n## [G\u201108]  require() or revert() statements that check input arguments should be at the top of the function\n\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas&ast;) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n/// @audit expensive op on line 105\n108:          require(proportion = 0.01e18, \"Proportion below 1%\");\n\n\n\nWitch.sol#L108(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L108)<br\n\n## [G\u201109]  Use custom errors rather than revert()/require() strings to save gas\n\nCustom errors are available from solidity version 0.8.4. Custom errors save ~50 gas(https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by avoiding having to allocate and store the revert string(https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 17 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n84:           require(param == \"ladle\", \"Unrecognized\");\n\n102:          require(initialOffer <= 1e18, \"InitialOffer above 100%\");\n\n103:          require(proportion <= 1e18, \"Proportion above 100%\");\n\n104           require(\n105               initialOffer == 0 || initialOffer = 0.01e18,\n106               \"InitialOffer below 1%\"\n107:          );\n\n108:          require(proportion = 0.01e18, \"Proportion below 1%\");\n\n189:          require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n200:          require(limits_.sum <= limits_.max, \"Collateral limit reached\");\n\n255:          require(auction_.start  0, \"Vault not under auction\");\n\n256:          require(cauldron.level(vaultId) = 0, \"Undercollateralized\");\n\n300:          require(auction_.start  0, \"Vault not under auction\");\n\n313:          require(liquidatorCut = minInkOut, \"Not enough bought\");\n\n328:              require(baseJoin != IJoin(address(0)), \"Join not found\");\n\n358:          require(auction_.start  0, \"Vault not under auction\");\n\n365:          require(liquidatorCut = minInkOut, \"Not enough bought\");\n\n395:              require(ilkJoin != IJoin(address(0)), \"Join not found\");\n\n416:          require(auction_.start  0, \"Vault not under auction\");\n\n437                   require(\n438                       auction_.art artIn = debt.min * (10debt.dec),\n439                       \"Leaves dust\"\n440:                  );\n\n\n\nWitch.sol#L84(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L84)<br\n\n## [G\u201110]  Functions guaranteed to revert when called by normal users can be marked payable\n\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 6 instances of this issue:*\n\nsolidity\nFile: contracts/Witch.sol\n\n83:       function point(bytes32 param, address value) external auth {\n\n95        function setLine(\n96            bytes6 ilkId,\n97            bytes6 baseId,\n98            uint32 duration,\n99            uint64 proportion,\n100           uint64 initialOffer\n101:      ) external auth {\n\n126       function setLimit(\n127           bytes6 ilkId,\n128           bytes6 baseId,\n129           uint128 max\n130:      ) external auth {\n\n141:      function setAnotherWitch(address value, bool isWitch) external auth {\n\n150       function setIgnoredPair(\n151           bytes6 ilkId,\n152           bytes6 baseId,\n153           bool ignore\n154:      ) external auth {\n\n161:      function setAuctioneerReward(uint128 auctioneerReward_) external auth {\n\n\n\nWitch.sol#L83(https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L83)<br\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]