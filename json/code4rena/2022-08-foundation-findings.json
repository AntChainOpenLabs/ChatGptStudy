[
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/**\n * @notice An interface for communicating fees to 3rd party marketplaces.\n * @dev Originally implemented in mainnet contract 0x44d6e8933f8271abcf253c72f9ed7e0e4c0323b3\n */\ninterface IGetFees {\n  /**\n   * @notice Get the recipient addresses to which creator royalties should be sent.\n   * @dev The expected royalty amounts are communicated with `getFeeBps`.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @return recipients An array of addresses to which royalties should be sent.\n   */\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory recipients);\n\n  /**\n   * @notice Get the creator royalty amounts to be sent to each recipient, in basis points.\n   * @dev The expected recipients are communicated with `getFeeRecipients`.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @return royaltiesInBasisPoints The array of fees to be sent to each recipient, in basis points.\n   */\n  function getFeeBps(uint256 tokenId) external view returns (uint256[] memory royaltiesInBasisPoints);\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/**\n * @notice Interface for EIP-2981: NFT Royalty Standard.\n * For more see: https://eips.ethereum.org/EIPS/eip-2981.\n */\ninterface IRoyaltyInfo {\n  /**\n   * @notice Get the creator royalties to be sent.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @param salePrice The total price of the sale.\n   * @return receiver The address to which royalties should be sent.\n   * @return royaltyAmount The total amount that should be sent to the `receiver`.\n   */\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount);\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\ninterface IGetRoyalties {\n  /**\n   * @notice Get the creator royalties to be sent.\n   * @dev The data is the same as when calling `getFeeRecipients` and `getFeeBps` separately.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @return recipients An array of addresses to which royalties should be sent.\n   * @return royaltiesInBasisPoints The array of fees to be sent to each recipient, in basis points.\n   */\n  function getRoyalties(uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory royaltiesInBasisPoints);\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "IGetFees.sol",
            "IRoyaltyInfo.sol",
            "IGetRoyalties.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "royaltyInfo",
                    "getFeeRecipients",
                    "getRoyalties",
                    "address("
                ],
                "Type": " Creator fees may be burned",
                "Description": "\nroyaltyInfo, getRoyalties, or getFeeRecipients may return address(0) as the recipient address. While the value 0 is correctly handled for the royalties itself, it is not for the address. In such a case, the ETH amount will be sent to address(0), i.e. it is burned and lost.\n\n",
                "Repair": "\nIn your logic for determining the recipients, treat address(0) as if no recipient was returned such that the other priorities / methods take over.\n\n\nHardlyDifficult (Foundation) confirmed, but disagreed with severity and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/31#issuecomment-1220570897):\n  We are looking into options here to improve.\n \n We believe this is Medium risk, burning a percent of the sale revenue is a form of leaking value. Otherwise the sale works as expected and the collector does get the NFT they purchased.\n \n The royalty APIs we use are meant to specific which addresses should receive payments and how much they each should receive. As the warden noted, we try to ignore entries which specify a 0 amount... but did not filter out address(0) recipients with 0 requested. Originally we were thinking this was a way of requesting that a portion of the sale be burned since that seems to be what the data is proposing.\n \n However we agree that this is more likely a configuration error. Since our market uses ETH and not ERC20 tokens, it's unlikely that creators would actually want a portion of the proceeds burned. We are exploring a change to send the additional revenue to the seller instead of burning the funds in this scenario.\n\nHickupHH3 (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/31#issuecomment-1226890842):\n  Case of protocol leaked value: Medium severity is appropriate.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/// Constant values shared across mixins.\n\n/**\n * @dev 100% in basis points.\n */\nuint256 constant BASIS_POINTS = 10000;\n\n/**\n * @dev The default admin role defined by OZ ACL modules.\n */\nbytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n/**\n * @dev Cap the number of royalty recipients.\n * A cap is required to ensure gas costs are not too high when a sale is settled.\n */\nuint256 constant MAX_ROYALTY_RECIPIENTS = 5;\n\n/**\n * @dev The minimum increase of 10% required when making an offer or placing a bid.\n */\nuint256 constant MIN_PERCENT_INCREMENT_DENOMINATOR = BASIS_POINTS / 1000;\n\n/**\n * @dev The gas limit used when making external read-only calls.\n * This helps to ensure that external calls does not prevent the market from executing.\n */\nuint256 constant READ_ONLY_GAS_LIMIT = 40000;\n\n/**\n * @dev Default royalty cut paid out on secondary sales.\n * Set to 10% of the secondary sale.\n */\nuint96 constant ROYALTY_IN_BASIS_POINTS = 1000;\n\n/**\n * @dev 10%, expressed as a denominator for more efficient calculations.\n */\nuint256 constant ROYALTY_RATIO = BASIS_POINTS / ROYALTY_IN_BASIS_POINTS;\n\n/**\n * @dev The gas limit to send ETH to multiple recipients, enough for a 5-way split.\n */\nuint256 constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\n\n/**\n * @dev The gas limit to send ETH to a single recipient, enough for a contract with a simple receiver.\n */\nuint256 constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "Constants.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n/\n  * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n  */\nfunction _distributeFunds(\n  address nftContract,\n  uint256 tokenId,\n  address payable seller,\n  uint256 price,\n  address payable buyReferrer\n)\n  internal\n  returns (\n    uint256 totalFees,\n    uint256 creatorRev,\n    uint256 sellerRev\n  )\n{\n  address payable[] memory creatorRecipients;\n  uint256[] memory creatorShares;\n\n  uint256 buyReferrerFee;\n  (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n    nftContract,\n    tokenId,\n    seller,\n    price,\n    buyReferrer\n  );\n\n  // Pay the creator(s)\n  unchecked {\n    for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n      _sendValueWithFallbackWithdraw(\n        creatorRecipients[i],\n        creatorShares[i],\n        SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients\n      );\n      // Sum the total creator rev from shares\n      // creatorShares is in ETH so creatorRev will not overflow here.\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  // Pay the seller\n  _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the protocol fee\n  _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the buy referrer fee\n  if (buyReferrerFee != 0) {\n    _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n    unchecked {\n      // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n      totalFees += buyReferrerFee;\n    }\n  }\n}\n"
                ],
                "Type": " NFT creator sales revenue recipients can steal gas",
                "Description": "\nSelling a NFT with NFTDropMarketFixedPriceSale.mintFromFixedPriceSale distributes the revenue from the sale to various recipients with the MarketFees._distributeFunds function.\n\nRecipients:\n\n*   NFT creator(s)\n*   NFT seller\n*   Protocol\n*   Buy referrer (optional)\n\nIt is possible to have multiple NFT creators. Sale revenue will be distributed to each NFT creator address. Revenue distribution is done by calling SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw and providing an appropriate gas limit to prevent consuming too much gas. For the revenue distribution to the seller, protocol and the buy referrer, a gas limit of SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20_000 is used. However, for the creators, a limit of SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000 is used. This higher amount of gas is used if PercentSplitETH is used as a recipient.\n\nA maximum of MAX_ROYALTY_RECIPIENTS = 5 NFT creator recipients are allowed.\n\nFor example, a once honest NFT collection and its 5 royalty creator recipients could turn \"malicious\" and could \"steal\" gas from NFT buyers on each NFT sale and therefore grief NFT sales. On each NFT sell, the 5 creator recipients (smart contracts) could consume the full amount of SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210_000 forwarded gas. Totalling 5 * 210_000 = 1_050_000 gas. With a gas price of e.g. 20 gwei, this equals to additional gas costs of 21_000_000 gwei = 0.028156 eth, with a ETH price of 2000, this would total to ~56.31 $ additional costs.\n\n\nmixins/shared/MarketFees.sol#L130(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L130)\n\nsolidity\n/\n  * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n  */\nfunction _distributeFunds(\n  address nftContract,\n  uint256 tokenId,\n  address payable seller,\n  uint256 price,\n  address payable buyReferrer\n)\n  internal\n  returns (\n    uint256 totalFees,\n    uint256 creatorRev,\n    uint256 sellerRev\n  )\n{\n  address payable[] memory creatorRecipients;\n  uint256[] memory creatorShares;\n\n  uint256 buyReferrerFee;\n  (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n    nftContract,\n    tokenId,\n    seller,\n    price,\n    buyReferrer\n  );\n\n  // Pay the creator(s)\n  unchecked {\n    for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n      _sendValueWithFallbackWithdraw(\n        creatorRecipients[i],\n        creatorShares[i],\n        SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS // @audit-info A higher amount of gas is forwarded to creator recipients\n      );\n      // Sum the total creator rev from shares\n      // creatorShares is in ETH so creatorRev will not overflow here.\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  // Pay the seller\n  _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the protocol fee\n  _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n  // Pay the buy referrer fee\n  if (buyReferrerFee != 0) {\n    _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n    unchecked {\n      // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n      totalFees += buyReferrerFee;\n    }\n  }\n}\n\n\n",
                "Repair": "\nConsider only providing a higher amount of gas (SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT.\n\nHardlyDifficult (Foundation) confirmed and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1220553946):\n  We will be making changes here.\n \n This seems like a Low risk issue since only gas is at risk, but protecting our collectors is an important goal so we are comfortable with Medium here.\n \n As the warden has noted, we use gas caps consistently when interacting with external addresses/contracts. This is important to ensure that the cost to collectors does not become unwieldy.. and that the calls cannot revert (e.g. if the receiver gets stuck in a loop).\n \n The gas limits we set are high enough to allow some custom logic to be performed, and to support smart contract wallets such as Gnosis Safe. For the scenario highlighted here, we have used a very high limit in order to work with contracts such as PercentSplitETH (which will push payments to up to 5 different recipients, and those recipients may be smart contract wallets themselves).\n \n However we were too flexible here. And in total, the max potential gas costs are higher than they should be. We have changed the logic to only use SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS when 1 recipient is defined, otherwise use SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT. This will support our PercentSplitETH scenario and use cases like it, while restricting the worst case scenario to something much more reasonable.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/165#issuecomment-1228026327):\n  Keeping the Medium severity because users are potentially paying more than necessary.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\ninterface IGetRoyalties {\n  /**\n   * @notice Get the creator royalties to be sent.\n   * @dev The data is the same as when calling `getFeeRecipients` and `getFeeBps` separately.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @return recipients An array of addresses to which royalties should be sent.\n   * @return royaltiesInBasisPoints The array of fees to be sent to each recipient, in basis points.\n   */\n  function getRoyalties(uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory royaltiesInBasisPoints);\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/FETHNode.sol\";\nimport \"./mixins/shared/FoundationTreasuryNode.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\nimport \"./mixins/shared/MarketFees.sol\";\nimport \"./mixins/shared/MarketSharedCore.sol\";\nimport \"./mixins/shared/SendValueWithFallbackWithdraw.sol\";\n\nimport \"./mixins/nftDropMarket/NFTDropMarketCore.sol\";\nimport \"./mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol\";\n\nerror NFTDropMarket_NFT_Already_Minted();\n\n/**\n * @title A market for minting NFTs with Foundation.\n */\ncontract NFTDropMarket is\n  Initializable,\n  FoundationTreasuryNode,\n  FETHNode,\n  MarketSharedCore,\n  NFTDropMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  MarketFees,\n  Gap10000,\n  NFTDropMarketFixedPriceSale\n{\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _treasury The Foundation Treasury contract address.\n   * @param _feth The FETH ERC-20 token contract address.\n   * @param _royaltyRegistry The Royalty Registry contract address.\n   */\n  constructor(\n    address payable _treasury,\n    address _feth,\n    address _royaltyRegistry\n  )\n    FoundationTreasuryNode(_treasury)\n    FETHNode(_feth)\n    MarketFees(\n      _royaltyRegistry,\n      /*assumePrimarySale=*/\n      true\n    ) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called once to configure the contract after the initial proxy deployment.\n   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.\n   */\n  function initialize() external initializer {\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns address(0) if the NFT has already been sold, otherwise checks for a listing in this market.\n   */\n  function _getSellerOf(address nftContract, uint256 tokenId)\n    internal\n    view\n    override(MarketSharedCore, NFTDropMarketFixedPriceSale)\n    returns (address payable seller)\n  {\n    // Check the current owner first in case it has been sold.\n    try IERC721(nftContract).ownerOf(tokenId) returns (address owner) {\n      if (owner != address(0)) {\n        // If sold, return address(0) since that owner cannot sell via this market.\n        return payable(address(0));\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    return super._getSellerOf(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Reverts if the NFT has already been sold, otherwise checks for a listing in this market.\n   */\n  function _getSellerOrOwnerOf(address nftContract, uint256 tokenId)\n    internal\n    view\n    override\n    returns (address payable sellerOrOwner)\n  {\n    // Check the current owner first in case it has been sold.\n    try IERC721(nftContract).ownerOf(tokenId) returns (address owner) {\n      if (owner != address(0)) {\n        // Once an NFT has been minted, it cannot be sold through this contract.\n        revert NFTDropMarket_NFT_Already_Minted();\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    return super._getSellerOf(nftContract, tokenId);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\n/**\n * @notice Interface for EIP-2981: NFT Royalty Standard.\n * For more see: https://eips.ethereum.org/EIPS/eip-2981.\n */\ninterface IRoyaltyInfo {\n  /**\n   * @notice Get the creator royalties to be sent.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @param salePrice The total price of the sale.\n   * @return receiver The address to which royalties should be sent.\n   * @return royaltyAmount The total amount that should be sent to the `receiver`.\n   */\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount);\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "IGetRoyalties.sol",
            "NFTDropMarket.sol",
            "NFTDropMarketFixedPriceSale.sol",
            "IRoyaltyInfo.sol",
            "FETH.sol",
            "MarketFees.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\ntry implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n  address payable[] memory _recipients,\n  uint256[] memory _splitPerRecipientInBasisPoints\n) {\n  (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n} catch // solhint-disable-next-line no-empty-blocks\n{\n  // Fall through\n}\n",
                    "//solidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 royaltyAmount\n  ) {\n    // Manifold contracts return (address(this), 0) when royalties are not defined\n    // so ignore results when the amount is 0\n    if (royaltyAmount  0) {\n      recipients = new address payable[(1);\n      recipients[0] = payable(receiver);\n      splitPerRecipientInBasisPoints = new uint256[(1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n",
                    "//solidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 /* royaltyAmount */\n  ) {\n    recipients = new address payable[(1);\n    recipients[0] = payable(receiver);\n    splitPerRecipientInBasisPoints = new uint256[(1);\n    // The split amount is assumed to be 100% when only 1 recipient is returned\n    return (recipients, splitPerRecipientInBasisPoints);\n  } \n"
                ],
                "Type": " Forget to check \"Some manifolds contracts of ERC-2981 return (address(this), 0) when royalties are not defined\" in 3rd priority - MarketFees.sol",
                "Description": "\nWrong return of cretorShares and creatorRecipients can make real royalties party can't gain the revenue of sale.\n\n\nFunction getFees() firstly call(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L422-L430) to function internalGetImmutableRoyalties to get the list of creatorRecipients and creatorShares if the nftContract define ERC2981 royalties.\n\nsolidity\ntry implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n  address payable[] memory _recipients,\n  uint256[] memory _splitPerRecipientInBasisPoints\n) {\n  (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n} catch // solhint-disable-next-line no-empty-blocks\n{\n  // Fall through\n}\n\n\n*\n\nIn the 1st priority(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L236-L255) it check the nftContract define the function royaltyInfo or not. If yes, it get the return value receiver and royaltyAmount. In some manifold contracts of erc2981, it return (address(this), 0) when royalties are not defined. So we ignore it when the royaltyAmount = 0\n\nsolidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 royaltyAmount\n  ) {\n    // Manifold contracts return (address(this), 0) when royalties are not defined\n    // so ignore results when the amount is 0\n    if (royaltyAmount  0) {\n      recipients = new address payable[(1);\n      recipients[0] = payable(receiver);\n      splitPerRecipientInBasisPoints = new uint256[(1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n\n*\n\nIn the same sense, the 3rd priority(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L297-L312) (it can reach to 3rd priority when function internalGetImmutableRoyalies fail to return some royalties) should check same as the 1st priority with the royaltyRegistry.getRoyaltyLookupAddress. But the 3rd priority forget to check the case when royaltyAmount == 0.\n\nsolidity\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 /* royaltyAmount */\n  ) {\n    recipients = new address payable[(1);\n    recipients[0] = payable(receiver);\n    splitPerRecipientInBasisPoints = new uint256[(1);\n    // The split amount is assumed to be 100% when only 1 recipient is returned\n    return (recipients, splitPerRecipientInBasisPoints);\n  } \n\n\nIt will make function(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/shared/MarketFees.sol#L98) _distributeFunds() transfer to the wrong creatorRecipients (for example erc2981 return (address(this), 0), market will transfer creator revenue to address(this) market contract, and make the fund freeze in contract forever).\n\nThis case just happen when\n\n*   nftContract doesn't have any support for royalties info\n*   overrideContract which was fetched fromroyaltyRegistry.getRoyaltyLookupAddress(nftContract) implements both function getRoyalties and royaltyInfo but doesn't support royaltyInfo by returning (address(this), 0).\n\n",
                "Repair": "\nAdd check if royaltyAmount  0 or not in 3rd priority.\n\nHardlyDifficult (Foundation) confirmed and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/147#issuecomment-1220593088):\n  This was a great catch. We will be making the recommended change.\n \n Medium risk seems correct as this is a form of potentially leaking value.\n \n We agree that any contract returning (address(this), 0) should be treated as no royalties defined instead of paying to address(this). \n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/147#issuecomment-1228039151):\n  Yes, agree that zero royalty amount check is missing for 3rd priority.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "NFTDropMarketFixedPriceSale.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "diff\ndiff --git a/FixedPriceDrop.sol.orig b/FixedPriceDrop.sol\nindex 0a6d698..56808f8 100644\n--a/FixedPriceDrop.sol.orig\n+++ b/FixedPriceDrop.sol\n@@ -71,14 +71,26 @@ contract TestFixedPriceDrop is Test {\n \n     / List for sale /\n     uint80 price = 0.5 ether;\n   uint16 limitPerAccount = 10;\n+    uint16 limitPerAccount = 3;\n     vm.prank(creator);\n     nftDropMarket.createFixedPriceSale(address(nftDropCollection), price, limitPerAccount);\n \n     / Mint from sale /\n     uint16 count = 3;\n     vm.deal(collector, 999 ether);\n   vm.prank(collector);\n+    vm.startPrank(collector);\n+    nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n+\n+    // Check that available count for collector is 0\n+    uint256 remaining = nftDropMarket.getAvailableCountFromFixedPriceSale(address(nftDropCollection), collector);\n+    assertEq(remaining, 0);\n+\n+    // Transfer all bought NFTs out\n+    nftDropCollection.transferFrom(collector, address(5), 1);\n+    nftDropCollection.transferFrom(collector, address(5), 2);\n+    nftDropCollection.transferFrom(collector, address(5), 3);\n+\n+    // Buy 3 more NFT\n     nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n   }\n }\n"
                ],
                "Type": " Possible to bypass saleConfig.limitPerAccount",
                "Description": "\nIt is possible to bypass the saleConfig.limitPerAccount set by the creator by transferring the NFTs out. For highly sought after NFT drops, a single smart contract can buy out the entire drop simply by calling mintFromFixedPriceSale then transferring the NFTs out and repeating the process multiple times.\n\n\nModify the FixedPriceDrop.sol Foundry test with the following changes.\n\ndiff\ndiff --git a/FixedPriceDrop.sol.orig b/FixedPriceDrop.sol\nindex 0a6d698..56808f8 100644\n--a/FixedPriceDrop.sol.orig\n+++ b/FixedPriceDrop.sol\n@@ -71,14 +71,26 @@ contract TestFixedPriceDrop is Test {\n \n     / List for sale /\n     uint80 price = 0.5 ether;\n   uint16 limitPerAccount = 10;\n+    uint16 limitPerAccount = 3;\n     vm.prank(creator);\n     nftDropMarket.createFixedPriceSale(address(nftDropCollection), price, limitPerAccount);\n \n     / Mint from sale /\n     uint16 count = 3;\n     vm.deal(collector, 999 ether);\n   vm.prank(collector);\n+    vm.startPrank(collector);\n+    nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n+\n+    // Check that available count for collector is 0\n+    uint256 remaining = nftDropMarket.getAvailableCountFromFixedPriceSale(address(nftDropCollection), collector);\n+    assertEq(remaining, 0);\n+\n+    // Transfer all bought NFTs out\n+    nftDropCollection.transferFrom(collector, address(5), 1);\n+    nftDropCollection.transferFrom(collector, address(5), 2);\n+    nftDropCollection.transferFrom(collector, address(5), 3);\n+\n+    // Buy 3 more NFT\n     nftDropMarket.mintFromFixedPriceSale{ value: price * count }(address(nftDropCollection), count, payable(0));\n   }\n }\n\n\n\nFoundry\n\n",
                "Repair": "\nUse a mapping to track how many NFTs an address has bought instead of relying on balanceOf.\n\nHardlyDifficult (Foundation) acknowledged and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/59#issuecomment-1218494243):\n This is accurate! We had several meetings about this concern while building the contract, ultimately deciding to move forward with this approach knowing that it has limitations. The trouble is every limit solution suggested and used in the wild today can be gamed, it's just varying levels of friction for an attacker to work around it. Once someone has coded up a workaround, it could easily be used on any of the collections being sold by our marketplace. So we decided to KISS.\n \n But if it can be gamed, why include a limit at all? Creators want one. It sets expectations with the community and makes the sale feel more fair. Many users will respect the limit as communicated we suspect more often than not, this simple limit check will be sufficient.\n \n What if it's not sufficient? If someone were to clearly abuse the system it may degrade the value of the collection for all. There are options available to the creator at that point. For example, the creator could create a new collection to replace the original airdropping NFTs to their legit holders, or allowing them to do an NFT swap (so the original collection can slowly be removed from circulation) -this swap could also have a deny list so that the abused sales cannot be used to redeem from the new collection, and presumably the original collection will quickly lose value so long as the creator's community is on board with this process. Or the creator and their community could choose to simply accept that the sale went down this way and wait for things to balance out again on the secondary market.\n \n I selected this instance as the primary submission for having a simple & clear coded POC.\n \n We agree Medium risk is appropriate for this since it could \"leak value with a hypothetical attack path with stated assumptions\".\n\n\n\n*\n\n\n"
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\n// Confirm that the collection has a sale in progress.\nif (saleConfig.limitPerAccount == 0) {\n\trevert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n}\n// Confirm that the buyer will not exceed the limit specified after minting.\nif (IERC721(nftContract).balanceOf(msg.sender) + count  saleConfig.limitPerAccount) {\t\n\trevert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n}\n"
                ],
                "Type": " contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
                "Description": "\nIn mintFromFixedPriceSale we can avoid the nested if blocks on lines 182-189(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L182-L189). This would improve readability and analyze and it would have the same effect. On the plus side, it will also save gas for a reverting call where saleConfig.limitPerAccount is zero by avoiding the outer if block in the original code.\n\nsolidity\n// Confirm that the collection has a sale in progress.\nif (saleConfig.limitPerAccount == 0) {\n\trevert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n}\n// Confirm that the buyer will not exceed the limit specified after minting.\nif (IERC721(nftContract).balanceOf(msg.sender) + count  saleConfig.limitPerAccount) {\t\n\trevert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n}\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\ninterface IGetRoyalties {\n  /**\n   * @notice Get the creator royalties to be sent.\n   * @dev The data is the same as when calling `getFeeRecipients` and `getFeeBps` separately.\n   * @param tokenId The ID of the NFT to get royalties for.\n   * @return recipients An array of addresses to which royalties should be sent.\n   * @return royaltiesInBasisPoints The array of fees to be sent to each recipient, in basis points.\n   */\n  function getRoyalties(uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory royaltiesInBasisPoints);\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/IERC20Approve.sol\";\nimport \"./interfaces/IERC20IncreaseAllowance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./libraries/BytesLibrary.sol\";\n\n/**\n * @title Auto-forward ETH to a pre-determined list of addresses.\n * @notice Deploys contracts which auto-forwards any ETH sent to it to a list of recipients\n * considering their percent share of the payment received.\n * ERC-20 tokens are also supported and may be split on demand by calling `splitERC20Tokens`.\n * If another asset type is sent to this contract address such as an NFT, arbitrary calls may be made by one\n * of the split recipients in order to recover them.\n * @dev Uses create2 counterfactual addresses so that the destination is known from the terms of the split.\n */\ncontract PercentSplitETH is Initializable {\n  using AddressUpgradeable for address payable;\n  using AddressUpgradeable for address;\n  using BytesLibrary for bytes;\n  using SafeMath for uint256;\n\n  /// @notice A representation of shares using 16-bits for efficient storage.\n  /// @dev This is only used internally.\n  struct ShareCompressed {\n    address payable recipient;\n    uint16 percentInBasisPoints;\n  }\n\n  /// @notice A representation of shares using 256-bits to ease integration.\n  struct Share {\n    address payable recipient;\n    uint256 percentInBasisPoints;\n  }\n\n  ShareCompressed[] private _shares;\n\n  uint256 private constant BASIS_POINTS = 10000;\n\n  /**\n   * @notice Emitted when an ERC20 token is transferred to a recipient through this split contract.\n   * @param erc20Contract The address of the ERC20 token contract.\n   * @param account The account which received payment.\n   * @param amount The amount of ERC20 tokens sent to this recipient.\n   */\n  event ERC20Transferred(address indexed erc20Contract, address indexed account, uint256 amount);\n  /**\n   * @notice Emitted when ETH is transferred to a recipient through this split contract.\n   * @param account The account which received payment.\n   * @param amount The amount of ETH payment sent to this recipient.\n   */\n  event ETHTransferred(address indexed account, uint256 amount);\n  /**\n   * @notice Emitted when a new percent split contract is created from this factory.\n   * @param contractAddress The address of the new percent split contract.\n   */\n  event PercentSplitCreated(address indexed contractAddress);\n  /**\n   * @notice Emitted for each share of the split being defined.\n   * @param recipient The address of the recipient when payment to the split is received.\n   * @param percentInBasisPoints The percent of the payment received by the recipient, in basis points.\n   */\n  event PercentSplitShare(address indexed recipient, uint256 percentInBasisPoints);\n\n  /**\n   * @dev Requires that the msg.sender is one of the recipients in this split.\n   */\n  modifier onlyRecipient() {\n    for (uint256 i = 0; i < _shares.length; ++i) {\n      if (_shares[i].recipient == msg.sender) {\n        _;\n        return;\n      }\n    }\n    revert(\"Split: Can only be called by one of the recipients\");\n  }\n\n  /**\n   * @notice Called once to configure the contract after the initial deployment.\n   * @dev This will be called by `createSplit` after deploying the proxy so it should never be called directly.\n   * @param shares The list of recipients and their share of the payment for the template to use.\n   */\n  function initialize(Share[] memory shares) external initializer {\n    require(shares.length >= 2, \"Split: Too few recipients\");\n    require(shares.length <= 5, \"Split: Too many recipients\");\n    uint256 total;\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < shares.length; ++i) {\n        require(shares[i].percentInBasisPoints < BASIS_POINTS, \"Split: Share must be less than 100%\");\n        // Require above ensures total will not overflow.\n        total += shares[i].percentInBasisPoints;\n        _shares.push(\n          ShareCompressed({\n            recipient: shares[i].recipient,\n            percentInBasisPoints: uint16(shares[i].percentInBasisPoints)\n          })\n        );\n        emit PercentSplitShare(shares[i].recipient, shares[i].percentInBasisPoints);\n      }\n    }\n    require(total == BASIS_POINTS, \"Split: Total amount must equal 100%\");\n  }\n\n  /**\n   * @notice Forwards any ETH received to the recipients in this split.\n   * @dev Each recipient increases the gas required to split\n   * and contract recipients may significantly increase the gas required.\n   */\n  receive() external payable {\n    _splitETH(msg.value);\n  }\n\n  /**\n   * @notice Creates a new minimal proxy contract and initializes it with the given split terms.\n   * If the contract had already been created, its address is returned.\n   * This must be called on the original implementation and not a proxy created previously.\n   * @param shares The list of recipients and their share of the payment for this split.\n   * @return splitInstance The contract address for the split contract created.\n   */\n  function createSplit(Share[] memory shares) external returns (PercentSplitETH splitInstance) {\n    bytes32 salt = keccak256(abi.encode(shares));\n    address clone = Clones.predictDeterministicAddress(address(this), salt);\n    splitInstance = PercentSplitETH(payable(clone));\n    if (!clone.isContract()) {\n      emit PercentSplitCreated(clone);\n      Clones.cloneDeterministic(address(this), salt);\n      splitInstance.initialize(shares);\n    }\n  }\n\n  /**\n   * @notice Allows the split recipients to make an arbitrary contract call.\n   * @dev This is provided to allow recovering from unexpected scenarios,\n   * such as receiving an NFT at this address.\n   *\n   * It will first attempt a fair split of ERC20 tokens before proceeding.\n   *\n   * This contract is built to split ETH payments. The ability to attempt to make other calls is here\n   * just in case other assets were also sent so that they don't get locked forever in the contract.\n   * @param target The address of the contract to call.\n   * @param callData The data to send to the `target` contract.\n   */\n  function proxyCall(address payable target, bytes memory callData) external onlyRecipient {\n    require(\n      !callData.startsWith(type(IERC20Approve).interfaceId) &&\n        !callData.startsWith(type(IERC20IncreaseAllowance).interfaceId),\n      \"Split: ERC20 tokens must be split\"\n    );\n    _splitERC20Tokens(IERC20(target));\n    target.functionCall(callData);\n  }\n\n  /**\n   * @notice Allows any ETH stored by the contract to be split among recipients.\n   * @dev Normally ETH is forwarded as it comes in, but a balance in this contract\n   * is possible if it was sent before the contract was created or if self destruct was used.\n   */\n  function splitETH() external {\n    _splitETH(address(this).balance);\n  }\n\n  /**\n   * @notice Anyone can call this function to split all available tokens at the provided address between the recipients.\n   * @dev This contract is built to split ETH payments. The ability to attempt to split ERC20 tokens is here\n   * just in case tokens were also sent so that they don't get locked forever in the contract.\n   * @param erc20Contract The address of the ERC20 token contract to split tokens for.\n   */\n  function splitERC20Tokens(IERC20 erc20Contract) external {\n    require(_splitERC20Tokens(erc20Contract), \"Split: ERC20 split failed\");\n  }\n\n  function _splitERC20Tokens(IERC20 erc20Contract) private returns (bool) {\n    try erc20Contract.balanceOf(address(this)) returns (uint256 balance) {\n      if (balance == 0) {\n        return false;\n      }\n      uint256 amountToSend;\n      uint256 totalSent;\n      unchecked {\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\n          ShareCompressed memory share = _shares[i];\n          bool success;\n          (success, amountToSend) = balance.tryMul(share.percentInBasisPoints);\n          if (!success) {\n            return false;\n          }\n          amountToSend /= BASIS_POINTS;\n          totalSent += amountToSend;\n          try erc20Contract.transfer(share.recipient, amountToSend) {\n            emit ERC20Transferred(address(erc20Contract), share.recipient, amountToSend);\n          } catch {\n            return false;\n          }\n        }\n        // Favor the 1st recipient if there are any rounding issues\n        amountToSend = balance - totalSent;\n      }\n      try erc20Contract.transfer(_shares[0].recipient, amountToSend) {\n        emit ERC20Transferred(address(erc20Contract), _shares[0].recipient, amountToSend);\n      } catch {\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  function _splitETH(uint256 value) private {\n    if (value != 0) {\n      uint256 totalSent;\n      uint256 amountToSend;\n      unchecked {\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\n          ShareCompressed memory share = _shares[i];\n          amountToSend = (value * share.percentInBasisPoints) / BASIS_POINTS;\n          totalSent += amountToSend;\n          share.recipient.sendValue(amountToSend);\n          emit ETHTransferred(share.recipient, amountToSend);\n        }\n        // Favor the 1st recipient if there are any rounding issues\n        amountToSend = value - totalSent;\n      }\n      _shares[0].recipient.sendValue(amountToSend);\n      emit ETHTransferred(_shares[0].recipient, amountToSend);\n    }\n  }\n\n  /**\n   * @notice Returns a recipient's percent share in basis points.\n   * @param index The index of the recipient to get the share of.\n   * @return percentInBasisPoints The percent of the payment received by the recipient, in basis points.\n   */\n  function getPercentInBasisPointsByIndex(uint256 index) external view returns (uint256 percentInBasisPoints) {\n    percentInBasisPoints = _shares[index].percentInBasisPoints;\n  }\n\n  /**\n   * @notice Returns the address for the proxy contract which would represent the given split terms.\n   * @dev The contract may or may not already be deployed at the address returned.\n   * Ensure that it is deployed before sending funds to this address.\n   * @param shares The list of recipients and their share of the payment for this split.\n   * @return splitInstance The contract address for the split contract created.\n   */\n  function getPredictedSplitAddress(Share[] memory shares) external view returns (address splitInstance) {\n    bytes32 salt = keccak256(abi.encode(shares));\n    splitInstance = Clones.predictDeterministicAddress(address(this), salt);\n  }\n\n  /**\n   * @notice Returns how many recipients are part of this split.\n   * @return length The number of recipients in this split.\n   */\n  function getShareLength() external view returns (uint256 length) {\n    length = _shares.length;\n  }\n\n  /**\n   * @notice Returns a recipient in this split.\n   * @param index The index of the recipient to get.\n   * @return recipient The recipient at the given index.\n   */\n  function getShareRecipientByIndex(uint256 index) external view returns (address payable recipient) {\n    recipient = _shares[index].recipient;\n  }\n\n  /**\n   * @notice Returns a tuple with the terms of this split.\n   * @return shares The list of recipients and their share of the payment for this split.\n   */\n  function getShares() external view returns (Share[] memory shares) {\n    shares = new Share[](_shares.length);\n    for (uint256 i = 0; i < shares.length; ++i) {\n      shares[i] = Share({ recipient: _shares[i].recipient, percentInBasisPoints: _shares[i].percentInBasisPoints });\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n",
        "CodeNames": [
            "IGetRoyalties.sol",
            "PercentSplitETH.sol",
            "MarketFees.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "BASIS_POINTS",
                    "getRoyalties",
                    "_recipients"
                ],
                "Type": " User may get all of the creator fees by specifying high number for himself",
                "Description": "\nIf one creator specified a share that is larger than BASIS_POINTS, the first creator gets all of the royalties. Depending on how these are set (which is not in the control of the project), this can be exploited by the first creator.\n\n\nA collective of artists have implemented a process where everyone can set its own share of the fees to the value that he thinks is fair and these values are returned by getRoyalties. Bob, the first entry in the list of _recipients sets its value to a value that is slightly larger than BASIS_POINTS such that he gets all of the royalties.\n\n",
                "Repair": "\nThere is no need for this check / logic, as the whole sum (totalShares) is used anyway to normalize the values.\n\nHardlyDifficult (Foundation) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/34#issuecomment-1218477008):\n We believe this is Low risk. For the Foundation collections, the royalty rate is hard coded to 10% or via PercentSplitETH which is not subject to this issue. For 3rd party collections, there are more direct ways to change the distribution if the creator was attempting to be malicious towards their partners -esp via the Royalty Registry.\n \n This report is true. And the recommendation seems reasonable. However we will not be making this change. We are currently investigating changing our royalty logic in order to use the values returned by collections directly, instead of normalizing it to 10% like we do now. Most of the royalty APIs used here are not official standards, but are becoming industry standards based on growing adoption -and they are expecting the percent amounts to be defined in Basis Points.\n \n We do not want to mislead the community too much to ease the pain of the potential upcoming change I mentioned above. If they are returning values  10,000 we don't want that pattern to be adopted by more collections.\n \n Another option may be to ignore the results if totalShares sums to  10,000 that's tempting but we are going to defer making a change like that until a future workstream which will be more dedicated to rethinking royalties.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/34#issuecomment-1229082114):\n  Am siding with the warden here, because for 3rd party collections, it may be the case that they use a larger denomination than basis points. As mentioned in a different issue, royalty standards are still in its infancy.\n \n  Most of the royalty APIs used here are not official standards, but are becoming industry standards based on growing adoption -and they are expecting the percent amounts to be defined in Basis Points.\n \n Hopeful for this to be the case so there is less ambiguity, and non-compliance can be ignored as suggested by the sponsor.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/FETHNode.sol\";\nimport \"./mixins/shared/FoundationTreasuryNode.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\nimport \"./mixins/shared/MarketFees.sol\";\nimport \"./mixins/shared/MarketSharedCore.sol\";\nimport \"./mixins/shared/SendValueWithFallbackWithdraw.sol\";\n\nimport \"./mixins/nftDropMarket/NFTDropMarketCore.sol\";\nimport \"./mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol\";\n\nerror NFTDropMarket_NFT_Already_Minted();\n\n/**\n * @title A market for minting NFTs with Foundation.\n */\ncontract NFTDropMarket is\n  Initializable,\n  FoundationTreasuryNode,\n  FETHNode,\n  MarketSharedCore,\n  NFTDropMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  MarketFees,\n  Gap10000,\n  NFTDropMarketFixedPriceSale\n{\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _treasury The Foundation Treasury contract address.\n   * @param _feth The FETH ERC-20 token contract address.\n   * @param _royaltyRegistry The Royalty Registry contract address.\n   */\n  constructor(\n    address payable _treasury,\n    address _feth,\n    address _royaltyRegistry\n  )\n    FoundationTreasuryNode(_treasury)\n    FETHNode(_feth)\n    MarketFees(\n      _royaltyRegistry,\n      /*assumePrimarySale=*/\n      true\n    ) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called once to configure the contract after the initial proxy deployment.\n   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.\n   */\n  function initialize() external initializer {\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns address(0) if the NFT has already been sold, otherwise checks for a listing in this market.\n   */\n  function _getSellerOf(address nftContract, uint256 tokenId)\n    internal\n    view\n    override(MarketSharedCore, NFTDropMarketFixedPriceSale)\n    returns (address payable seller)\n  {\n    // Check the current owner first in case it has been sold.\n    try IERC721(nftContract).ownerOf(tokenId) returns (address owner) {\n      if (owner != address(0)) {\n        // If sold, return address(0) since that owner cannot sell via this market.\n        return payable(address(0));\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    return super._getSellerOf(nftContract, tokenId);\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Reverts if the NFT has already been sold, otherwise checks for a listing in this market.\n   */\n  function _getSellerOrOwnerOf(address nftContract, uint256 tokenId)\n    internal\n    view\n    override\n    returns (address payable sellerOrOwner)\n  {\n    // Check the current owner first in case it has been sold.\n    try IERC721(nftContract).ownerOf(tokenId) returns (address owner) {\n      if (owner != address(0)) {\n        // Once an NFT has been minted, it cannot be sold through this contract.\n        revert NFTDropMarket_NFT_Already_Minted();\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    return super._getSellerOf(nftContract, tokenId);\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTDropMarketFixedPriceSale.sol",
            "NFTDropCollection.sol",
            "NFTDropMarket.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "count =",
                    "CreateFixedPriceSale(customERC",
                    "count",
                    "mintCountTo",
                    "limit",
                    "mintCountTo()",
                    "firstTokenId",
                    "mintFromFixedPriceSale(customERC",
                    "nftContract",
                    "createFixedPriceSale()",
                    "CreateFixedPriceSale"
                ],
                "Type": " Malicious Creator can steal from collectors upon minting with a custom NFT contract",
                "Description": "\nIn the case of a fixed price sale where nftContract is a custom NFT contract that adheres to INFTDropCollectionMint, a malicious creator can set a malicious implementation of INFTDropCollectionMint.mintCountTo() that would result in collectors calling this function losing funds without receiving the expected amount of NFTs.\n\n\nHere is a Foundry test(https://gist.github.com/joestakey/4b13c7ae6029332da6eaf63b9d2a38bd) that shows a fixed price sale with a malicious NFT contract, where a collector pays for 10 NFTs while only receiving one. It can be described as follow:\n\n*   A creator creates a malicious nftContract with mintCountTo minting only one NFT per call, regardless of the value of count\n\n*   The creator calls NFTDropMarketFixedPriceSale.createFixedPriceSale() to create a sale for nftContract, with limit set to 15.\n\n*   Bob is monitoring the CreateFixedPriceSale event. Upon noticing CreateFixedPriceSale(customERC721, Alice, price, limit), he calls NFTDropMarketFixedPriceSale.mintFromFixedPriceSale(customERC721, count == 10,). He pays the price of count = 10 NFTs, but because of the logic in mintCountTo, only receives one NFT.\n\nNote that mintCountTo can be implemented in many malicious ways, this is only one example. Another implementation could simply return firstTokenId without performing any minting.\n\n\nFoundry\n\n",
                "Repair": "\nThe problem here lies in the implementation of INFTDropCollectionMint(nftContract).mintCountTo(). You could add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf().\n\ndiff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n\n\nitsmeSTYJ (warden) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/211#issuecomment-1217433818):\n  This assumes a custom NFT contract with a bad implementation of mintCountTo which _may_ be a stretch but I agree that your mitigation steps should be added as a sanity check.\n\nHardlyDifficult (Foundation) confirmed and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/211#issuecomment-1220577342):\n  We will be making the recommended change.\n \n There's not really anything we can do to completely stop malicious contracts this is an inherit risk with NFT marketplaces. Even the recommended solution here is something a malicious contract could fake in order to bypass that requirement.\n \n What sold us on making a change here was not malicious creators / contracts but instead potential errors in the implementation or misunderstanding of the interface requirements our marketplace expects. To prevent these errors, we are introducing the recommended change (and it only added 1,300 gas to the mint costs!)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @notice A contract implementing just the minimum 721 requirements.\n * @dev Scaled back from OZ to remove the metadata extension and add a public mint function:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/token/ERC721/ERC721.sol\n */\ncontract BasicERC721 is ERC165, IERC721 {\n  using AddressUpgradeable for address;\n\n  // Mapping from token ID to owner address\n  mapping(uint256 => address) internal _owners;\n\n  // Mapping owner address to token count\n  mapping(address => uint256) internal _balances;\n\n  // Mapping from token ID to approved address\n  mapping(uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n    return interfaceId == type(IERC721).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721-balanceOf}.\n   */\n  function balanceOf(address owner) public view virtual override returns (uint256 balance) {\n    require(owner != address(0), \"ERC721: balance query for the zero address\");\n    return _balances[owner];\n  }\n\n  /**\n   * @dev See {IERC721-ownerOf}.\n   */\n  function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n    owner = _owners[tokenId];\n    require(owner != address(0), \"ERC721: invalid token ID\");\n    return owner;\n  }\n\n  /**\n   * @dev See {IERC721-approve}.\n   */\n  function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ownerOf(tokenId);\n    require(to != owner, \"ERC721: approval to current owner\");\n\n    require(\n      msg.sender == owner || isApprovedForAll(owner, msg.sender),\n      \"ERC721: approve caller is not token owner nor approved for all\"\n    );\n\n    _approve(to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-getApproved}.\n   */\n  function getApproved(uint256 tokenId) public view virtual override returns (address operator) {\n    require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev See {IERC721-setApprovalForAll}.\n   */\n  function setApprovalForAll(address operator, bool approved) public virtual override {\n    require(operator != msg.sender, \"ERC721: approve to caller\");\n\n    _operatorApprovals[msg.sender][operator] = approved;\n    emit ApprovalForAll(msg.sender, operator, approved);\n  }\n\n  /**\n   * @dev See {IERC721-isApprovedForAll}.\n   */\n  function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev See {IERC721-transferFrom}.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    //solhint-disable-next-line max-line-length\n    require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner nor approved\");\n\n    _transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) public virtual override {\n    require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner nor approved\");\n    _safeTransfer(from, to, tokenId, _data);\n  }\n\n  /**\n   * @notice Allow anyone to mint any unused tokenId for easy testing.\n   */\n  function mint(address to, uint256 tokenId) external {\n    _mint(to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n   *\n   * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n   * implement alternative mechanisms to perform token transfer, such as signature-based.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n   *   which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _safeTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) internal virtual {\n    _transfer(from, to, tokenId);\n    require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n  }\n\n  /**\n   * @dev Returns whether `tokenId` exists.\n   *\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n   *\n   * Tokens start existing when they are minted (`_mint`),\n   * and stop existing when they are burned (`_burn`).\n   */\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    return _owners[tokenId] != address(0);\n  }\n\n  /**\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n    require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n    address owner = ownerOf(tokenId);\n    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n  }\n\n  /**\n   * @dev Safely mints `tokenId` and transfers it to `to`.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must not exist.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n   *   which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _safeMint(address to, uint256 tokenId) internal virtual {\n    _safeMint(to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n   * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n   */\n  function _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) internal virtual {\n    _mint(to, tokenId);\n    require(\n      _checkOnERC721Received(address(0), to, tokenId, _data),\n      \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  /**\n   * @dev Mints `tokenId` and transfers it to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n   *\n   * Requirements:\n   *\n   * - `tokenId` must not exist.\n   * - `to` cannot be the zero address.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _mint(address to, uint256 tokenId) internal virtual {\n    require(to != address(0), \"ERC721: mint to the zero address\");\n    require(!_exists(tokenId), \"ERC721: token already minted\");\n\n    _balances[to] += 1;\n    _owners[tokenId] = to;\n\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual {\n    require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n    require(to != address(0), \"ERC721: transfer to the zero address\");\n\n    // Clear approvals from the previous owner\n    _approve(address(0), tokenId);\n\n    _balances[from] -= 1;\n    _balances[to] += 1;\n    _owners[tokenId] = to;\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Approve `to` to operate on `tokenId`\n   *\n   * Emits a {Approval} event.\n   */\n  function _approve(address to, uint256 tokenId) internal virtual {\n    _tokenApprovals[tokenId] = to;\n    emit Approval(ownerOf(tokenId), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n   * The call is not executed if the target address is not a contract.\n   *\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return bool whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (to.isContract()) {\n      try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\n        return retval == IERC721Receiver.onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTDropCollection.sol",
            "NFTCollection.sol",
            "BasicERC721.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "_checkOnERC",
                    "_mint",
                    "ERC",
                    "count",
                    "mintCountTo",
                    "IERC",
                    "onERC"
                ],
                "Type": " NFT of NFT collection or NFT drop collection can be locked when calling _mint or mintCountTo function to mint it to a contract that does not support ERC721 protocol",
                "Description": "\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187\n\n\nWhen calling the following _mint or mintCountTo function for minting an NFT of a NFT collection or NFT drop collection, the OpenZeppelin's ERC721Upgradeable contract's _mint(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is used to mint the NFT to a receiver. If such receiver is a contract that does not support the ERC721 protocol, the NFT will be locked and cannot be retrieved.\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274\n\n      function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n        require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n        require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n        unchecked {\n          // Number of tokens cannot overflow 256 bits.\n          tokenId = ++latestTokenId;\n          require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n          cidToMinted[tokenCID] = true;\n          _tokenCIDs[tokenId] = tokenCID;\n          _mint(msg.sender, tokenId);\n          emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n        }\n      }\n\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187\n\n      function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n        require(count != 0, \"NFTDropCollection: count must be greater than 0\");\n\n        unchecked {\n          // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n          firstTokenId = latestTokenId + 1;\n        }\n        latestTokenId = latestTokenId + count;\n        require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n        for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n          _mint(to, i);\n          unchecked {\n            ++i;\n          }\n        }\n      }\n\nFor reference, OpenZeppelin's documentation for _mint(https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721-_mint-address-uint256-) states: \"Usage of this method is discouraged, use _safeMint whenever possible\".\n\n\nThe following steps can occur when minting an NFT of a NFT collection or NFT drop collection.\n\n1.  The _mint(https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L262-L274) or mintCountTo(https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L171-L187) function is called with msg.sender or the to input corresponding to a contract.\n2.  The OpenZeppelin's ERC721Upgradeable contract's _mint(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function is called with msg.sender or to used in Step 1 as the receiver address.\n3.  Since calling the OpenZeppelin's ERC721Upgradeable contract's _mint(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L284-L296) function does not execute the same contract's _checkOnERC721Received(https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC721/ERC721Upgradeable.sol#L400-L422) function, it is unknown if the receiving contract inherits from the IERC721ReceiverUpgradeable interface and implements the onERC721Received function or not. It is possible that the receiving contract does not support the ERC721 protocol, which causes the minted NFT to be locked.\n\n\nVSCode\n\n",
                "Repair": "\n<https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollection.sol#L271 can be changed to the following code.\n\n    _safeMint(msg.sender, tokenId);\n\nAlso, <https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L182 can be changed to the following code.\n\n    _safeMint(to, i);\n\nHardlyDifficult (Foundation) confirmed and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/183#issuecomment-1219513491):\n  Agree will fix.\n \n Generally we are inclined to skip \"safe\" by default it can introduce reentrancy & reverting risk and increase gas costs. When a user is making an action to buy or mint an NFT for themselves, it's very clear that they are trying to acquire an NFT so using safe to ensure that they support NFTs seems like a Low risk concern and we are inclined to avoid potential reentrancy/reverts and save costs for the common user paths.\n \n However in this scenario the part that stood out as different is instead of minting for yourself (the msg.sender) we support minting to an arbitrary to address, e.g. for an airdrop type use case. Here specifically it does seem that sending to a list of addresses could be error prone, where a contract address without 721 support was incorrectly captured. To guard against that scenario specifically we are moving forward with this change.\n \n Then for consistency we have decided to use safeMint for both collection types because the difference is nuanced.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTDropMarketFixedPriceSale.sol",
            "NFTDropCollection.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "diff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n",
                    "\n /// if the minting fails it MUST result in the transaction being reverted.\n "
                ],
                "Type": "  mintFromFixedPriceSale  for a custom contract can lead to users losing funds",
                "Description": "\nNFTDropMarketFixedPriceSale.createFixedPriceSale allows creators to create a sale drop.\nA creator can create a drop sale for their custom NFT Contract that adheres to INFTDropCollectionMint.\n\nINFTDropCollectionMint.mintCountTo must return the firstTokenId being minted, but it is not clear as to what should be returned upon all tokens being minted. A valid implementation could for instance return 0 if called after the last token has been minted.\n\nBut the drop market expects the call to mintCountTo(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) to revert upon the last token being minted, meaning a user calling it afterwards would lose the ETH they sent.\n\n\n*   Alice creates a customERC721 contract adhering to INFTDropCollectionMint. She writes mintCountTo() so that it returns 0 if called when all the tokens have been minted.\n*   The sale happens and collectors call mintFromFixedPriceSale until all the tokens have been minted.\n*   Bob now calls mintFromFixedPriceSale. Because all the tokens have been minted, the call to mintCountTo(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L207) does not revert but returns 0.\n*   The function call then proceeds to distribute the funds.\n*   Bob have lost mintCost ETH, while not receiving any NFT.\n\nYou can find this Foundry test(https://gist.github.com/joestakey/5dc8839c7622bdb9467d743924f072b6) reproducing the issue.\n\nNote that this is not an issue of a malicious creator rugging collectors with a malicious implementation: they have implemented their contract to adhere to INFTDropCollectionMint, and the sale went as expected.\n\nIt is not unrealistic to imagine collectors monitoring CreateFixedPriceSale and calling mintFromFixedPriceSale based on it. In this case, all the mintFromFixedPriceSale processed after the last token being minted would lead to loss of funds.\n\n\nFoundry\n\n\nYou can add an additional check in NFTDropMarketFixedPriceSale.mintCountTo() using ERC721(nftContract).balanceOf().\n\ndiff\n+ uint256 balanceBefore = IERC721(nftContract).balanceOf(msg.sender);\n207:     firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n+ uint256 balanceAfter = IERC721(nftContract).balanceOf(msg.sender);\n+ require(balanceAfter == balanceBefore + count, \"minting failed\")\n\n\nYou can also specify in INFTDropCollectionMint that mintCountTo must revert if called after all tokens have been minted.\n\nHardlyDifficult (Foundation) marked as duplicate and commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1220574136):\n  Although this submission uses a different POC, we believe it's the same issue & root cause as #211(https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n \n Dupe of #211(https://github.com/code-423n4/2022-08-foundation-findings/issues/211).\n\njoestakey (warden) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1229461934):\n  I will argue this issue is actually different than #211(https://github.com/code-423n4/2022-08-foundation-findings/issues/211), although they both come from the same function call:\n \n In #211(https://github.com/code-423n4/2022-08-foundation-findings/issues/211), the issue lies in the logic performed in INFTDropCollectionMint.mintCountTo(), more precisely the fact that a malicious implementation can perform incorrect state logic, which results in any collector calling NFTDropMarketFixedPriceSale.mintFromFixedPriceSale losing funds without receiving the expected amount of NFTs.\n Here, the issue lies in the return value of INFTDropCollectionMint.mintCountTo() in an edge case when all the tokens have been minted. There is no malicious implementation or wrong state logic: users calling NFTDropMarketFixedPriceSale.mintFromFixedPriceSale will receive the expected amount of NFTs. The problem is when the minting is done: the DropMarket expect subsequent calls to mintCountTo() to fail. While you can argue not reverting after the final token has been minted is breaking a semantic requirement, it still complies with the interface INFTDropCollectionMint. Not reverting on failure is a behavior that exists in other standards, such as some ERC20 tokens for instance, like ZRX(https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code).\n \n To illustrate the difference between the two issues, take the NFT contract used in the PoC for this issue: users calling NFTDropMarketFixedPriceSale.mintFromFixedPriceSale will receive the expected amount of NFTs i.e. it is not affected by the issue #211. The problem arises only upon the final token being minted.\n \n In summary, #211(https://github.com/code-423n4/2022-08-foundation-findings/issues/211) is about malicious implementations that users should be made aware of (docs or UI warnings) while this issue has to do with the fact INFTDropCollectionMint.mintCountTo() should define a stricter behavior when the last token has been minted, perhaps by adding a comment such as:\n \n /// if the minting fails it MUST result in the transaction being reverted.\n \n \n @HickupHH3 thoughts?\n \n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/279#issuecomment-1240810016):\n The root cause for both issues is about the \"potential errors in the implementation or misunderstanding of the interface requirements\". Simply put, the ambiguity regarding the specification of mintCountTo() allows for it to be exploited. As you pointed out, #211 is exploited by malicious implementations while this issue happens even if the implementation is seemingly compliant to the interface because of the ambiguity.\n \n It's a tough decision because while the methods are different, the root cause and consequence (users losing funds) are the same.\n \n I'll side with you on this one, because the attack vectors are quite distinct. It's similar to how I separated the strategist rug vectors for the Rubicon contest.\n\n\n\n*\n\n\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 73 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-08-foundation-findings/issues/184) by Saw-mon&#95;and&#95;Natalie received the top score from the judge.\n\n*The following wardens also submitted reports: Dravee(https://github.com/code-423n4/2022-08-foundation-findings/issues/127), Lambda(https://github.com/code-423n4/2022-08-foundation-findings/issues/25), IllIllI(https://github.com/code-423n4/2022-08-foundation-findings/issues/207), rbserver(https://github.com/code-423n4/2022-08-foundation-findings/issues/289), 0x1f8b(https://github.com/code-423n4/2022-08-foundation-findings/issues/41), berndartmueller(https://github.com/code-423n4/2022-08-foundation-findings/issues/161), Chom(https://github.com/code-423n4/2022-08-foundation-findings/issues/51), zkhorse(https://github.com/code-423n4/2022-08-foundation-findings/issues/208), carlitox477(https://github.com/code-423n4/2022-08-foundation-findings/issues/148), 0xSmartContract(https://github.com/code-423n4/2022-08-foundation-findings/issues/115), csanuragjain(https://github.com/code-423n4/2022-08-foundation-findings/issues/112), joestakey(https://github.com/code-423n4/2022-08-foundation-findings/issues/249), 0xsolstars(https://github.com/code-423n4/2022-08-foundation-findings/issues/239), bin2chen(https://github.com/code-423n4/2022-08-foundation-findings/issues/144), Ruhum(https://github.com/code-423n4/2022-08-foundation-findings/issues/62), shenwilly(https://github.com/code-423n4/2022-08-foundation-findings/issues/167), Deivitto(https://github.com/code-423n4/2022-08-foundation-findings/issues/274), 0xNazgul(https://github.com/code-423n4/2022-08-foundation-findings/issues/234), d3e4(https://github.com/code-423n4/2022-08-foundation-findings/issues/262), yash90(https://github.com/code-423n4/2022-08-foundation-findings/issues/224), 0xDjango(https://github.com/code-423n4/2022-08-foundation-findings/issues/139), 0xSolus(https://github.com/code-423n4/2022-08-foundation-findings/issues/130), c3phas(https://github.com/code-423n4/2022-08-foundation-findings/issues/251), Rolezn(https://github.com/code-423n4/2022-08-foundation-findings/issues/37), simon135(https://github.com/code-423n4/2022-08-foundation-findings/issues/188), Bnke0x0(https://github.com/code-423n4/2022-08-foundation-findings/issues/69), robee(https://github.com/code-423n4/2022-08-foundation-findings/issues/156), rvierdiiev(https://github.com/code-423n4/2022-08-foundation-findings/issues/196), 0x52(https://github.com/code-423n4/2022-08-foundation-findings/issues/85), auditor0517(https://github.com/code-423n4/2022-08-foundation-findings/issues/194), danb(https://github.com/code-423n4/2022-08-foundation-findings/issues/21), delfin454000(https://github.com/code-423n4/2022-08-foundation-findings/issues/212), durianSausage(https://github.com/code-423n4/2022-08-foundation-findings/issues/44), erictee(https://github.com/code-423n4/2022-08-foundation-findings/issues/14), ladboy233(https://github.com/code-423n4/2022-08-foundation-findings/issues/247), oyc&#95;109(https://github.com/code-423n4/2022-08-foundation-findings/issues/57), PwnedNoMore(https://github.com/code-423n4/2022-08-foundation-findings/issues/232), TomJ(https://github.com/code-423n4/2022-08-foundation-findings/issues/174), gogo(https://github.com/code-423n4/2022-08-foundation-findings/issues/49), Kumpa(https://github.com/code-423n4/2022-08-foundation-findings/issues/86), mics(https://github.com/code-423n4/2022-08-foundation-findings/issues/73), ret2basic(https://github.com/code-423n4/2022-08-foundation-findings/issues/222), rokinot(https://github.com/code-423n4/2022-08-foundation-findings/issues/117), thank&#95;you(https://github.com/code-423n4/2022-08-foundation-findings/issues/179), Treasure-Seeker(https://github.com/code-423n4/2022-08-foundation-findings/issues/93), wagmi(https://github.com/code-423n4/2022-08-foundation-findings/issues/272), Waze(https://github.com/code-423n4/2022-08-foundation-findings/issues/199), &#95;141345&#95;(https://github.com/code-423n4/2022-08-foundation-findings/issues/101), brgltd(https://github.com/code-423n4/2022-08-foundation-findings/issues/253), bulej93(https://github.com/code-423n4/2022-08-foundation-findings/issues/149), JC(https://github.com/code-423n4/2022-08-foundation-findings/issues/285), zeesaw(https://github.com/code-423n4/2022-08-foundation-findings/issues/47), fatherOfBlocks(https://github.com/code-423n4/2022-08-foundation-findings/issues/83), sikorico(https://github.com/code-423n4/2022-08-foundation-findings/issues/71), apostle0x01(https://github.com/code-423n4/2022-08-foundation-findings/issues/257), jonatascm(https://github.com/code-423n4/2022-08-foundation-findings/issues/214), Vexjon(https://github.com/code-423n4/2022-08-foundation-findings/issues/6), cryptphi(https://github.com/code-423n4/2022-08-foundation-findings/issues/219), 0xackermann(https://github.com/code-423n4/2022-08-foundation-findings/issues/98), 0xmatt(https://github.com/code-423n4/2022-08-foundation-findings/issues/153), bobirichman(https://github.com/code-423n4/2022-08-foundation-findings/issues/74), DevABDee(https://github.com/code-423n4/2022-08-foundation-findings/issues/173), ElKu(https://github.com/code-423n4/2022-08-foundation-findings/issues/170), iamwhitelights(https://github.com/code-423n4/2022-08-foundation-findings/issues/42), LeoS(https://github.com/code-423n4/2022-08-foundation-findings/issues/76), Rohan16(https://github.com/code-423n4/2022-08-foundation-findings/issues/225), Sm4rty(https://github.com/code-423n4/2022-08-foundation-findings/issues/202), MiloTruck(https://github.com/code-423n4/2022-08-foundation-findings/issues/105), ReyAdmirado(https://github.com/code-423n4/2022-08-foundation-findings/issues/61), Aymen0909(https://github.com/code-423n4/2022-08-foundation-findings/issues/273), cccz(https://github.com/code-423n4/2022-08-foundation-findings/issues/97), and Yiko(https://github.com/code-423n4/2022-08-foundation-findings/issues/18).*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n"
                ],
                "Type": " contracts/mixins/collections/CollectionRoyalties.sol ",
                "Description": "\nOn line 80(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/CollectionRoyalties.sol#L80), supportsInterface can be rewritten to avoid the if/esle branching:\n\nsolidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool interfaceSupported) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "",
                "Location": [
                    "//solidity\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  ContractFactory,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n"
                ],
                "Type": " contracts/NFTCollection.sol",
                "Description": "\n\nThe inheritance contracts on line 29-40(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L29-L40) can be consolidated into a shorter list:\n\nsolidity\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  ContractFactory,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n\n\nThen you would need to adjust the overrides on lines 255(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L255) and 316(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollection.sol#L316)\n\n\nDifferent tokenIDs can not share the same CID by design. Although it is possible to design the contract so that some tokens share the same CID to save storage and also server space for off-chain contents.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "2",
                "Location": [
                    "//solidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId || \n\t\tsuper.supportsInterface(interfaceId);\n\t);\n}\n",
                    "//solidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tinterfaceSupported = super.supportsInterface(interfaceId)\n\t)\n}\n"
                ],
                "Type": " Simplify  supportsInterface  check",
                "Description": "\n\nNFTDropCollection.supportsInterface (lines 284-295(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L284-L295)) can be changed to:\n\nsolidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId || \n\t\tsuper.supportsInterface(interfaceId);\n\t);\n}\n\n\n\nCollectionRoyalties.supportsInterface (lines 80-91(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/collections/CollectionRoyalties.sol#L80-L91)) can be changed to:\n\nsolidity\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\treturn (\n\t\tinterfaceId == type(IRoyaltyInfo).interfaceId ||\n\t\tinterfaceId == type(ITokenCreator).interfaceId ||\n\t\tinterfaceId == type(IGetRoyalties).interfaceId ||\n\t\tinterfaceId == type(IGetFees).interfaceId ||\n\t\tinterfaceSupported = super.supportsInterface(interfaceId)\n\t)\n}\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./IRoles.sol\";\nimport \"./IProxyCall.sol\";\n\ninterface ICollectionFactory {\n  function rolesContract() external returns (IRoles);\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\ninterface IProxyCall {\n  function proxyCallAndReturnAddress(address externalContract, bytes memory callData)\n    external\n    returns (address payable result);\n}\n\n\n",
        "CodeNames": [
            "ICollectionFactory.sol",
            "IProxyCall.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [],
                "Type": " contracts/interfaces/ICollectionFactory.sol ",
                "Description": "\nIn ICollectionFactory on line 6(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/interfaces/ICollectionFactory.sol#L6), IProxyCall is never used and can safely be removed. Unless there is a plan to use it in the future. Maybe a comment explaining why it was imported here would be helpful.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"../../interfaces/ICollectionFactory.sol\";\n\n/**\n * @title Stores a reference to the factory which is used to create contract proxies.\n */\nabstract contract ContractFactory {\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The address of the factory which was used to create this contract.\n   * @return The factory contract address.\n   */\n  address public immutable contractFactory;\n\n  modifier onlyContractFactory() {\n    require(msg.sender == contractFactory, \"ContractFactory: Caller is not the factory\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create these contracts.\n   */\n  constructor(address _contractFactory) {\n    require(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\n    contractFactory = _contractFactory;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n",
        "CodeNames": [
            "ContractFactory.sol",
            "NFTCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\n 5\timport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n13 \tusing AddressUpgradeable for address;\n31\trequire(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\n"
                ],
                "Type": " contracts/mixins/shared/ContractFactory.sol",
                "Description": "\nOn line 31(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/ContractFactory.sol#L31), there is a check for _contractFactory to see if it already has a code. I guess this is an extra check that can be removed. Since if _contractFactory calls the constructor here in its own constructor by then _contractFactory.isContract() = _contractFactory.code.length == 0. Also, it is possible that a wrong contract address is passed here, so the check would not really do anything. This will only check against accidental EOA addresses used for _contractFactory. So we could possibly remove the following lines:\n\nsolidity\n 5\timport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n13 \tusing AddressUpgradeable for address;\n31\trequire(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\n\n\nIf there is a stricter condition for the allowed contractFactory addresses, maybe we could use that instead. One possible idea is an array of implementation contract code hashes that we could check. Or maybe contracts that have a function similar to supportsInterface that returns a magic number which we could check here.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollectionFactory.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nconstructor(address _rolesContract) {\n\trequire(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\"); \n\n\trolesContract = IRoles(_rolesContract);\n}\n\n",
                    "//solidity\nconstructor(address _rolesContract, bytes32 codehash) {\n\trequire(_rolesContract.codehash == codehash, \"NFTCollectionFactory: RolesContract is not a contract\");\n\n\trolesContract = IRoles(_rolesContract);\n}\n"
                ],
                "Type": " contracts/NFTCollectionFactory.sol",
                "Description": "\n\nOn lines 182(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L182), and 203(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L203) instead of checking if addr.isContract() to avoid setting the addresses to EOA by mistake it would be best to pass the code hash instead and check the code hash at those addresses. So for example:\n\nBefore:\n\nsolidity\nconstructor(address _rolesContract) {\n\trequire(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\"); \n\n\trolesContract = IRoles(_rolesContract);\n}\n\n\n\nAfter:\n\nsolidity\nconstructor(address _rolesContract, bytes32 codehash) {\n\trequire(_rolesContract.codehash == codehash, \"NFTCollectionFactory: RolesContract is not a contract\");\n\n\trolesContract = IRoles(_rolesContract);\n}\n\n\nThis is a stronger requirement since it would guarantee that the addresses are contracts and also they have the required code hash. For the functions to pass the require statements you would need to make 2 mistakes, one for the address and the other for the code hash. The probability of making this mistake should be theoretically lower than just passing a wrong address.\n\n\nDoesn't have an initializer like versionNFTCollection.\n\n\nrolerManager might be a better name for this immutable variable and would make it easier to remember what it does (ref. line 104(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L104)).\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollection.sol",
            "MarketFees.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n",
                    "//solidity\n// If +1 overflows then +count would also overflow, since count  0.\n",
                    "//solidity\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  ContractFactory,\n  MinterRole,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n"
                ],
                "Type": " contracts/NFTDropCollection.sol",
                "Description": "\n\nWe can rewrite supportsInterface function (Lines 284-294(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L284-L294)) like the following block which would make it easier to read and possibly would save some gas.\n\nsolidity\nfunction supportsInterface(bytes4 interfaceId)\n\tpublic\n\tview\n\toverride(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n\treturns (bool)\n{\n\treturn (\n\t\tinterfaceId == type(INFTDropCollectionMint).interfaceId ||\n\t\tsuper.supportsInterface(interfaceId)\n\t);\n}\n\n\n\nSo the current comment says:\n\n If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n\nBut count can not be zero if we have reached this line. Since we have already checked for a non-zero count on line 172(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L172)\n\nSo we can change the comment to\n\nsolidity\n// If +1 overflows then +count would also overflow, since count  0.\n\n\n\nLike NFTCollection, the inheritence list for NFTDropCollection contract on lines 28-46(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L28-L46) can be consolidated more.\n\nsolidity\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  ContractFactory,\n  MinterRole,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n\n\nThe overrides on lines 245(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L245) and 287(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L287) would also need to be modified accordingly.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "",
                "Location": [
                    "//solidity\nconstructor(\n\taddress payable _foundationMarket,\n\taddress payable _foundationDropMarket,\n\tuint256 _lockupInterval\n) {\n\tif (!_foundationMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (!_foundationDropMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (_lockupInterval == 0) {\n\t\trevert FETH_Invalid_Lockup_Duration();\n\t}\n\n\tfoundationMarket = _foundationMarket;\n\tfoundationDropMarket = _foundationDropMarket;\n\tlockupInterval = _lockupInterval; \n\tlockupDuration = _lockupInterval * 24;\n}\n"
                ],
                "Type": " contracts/FETH.sol (Out of Scope)",
                "Description": "\nIn constructor instead of passing _lockupDuration pass _lockupInterval to save on the exact division check.\n\nSo taking that into consideration the constructor would look like this:\n\nsolidity\nconstructor(\n\taddress payable _foundationMarket,\n\taddress payable _foundationDropMarket,\n\tuint256 _lockupInterval\n) {\n\tif (!_foundationMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (!_foundationDropMarket.isContract()) {\n\t\trevert FETH_Market_Must_Be_A_Contract();\n\t}\n\tif (_lockupInterval == 0) {\n\t\trevert FETH_Invalid_Lockup_Duration();\n\t}\n\n\tfoundationMarket = _foundationMarket;\n\tfoundationDropMarket = _foundationDropMarket;\n\tlockupInterval = _lockupInterval; \n\tlockupDuration = _lockupInterval * 24;\n}\n\n\nAlso, the _lockupInterval  check is moved up before the assignments to save gas in case of a revert. If there will be no revert, moving up the if block would not introduce any gas changes, since the check will be performed eventually.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "4",
                "Location": [
                    "//solidity\nif (spenderAllowance == type(uint256).max) {\n\treturn ;\n}\n\nif (spenderAllowance < amount) {\n\trevert FETH_Insufficient_Allowance(spenderAllowance);\n}\n// The check above ensures allowance cannot underflow.\nunchecked {\n\tspenderAllowance -= amount;\n}\naccountInfo.allowance[msg.sender] = spenderAllowance;\nemit Approval(from, msg.sender, spenderAllowance);\n"
                ],
                "Type": " Avoid Nested  if  Blocks",
                "Description": "\nFor better readability and analysis it is better to avoid nested if blocks. Here is an example:\n\n\nAfter edit:\n\nsolidity\nif (spenderAllowance == type(uint256).max) {\n\treturn ;\n}\n\nif (spenderAllowance < amount) {\n\trevert FETH_Insufficient_Allowance(spenderAllowance);\n}\n// The check above ensures allowance cannot underflow.\nunchecked {\n\tspenderAllowance -= amount;\n}\naccountInfo.allowance[msg.sender] = spenderAllowance;\nemit Approval(from, msg.sender, spenderAllowance);\n\n\nHardlyDifficult (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/184#issuecomment-1219792087):\n Very detailed and thoughtful feedback -thank you!\n \n1] supportsInterface can be rewritten to avoid the if/else branching:\n \n  I think I do like this style more, will consider the change.\n \n2] contracts/interfaces/ICollectionFactory.sol\n \n  Agree, fixed.\n \n3] contracts/mixins/shared/ContractFactory.sol\n \n  Not sure I'm following this suggestion. There does not appear to be another .code.length type check included at the moment. Considering a stricter check is compelling but since this is an admin function call I think that may be overkill here.\n \n4.1] Shorter inheritance list\n \n  True but for top-level contracts I like to expand all inherited contracts to make it clear what all the dependencies are and the lineriazation order they are included in.\n \n4.2] CID need to be unique per tokenID\n \n  Agree. This is a primary goal of the NFTDropCollection. As you note there are other more flexible ways we could run with this type of approach and we may consider those in the future.\n \n5.1] .isContract()\n \n  Fair feedback. Considering a stricter check is compelling but since this is an admin function call I think that may be overkill here.\n \n5.2] versionNFTDropCollection\n \n  By design the default value of 0 is correct there. NFTCollections were previously created by a different factory contract, we wanted the new factory to pick up version where that left off. But drops are new so starting at 0 is correct.\n \n5.3] a better name can be chosen for rolesContract\n \n Agree, I like that name more and will update.\n \n6.2] The comment on line 175(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTDropCollection.sol#L175) needs a bit of correction\n \n  Good catch -this was missed after adding a require against count == 0. Will fix.\n \n7] contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol\n \n  Although minor, this approach was used to save gas for the happy case scenario since it avoids a second if condition.\n \n8] contracts/FETH.sol (Out of Scope)\n \n Fair feedback, but I think the current approach is easier to reason about. And saving admin-only gas is not a goal for us.\n \n9] Line Width\n \n  Our linter is configured to require 120... although maybe you mean we are adding new lines too early in some instances (?)\n \n10] Hard-coded gas limits\n \n  Fair feedback. However the use case requires some gas limit to be defined and it's not clear there is a viable alternative here.\n \n11] address.isContract check\n \n This is good feedback. ATM these checks are there to help avoid simple errors by the admin. I'm not sure that the stricter check is worth the complexity to maintain.\n \n12] Use fixed pragma\n \n Disagree. We intentionally use a floating pragma in order to make integrating with contracts easier. Other contract developers are looking to interact with our contracts and they may be on a different version than we use. The pragma selected for our contracts is the minimum required in order to correctly compile and function. This way integration is easier if they lag a few versions behind, or if they use the latest but we don't bump our packages frequently enough, and when we do upgrade versions unless there was a breaking solidity change -it should just swap in by incrementing our npm package version.\n \n14] Avoid Nested if Blocks\n \n (out of scope) I agree that style is better, will fix.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/184#issuecomment-1255770289):\n  Slightly disagree with #3. Agree with sponsor that the suggestion isn't clear.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 73 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-08-foundation-findings/issues/122) by Dravee received the top score from the judge.\n\n*The following wardens also submitted reports: c3phas(https://github.com/code-423n4/2022-08-foundation-findings/issues/277), 0x1f8b(https://github.com/code-423n4/2022-08-foundation-findings/issues/35), Deivitto(https://github.com/code-423n4/2022-08-foundation-findings/issues/261), IllIllI(https://github.com/code-423n4/2022-08-foundation-findings/issues/206), 0xkatana(https://github.com/code-423n4/2022-08-foundation-findings/issues/123), Saw-mon&#95;and&#95;Natalie(https://github.com/code-423n4/2022-08-foundation-findings/issues/187), ReyAdmirado(https://github.com/code-423n4/2022-08-foundation-findings/issues/60), oyc&#95;109(https://github.com/code-423n4/2022-08-foundation-findings/issues/56), Bnke0x0(https://github.com/code-423n4/2022-08-foundation-findings/issues/52), MiloTruck(https://github.com/code-423n4/2022-08-foundation-findings/issues/106), simon135(https://github.com/code-423n4/2022-08-foundation-findings/issues/192), gogo(https://github.com/code-423n4/2022-08-foundation-findings/issues/48), JC(https://github.com/code-423n4/2022-08-foundation-findings/issues/284), ajtra(https://github.com/code-423n4/2022-08-foundation-findings/issues/65), erictee(https://github.com/code-423n4/2022-08-foundation-findings/issues/13), 0xSmartContract(https://github.com/code-423n4/2022-08-foundation-findings/issues/128), jag(https://github.com/code-423n4/2022-08-foundation-findings/issues/80), saian(https://github.com/code-423n4/2022-08-foundation-findings/issues/151), TomJ(https://github.com/code-423n4/2022-08-foundation-findings/issues/171), zkhorse(https://github.com/code-423n4/2022-08-foundation-findings/issues/210), &#95;141345&#95;(https://github.com/code-423n4/2022-08-foundation-findings/issues/100), Rolezn(https://github.com/code-423n4/2022-08-foundation-findings/issues/38), Aymen0909(https://github.com/code-423n4/2022-08-foundation-findings/issues/271), DevABDee(https://github.com/code-423n4/2022-08-foundation-findings/issues/175), joestakey(https://github.com/code-423n4/2022-08-foundation-findings/issues/66), d3e4(https://github.com/code-423n4/2022-08-foundation-findings/issues/256), fatherOfBlocks(https://github.com/code-423n4/2022-08-foundation-findings/issues/82), Noah3o6(https://github.com/code-423n4/2022-08-foundation-findings/issues/102), Tomio(https://github.com/code-423n4/2022-08-foundation-findings/issues/181), Trabajo&#95;de&#95;mates(https://github.com/code-423n4/2022-08-foundation-findings/issues/205), Waze(https://github.com/code-423n4/2022-08-foundation-findings/issues/197), durianSausage(https://github.com/code-423n4/2022-08-foundation-findings/issues/43), Amithuddar(https://github.com/code-423n4/2022-08-foundation-findings/issues/246), LeoS(https://github.com/code-423n4/2022-08-foundation-findings/issues/77), robee(https://github.com/code-423n4/2022-08-foundation-findings/issues/155), Rohan16(https://github.com/code-423n4/2022-08-foundation-findings/issues/226), Sm4rty(https://github.com/code-423n4/2022-08-foundation-findings/issues/201), 0xNazgul(https://github.com/code-423n4/2022-08-foundation-findings/issues/233), bobirichman(https://github.com/code-423n4/2022-08-foundation-findings/issues/75), carlitox477(https://github.com/code-423n4/2022-08-foundation-findings/issues/145), CodingNameKiki(https://github.com/code-423n4/2022-08-foundation-findings/issues/11), ElKu(https://github.com/code-423n4/2022-08-foundation-findings/issues/168), pfapostol(https://github.com/code-423n4/2022-08-foundation-findings/issues/104), 0x040(https://github.com/code-423n4/2022-08-foundation-findings/issues/287), 0xbepresent(https://github.com/code-423n4/2022-08-foundation-findings/issues/55), 0xDjango(https://github.com/code-423n4/2022-08-foundation-findings/issues/140), mics(https://github.com/code-423n4/2022-08-foundation-findings/issues/72), apostle0x01(https://github.com/code-423n4/2022-08-foundation-findings/issues/250), cRat1st0s(https://github.com/code-423n4/2022-08-foundation-findings/issues/107), Diraco(https://github.com/code-423n4/2022-08-foundation-findings/issues/53), Fitraldys(https://github.com/code-423n4/2022-08-foundation-findings/issues/245), Funen(https://github.com/code-423n4/2022-08-foundation-findings/issues/281), gerdusx(https://github.com/code-423n4/2022-08-foundation-findings/issues/276), ignacio(https://github.com/code-423n4/2022-08-foundation-findings/issues/5), Metatron(https://github.com/code-423n4/2022-08-foundation-findings/issues/209), samruna(https://github.com/code-423n4/2022-08-foundation-findings/issues/4), SpaceCake(https://github.com/code-423n4/2022-08-foundation-findings/issues/120), zeesaw(https://github.com/code-423n4/2022-08-foundation-findings/issues/45), zuhaibmohd(https://github.com/code-423n4/2022-08-foundation-findings/issues/109), 0xHarry(https://github.com/code-423n4/2022-08-foundation-findings/issues/67), brgltd(https://github.com/code-423n4/2022-08-foundation-findings/issues/255), bulej93(https://github.com/code-423n4/2022-08-foundation-findings/issues/150), Chom(https://github.com/code-423n4/2022-08-foundation-findings/issues/242), hakerbaya(https://github.com/code-423n4/2022-08-foundation-findings/issues/180), ladboy233(https://github.com/code-423n4/2022-08-foundation-findings/issues/264), medikko(https://github.com/code-423n4/2022-08-foundation-findings/issues/282), newfork01(https://github.com/code-423n4/2022-08-foundation-findings/issues/172), rvierdiiev(https://github.com/code-423n4/2022-08-foundation-findings/issues/198), sach1r0(https://github.com/code-423n4/2022-08-foundation-findings/issues/185), sikorico(https://github.com/code-423n4/2022-08-foundation-findings/issues/70), wagmi(https://github.com/code-423n4/2022-08-foundation-findings/issues/278), and Yiko(https://github.com/code-423n4/2022-08-foundation-findings/issues/19).*\n\n## Code Impressions\n\nOverall, the code is pretty optimized:\n\n*   Using clones to deploy contracts is an excellent call\n*   The unchecked statements are well used\n*   Storage variables are tightly packed\n\nJust one particular finding was present across the whole project:\n\n*   The revert strings are too long. Please try to make them fit in 32 bytes (use the first letters of the contract as a prefix, as an example, like NFTCF instead of NFTCollectionFactory), or use Custom Errors consistently\n\nDue to some inconsistencies with the gas-stories.txt file, I unfortunately did not attach it.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "diff\nFile: NFTDropMarketFixedPriceSale.sol\n240:     if (currentBalance = limitPerAccount) {\n241:       // User has exhausted their limit.\n242:       return 0;\n243:     }\n244: \n245:     uint256 availableToMint = limitPerAccount currentBalance;\n+ 245:     uint256 availableToMint;\n+ 245:     unchecked { availableToMint = limitPerAccount currentBalance; }\n"
                ],
                "Type": " Unchecking arithmetics operations that can't underflow/overflow",
                "Description": "\nWhile this is inside an external view function, consider wrapping this in an unchecked statement so that external contracts calling this might save some gas:\n\n*   L245 can be unchecked due to L240(https://github.com/JustDravee/dravee-2022-08-foundation/blob/61ca1242cbfa69f45097286837def0f49558087c/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L240-L245)\n\ndiff\nFile: NFTDropMarketFixedPriceSale.sol\n240:     if (currentBalance = limitPerAccount) {\n241:       // User has exhausted their limit.\n242:       return 0;\n243:     }\n244: \n245:     uint256 availableToMint = limitPerAccount currentBalance;\n+ 245:     uint256 availableToMint;\n+ 245:     unchecked { availableToMint = limitPerAccount currentBalance; }\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [
                    "//solidity\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n",
                    "diff\nfor (uint256 i; i < numIterations; i++) {\n+ for (uint256 i; i < numIterations;) {\n // ...  \n+   unchecked { ++i; }\n}  \n"
                ],
                "Type": " Increments/decrements can be unchecked in for-loops",
                "Description": "\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\nethereum/solidity#10695(https://github.com/ethereum/solidity/issues/10695)\n\nConsider wrapping with an unchecked block here (around 25 gas saved per instance):\n\nsolidity\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n\n\nThe change would be:\n\ndiff\nfor (uint256 i; i < numIterations; i++) {\n+ for (uint256 i; i < numIterations;) {\n // ...  \n+   unchecked { ++i; }\n}  \n\n\nThe same can be applied with decrements (which should use break when i == 0).\n\nThe risk of overflow is non-existent for uint256 here.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "0",
                "Location": [
                    "//solidity\nuint256 constant READ_ONLY_GAS_LIMIT = 40000;\nuint256 constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\nuint256 constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\n"
                ],
                "Type": " Hard-coded gas limits",
                "Description": "\nIn contracts/mixins/shared/Constants.sol we have 3 gas limit constants:\n\nsolidity\nuint256 constant READ_ONLY_GAS_LIMIT = 40000;\nuint256 constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;\nuint256 constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;\n\n\nThese numbers are not future-proof as some hardforks introduce changes to gas costs. These potential future changes to gas costs might break some of the functionalities of the smart contracts that use these constants. This is something to keep in mind. If some hardfork, would break a smart contract using these numbers you would need to deploy new contracts with adjusted gas limit constants. Or you can also have these gas limits be mutable by admins on-chain. For example, all 3 of these values can be stored on-chain in 1 storage slot.\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n"
                ],
                "Type": " Duplicated conditions should be refactored to a modifier or function to save deployment costs",
                "Description": "\nsolidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nmixins/shared/MarketFees.sol:126:      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:503:      for (uint256 i = 1; i < creatorRecipients.length; ) {\n"
                ],
                "Type": "  <array>.length  should not be looked up in every loop of a  for-loop ",
                "Description": "\nReading array length at each iteration of the loop consumes more gas than necessary.\n\nIn the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration.\nIn the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.\n\nHere, consider storing the array's length in a variable before the for-loop, and use this new variable instead:\n\nsolidity\nmixins/shared/MarketFees.sol:126:      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:198:    for (uint256 i = 0; i < creatorShares.length; ++i) {\nmixins/shared/MarketFees.sol:484:          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\nmixins/shared/MarketFees.sol:503:      for (uint256 i = 1; i < creatorRecipients.length; ) {\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollection.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": [
                    "//solidity\nconstructor(address c, bytes32 h) {\n\tif( c.codehash != h) {\n\t\trevert CustomError();\n\t}\n}\n"
                ],
                "Type": "  address.isContract  check",
                "Description": "\nLots of the contracts in this project import import \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\" and use address.isContract() to check if an address is a contract and not a EOA. I guess this is only a check if the deployer by mistake provides the wrong address. I think this should be double-checked off-chain. If an on-chain check is needed, there are other checks that can be done that are even more strict than just checking against EOA mistakes. For example, we can provide the contract as the second input to the constructor and check the address's codehash against that. Here is a template as an example:\n\nsolidity\nconstructor(address c, bytes32 h) {\n\tif( c.codehash != h) {\n\t\trevert CustomError();\n\t}\n}\n\n\nNot only does this check for address with code, but also pinpoints the contract hash to a specific hash. Another type of check that can be used is to check if the provided contract address supports a specific interfaceSupport or call an endpoint of the contract expecting it to return a specific magic number.\n\nHere is a list of places isContract has been used:\n\n1.  FETH.sol L201(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/FETH.sol#L201)\n2.  FETH.sol L204(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/FETH.sol#L204)\n3.  NFTCollectionFactory.sol L182(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L182)\n4.  NFTCollectionFactory.sol L203(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L203)\n5.  NFTCollectionFactory.sol L227(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/NFTCollectionFactory.sol#L227)\n6.  PercentSplitETH.sol L171(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/PercentSplitETH.sol#L171)\n7.  AddressLibrary.sol L31(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/libraries/AddressLibrary.sol#L31)\n8.  ContractFactory.sol L31(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/ContractFactory.sol#L31)\n9.  FETHNode.sol L23(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/FETHNode.sol#L23)\n10. FoundationTreasuryNode.sol L48(https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/shared/FoundationTreasuryNode.sol#L48)\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: NFTCollectionFactory.sol\n257:   function createNFTCollection( //@audit-ok OK function\n258:     string calldata name,\n259:     string calldata symbol,\n260:     uint256 nonce\n261:   ) external returns (address collection) {\n262:     require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\"); //@audit why is the check inconsistently done ? Here it's in this function but for drop it's in the initialize() function. Chose 1, I'd advise this one style to save gas.\n263: \n264:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n265:     collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n266: \n267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n268: \n269:     emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n270:   }\n",
                    "//solidity\nFile: NFTDropCollection.sol\n120:   function initialize(\n121:     address payable _creator,\n122:     string calldata _name,\n123:     string calldata _symbol,\n124:     string calldata _baseURI,\n125:     bytes32 _postRevealBaseURIHash,\n126:     uint32 _maxTokenId,\n127:     address _approvedMinter,\n128:     address payable _paymentAddress\n129:   ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n130:     require(bytes(_symbol).length  0, \"NFTDropCollection: `_symbol` must be set\");\n131:     require(_maxTokenId  0, \"NFTDropCollection: `_maxTokenId` must be set\");\n",
                    "diff\nFile: NFTCollectionFactory.sol\n386:   function _createNFTDropCollection(\n387:     string calldata name,\n388:     string calldata symbol,\n389:     string calldata baseURI,\n390:     bytes32 postRevealBaseURIHash,\n391:     uint32 maxTokenId,\n392:     address approvedMinter,\n393:     address payable paymentAddress,\n394:     uint256 nonce\n395:   ) private returns (address collection) {\n396:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n+ 396:     require(bytes(symbol).length ! 0, \"NFTDropCollection: `symbol` must be set\");\n397:     collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n398: \n399:     INFTDropCollectionInitializer(collection).initialize(\n400:       payable(msg.sender),\n401:       name,\n402:       symbol,\n403:       baseURI,\n404:       postRevealBaseURIHash,\n405:       maxTokenId,\n406:       approvedMinter,\n407:       paymentAddress\n408:     );\n"
                ],
                "Type": " Check for  bytes(_symbol).length > 0  before calling  NFTDropCollection.initialize() , like it's done for  NFTCollection.initialize() ",
                "Description": "\nThis could save a lot of gas if the revert condition is met.\n\nFor NFTCollection, the check is made in NFTCollectionFactory.createNFTCollection().\n\n*   NFTCollectionFactory.sol#L262(https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollectionFactory.sol#L262)\n\nsolidity\nFile: NFTCollectionFactory.sol\n257:   function createNFTCollection( //@audit-ok OK function\n258:     string calldata name,\n259:     string calldata symbol,\n260:     uint256 nonce\n261:   ) external returns (address collection) {\n262:     require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\"); //@audit why is the check inconsistently done ? Here it's in this function but for drop it's in the initialize() function. Chose 1, I'd advise this one style to save gas.\n263: \n264:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n265:     collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n266: \n267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n268: \n269:     emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n270:   }\n\n\nHowever, for NFTDropCollection, the check is made way further, after even the contract's creation (during the initialization):\n\n*   NFTDropCollection.sol#L130(https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTDropCollection.sol#L130)\n\nsolidity\nFile: NFTDropCollection.sol\n120:   function initialize(\n121:     address payable _creator,\n122:     string calldata _name,\n123:     string calldata _symbol,\n124:     string calldata _baseURI,\n125:     bytes32 _postRevealBaseURIHash,\n126:     uint32 _maxTokenId,\n127:     address _approvedMinter,\n128:     address payable _paymentAddress\n129:   ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n130:     require(bytes(_symbol).length  0, \"NFTDropCollection: _symbol must be set\");\n131:     require(_maxTokenId  0, \"NFTDropCollection: _maxTokenId must be set\");\n\n\nConsider moving the check in NFTCollectionFactory._createNFTDropCollection():\n\n*   NFTCollectionFactory.sol#L396(https://github.com/code-423n4/2022-08-foundation/blob/main/contracts/NFTCollectionFactory.sol#L396)\n\ndiff\nFile: NFTCollectionFactory.sol\n386:   function _createNFTDropCollection(\n387:     string calldata name,\n388:     string calldata symbol,\n389:     string calldata baseURI,\n390:     bytes32 postRevealBaseURIHash,\n391:     uint32 maxTokenId,\n392:     address approvedMinter,\n393:     address payable paymentAddress,\n394:     uint256 nonce\n395:   ) private returns (address collection) {\n396:     // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n+ 396:     require(bytes(symbol).length ! 0, \"NFTDropCollection: symbol must be set\");\n397:     collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n398: \n399:     INFTDropCollectionInitializer(collection).initialize(\n400:       payable(msg.sender),\n401:       name,\n402:       symbol,\n403:       baseURI,\n404:       postRevealBaseURIHash,\n405:       maxTokenId,\n406:       approvedMinter,\n407:       paymentAddress\n408:     );\n\n\nThis would save the deployment cost of an impossible to initialize contract (which would further need to be destroyed before being redeployed).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "diff\nFile: NFTDropCollection.sol\n171:   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) { //@audit-ok\n172:     require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n173: \n+ 173:      uint32 _latestTokenId = latestTokenId;\n174:     unchecked {\n175:       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n176:       firstTokenId = latestTokenId + 1; //@audit gas: SLOAD 1 (latestTokenId)\n+ 176:       firstTokenId = _latestTokenId + 1;\n177:     }\n178:     latestTokenId = latestTokenId + count; //@audit gas: SLOAD 2 (latestTokenId)\n+ 178:     _latestTokenId = _latestTokenId + count;\n+ 178:     latestTokenId = _latestTokenId;\n179:     require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\"); //@audit gas: SLOAD 3 (latestTokenId)\n+ 179:     require(_latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n180: \n181:     for (uint256 i = firstTokenId; i <= latestTokenId; ) {  //@audit gas: SLOAD \"latestTokenId firstTokenId + 1\" (latestTokenId)\n+ 181:     for (uint256 i = firstTokenId; i <= _latestTokenId; ) {\n182:       _mint(to, i);\n183:       unchecked {\n184:         ++i;\n185:       }\n186:     }\n187:   }\n",
                    "diff\nFile: NFTCollectionFactory.sol\n202:   function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n203:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n204:     implementationNFTCollection = _implementation;\n+ 204:     uint32 _versionNFTCollection;\n205:     unchecked {\n206:       // Version cannot overflow 256 bits.\n207:       versionNFTCollection++;\n+ 207:       _versionNFTCollection = ++versionNFTCollection;\n208:     }\n209: \n210:     // The implementation is initialized when assigned so that others may not claim it as their own.\n211:     INFTCollectionInitializer(_implementation).initialize(\n212:       payable(address(rolesContract)),\n213:       string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n+ 213:       string.concat(\"NFT Collection Implementation v\", _versionNFTCollection.toString()),\n214:       string.concat(\"NFTv\", versionNFTCollection.toString())\n+ 214:       string.concat(\"NFTv\", _versionNFTCollection.toString())\n215:     );\n216: \n217:     emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n+ 217:     emit ImplementationNFTCollectionUpdated(_implementation, _versionNFTCollection);\n218:   }\n",
                    "diff\nFile: NFTCollectionFactory.sol\n226:   function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n227:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n228:     implementationNFTDropCollection = _implementation;\n+ 228:         uint32 _versionNFTDropCollection;\n229:     unchecked {\n230:       // Version cannot overflow 256 bits.\n231:       versionNFTDropCollection++;\n+ 231:       _versionNFTDropCollection = ++versionNFTDropCollection;\n232:     }\n233: \n234:     emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n+ 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, _versionNFTDropCollection);\n235: \n236:     // The implementation is initialized when assigned so that others may not claim it as their own.\n237:     INFTDropCollectionInitializer(_implementation).initialize(\n238:       payable(address(this)),\n239:       string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n240:       string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n+ 239:       string.concat(\"NFT Drop Collection Implementation v\", _versionNFTDropCollection.toString()),\n+ 240:       string.concat(\"NFTDropV\", _versionNFTDropCollection.toString()),\n241:       \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n242:       0x1337000000000000000000000000000000000000000000000000000000001337,\n243:       1,\n244:       address(0),\n245:       payable(0)\n246:     );\n247:   }\n",
                    "diff\nFile: NFTCollection.sol\n332:   function _baseURI() internal view override returns (string memory) {\n333:     if (bytes(baseURI_).length != 0) {\n+ 333:     string memory memBaseURI = baseURI_;\n+ 333:     if (bytes(memBaseURI).length != 0) {\n334:       return baseURI_;\n+ 334:       return memBaseURI;\n335:     }\n336:     return \"ipfs://\";\n337:   }\n"
                ],
                "Type": " Caching storage values in memory",
                "Description": "\nThe code can be optimized by minimizing the number of SLOADs.\n\nSLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.\n\n*   Saving many SLOADs (including in a for-loop)(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L171-L187):\n\ndiff\nFile: NFTDropCollection.sol\n171:   function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) { //@audit-ok\n172:     require(count != 0, \"NFTDropCollection: count must be greater than 0\");\n173: \n+ 173:      uint32 _latestTokenId = latestTokenId;\n174:     unchecked {\n175:       // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n176:       firstTokenId = latestTokenId + 1; //@audit gas: SLOAD 1 (latestTokenId)\n+ 176:       firstTokenId = _latestTokenId + 1;\n177:     }\n178:     latestTokenId = latestTokenId + count; //@audit gas: SLOAD 2 (latestTokenId)\n+ 178:     _latestTokenId = _latestTokenId + count;\n+ 178:     latestTokenId = _latestTokenId;\n179:     require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\"); //@audit gas: SLOAD 3 (latestTokenId)\n+ 179:     require(_latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n180: \n181:     for (uint256 i = firstTokenId; i <= latestTokenId; ) {  //@audit gas: SLOAD \"latestTokenId firstTokenId + 1\" (latestTokenId)\n+ 181:     for (uint256 i = firstTokenId; i <= _latestTokenId; ) {\n182:       _mint(to, i);\n183:       unchecked {\n184:         ++i;\n185:       }\n186:     }\n187:   }\n\n\n*   Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L202-L218):\n\ndiff\nFile: NFTCollectionFactory.sol\n202:   function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n203:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n204:     implementationNFTCollection = _implementation;\n+ 204:     uint32 _versionNFTCollection;\n205:     unchecked {\n206:       // Version cannot overflow 256 bits.\n207:       versionNFTCollection++;\n+ 207:       _versionNFTCollection = ++versionNFTCollection;\n208:     }\n209: \n210:     // The implementation is initialized when assigned so that others may not claim it as their own.\n211:     INFTCollectionInitializer(_implementation).initialize(\n212:       payable(address(rolesContract)),\n213:       string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n+ 213:       string.concat(\"NFT Collection Implementation v\", _versionNFTCollection.toString()),\n214:       string.concat(\"NFTv\", versionNFTCollection.toString())\n+ 214:       string.concat(\"NFTv\", _versionNFTCollection.toString())\n215:     );\n216: \n217:     emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n+ 217:     emit ImplementationNFTCollectionUpdated(_implementation, _versionNFTCollection);\n218:   }\n\n\n*   Saving 3 SLOADs (+ a pre-increment is cheaper, but this is counter-balanced with the memory variable)(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollectionFactory.sol#L226-L247)\n\ndiff\nFile: NFTCollectionFactory.sol\n226:   function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n227:     require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n228:     implementationNFTDropCollection = _implementation;\n+ 228:         uint32 _versionNFTDropCollection;\n229:     unchecked {\n230:       // Version cannot overflow 256 bits.\n231:       versionNFTDropCollection++;\n+ 231:       _versionNFTDropCollection = ++versionNFTDropCollection;\n232:     }\n233: \n234:     emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n+ 234:     emit ImplementationNFTDropCollectionUpdated(_implementation, _versionNFTDropCollection);\n235: \n236:     // The implementation is initialized when assigned so that others may not claim it as their own.\n237:     INFTDropCollectionInitializer(_implementation).initialize(\n238:       payable(address(this)),\n239:       string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n240:       string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n+ 239:       string.concat(\"NFT Drop Collection Implementation v\", _versionNFTDropCollection.toString()),\n+ 240:       string.concat(\"NFTDropV\", _versionNFTDropCollection.toString()),\n241:       \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n242:       0x1337000000000000000000000000000000000000000000000000000000001337,\n243:       1,\n244:       address(0),\n245:       payable(0)\n246:     );\n247:   }\n\n\n*   Saving 1 SLOAD. If we're optimistic towards the presence of a baseURI_ string here, this should be cached(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTCollection.sol#L332-L337):\n\ndiff\nFile: NFTCollection.sol\n332:   function _baseURI() internal view override returns (string memory) {\n333:     if (bytes(baseURI_).length != 0) {\n+ 333:     string memory memBaseURI = baseURI_;\n+ 333:     if (bytes(memBaseURI).length != 0) {\n334:       return baseURI_;\n+ 334:       return memBaseURI;\n335:     }\n336:     return \"ipfs://\";\n337:   }\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: NFTCollectionFactory.sol\n363:   function createNFTDropCollectionWithPaymentFactory(\n364:     string calldata name,\n365:     string calldata symbol,\n366:     string calldata baseURI,\n367:     bytes32 postRevealBaseURIHash,\n368:     uint32 maxTokenId,\n369:     address approvedMinter,\n370:     uint256 nonce,\n371:     CallWithoutValue memory paymentAddressFactoryCall\n+ 371:     CallWithoutValue calldata paymentAddressFactoryCall\n372:   ) external returns (address collection) {\n"
                ],
                "Type": " Use  calldata  instead of  memory ",
                "Description": "\nWhen a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array.length). Using calldata directly bypasses this loop.\n\nIf the array is passed to an internal function which passes the array to another internal function where the array is modified and therefore memory is used in the external call, it's still more gas-efficient to use calldata when the external function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nAffected code (around 60 gas to be saved):\n\nsolidity\nFile: NFTCollectionFactory.sol\n363:   function createNFTDropCollectionWithPaymentFactory(\n364:     string calldata name,\n365:     string calldata symbol,\n366:     string calldata baseURI,\n367:     bytes32 postRevealBaseURIHash,\n368:     uint32 maxTokenId,\n369:     address approvedMinter,\n370:     uint256 nonce,\n371:     CallWithoutValue memory paymentAddressFactoryCall\n+ 371:     CallWithoutValue calldata paymentAddressFactoryCall\n372:   ) external returns (address collection) {\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollectionFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-03",
                "Location": [
                    "diff\nFile: NFTDropCollection.sol\n232:   function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n233:     external\n234:     validBaseURI(_baseURI)\n235:     onlyWhileUnrevealed\n236:     onlyAdmin\n237:   {\n238:     require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n239: \n240:     postRevealBaseURIHash = _postRevealBaseURIHash;\n241:     baseURI = _baseURI;\n242:     emit URIUpdated(baseURI, postRevealBaseURIHash);\n+ 242:     emit URIUpdated(_baseURI, _postRevealBaseURIHash);\n243:   }\n",
                    "diff\nFile: NFTDropMarketFixedPriceSale.sol\n152:     // Save the sale details.\n153:     saleConfig.seller = payable(msg.sender);\n154:     saleConfig.price = price;\n155:     saleConfig.limitPerAccount = limitPerAccount;\n156:     emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n+ 156:     emit CreateFixedPriceSale(nftContract, payable(msg.sender), price, limitPerAccount);\n"
                ],
                "Type": " Avoid emitting a storage variable when a memory value is available",
                "Description": "\nWhen they are the same, consider emitting the memory value instead of the storage value:\n\n*   NFTDropCollection.sol#L242(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/NFTDropCollection.sol#L242)\n\ndiff\nFile: NFTDropCollection.sol\n232:   function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n233:     external\n234:     validBaseURI(_baseURI)\n235:     onlyWhileUnrevealed\n236:     onlyAdmin\n237:   {\n238:     require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use reveal instead\");\n239: \n240:     postRevealBaseURIHash = _postRevealBaseURIHash;\n241:     baseURI = _baseURI;\n242:     emit URIUpdated(baseURI, postRevealBaseURIHash);\n+ 242:     emit URIUpdated(_baseURI, _postRevealBaseURIHash);\n243:   }\n\n\n*   NFTDropMarketFixedPriceSale.sol#L156(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L156)\n\ndiff\nFile: NFTDropMarketFixedPriceSale.sol\n152:     // Save the sale details.\n153:     saleConfig.seller = payable(msg.sender);\n154:     saleConfig.price = price;\n155:     saleConfig.limitPerAccount = limitPerAccount;\n156:     emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n+ 156:     emit CreateFixedPriceSale(nftContract, payable(msg.sender), price, limitPerAccount);\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollectionFactory.sol",
            "NFTCollection.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nlibraries/AddressLibrary.sol:31:    require(contractAddress.isContract(), \"InternalProxyCall: did not return a contract\");\nmixins/collections/SequentialMintCollection.sol:58:    require(msg.sender == owner, \"SequentialMintCollection: Caller is not creator\");\nmixins/collections/SequentialMintCollection.sol:63:    require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\");\nmixins/collections/SequentialMintCollection.sol:74:    require(totalSupply() == 0, \"SequentialMintCollection: Any NFTs minted must be burned first\");\nmixins/collections/SequentialMintCollection.sol:87:    require(_maxTokenId != 0, \"SequentialMintCollection: Max token ID may not be cleared\");\nmixins/collections/SequentialMintCollection.sol:88:    require(maxTokenId == 0 || _maxTokenId < maxTokenId, \"SequentialMintCollection: Max token ID may not increase\");\nmixins/collections/SequentialMintCollection.sol:89:    require(latestTokenId <= _maxTokenId, \"SequentialMintCollection: Max token ID must be = last mint\");\nmixins/roles/AdminRole.sol:19:    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"AdminRole: caller does not have the Admin role\");\nmixins/roles/MinterRole.sol:22:    require(isMinter(msg.sender) || isAdmin(msg.sender), \"MinterRole: Must have the minter or admin role\");\nmixins/shared/ContractFactory.sol:22:    require(msg.sender == contractFactory, \"ContractFactory: Caller is not the factory\");\nmixins/shared/ContractFactory.sol:31:    require(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\nNFTCollection.sol:158:    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\nNFTCollection.sol:263:    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\nNFTCollection.sol:264:    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\nNFTCollection.sol:268:      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\nNFTCollection.sol:327:    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\nNFTCollectionFactory.sol:173:    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\nNFTCollectionFactory.sol:182:    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:262:    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length  0, \"NFTDropCollection: `_baseURI` must be set\");\nNFTDropCollection.sol:93:    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length  0, \"NFTDropCollection: `_symbol` must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId  0, \"NFTDropCollection: `_maxTokenId` must be set\");\nNFTDropCollection.sol:172:    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\nNFTDropCollection.sol:179:    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\nNFTDropCollection.sol:238:    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n"
                ],
                "Type": " Reduce the size of error messages (Long revert Strings)",
                "Description": "\nShortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.\n\nRevert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.\n\nRevert strings  32 bytes:\n\nsolidity\nlibraries/AddressLibrary.sol:31:    require(contractAddress.isContract(), \"InternalProxyCall: did not return a contract\");\nmixins/collections/SequentialMintCollection.sol:58:    require(msg.sender == owner, \"SequentialMintCollection: Caller is not creator\");\nmixins/collections/SequentialMintCollection.sol:63:    require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\");\nmixins/collections/SequentialMintCollection.sol:74:    require(totalSupply() == 0, \"SequentialMintCollection: Any NFTs minted must be burned first\");\nmixins/collections/SequentialMintCollection.sol:87:    require(_maxTokenId != 0, \"SequentialMintCollection: Max token ID may not be cleared\");\nmixins/collections/SequentialMintCollection.sol:88:    require(maxTokenId == 0 || _maxTokenId < maxTokenId, \"SequentialMintCollection: Max token ID may not increase\");\nmixins/collections/SequentialMintCollection.sol:89:    require(latestTokenId <= _maxTokenId, \"SequentialMintCollection: Max token ID must be = last mint\");\nmixins/roles/AdminRole.sol:19:    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"AdminRole: caller does not have the Admin role\");\nmixins/roles/MinterRole.sol:22:    require(isMinter(msg.sender) || isAdmin(msg.sender), \"MinterRole: Must have the minter or admin role\");\nmixins/shared/ContractFactory.sol:22:    require(msg.sender == contractFactory, \"ContractFactory: Caller is not the factory\");\nmixins/shared/ContractFactory.sol:31:    require(_contractFactory.isContract(), \"ContractFactory: Factory is not a contract\");\nNFTCollection.sol:158:    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\nNFTCollection.sol:263:    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\nNFTCollection.sol:264:    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\nNFTCollection.sol:268:      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\nNFTCollection.sol:327:    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\nNFTCollectionFactory.sol:173:    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\nNFTCollectionFactory.sol:182:    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:262:    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length  0, \"NFTDropCollection: _baseURI must be set\");\nNFTDropCollection.sol:93:    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length  0, \"NFTDropCollection: _symbol must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId  0, \"NFTDropCollection: _maxTokenId must be set\");\nNFTDropCollection.sol:172:    require(count != 0, \"NFTDropCollection: count must be greater than 0\");\nNFTDropCollection.sol:179:    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\nNFTDropCollection.sol:238:    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use reveal instead\");\n\n\nConsider shortening the revert strings to fit in 32 bytes.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*                                                                               \n  \uff65\n   *\u3000\u2605 \n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000* \n\u3000\u3000\u3000 *\u3000\u2605   \uff61\n                      `                     .-:::::-.`              `-::---...```                   \n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:        \n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy        \n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy        \n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy        \n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy        \n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy        \n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy        \n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy        \n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy        \n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        \n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        \n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo        \n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo            \n                                              `````       \n   *\u3000 \n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./mixins/treasury/AdminRole.sol\";\nimport \"./mixins/treasury/CollateralManagement.sol\";\nimport \"./mixins/treasury/OperatorRole.sol\";\n\n/**\n * @title Manage revenue and roles for Foundation.\n * @notice All fees generated by the market are forwarded to this contract.\n * It also defines the Admin and Operator roles which are used in other contracts.\n */\ncontract FoundationTreasury is Initializable, AdminRole, OperatorRole, CollateralManagement {\n  /**\n   * @notice Called one time after deployment to initialize the contract.\n   * @param admin The account to add as the initial admin.\n   */\n  function initialize(address admin) external initializer {\n    AdminRole._initializeAdminRole(admin);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "FoundationTreasury.sol",
            "NFTCollection.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-08",
                "Location": [
                    "diff\nFile: SequentialMintCollection.sol\n62:   function _initializeSequentialMintCollection(address payable _creator, uint32 _maxTokenId) internal onlyInitializing {\n63:     require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\"); //@audit gas: this is redundant as only factory can init and always pass good result\n64: \n65:     owner = _creator;\n66:     maxTokenId = _maxTokenId;\n67:   }\n",
                    "//solidity\ncontracts/NFTCollectionFactory.sol:\n  211:     INFTCollectionInitializer(_implementation).initialize(\n  212        payable(address(rolesContract)),\n",
                    "//solidity\n  237:     INFTDropCollectionInitializer(_implementation).initialize(\n  238        payable(address(this)),\n",
                    "//solidity\n  267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n",
                    "//solidity\n  399:     INFTDropCollectionInitializer(collection).initialize(\n  400        payable(msg.sender),\n"
                ],
                "Type": " Redundant check",
                "Description": "\nThe following require statement is redundant:\n\n*   SequentialMintCollection.sol#L63(https://github.com/code-423n4/2022-08-foundation/blob/792e00df429b0df9ee5d909a0a5a6e72bd07cf79/contracts/mixins/collections/SequentialMintCollection.sol#L63)\n\ndiff\nFile: SequentialMintCollection.sol\n62:   function _initializeSequentialMintCollection(address payable _creator, uint32 _maxTokenId) internal onlyInitializing {\n63:     require(_creator != address(0), \"SequentialMintCollection: Creator cannot be the zero address\"); //@audit gas: this is redundant as only factory can init and always pass good result\n64: \n65:     owner = _creator;\n66:     maxTokenId = _maxTokenId;\n67:   }\n\n\nThis is due to the fact that the initialize() methods have the onlyContractFactory modifier already, and that calls to initialize from the factory are not using address(0) (and hardly ever will in the future of the solution). See these initializations where the first argument is creator:\n\nsolidity\ncontracts/NFTCollectionFactory.sol:\n  211:     INFTCollectionInitializer(_implementation).initialize(\n  212        payable(address(rolesContract)),\n\n\nsolidity\n  237:     INFTDropCollectionInitializer(_implementation).initialize(\n  238        payable(address(this)),\n\n\nsolidity\n  267:     INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n\nsolidity\n  399:     INFTDropCollectionInitializer(collection).initialize(\n  400        payable(msg.sender),\n\n\nConsider removing this check.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTDropCollectionMint.sol\";\n\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/roles/AdminRole.sol\";\nimport \"./mixins/roles/MinterRole.sol\";\nimport \"./mixins/shared/Constants.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A contract to batch mint a collection of NFTs.\n * @notice A 10% royalty to the creator is included which may be split with collaborators.\n * @dev A collection can have up to 4,294,967,295 (2^32-1) tokens\n */\ncontract NFTDropCollection is\n  INFTDropCollectionInitializer,\n  INFTDropCollectionMint,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  AdminRole,\n  MinterRole,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using Strings for uint256;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address to pay the proceeds/royalties for the collection.\n   * @dev If this is set to address(0) then the proceeds go to the creator.\n   */\n  address payable private paymentAddress;\n  // 96 bits free space\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `<tokenId>.json` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for `tokenId`: \"1\" with `baseURI`: \"ipfs://foo/\" is \"ipfs://foo/1.json\".\n   * @return The base URI used by this collection.\n   */\n  string public baseURI;\n\n  /****** Slot 2 ******/\n  /**\n   * @notice The hash of the revealed baseURI for the collection.\n   * @dev This can be used to verify that the content was not changed after NFTs were minted.\n   * @return bytes32(0) if the content has been revealed.\n   * In pre-reveal state this is set to bytes32(1) when the final content is unknown\n   * otherwise set to keccak256(finalContentBaseURI).\n   */\n  bytes32 public postRevealBaseURIHash;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice Emitted when the collection is revealed.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  event URIUpdated(string baseURI, bytes32 postRevealBaseURIHash);\n\n  modifier validBaseURI(string calldata _baseURI) {\n    require(bytes(_baseURI).length > 0, \"NFTDropCollection: `_baseURI` must be set\");\n    _;\n  }\n\n  modifier onlyWhileUnrevealed() {\n    require(postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: Already revealed\");\n    _;\n  }\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * This account is the default admin for this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   * @param _baseURI The base URI for the collection.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param _maxTokenId The max token id for this collection.\n   * @param _approvedMinter An optional address to grant the MINTER_ROLE.\n   * Set to address(0) if only admins should be granted permission to mint.\n   * @param _paymentAddress The address that will receive royalties and mint payments.\n   */\n  function initialize(\n    address payable _creator,\n    string calldata _name,\n    string calldata _symbol,\n    string calldata _baseURI,\n    bytes32 _postRevealBaseURIHash,\n    uint32 _maxTokenId,\n    address _approvedMinter,\n    address payable _paymentAddress\n  ) external initializer onlyContractFactory validBaseURI(_baseURI) {\n    require(bytes(_symbol).length > 0, \"NFTDropCollection: `_symbol` must be set\");\n    require(_maxTokenId > 0, \"NFTDropCollection: `_maxTokenId` must be set\");\n\n    // Initialize the NFT\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, _maxTokenId);\n\n    // Initialize royalties\n    if (_paymentAddress != address(0)) {\n      // If no payment address was defined, use the creator's address.\n      paymentAddress = _paymentAddress;\n    }\n\n    // Initialize URI\n    baseURI = _baseURI;\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n\n    // Initialize access control\n    AdminRole._initializeAdminRole(_creator);\n    if (_approvedMinter != address(0)) {\n      MinterRole._initializeMinterRole(_approvedMinter);\n    }\n  }\n\n  /**\n   * @notice Allows the collection admin to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyAdmin` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyAdmin {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint `count` number of NFTs for the `to` address.\n   * @dev This is only callable by an address with either the MINTER_ROLE or the DEFAULT_ADMIN_ROLE.\n   * @param count The number of NFTs to mint.\n   * @param to The address to mint the NFTs for.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   */\n  function mintCountTo(uint16 count, address to) external onlyMinterOrAdmin returns (uint256 firstTokenId) {\n    require(count != 0, \"NFTDropCollection: `count` must be greater than 0\");\n\n    unchecked {\n      // If +1 overflows then +count would also overflow, unless count==0 in which case the loop would exceed gas limits\n      firstTokenId = latestTokenId + 1;\n    }\n    latestTokenId = latestTokenId + count;\n    require(latestTokenId <= maxTokenId, \"NFTDropCollection: Exceeds max tokenId\");\n\n    for (uint256 i = firstTokenId; i <= latestTokenId; ) {\n      _mint(to, i);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Allows a collection admin to reveal the collection's final content.\n   * @dev Once revealed, the collection's content is immutable.\n   * Use `updatePreRevealContent` to update content while unrevealed.\n   * @param _baseURI The base URI of the final content for this collection.\n   */\n  function reveal(string calldata _baseURI) external onlyAdmin validBaseURI(_baseURI) onlyWhileUnrevealed {\n    // `postRevealBaseURIHash` == 0 indicates that the collection has been revealed.\n    delete postRevealBaseURIHash;\n\n    // Set the new base URI.\n    baseURI = _baseURI;\n    emit URIUpdated(_baseURI, \"\");\n  }\n\n  /**\n   * @notice Allows a collection admin to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyAdmin {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyAdmin {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  /**\n   * @notice Allows a collection admin to update the pre-reveal content.\n   * @dev Use `reveal` to reveal the final content for this collection.\n   * @param _baseURI The base URI of the pre-reveal content.\n   * @param _postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   */\n  function updatePreRevealContent(string calldata _baseURI, bytes32 _postRevealBaseURIHash)\n    external\n    validBaseURI(_baseURI)\n    onlyWhileUnrevealed\n    onlyAdmin\n  {\n    require(_postRevealBaseURIHash != bytes32(0), \"NFTDropCollection: use `reveal` instead\");\n\n    postRevealBaseURIHash = _postRevealBaseURIHash;\n    baseURI = _baseURI;\n    emit URIUpdated(baseURI, postRevealBaseURIHash);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(\n    uint256 /* tokenId */\n  ) public view override returns (address payable creatorPaymentAddress) {\n    creatorPaymentAddress = paymentAddress;\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @notice Returns whether the collection has been revealed.\n   * @dev Once revealed, the collection's content is immutable.\n   * @return revealed True if the collection has been revealed.\n   */\n  function isRevealed() external view returns (bool revealed) {\n    revealed = postRevealBaseURIHash == bytes32(0);\n  }\n\n  /**\n   * @notice Get the number of tokens which can still be minted.\n   * @return count The max number of additional NFTs that can be minted by this collection.\n   */\n  function numberOfTokensAvailableToMint() external view returns (uint256 count) {\n    // Mint ensures that latestTokenId is always <= maxTokenId\n    unchecked {\n      count = maxTokenId - latestTokenId;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, AccessControlUpgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    if (interfaceId == type(INFTDropCollectionMint).interfaceId) {\n      interfaceSupported = true;\n    } else {\n      interfaceSupported = super.supportsInterface(interfaceId);\n    }\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    _requireMinted(tokenId);\n\n    return string.concat(baseURI, tokenId.toString(), \".json\");\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IGetRoyalties.sol\";\nimport \"./interfaces/ITokenCreator.sol\";\nimport \"./interfaces/IGetFees.sol\";\nimport \"./interfaces/IRoyaltyInfo.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\n\nimport \"./mixins/collections/SequentialMintCollection.sol\";\nimport \"./mixins/collections/CollectionRoyalties.sol\";\nimport \"./mixins/shared/ContractFactory.sol\";\n\n/**\n * @title A collection of NFTs by a single creator.\n * @notice All NFTs from this contract are minted by the same creator.\n * A 10% royalty to the creator is included which may be split with collaborators on a per-NFT basis.\n */\ncontract NFTCollection is\n  INFTCollectionInitializer,\n  IGetRoyalties,\n  IGetFees,\n  IRoyaltyInfo,\n  ITokenCreator,\n  ContractFactory,\n  Initializable,\n  ERC165Upgradeable,\n  ERC721Upgradeable,\n  ERC721BurnableUpgradeable,\n  SequentialMintCollection,\n  CollectionRoyalties\n{\n  using AddressLibrary for address;\n  using AddressUpgradeable for address;\n\n  /**\n   * @notice The baseURI to use for the tokenURI, if undefined then `ipfs://` is used.\n   */\n  string private baseURI_;\n\n  /**\n   * @dev Stores hashes minted to prevent duplicates.\n   */\n  mapping(string => bool) private cidToMinted;\n\n  /**\n   * @dev Stores an optional alternate address to receive creator revenue and royalty payments.\n   * The target address may be a contract which could split or escrow payments.\n   */\n  mapping(uint256 => address payable) private tokenIdToCreatorPaymentAddress;\n\n  /**\n   * @dev Stores a CID for each NFT.\n   */\n  mapping(uint256 => string) private _tokenCIDs;\n\n  /**\n   * @notice Emitted when the owner changes the base URI to be used for NFTs in this collection.\n   * @param baseURI The new base URI to use.\n   */\n  event BaseURIUpdated(string baseURI);\n  /**\n   * @notice Emitted when a new NFT is minted.\n   * @param creator The address of the collection owner at this time this NFT was minted.\n   * @param tokenId The tokenId of the newly minted NFT.\n   * @param indexedTokenCID The CID of the newly minted NFT, indexed to enable watching for mint events by the tokenCID.\n   * @param tokenCID The actual CID of the newly minted NFT.\n   */\n  event Minted(address indexed creator, uint256 indexed tokenId, string indexed indexedTokenCID, string tokenCID);\n  /**\n   * @notice Emitted when the payment address for creator royalties is set.\n   * @param fromPaymentAddress The original address used for royalty payments.\n   * @param toPaymentAddress The new address used for royalty payments.\n   * @param tokenId The NFT which had the royalty payment address updated.\n   */\n  event TokenCreatorPaymentAddressSet(\n    address indexed fromPaymentAddress,\n    address indexed toPaymentAddress,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @notice Initialize the template's immutable variables.\n   * @param _contractFactory The factory which will be used to create collection contracts.\n   */\n  constructor(address _contractFactory)\n    ContractFactory(_contractFactory) // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @notice Called by the contract factory on creation.\n   * @param _creator The creator of this collection.\n   * @param _name The collection's `name`.\n   * @param _symbol The collection's `symbol`.\n   */\n  function initialize(\n    address payable _creator,\n    string memory _name,\n    string memory _symbol\n  ) external initializer onlyContractFactory {\n    __ERC721_init(_name, _symbol);\n    _initializeSequentialMintCollection(_creator, 0);\n  }\n\n  /**\n   * @notice Allows the creator to burn a specific token if they currently own the NFT.\n   * @param tokenId The ID of the NFT to burn.\n   * @dev The function here asserts `onlyCreator` while the super confirms ownership.\n   */\n  function burn(uint256 tokenId) public override onlyCreator {\n    super.burn(tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mint(string calldata tokenCID) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintAndApprove(string calldata tokenCID, address operator) external returns (uint256 tokenId) {\n    tokenId = _mint(tokenCID);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddress(string calldata tokenCID, address payable tokenCreatorPaymentAddress)\n    public\n    returns (uint256 tokenId)\n  {\n    require(tokenCreatorPaymentAddress != address(0), \"NFTCollection: tokenCreatorPaymentAddress is required\");\n    tokenId = _mint(tokenCID);\n    tokenIdToCreatorPaymentAddress[tokenId] = tokenCreatorPaymentAddress;\n    emit TokenCreatorPaymentAddressSet(address(0), tokenCreatorPaymentAddress, tokenId);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and approves the provided operator address.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param tokenCreatorPaymentAddress The royalty recipient address to use for this NFT.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentAddressAndApprove(\n    string calldata tokenCID,\n    address payable tokenCreatorPaymentAddress,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactory(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData\n  ) public returns (uint256 tokenId) {\n    address payable tokenCreatorPaymentAddress = paymentAddressFactory.callAndReturnContractAddress(\n      paymentAddressCallData\n    );\n    tokenId = mintWithCreatorPaymentAddress(tokenCID, tokenCreatorPaymentAddress);\n  }\n\n  /**\n   * @notice Mint an NFT defined by its metadata path and have creator revenue/royalties sent to an alternate address\n   * which is defined by a contract call, typically a proxy contract address representing the payment terms.\n   * @dev This is only callable by the collection creator/owner.\n   * It can be used the first time they mint to save having to issue a separate approval\n   * transaction before listing the NFT for sale.\n   * @param tokenCID The CID for the metadata json of the NFT to mint.\n   * @param paymentAddressFactory The contract to call which will return the address to use for payments.\n   * @param paymentAddressCallData The call details to sent to the factory provided.\n   * @param operator The address to set as an approved operator for the creator's account.\n   * @return tokenId The tokenId of the newly minted NFT.\n   */\n  function mintWithCreatorPaymentFactoryAndApprove(\n    string calldata tokenCID,\n    address paymentAddressFactory,\n    bytes calldata paymentAddressCallData,\n    address operator\n  ) external returns (uint256 tokenId) {\n    tokenId = mintWithCreatorPaymentFactory(tokenCID, paymentAddressFactory, paymentAddressCallData);\n    setApprovalForAll(operator, true);\n  }\n\n  /**\n   * @notice Allows the collection creator to destroy this contract only if\n   * no NFTs have been minted yet or the minted NFTs have been burned.\n   * @dev Once destructed, a new collection could be deployed to this address (although that's discouraged).\n   */\n  function selfDestruct() external onlyCreator {\n    _selfDestruct();\n  }\n\n  /**\n   * @notice Allows the owner to assign a baseURI to use for the tokenURI instead of the default `ipfs://`.\n   * @param baseURIOverride The new base URI to use for all NFTs in this collection.\n   */\n  function updateBaseURI(string calldata baseURIOverride) external onlyCreator {\n    baseURI_ = baseURIOverride;\n\n    emit BaseURIUpdated(baseURIOverride);\n  }\n\n  /**\n   * @notice Allows the owner to set a max tokenID.\n   * This provides a guarantee to collectors about the limit of this collection contract, if applicable.\n   * @dev Once this value has been set, it may be decreased but can never be increased.\n   * This max may be less than the final `totalSupply` if 1 or more tokens were burned.\n   * @param _maxTokenId The max tokenId to set, all NFTs must have a tokenId less than or equal to this value.\n   */\n  function updateMaxTokenId(uint32 _maxTokenId) external onlyCreator {\n    _updateMaxTokenId(_maxTokenId);\n  }\n\n  function _burn(uint256 tokenId) internal override(ERC721Upgradeable, SequentialMintCollection) {\n    delete cidToMinted[_tokenCIDs[tokenId]];\n    delete tokenIdToCreatorPaymentAddress[tokenId];\n    delete _tokenCIDs[tokenId];\n    super._burn(tokenId);\n  }\n\n  function _mint(string calldata tokenCID) private onlyCreator returns (uint256 tokenId) {\n    require(bytes(tokenCID).length != 0, \"NFTCollection: tokenCID is required\");\n    require(!cidToMinted[tokenCID], \"NFTCollection: NFT was already minted\");\n    unchecked {\n      // Number of tokens cannot overflow 256 bits.\n      tokenId = ++latestTokenId;\n      require(maxTokenId == 0 || tokenId <= maxTokenId, \"NFTCollection: Max token count has already been minted\");\n      cidToMinted[tokenCID] = true;\n      _tokenCIDs[tokenId] = tokenCID;\n      _mint(msg.sender, tokenId);\n      emit Minted(msg.sender, tokenId, tokenCID, tokenCID);\n    }\n  }\n\n  /**\n   * @notice The base URI used for all NFTs in this collection.\n   * @dev The `tokenCID` is appended to this to obtain an NFT's `tokenURI`.\n   *      e.g. The URI for a token with the `tokenCID`: \"foo\" and `baseURI`: \"ipfs://\" is \"ipfs://foo\".\n   * @return uri The base URI used by this collection.\n   */\n  function baseURI() external view returns (string memory uri) {\n    uri = _baseURI();\n  }\n\n  /**\n   * @notice Checks if the creator has already minted a given NFT using this collection contract.\n   * @param tokenCID The CID to check for.\n   * @return hasBeenMinted True if the creator has already minted an NFT with this CID.\n   */\n  function getHasMintedCID(string calldata tokenCID) external view returns (bool hasBeenMinted) {\n    hasBeenMinted = cidToMinted[tokenCID];\n  }\n\n  /**\n   * @inheritdoc CollectionRoyalties\n   */\n  function getTokenCreatorPaymentAddress(uint256 tokenId)\n    public\n    view\n    override\n    returns (address payable creatorPaymentAddress)\n  {\n    creatorPaymentAddress = tokenIdToCreatorPaymentAddress[tokenId];\n    if (creatorPaymentAddress == address(0)) {\n      creatorPaymentAddress = owner;\n    }\n  }\n\n  /**\n   * @inheritdoc IERC165Upgradeable\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC165Upgradeable, ERC721Upgradeable, CollectionRoyalties)\n    returns (bool interfaceSupported)\n  {\n    // This is a no-op function required to avoid compile errors.\n    interfaceSupported = super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @inheritdoc IERC721MetadataUpgradeable\n   */\n  function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n    require(_exists(tokenId), \"NFTCollection: URI query for nonexistent token\");\n\n    uri = string.concat(_baseURI(), _tokenCIDs[tokenId]);\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    if (bytes(baseURI_).length != 0) {\n      return baseURI_;\n    }\n    return \"ipfs://\";\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTDropCollection.sol",
            "NFTCollection.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length  0, \"NFTDropCollection: `_baseURI` must be set\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length  0, \"NFTDropCollection: `_symbol` must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId  0, \"NFTDropCollection: `_maxTokenId` must be set\");\n"
                ],
                "Type": " Pre-Solidity  0.8.13 :  > 0  is less efficient than  != 0  for unsigned integers",
                "Description": "\nUp until Solidity 0.8.13: != 0 costs less gas compared to  0 for unsigned integers in require statements with the optimizer enabled (6 gas)\n\nProof: While it may seem that  0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer AND you're in a require statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706\n\nAs the Solidity version used here is 0.8.12, consider changing  0 with != 0 here:\n\nsolidity\nNFTDropCollection.sol:88:    require(bytes(_baseURI).length  0, \"NFTDropCollection: _baseURI must be set\");\nNFTDropCollection.sol:130:    require(bytes(_symbol).length  0, \"NFTDropCollection: _symbol must be set\");\nNFTDropCollection.sol:131:    require(_maxTokenId  0, \"NFTDropCollection: _maxTokenId must be set\");\n\n\nAlso, please enable the Optimizer.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"./interfaces/IERC20Approve.sol\";\nimport \"./interfaces/IERC20IncreaseAllowance.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./libraries/BytesLibrary.sol\";\n\n/**\n * @title Auto-forward ETH to a pre-determined list of addresses.\n * @notice Deploys contracts which auto-forwards any ETH sent to it to a list of recipients\n * considering their percent share of the payment received.\n * ERC-20 tokens are also supported and may be split on demand by calling `splitERC20Tokens`.\n * If another asset type is sent to this contract address such as an NFT, arbitrary calls may be made by one\n * of the split recipients in order to recover them.\n * @dev Uses create2 counterfactual addresses so that the destination is known from the terms of the split.\n */\ncontract PercentSplitETH is Initializable {\n  using AddressUpgradeable for address payable;\n  using AddressUpgradeable for address;\n  using BytesLibrary for bytes;\n  using SafeMath for uint256;\n\n  /// @notice A representation of shares using 16-bits for efficient storage.\n  /// @dev This is only used internally.\n  struct ShareCompressed {\n    address payable recipient;\n    uint16 percentInBasisPoints;\n  }\n\n  /// @notice A representation of shares using 256-bits to ease integration.\n  struct Share {\n    address payable recipient;\n    uint256 percentInBasisPoints;\n  }\n\n  ShareCompressed[] private _shares;\n\n  uint256 private constant BASIS_POINTS = 10000;\n\n  /**\n   * @notice Emitted when an ERC20 token is transferred to a recipient through this split contract.\n   * @param erc20Contract The address of the ERC20 token contract.\n   * @param account The account which received payment.\n   * @param amount The amount of ERC20 tokens sent to this recipient.\n   */\n  event ERC20Transferred(address indexed erc20Contract, address indexed account, uint256 amount);\n  /**\n   * @notice Emitted when ETH is transferred to a recipient through this split contract.\n   * @param account The account which received payment.\n   * @param amount The amount of ETH payment sent to this recipient.\n   */\n  event ETHTransferred(address indexed account, uint256 amount);\n  /**\n   * @notice Emitted when a new percent split contract is created from this factory.\n   * @param contractAddress The address of the new percent split contract.\n   */\n  event PercentSplitCreated(address indexed contractAddress);\n  /**\n   * @notice Emitted for each share of the split being defined.\n   * @param recipient The address of the recipient when payment to the split is received.\n   * @param percentInBasisPoints The percent of the payment received by the recipient, in basis points.\n   */\n  event PercentSplitShare(address indexed recipient, uint256 percentInBasisPoints);\n\n  /**\n   * @dev Requires that the msg.sender is one of the recipients in this split.\n   */\n  modifier onlyRecipient() {\n    for (uint256 i = 0; i < _shares.length; ++i) {\n      if (_shares[i].recipient == msg.sender) {\n        _;\n        return;\n      }\n    }\n    revert(\"Split: Can only be called by one of the recipients\");\n  }\n\n  /**\n   * @notice Called once to configure the contract after the initial deployment.\n   * @dev This will be called by `createSplit` after deploying the proxy so it should never be called directly.\n   * @param shares The list of recipients and their share of the payment for the template to use.\n   */\n  function initialize(Share[] memory shares) external initializer {\n    require(shares.length >= 2, \"Split: Too few recipients\");\n    require(shares.length <= 5, \"Split: Too many recipients\");\n    uint256 total;\n    unchecked {\n      // The array length cannot overflow 256 bits.\n      for (uint256 i = 0; i < shares.length; ++i) {\n        require(shares[i].percentInBasisPoints < BASIS_POINTS, \"Split: Share must be less than 100%\");\n        // Require above ensures total will not overflow.\n        total += shares[i].percentInBasisPoints;\n        _shares.push(\n          ShareCompressed({\n            recipient: shares[i].recipient,\n            percentInBasisPoints: uint16(shares[i].percentInBasisPoints)\n          })\n        );\n        emit PercentSplitShare(shares[i].recipient, shares[i].percentInBasisPoints);\n      }\n    }\n    require(total == BASIS_POINTS, \"Split: Total amount must equal 100%\");\n  }\n\n  /**\n   * @notice Forwards any ETH received to the recipients in this split.\n   * @dev Each recipient increases the gas required to split\n   * and contract recipients may significantly increase the gas required.\n   */\n  receive() external payable {\n    _splitETH(msg.value);\n  }\n\n  /**\n   * @notice Creates a new minimal proxy contract and initializes it with the given split terms.\n   * If the contract had already been created, its address is returned.\n   * This must be called on the original implementation and not a proxy created previously.\n   * @param shares The list of recipients and their share of the payment for this split.\n   * @return splitInstance The contract address for the split contract created.\n   */\n  function createSplit(Share[] memory shares) external returns (PercentSplitETH splitInstance) {\n    bytes32 salt = keccak256(abi.encode(shares));\n    address clone = Clones.predictDeterministicAddress(address(this), salt);\n    splitInstance = PercentSplitETH(payable(clone));\n    if (!clone.isContract()) {\n      emit PercentSplitCreated(clone);\n      Clones.cloneDeterministic(address(this), salt);\n      splitInstance.initialize(shares);\n    }\n  }\n\n  /**\n   * @notice Allows the split recipients to make an arbitrary contract call.\n   * @dev This is provided to allow recovering from unexpected scenarios,\n   * such as receiving an NFT at this address.\n   *\n   * It will first attempt a fair split of ERC20 tokens before proceeding.\n   *\n   * This contract is built to split ETH payments. The ability to attempt to make other calls is here\n   * just in case other assets were also sent so that they don't get locked forever in the contract.\n   * @param target The address of the contract to call.\n   * @param callData The data to send to the `target` contract.\n   */\n  function proxyCall(address payable target, bytes memory callData) external onlyRecipient {\n    require(\n      !callData.startsWith(type(IERC20Approve).interfaceId) &&\n        !callData.startsWith(type(IERC20IncreaseAllowance).interfaceId),\n      \"Split: ERC20 tokens must be split\"\n    );\n    _splitERC20Tokens(IERC20(target));\n    target.functionCall(callData);\n  }\n\n  /**\n   * @notice Allows any ETH stored by the contract to be split among recipients.\n   * @dev Normally ETH is forwarded as it comes in, but a balance in this contract\n   * is possible if it was sent before the contract was created or if self destruct was used.\n   */\n  function splitETH() external {\n    _splitETH(address(this).balance);\n  }\n\n  /**\n   * @notice Anyone can call this function to split all available tokens at the provided address between the recipients.\n   * @dev This contract is built to split ETH payments. The ability to attempt to split ERC20 tokens is here\n   * just in case tokens were also sent so that they don't get locked forever in the contract.\n   * @param erc20Contract The address of the ERC20 token contract to split tokens for.\n   */\n  function splitERC20Tokens(IERC20 erc20Contract) external {\n    require(_splitERC20Tokens(erc20Contract), \"Split: ERC20 split failed\");\n  }\n\n  function _splitERC20Tokens(IERC20 erc20Contract) private returns (bool) {\n    try erc20Contract.balanceOf(address(this)) returns (uint256 balance) {\n      if (balance == 0) {\n        return false;\n      }\n      uint256 amountToSend;\n      uint256 totalSent;\n      unchecked {\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\n          ShareCompressed memory share = _shares[i];\n          bool success;\n          (success, amountToSend) = balance.tryMul(share.percentInBasisPoints);\n          if (!success) {\n            return false;\n          }\n          amountToSend /= BASIS_POINTS;\n          totalSent += amountToSend;\n          try erc20Contract.transfer(share.recipient, amountToSend) {\n            emit ERC20Transferred(address(erc20Contract), share.recipient, amountToSend);\n          } catch {\n            return false;\n          }\n        }\n        // Favor the 1st recipient if there are any rounding issues\n        amountToSend = balance - totalSent;\n      }\n      try erc20Contract.transfer(_shares[0].recipient, amountToSend) {\n        emit ERC20Transferred(address(erc20Contract), _shares[0].recipient, amountToSend);\n      } catch {\n        return false;\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  function _splitETH(uint256 value) private {\n    if (value != 0) {\n      uint256 totalSent;\n      uint256 amountToSend;\n      unchecked {\n        for (uint256 i = _shares.length - 1; i != 0; i--) {\n          ShareCompressed memory share = _shares[i];\n          amountToSend = (value * share.percentInBasisPoints) / BASIS_POINTS;\n          totalSent += amountToSend;\n          share.recipient.sendValue(amountToSend);\n          emit ETHTransferred(share.recipient, amountToSend);\n        }\n        // Favor the 1st recipient if there are any rounding issues\n        amountToSend = value - totalSent;\n      }\n      _shares[0].recipient.sendValue(amountToSend);\n      emit ETHTransferred(_shares[0].recipient, amountToSend);\n    }\n  }\n\n  /**\n   * @notice Returns a recipient's percent share in basis points.\n   * @param index The index of the recipient to get the share of.\n   * @return percentInBasisPoints The percent of the payment received by the recipient, in basis points.\n   */\n  function getPercentInBasisPointsByIndex(uint256 index) external view returns (uint256 percentInBasisPoints) {\n    percentInBasisPoints = _shares[index].percentInBasisPoints;\n  }\n\n  /**\n   * @notice Returns the address for the proxy contract which would represent the given split terms.\n   * @dev The contract may or may not already be deployed at the address returned.\n   * Ensure that it is deployed before sending funds to this address.\n   * @param shares The list of recipients and their share of the payment for this split.\n   * @return splitInstance The contract address for the split contract created.\n   */\n  function getPredictedSplitAddress(Share[] memory shares) external view returns (address splitInstance) {\n    bytes32 salt = keccak256(abi.encode(shares));\n    splitInstance = Clones.predictDeterministicAddress(address(this), salt);\n  }\n\n  /**\n   * @notice Returns how many recipients are part of this split.\n   * @return length The number of recipients in this split.\n   */\n  function getShareLength() external view returns (uint256 length) {\n    length = _shares.length;\n  }\n\n  /**\n   * @notice Returns a recipient in this split.\n   * @param index The index of the recipient to get.\n   * @return recipient The recipient at the given index.\n   */\n  function getShareRecipientByIndex(uint256 index) external view returns (address payable recipient) {\n    recipient = _shares[index].recipient;\n  }\n\n  /**\n   * @notice Returns a tuple with the terms of this split.\n   * @return shares The list of recipients and their share of the payment for this split.\n   */\n  function getShares() external view returns (Share[] memory shares) {\n    shares = new Share[](_shares.length);\n    for (uint256 i = 0; i < shares.length; ++i) {\n      shares[i] = Share({ recipient: _shares[i].recipient, percentInBasisPoints: _shares[i].percentInBasisPoints });\n    }\n  }\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "PercentSplitETH.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-11",
                "Location": [
                    "//solidity\nuint i = 1;  \nuint j = 2;\nrequire(j == i++, \"This will be false as i is incremented after the comparison\");\n",
                    "//solidity\nuint i = 1;  \nuint j = 2;\nrequire(j == ++i, \"This will be true as i is incremented before the comparison\");\n",
                    "//solidity\nNFTCollectionFactory.sol:207:      versionNFTCollection++;\nNFTCollectionFactory.sol:231:      versionNFTDropCollection++;\n"
                ],
                "Type": "  ++i  costs less gas compared to  i++  or  i += 1  (same for  --i  vs  i--  or  i -= 1 )",
                "Description": "\nPre-increments and pre-decrements are cheaper.\n\nFor a uint256 i variable, the following is true with the Optimizer enabled at 10k:\n\nIncrement:\n\n*   i += 1 is the most expensive form\n*   i++ costs 6 gas less than i += 1\n*   ++i costs 5 gas less than i++ (11 gas less than i += 1)\n\nDecrement:\n\n*   i -= 1 is the most expensive form\n*   i-- costs 11 gas less than i -= 1\n*   --i costs 5 gas less than i-- (16 gas less than i -= 1)\n\nNote that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:\n\nsolidity\nuint i = 1;  \nuint j = 2;\nrequire(j == i++, \"This will be false as i is incremented after the comparison\");\n\n\nHowever, pre-increments (or pre-decrements) return the new value:\n\nsolidity\nuint i = 1;  \nuint j = 2;\nrequire(j == ++i, \"This will be true as i is incremented before the comparison\");\n\n\nIn the pre-increment case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2.\n\nAffected code:\n\nsolidity\nNFTCollectionFactory.sol:207:      versionNFTCollection++;\nNFTCollectionFactory.sol:231:      versionNFTDropCollection++;\n\n\nConsider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./interfaces/ICollectionFactory.sol\";\nimport \"./interfaces/INFTDropCollectionInitializer.sol\";\nimport \"./interfaces/INFTCollectionInitializer.sol\";\nimport \"./interfaces/IRoles.sol\";\n\nimport \"./libraries/AddressLibrary.sol\";\nimport \"./mixins/shared/Gap10000.sol\";\n\n/**\n * @title A factory to create NFT collections.\n * @notice Call this factory to create NFT collections.\n * @dev This creates and initializes an ERC-1165 minimal proxy pointing to a NFT collection contract implementation.\n */\ncontract NFTCollectionFactory is ICollectionFactory, Initializable, Gap10000 {\n  using AddressUpgradeable for address;\n  using Clones for address;\n  using Strings for uint32;\n\n  /****** Slot 0 (after inheritance) ******/\n  /**\n   * @notice The address of the implementation all new NFTCollections will leverage.\n   * @dev When this is changed, `versionNFTCollection` is incremented.\n   * @return The implementation address for NFTCollection.\n   */\n  address public implementationNFTCollection;\n\n  /**\n   * @notice The implementation version of new NFTCollections.\n   * @dev This is auto-incremented each time `implementationNFTCollection` is changed.\n   * @return The current NFTCollection implementation version.\n   */\n  uint32 public versionNFTCollection;\n\n  /****** Slot 1 ******/\n  /**\n   * @notice The address of the implementation all new NFTDropCollections will leverage.\n   * @dev When this is changed, `versionNFTDropCollection` is incremented.\n   * @return The implementation address for NFTDropCollection.\n   */\n  address public implementationNFTDropCollection;\n\n  /**\n   * @notice The implementation version of new NFTDropCollections.\n   * @dev This is auto-incremented each time `implementationNFTDropCollection` is changed.\n   * @return The current NFTDropCollection implementation version.\n   */\n  uint32 public versionNFTDropCollection;\n\n  /****** End of storage ******/\n\n  /**\n   * @notice The contract address which manages common roles.\n   * @dev Defines a centralized admin role definition for permissioned functions below.\n   * @return The contract address with role definitions.\n   */\n  IRoles public immutable rolesContract;\n\n  /**\n   * @notice Emitted when the implementation of NFTCollection used by new collections is updated.\n   * @param implementation The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTCollectionUpdated(address indexed implementation, uint256 indexed version);\n\n  /**\n   * @notice Emitted when the implementation of NFTDropCollection used by new collections is updated.\n   * @param implementationNFTDropCollection The new implementation contract address.\n   * @param version The version of the new implementation, auto-incremented.\n   */\n  event ImplementationNFTDropCollectionUpdated(\n    address indexed implementationNFTDropCollection,\n    uint256 indexed version\n  );\n\n  /**\n   * @notice Emitted when a new NFTCollection is created from this factory.\n   * @param collection The address of the new NFT collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param version The implementation version used by the new collection.\n   * @param name The name of the collection contract created.\n   * @param symbol The symbol of the collection contract created.\n   * @param nonce The nonce used by the creator when creating the collection,\n   * used to define the address of the collection.\n   */\n  event NFTCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    uint256 indexed version,\n    string name,\n    string symbol,\n    uint256 nonce\n  );\n\n  /**\n   * @notice Emitted when a new NFTDropCollection is created from this factory.\n   * @param collection The address of the new NFT drop collection contract.\n   * @param creator The address of the creator which owns the new collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max `tokenID` for this collection.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @param version The implementation version used by the new NFTDropCollection collection.\n   * @param nonce The nonce used by the creator to create this collection.\n   */\n  event NFTDropCollectionCreated(\n    address indexed collection,\n    address indexed creator,\n    address indexed approvedMinter,\n    string name,\n    string symbol,\n    string baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint256 maxTokenId,\n    address paymentAddress,\n    uint256 version,\n    uint256 nonce\n  );\n\n  modifier onlyAdmin() {\n    require(rolesContract.isAdmin(msg.sender), \"NFTCollectionFactory: Caller does not have the Admin role\");\n    _;\n  }\n\n  /**\n   * @notice Defines requirements for the collection drop factory at deployment time.\n   * @param _rolesContract The address of the contract defining roles for collections to use.\n   */\n  constructor(address _rolesContract) {\n    require(_rolesContract.isContract(), \"NFTCollectionFactory: RolesContract is not a contract\");\n\n    rolesContract = IRoles(_rolesContract);\n  }\n\n  /**\n   * @notice Initializer called after contract creation.\n   * @dev This is used so that this factory will resume versions from where our original factory had left off.\n   * @param _versionNFTCollection The current implementation version for NFTCollections.\n   */\n  function initialize(uint32 _versionNFTCollection) external initializer {\n    versionNFTCollection = _versionNFTCollection;\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTCollection collection implementation address.\n   */\n  function adminUpdateNFTCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTCollection++;\n    }\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTCollectionInitializer(_implementation).initialize(\n      payable(address(rolesContract)),\n      string.concat(\"NFT Collection Implementation v\", versionNFTCollection.toString()),\n      string.concat(\"NFTv\", versionNFTCollection.toString())\n    );\n\n    emit ImplementationNFTCollectionUpdated(_implementation, versionNFTCollection);\n  }\n\n  /**\n   * @notice Allows Foundation to change the NFTDropCollection implementation used for future collections.\n   * This call will auto-increment the version.\n   * Existing collections are not impacted.\n   * @param _implementation The new NFTDropCollection collection implementation address.\n   */\n  function adminUpdateNFTDropCollectionImplementation(address _implementation) external onlyAdmin {\n    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n    implementationNFTDropCollection = _implementation;\n    unchecked {\n      // Version cannot overflow 256 bits.\n      versionNFTDropCollection++;\n    }\n\n    emit ImplementationNFTDropCollectionUpdated(_implementation, versionNFTDropCollection);\n\n    // The implementation is initialized when assigned so that others may not claim it as their own.\n    INFTDropCollectionInitializer(_implementation).initialize(\n      payable(address(this)),\n      string.concat(\"NFT Drop Collection Implementation v\", versionNFTDropCollection.toString()),\n      string.concat(\"NFTDropV\", versionNFTDropCollection.toString()),\n      \"ipfs://bafybeibvxnuaqtvaxu26gdgly2rm4g2piu7b2tqlx2dsz6wwhqbey2gddy/\",\n      0x1337000000000000000000000000000000000000000000000000000000001337,\n      1,\n      address(0),\n      payable(0)\n    );\n  }\n\n  /**\n   * @notice Create a new collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTCollection(\n    string calldata name,\n    string calldata symbol,\n    uint256 nonce\n  ) external returns (address collection) {\n    require(bytes(symbol).length != 0, \"NFTCollectionFactory: Symbol is required\");\n\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTCollectionInitializer(collection).initialize(payable(msg.sender), name, symbol);\n\n    emit NFTCollectionCreated(collection, msg.sender, versionNFTCollection, name, symbol, nonce);\n  }\n\n  /**\n   * @notice Create a new drop collection contract.\n   * @dev The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address.\n   * @dev All params other than `paymentAddress` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddress The address that will receive royalties and mint payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentAddress(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    address payable paymentAddress\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        paymentAddress != msg.sender ? paymentAddress : payable(0),\n        nonce\n      );\n  }\n\n  /**\n   * @notice Create a new drop collection contract with a custom payment address derived from the factory.\n   * @dev All params other than `paymentAddressFactoryCall` are the same as in `createNFTDropCollection`.\n   * The nonce must be unique for the msg.sender + implementation version, otherwise this call will revert.\n   * @param name The collection's `name`.\n   * @param symbol The collection's `symbol`.\n   * @param baseURI The base URI for the collection.\n   * @param postRevealBaseURIHash The hash of the revealed baseURI for the collection.\n   * Set to bytes32(0) if the content is revealed by default (note that revealed content is immutable).\n   * If the post reveal content is unknown, use bytes32(uint(1)) to indicate the `baseURI` is pre-reveal content.\n   * @param maxTokenId The max token id for this collection.\n   * @param approvedMinter An optional address to grant the MINTER_ROLE.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @param paymentAddressFactoryCall The contract call which will return the address to use for payments.\n   * @return collection The address of the newly created collection contract.\n   */\n  function createNFTDropCollectionWithPaymentFactory(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    uint256 nonce,\n    CallWithoutValue memory paymentAddressFactoryCall\n  ) external returns (address collection) {\n    return\n      _createNFTDropCollection(\n        name,\n        symbol,\n        baseURI,\n        postRevealBaseURIHash,\n        maxTokenId,\n        approvedMinter,\n        AddressLibrary.callAndReturnContractAddress(paymentAddressFactoryCall),\n        nonce\n      );\n  }\n\n  function _createNFTDropCollection(\n    string calldata name,\n    string calldata symbol,\n    string calldata baseURI,\n    bytes32 postRevealBaseURIHash,\n    uint32 maxTokenId,\n    address approvedMinter,\n    address payable paymentAddress,\n    uint256 nonce\n  ) private returns (address collection) {\n    // This reverts if the NFT was previously created using this implementation version + msg.sender + nonce\n    collection = implementationNFTDropCollection.cloneDeterministic(_getSalt(msg.sender, nonce));\n\n    INFTDropCollectionInitializer(collection).initialize(\n      payable(msg.sender),\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      approvedMinter,\n      paymentAddress\n    );\n\n    emit NFTDropCollectionCreated(\n      collection,\n      msg.sender,\n      approvedMinter,\n      name,\n      symbol,\n      baseURI,\n      postRevealBaseURIHash,\n      maxTokenId,\n      paymentAddress,\n      versionNFTDropCollection,\n      nonce\n    );\n  }\n\n  /**\n   * @notice Returns the address of a collection given the current implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  /**\n   * @notice Returns the address of a NFTDropCollection collection given the current\n   * implementation version, creator, and nonce.\n   * This will return the same address whether the collection has already been created or not.\n   * @param creator The creator of the collection.\n   * @param nonce An arbitrary value used to allow a creator to mint multiple collections with a counterfactual address.\n   * @return collection The address of the collection contract that would be created by this nonce.\n   */\n  function predictNFTDropCollectionAddress(address creator, uint256 nonce) external view returns (address collection) {\n    collection = implementationNFTDropCollection.predictDeterministicAddress(_getSalt(creator, nonce));\n  }\n\n  function _getSalt(address creator, uint256 nonce) private pure returns (bytes32) {\n    return keccak256(abi.encodePacked(creator, nonce));\n  }\n}\n\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/IGetFees.sol\";\nimport \"../../interfaces/IGetRoyalties.sol\";\nimport \"../../interfaces/IOwnable.sol\";\nimport \"../../interfaces/IRoyaltyInfo.sol\";\nimport \"../../interfaces/ITokenCreator.sol\";\n\nimport \"../../libraries/ArrayLibrary.sol\";\n\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./OZERC165Checker.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\nimport \"./MarketSharedCore.sol\";\n\nerror NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin to distribute funds when an NFT is sold.\n */\nabstract contract MarketFees is FoundationTreasuryNode, MarketSharedCore, SendValueWithFallbackWithdraw {\n  using AddressUpgradeable for address;\n  using ArrayLibrary for address payable[];\n  using ArrayLibrary for uint256[];\n  using ERC165Checker for address;\n  using OZERC165Checker for address;\n\n  /**\n   * @dev Removing old unused variables in an upgrade safe way. Was:\n   * uint256 private _primaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryFoundationFeeBasisPoints;\n   * uint256 private _secondaryCreatorFeeBasisPoints;\n   * mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;\n   */\n  uint256[4] private __gap_was_fees;\n\n  /// @notice The royalties sent to creator recipients on secondary sales.\n  uint256 private constant CREATOR_ROYALTY_DENOMINATOR = BASIS_POINTS / 1000; // 10%\n  /// @notice The fee collected by Foundation for sales facilitated by this market contract.\n  uint256 private constant PROTOCOL_FEE_DENOMINATOR = BASIS_POINTS / 500; // 5%\n  /// @notice The fee collected by the buy referrer for sales facilitated by this market contract.\n  ///         This fee is calculated from the total protocol fee.\n  /// @dev 20% of protocol fee == 1% of total sale.\n  uint256 private constant BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR = 5;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /// @notice The address of this contract's implementation.\n  /// @dev This is used when making stateless external calls to this contract,\n  /// saving gas over hopping through the proxy which is only necessary when accessing state.\n  MarketFees private immutable implementationAddress;\n\n  /// @notice True for the Drop market which only performs primary sales. False if primary & secondary are supported.\n  bool private immutable assumePrimarySale;\n\n  /**\n   * @notice Emitted when a NFT sold with a referrer.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param buyReferrer The account which received the buy referral incentive.\n   * @param buyReferrerFee The portion of the protocol fee collected by the buy referrer.\n   * @param buyReferrerSellerFee The portion of the owner revenue collected by the buy referrer (not implemented).\n   */\n  event BuyReferralPaid(\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    address buyReferrer,\n    uint256 buyReferrerFee,\n    uint256 buyReferrerSellerFee\n  );\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry, bool _assumePrimarySale) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketFees_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n\n    assumePrimarySale = _assumePrimarySale;\n\n    // In the constructor, `this` refers to the implementation address. Everywhere else it'll be the proxy.\n    implementationAddress = this;\n  }\n\n  /**\n   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.\n   */\n  function _distributeFunds(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    internal\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      uint256 sellerRev\n    )\n  {\n    address payable[] memory creatorRecipients;\n    uint256[] memory creatorShares;\n\n    uint256 buyReferrerFee;\n    (totalFees, creatorRecipients, creatorShares, sellerRev, buyReferrerFee) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      buyReferrer\n    );\n\n    // Pay the creator(s)\n    unchecked {\n      for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n        _sendValueWithFallbackWithdraw(\n          creatorRecipients[i],\n          creatorShares[i],\n          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS\n        );\n        // Sum the total creator rev from shares\n        // creatorShares is in ETH so creatorRev will not overflow here.\n        creatorRev += creatorShares[i];\n      }\n    }\n\n    // Pay the seller\n    _sendValueWithFallbackWithdraw(seller, sellerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the protocol fee\n    _sendValueWithFallbackWithdraw(getFoundationTreasury(), totalFees, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n\n    // Pay the buy referrer fee\n    if (buyReferrerFee != 0) {\n      _sendValueWithFallbackWithdraw(buyReferrer, buyReferrerFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n      emit BuyReferralPaid(nftContract, tokenId, buyReferrer, buyReferrerFee, 0);\n      unchecked {\n        // Add the referrer fee back into the total fees so that all 3 return fields sum to the total price for events\n        totalFees += buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns how funds will be distributed for a sale at the given price point.\n   * @param nftContract The address of the NFT contract.\n   * @param tokenId The id of the NFT.\n   * @param price The sale price to calculate the fees for.\n   * @return totalFees How much will be sent to the Foundation treasury and/or referrals.\n   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.\n   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.\n   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.\n   * If there is only one `creatorRecipient`, this may be an empty array.\n   * Otherwise `creatorShares.length` == `creatorRecipients.length`.\n   * @return sellerRev How much will be sent to the owner/seller of the NFT.\n   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.\n   * @return seller The address of the owner of the NFT.\n   * If `sellerRev` is 0, this may be `address(0)`.\n   */\n  function getFeesAndRecipients(\n    address nftContract,\n    uint256 tokenId,\n    uint256 price\n  )\n    external\n    view\n    returns (\n      uint256 totalFees,\n      uint256 creatorRev,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      address payable seller\n    )\n  {\n    seller = _getSellerOrOwnerOf(nftContract, tokenId);\n    (totalFees, creatorRecipients, creatorShares, sellerRev, ) = _getFees(\n      nftContract,\n      tokenId,\n      seller,\n      price,\n      // TODO add referral info\n      payable(0)\n    );\n\n    // Sum the total creator rev from shares\n    for (uint256 i = 0; i < creatorShares.length; ++i) {\n      creatorRev += creatorShares[i];\n    }\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @dev See https://royaltyregistry.xyz/\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() external view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks the token creator.\n   */\n  function internalGetTokenCreator(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable creator)\n  {\n    creator = ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId);\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * If ERC2981 royalties (or getRoyalties) are defined by the NFT contract, allow this standard to define immutable\n   * royalties that cannot be later changed via the royalty registry.\n   */\n  function internalGetImmutableRoyalties(address nftContract, uint256 tokenId)\n    external\n    view\n    returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints)\n  {\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 royaltyAmount\n      ) {\n        // Manifold contracts return (address(this), 0) when royalties are not defined\n        // - so ignore results when the amount is 0\n        if (royaltyAmount > 0) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          splitPerRecipientInBasisPoints = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n          return (recipients, splitPerRecipientInBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n          return (_recipients, recipientBasisPoints);\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n  }\n\n  /**\n   * @notice **For internal use only.**\n   * @dev This function is external to allow using try/catch but is not intended for external use.\n   * This checks for royalties defined in the royalty registry or via a non-standard royalty API.\n   */\n  // solhint-disable-next-line code-complexity\n  function internalGetMutableRoyalties(\n    address nftContract,\n    uint256 tokenId,\n    address payable creator\n  ) external view returns (address payable[] memory recipients, uint256[] memory splitPerRecipientInBasisPoints) {\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n\n    try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n      address overrideContract\n    ) {\n      if (overrideContract != nftContract) {\n        nftContract = overrideContract;\n\n        // The functions above are repeated here if an override is set.\n\n        // 3rd priority: ERC-2981 override\n        if (nftContract.supportsERC165InterfaceUnchecked(type(IRoyaltyInfo).interfaceId)) {\n          try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n            address receiver,\n            uint256 /* royaltyAmount */\n          ) {\n            recipients = new address payable[](1);\n            recipients[0] = payable(receiver);\n            splitPerRecipientInBasisPoints = new uint256[](1);\n            // The split amount is assumed to be 100% when only 1 recipient is returned\n            return (recipients, splitPerRecipientInBasisPoints);\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n\n        // 4th priority: getRoyalties override\n        if (recipients.length == 0 && nftContract.supportsERC165InterfaceUnchecked(type(IGetRoyalties).interfaceId)) {\n          try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            address payable[] memory _recipients,\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length != 0 && _recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Ignore out of gas errors and continue using the nftContract address\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (nftContract.supportsERC165InterfaceUnchecked(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length != 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              return (_recipients, recipientBasisPoints);\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    if (creator != address(0)) {\n      // Only pay the tokenCreator if there wasn't another royalty defined\n      recipients = new address payable[](1);\n      recipients[0] = creator;\n      splitPerRecipientInBasisPoints = new uint256[](1);\n      // The split amount is assumed to be 100% when only 1 recipient is returned\n      return (recipients, splitPerRecipientInBasisPoints);\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (owner != address(0)) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        splitPerRecipientInBasisPoints = new uint256[](1);\n        // The split amount is assumed to be 100% when only 1 recipient is returned\n        return (recipients, splitPerRecipientInBasisPoints);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Calculates how funds should be distributed for the given sale details.\n   * @dev When the NFT is being sold by the `tokenCreator`, all the seller revenue will\n   * be split with the royalty recipients defined for that NFT.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getFees(\n    address nftContract,\n    uint256 tokenId,\n    address payable seller,\n    uint256 price,\n    address payable buyReferrer\n  )\n    private\n    view\n    returns (\n      uint256 totalFees,\n      address payable[] memory creatorRecipients,\n      uint256[] memory creatorShares,\n      uint256 sellerRev,\n      uint256 buyReferrerFee\n    )\n  {\n    // Calculate the protocol fee\n    unchecked {\n      // SafeMath is not required when dividing by a non-zero constant.\n      totalFees = price / PROTOCOL_FEE_DENOMINATOR;\n    }\n\n    address payable creator;\n    try implementationAddress.internalGetTokenCreator(nftContract, tokenId) returns (address payable _creator) {\n      creator = _creator;\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    try implementationAddress.internalGetImmutableRoyalties(nftContract, tokenId) returns (\n      address payable[] memory _recipients,\n      uint256[] memory _splitPerRecipientInBasisPoints\n    ) {\n      (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    if (creatorRecipients.length == 0) {\n      // Check mutable royalties only if we didn't find results from the immutable API\n      try implementationAddress.internalGetMutableRoyalties(nftContract, tokenId, creator) returns (\n        address payable[] memory _recipients,\n        uint256[] memory _splitPerRecipientInBasisPoints\n      ) {\n        (creatorRecipients, creatorShares) = (_recipients, _splitPerRecipientInBasisPoints);\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    if (creatorRecipients.length != 0 || assumePrimarySale) {\n      uint256 creatorRev;\n      if (assumePrimarySale) {\n        // All revenue should go to the creator recipients\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n        if (creatorRecipients.length == 0) {\n          // If no creators were found via the royalty APIs, then set that recipient to the seller's address\n          creatorRecipients = new address payable[](1);\n          creatorRecipients[0] = seller;\n          creatorShares = new uint256[](1);\n          // The split amount is assumed to be 100% when only 1 recipient is returned\n        }\n      } else if (seller == creator || (creatorRecipients.length == 1 && seller == creatorRecipients[0])) {\n        // When sold by the creator, all revenue is split if applicable.\n        // If the seller is unknown, assume it's being sold by the creator.\n        unchecked {\n          // totalFees is always < price.\n          creatorRev = price - totalFees;\n        }\n      } else {\n        // Rounding favors the owner first, then creator, and foundation last.\n        unchecked {\n          // SafeMath is not required when dividing by a non-zero constant.\n          creatorRev = price / CREATOR_ROYALTY_DENOMINATOR;\n        }\n        sellerRev = price - totalFees - creatorRev;\n      }\n\n      // Cap the max number of recipients supported\n      creatorRecipients.capLength(MAX_ROYALTY_RECIPIENTS);\n      creatorShares.capLength(MAX_ROYALTY_RECIPIENTS);\n\n      // Sum the total shares defined\n      uint256 totalShares;\n      if (creatorRecipients.length > 1) {\n        unchecked {\n          for (uint256 i = 0; i < creatorRecipients.length; ++i) {\n            if (creatorShares[i] > BASIS_POINTS) {\n              // If the numbers are >100% we ignore the fee recipients and pay just the first instead\n              totalShares = 0;\n              break;\n            }\n            totalShares += creatorShares[i];\n          }\n        }\n\n        if (totalShares == 0) {\n          // If no shares were defined or shares were out of bounds, pay only the first recipient\n          creatorRecipients.capLength(1);\n          creatorShares.capLength(1);\n        }\n      }\n\n      // Send payouts to each additional recipient if more than 1 was defined\n      uint256 totalRoyaltiesDistributed;\n      for (uint256 i = 1; i < creatorRecipients.length; ) {\n        uint256 royalty = (creatorRev * creatorShares[i]) / totalShares;\n        totalRoyaltiesDistributed += royalty;\n        creatorShares[i] = royalty;\n        unchecked {\n          ++i;\n        }\n      }\n\n      // Send the remainder to the 1st creator, rounding in their favor\n      creatorShares[0] = creatorRev - totalRoyaltiesDistributed;\n    } else {\n      // No royalty recipients found.\n      unchecked {\n        // totalFees is always < price.\n        sellerRev = price - totalFees;\n      }\n    }\n\n    if (buyReferrer != address(0) && buyReferrer != msg.sender && buyReferrer != seller && buyReferrer != creator) {\n      unchecked {\n        buyReferrerFee = totalFees / BUY_REFERRER_PROTOCOL_FEE_DENOMINATOR;\n\n        // buyReferrerFee is always <= totalFees\n        totalFees -= buyReferrerFee;\n      }\n    }\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}\n\n\n/*\n  \uff65\n   *\u3000\u2605\n      \uff65 \uff61\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n\u200b\n                      `                     .-:::::-.`              `-::---...```\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\n                                              `````\n   *\u3000\n      \uff65 \uff61\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\n\u3000\uff65\uff9f*\uff61\u2605\uff65\n \u2606\u2234\uff61\u3000*\n\uff65 \uff61\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"./libraries/LockedBalance.sol\";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Cannot_Deposit_To_Address_Zero();\nerror FETH_Cannot_Deposit_To_FETH();\nerror FETH_Cannot_Withdraw_To_Address_Zero();\nerror FETH_Cannot_Withdraw_To_FETH();\nerror FETH_Cannot_Withdraw_To_Market();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \"bucket\".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n * FETH is an upgradeable contract. Overtime we will progressively decentralize, potentially giving upgrade permissions\n * to a DAO ownership or removing the permissions entirely.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account's info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address => uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address => AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  /// @notice The Foundation drop market contract with permissions to withdraw available funds.\n  address payable private immutable foundationDropMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation ETH\n   */\n  string public constant name = \"Foundation ETH\";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = \"FETH\";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it's only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user's account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket && msg.sender != foundationDropMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Set immutable variables for the implementation contract.\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(\n    address payable _foundationMarket,\n    address payable _foundationDropMarket,\n    uint256 _lockupDuration\n  ) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    if (!_foundationDropMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    foundationDropMarket = _foundationDropMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @dev To prevent attack vectors, clients SHOULD make sure to create user interfaces in such a way\n   * that they set the allowance first to 0 before setting it to another value for the same spender.\n   * We will add support for `increaseAllowance` in the future.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    } else if (account == address(0)) {\n      revert FETH_Cannot_Deposit_To_Address_Zero();\n    } else if (account == address(this)) {\n      revert FETH_Cannot_Deposit_To_FETH();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account's FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user's available balance and returns ETH to the caller.\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user's account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user's offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    } else if (to == address(0)) {\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\n    } else if (to == address(this)) {\n      revert FETH_Cannot_Withdraw_To_FETH();\n    } else if (to == address(foundationMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    } else if (to == address(foundationDropMarket)) {\n      revert FETH_Cannot_Withdraw_To_Market();\n    }\n\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount, from);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(\n    AccountInfo storage accountInfo,\n    uint256 amount,\n    address from\n  ) private {\n    uint256 spenderAllowance = accountInfo.allowance[msg.sender];\n    if (spenderAllowance != type(uint256).max) {\n      if (spenderAllowance < amount) {\n        revert FETH_Insufficient_Allowance(spenderAllowance);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        spenderAllowance -= amount;\n      }\n      accountInfo.allowance[msg.sender] = spenderAllowance;\n      emit Approval(from, msg.sender, spenderAllowance);\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account's available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    uint96 freedBalance = accountInfo.freedBalance;\n    // Free from escrow in order to consider any expired escrow balance\n    if (freedBalance < amount) {\n      revert FETH_Insufficient_Available_Funds(freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance = freedBalance - uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   * Sets the next bucket that hasn't expired as the new start index.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that's the new start index\n      if (escrow.expiration >= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is <= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value < amount) {\n      unchecked {\n        // The if check above prevents an underflow here\n        _deductBalanceFrom(accountInfo, amount - msg.value);\n      }\n    } else if (msg.value != amount) {\n      // There's no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always < 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration > type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be < 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be < 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration < block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it's the last one\n        unchecked {\n          if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n            // The number of escrow buckets will never overflow 32 bits.\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount < amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount > escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    amount = accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    market = foundationMarket;\n  }\n\n  /**\n   * @notice Gets the Foundation drop market address which has permissions to withdraw available funds.\n   * @return market The Foundation drop market contract address.\n   */\n  function getFoundationDropMarket() external view returns (address market) {\n    market = foundationDropMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always < 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\n   * but this is on-par with the WETH implementation and done for gas savings.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    return address(this).balance;\n  }\n}\n\n\n",
        "CodeNames": [
            "NFTCollectionFactory.sol",
            "MarketFees.sol",
            "FETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-13",
                "Location": [
                    "//solidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n"
                ],
                "Type": " Use Custom Errors instead of Revert Strings to save Gas",
                "Description": "\nCustom errors are available from solidity version 0.8.4. Custom errors save ~50 gas(https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by avoiding having to allocate and store the revert string(https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\nAdditionally, custom errors can be used inside and outside of contracts (including interfaces and libraries).\n\nSource: <https://blog.soliditylang.org/2021/04/21/custom-errors/:\n\n Starting from Solidity v0.8.4(https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n\nConsider replacing all revert strings with custom errors in the solution, and particularly those that have multiple occurrences:\n\nsolidity\nNFTCollectionFactory.sol:203:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\nNFTCollectionFactory.sol:227:    require(_implementation.isContract(), \"NFTCollectionFactory: Implementation is not a contract\");\n\n\nHardlyDifficult (Foundation) commented(https://github.com/code-423n4/2022-08-foundation-findings/issues/122#issuecomment-1220091166):\n  Great report, the code diffs really help to understand your points. And the statements like Saving 3 SLOADs makes the impact clear. Thanks!\n \n \n G-01] Check for bytes(_symbol).length  0 \n \n Agree, and it's good for consistency. Fixed.\n \n G=02] Caching storage values in memory\n \n Agree, will fix this up. Except for the admin update functions since we are not trying to optimize for the admin and I think the code is a little cleaner as is.\n \n G-03] Avoid emitting a storage variable when a memory value is available\n \n  Agree, fixed.\n \n G-04] Unchecking arithmetics operations that can't underflow/overflow\n \n  Agree, changed.\n \n G-05] calldata\n \n  Valid & will fix. This saves ~60 gas on createNFTDropCollectionWithPaymentFactory\n \n G-06] Use short error messages\n \n  Agree but won't fix. We use up to 64 bytes, aiming to respect the incremental cost but 32 bytes is a bit too short to provide descriptive error messages for our users.\n \n G-07] Duplicated conditions should be refactored to a modifier\n \n  Agree, will consider a change here.\n \n G-08] Redundant check\n \n  Good catch! Agree, will fix\n \n G-09] Pre-Solidity 0.8.13:  0 is less efficient than != 0 for unsigned integers\n \n  Ahh that's where it got fixed. I've been calling this invalid after testing -good to know where that had changed. We are compiling with 0.8.16 even though we have a floating 0.8.12.\n \n G-10] Cache Array Length Outside of Loop\n \n  May be theoretically valid, but won't fix. I tested this: gas-reporter and our gas-stories suite is reporting a small regression using this technique. It also hurts readability a bit so we wouldn't want to include it unless it was a clear win.\n \n G-11] ++i costs less than i++\n \n  Agree and will fix.\n \n G-12] unchecked loop in getFeesAndRecipients\n \n  getFeesAndRecipients  is a read only function not intended to be used on-chain, but as a best practice we will add unchecked there as well.\n \n The other example provided was already unchecked -invalid.\n \n G-13] Custom errors\n \n  Agree but won't fix at this time. We use these in the market but not in collections. Unfortunately custom errors are still not as good of an experience for users (e.g. on etherscan). We used them in the market originally because we were nearing the max contract size limit and this was a good way to reduce the bytecode. We'll consider this in the future as tooling continues to improve.\n \n \n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]