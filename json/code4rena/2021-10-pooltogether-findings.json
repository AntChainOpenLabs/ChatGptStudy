[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "tex\n2 ^ {bitRange times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\nf(bitRange, n) = 2 ^ {bitRange times n} ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\n\nBecause:\n\n2 ^ {bitRange times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n2 ^ {bitRange times (n-1)} f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n\nTherefore:\n\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) ( 2 ^ {bitRange times (n-1)} f(bitRange, n-1) )\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) 2 ^ {bitRange times (n-1)} + f(bitRange, n-1)\nf(bitRange, n) = 2 ^ {bitRange times n} 2 ^ {bitRange times (n-1)}\n",
                    "tex\nf(bitRange, n) = (2 ^ {bitRange} 1) times 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange} times 2 ^ {bitRange times (n 1)} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange times (n 1)} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange times n bitRange} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange times n} 2 ^ {bitRange times (n 1)}\n"
                ],
                "Type": " The formula of number of prizes for a degree is wrong",
                "Description": "\nThe formula of the number of prizes for a degree per the document: <https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is:\n\n    Number of prizes for a degree = (2^bit range)^degree (2^bit range)^(degree-1) (2^bit range)^(degree-2) ...\n\nShould be changed to:\n\n    Number of prizes for a degree = (2^bit range)^degree (2^bit range)^(degree-1)\n\nor\n\n    Number of prizes for a degree = 2^(bit range * degree) 2^(bit range * (degree-1))\n\n\nPer the document:\n\n prize for a degree = total prize * degree percentage / number of prizes for a degree\n\nDue to the miscalculation of number of prizes for a degree, it will be smaller than expected, as a result, prize for a degree will be larger than expected. Making the protocol giving out more prizes than designed.\n\n\n We will use f(bitRange, degree) to represent numberOfPrizesForDegree(bitRangeSize, degree).\n\n\ntex\n2 ^ {bitRange times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\nf(bitRange, n) = 2 ^ {bitRange times n} ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )\n\nBecause:\n\n2 ^ {bitRange times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n2 ^ {bitRange times (n-1)} f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)\n\nTherefore:\n\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) ( 2 ^ {bitRange times (n-1)} f(bitRange, n-1) )\nf(bitRange, n) = 2 ^ {bitRange times n} f(bitRange, n-1) 2 ^ {bitRange times (n-1)} + f(bitRange, n-1)\nf(bitRange, n) = 2 ^ {bitRange times n} 2 ^ {bitRange times (n-1)}\n\n\nBecause 2^x = 1 << x\n\nTherefore, when n  0:\n\n    f(bitRange, n) = ( 1 << bitRange * n ) ( 1 << bitRange * (n 1) )\n\nQED.\n\n\nBy definition, degree n is constructed by 3 chunks:\n\n*   The first N numbers, must equal the matching numbers. Number of possible values: 1;\n*   The N-th number, must not equal the N-th matching number. Number of possible values: 2^bitRange 1\n*   From N (not include) until the end. Number of possible values: 2 ^ (bitRange * (n-1))\n\nTherefore, total numberOfPrizesForDegree will be:\n\ntex\nf(bitRange, n) = (2 ^ {bitRange} 1) times 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange} times 2 ^ {bitRange times (n 1)} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange times (n 1)} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange + bitRange times n bitRange} 2 ^ {bitRange times (n 1)}\nf(bitRange, n) = 2 ^ {bitRange times n} 2 ^ {bitRange times (n 1)}\n\n\nQED.\n\n",
                "Repair": "\n<https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431\n\nsolidity\n/\n    * @notice Calculates the number of prizes for a given prizeDistributionIndex\n    * @param _bitRangeSize Bit range size for Draw\n    * @param _prizeTierIndex Index of the prize tier array to calculate\n    * @return returns the fraction of the total prize (base 1e18)\n    */\nfunction _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n    internal\n    pure\n    returns (uint256)\n{\n    uint256 bitRangeDecimal = 2uint256(_bitRangeSize);\n    uint256 numberOfPrizesForIndex = bitRangeDecimal_prizeTierIndex;\n\n    while (_prizeTierIndex  0) {\n        numberOfPrizesForIndex -= bitRangeDecimal(_prizeTierIndex 1);\n        _prizeTierIndex--;\n    }\n\n    return numberOfPrizesForIndex;\n}\n\n\nL423-431 should change to:\n\nsolidity\nif (_prizeTierIndex  0) {\n    return ( 1 << _bitRangeSize * _prizeTierIndex ) ( 1 << _bitRangeSize * (_prizeTierIndex 1) );\n} else {\n    return 1;\n}\n\n\nBTW, the comment on L416 is wrong:\n\n*   seems like it's copied from _calculatePrizeTierFraction()\n*   plus, it's not base 1e18 but base 1e9\n\nPierrickGT (PoolTogether) confirmed and patched(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33#issuecomment-943604800):\n  PR: https://github.com/pooltogether/v4-core/pull/242\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33#issuecomment-943845472):\n  The warden found the usage of an incorrect formula that would cause the protocol to give out larger prizes than expected, the sponsor has mitigated in a following PR\n\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " Deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).\n\n\nThe PrizePool._depositTo() function will try to supply more _amount than was actually transferred.\nThe tx will revert and these tokens cannot be used.\n\n",
                "Repair": "\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\nasselstine (PoolTogether) acknowledged(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/30#issuecomment-942994789):\n  We don't plan on incorporating fee-on-transfer tokens, so I think we can safely ignore this.\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/30#issuecomment-943854691):\n  The sponsor acknowledges the finding, simple mitigation is to not use feeOnTransfer tokens in the protocol\n\n\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": "  PrizePool.awardExternalERC721()  Erroneously Emits Events",
                "Description": "\n\nThe awardExternalERC721() function uses solidity's try and catch statement to ensure a single tokenId cannot deny function execution. If the try statement fails, an ErrorAwardingExternalERC721 event is emitted with the relevant error, however, the failed tokenId is not removed from the list of tokenIds emitted at the end of function execution. As a result, the AwardedExternalERC721 is emitted with the entire list of tokenIds, regardless of failure.  An off-chain script or user could therefore be tricked into thinking an ERC721 tokenId was successfully awarded.\n\n\n<https://github.com/pooltogether/v4-core/blob/master/contracts/prize-pool/PrizePool.sol#L250-L270\n\n\nManual code review\n\n",
                "Repair": "\nConsider emitting only successfully transferred tokenIds in the AwardedExternalERC721 event.\n\nPierrickGT (PoolTogether) confirmed and patched(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62#issuecomment-943617886):\n  PR: https://github.com/pooltogether/v4-core/pull/246\n\nAlex the Entreprenerd (judge) commented(https://github.com/code-423n4/2021-10-pooltogether-findings/issues/62#issuecomment-943857035):\n  The sponsor acknowledged and mitigated by actively managing a list of _awardedTokenIds to keep track of the tokens that didn't go through the catch part of the error hadling\n\n\n\n \n\n"
            }
        ]
    }
]