[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\ncontract NestedAsset is ERC721Enumerable, Ownable {\n    using Counters for Counters.Counter;\n\n    event FactoryAdded(address newFactory);\n    event FactoryRemoved(address oldFactory);\n\n    Counters.Counter private _tokenIds;\n\n    /// @dev Supported factories to interact with\n    mapping(address => bool) public supportedFactories;\n\n    /// @dev Stores the URI of each asset\n    mapping(uint256 => string) private _tokenURIs;\n\n    /// @dev Stores the original asset of each asset\n    mapping(uint256 => uint256) public originalAsset;\n\n    /// @dev Stores owners of burnt assets\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\n\n    constructor() ERC721(\"NestedNFT\", \"NESTED\") {}\n\n    /// @dev Reverts the transaction if the caller is not the factory\n    modifier onlyFactory() {\n        require(supportedFactories[_msgSender()], \"NestedAsset: FORBIDDEN_NOT_FACTORY\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the address is not the token owner\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\n        require(_address == ownerOf(_tokenId), \"NestedAsset: FORBIDDEN_NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @return The token Uniform Resource Identifier (URI)\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(_exists(_tokenId), \"URI query for nonexistent token\");\n        return _tokenURIs[_tokenId];\n    }\n\n    /// @notice Returns the owner of the original token if the token was replicated\n    /// If the original asset was burnt, the last owner before burn is returned\n    /// @param _tokenId The asset for which we want to know the original owner\n    /// @return The owner of the original asset\n    function originalOwner(uint256 _tokenId) public view returns (address) {\n        uint256 originalAssetId = originalAsset[_tokenId];\n\n        if (originalAssetId != 0) {\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\n        }\n        return address(0);\n    }\n\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\n    /// @param _owner The account address that signed the transaction\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 tokenId = _tokenIds.current();\n        _safeMint(_owner, tokenId);\n\n        // Stores the first asset of the replication chain as the original\n        if (_replicatedTokenId == 0) {\n            return tokenId;\n        }\n\n        require(\n            _exists(_replicatedTokenId) && tokenId != _replicatedTokenId,\n            \"NestedAsset::mint: Invalid replicated token ID\"\n        );\n\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\n\n        return tokenId;\n    }\n\n    /// @notice Mints an ERC721 token and sets the tokenUri\n    /// @param _owner The account address that signed the transaction\n    /// @param _metadataURI he metadata URI string\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mintWithMetadata(\n        address _owner,\n        string memory _metadataURI,\n        uint256 _replicatedTokenId\n    ) external onlyFactory returns (uint256) {\n        uint256 tokenId = mint(_owner, _replicatedTokenId);\n        _setTokenURI(tokenId, _metadataURI);\n        return tokenId;\n    }\n\n    /// @notice Backfills the token URI if it had never set\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _owner The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function backfillTokenURI(\n        uint256 _tokenId,\n        address _owner,\n        string memory _metadataURI\n    ) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        require(bytes(tokenURI(_tokenId)).length == 0, \"NestedAsset: TOKEN_URI_IMMUTABLE\");\n        _setTokenURI(_tokenId, _metadataURI);\n    }\n\n    /// @notice Burns an ERC721 token\n    /// @param _owner The account address that signed the transaction\n    /// @param _tokenId The id of the NestedAsset\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        lastOwnerBeforeBurn[_tokenId] = _owner;\n        _burn(_tokenId);\n\n        if (bytes(_tokenURIs[_tokenId]).length != 0) {\n            delete _tokenURIs[_tokenId];\n        }\n    }\n\n    /// @notice Sets the factory for Nested assets\n    /// @param _factory the address of the new factory\n    function setFactory(address _factory) external onlyOwner {\n        require(_factory != address(0), \"NestedAsset: INVALID_ADDRESS\");\n        supportedFactories[_factory] = true;\n        emit FactoryAdded(_factory);\n    }\n\n    /// @notice Remove a supported factory from NestedAssets\n    /// @param _factory The address of the factory to remove\n    function removeFactory(address _factory) external onlyOwner {\n        require(supportedFactories[_factory] == true, \"NestedAsset: ALREADY_NOT_SUPPORTED\");\n        supportedFactories[_factory] = false;\n        emit FactoryRemoved(_factory);\n    }\n\n    /// @dev Sets the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function _setTokenURI(uint256 _tokenId, string memory _metadataURI) internal {\n        _tokenURIs[_tokenId] = _metadataURI;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedAsset.sol",
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "create()",
                    "sendFeesWithRoyalties()",
                    "addShares()"
                ],
                "Type": " Copy your own portfolio to keep earning royalties ",
                "Description": "\nIn NestedFactory.sol going through the create() function which leads to the sendFeesWithRoyalties() = addShares() function,  Im not seeing any checks preventing someone from copying their own portfolio and receiving royalty shares for it and simply repeating the process over and over again.\n\nFeeSplitter.sol L152(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L152)\nFeeSplitter.sol L220(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L220)\nNestedFactory.sol L103(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L103)\nNestedAsset.sol L69(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L69)\nNestedFactory.sol L103(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L103)\nNestedFactory.sol L491(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L491)\n\nManual code review\n\n",
                "Repair": "A require statement should be added not allowing users to copy their own portfolios.\n\nmaximebrugel (Nested) disagreed with severity(https://github.com/code-423n4/2021-11-nested-findings/issues/30#issuecomment-970388713):\n  Indeed, a user can copy his own portfolio to reduce the fees, however a require statement won't fix this issue...\n\n This problem cannot be corrected but only mitigated, since the user can use two different wallets.\n Currently the front-end doesn't allow to duplicate a portfolio with the same address.\n\n I don't consider this a \"High Risk\" since the assets are not really stolen. Maybe \"Med Risk\" ? This is by design an issue and we tolerate that users can do this (with multiple wallets).\n\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/30#issuecomment-985642915):\n  I'm reading that the vulnerability actually lowers fees to zero for a dedicated attacker, since creating a arbitrarily large number of wallets and bypassing the frontend is easy. In theory leaking protocol value would be a severity 2, but since this is effectively disabling a core feature of the protocol (fees), the severity 3 is sustained.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/external/INestedToken.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\n\n/// @title Token sent to this contract are used to purchase NST.\n/// @dev Some of it is burned, the rest is sent to a pool that will redistribute\n///      to the NST ecosystem and community.\ncontract NestedBuybacker is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for INestedToken;\n\n    /// @dev Emitted when the reserve address is updated\n    /// @param newReserve The new reserve address\n    event ReserveUpdated(address newReserve);\n\n    /// @dev Emitted when the fee splitter address is updated\n    /// @param newFeeSplitter The new FeeSplitter address\n    event FeeSplitterUpdated(FeeSplitter newFeeSplitter);\n\n    /// @dev Emitted when the burn percentage is updated\n    /// @param newBurnPart The new burn percentage amount\n    event BurnPartUpdated(uint256 newBurnPart);\n\n    /// @dev Emitted when the buy back is executed\n    /// @param forToken sellToken used for the buy back\n    event BuybackTriggered(IERC20 forToken);\n\n    /// @dev The Nested project token\n    INestedToken public immutable NST;\n\n    /// @dev Current address where user assets are stored\n    address public nstReserve;\n\n    /// @dev Current fee splitter address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Part of the bought tokens to be burned (100% = 1000)\n    uint256 public burnPercentage;\n\n    constructor(\n        address _NST,\n        address _nstReserve,\n        address payable _feeSplitter,\n        uint256 _burnPercentage\n    ) {\n        require(_burnPercentage <= 1000, \"NestedBuybacker::constructor: Burn part to high\");\n        burnPercentage = _burnPercentage;\n        NST = INestedToken(_NST);\n        feeSplitter = FeeSplitter(_feeSplitter);\n        nstReserve = _nstReserve;\n    }\n\n    /// @notice Claim awarded fees from the FeeSplitter contract\n    /// @param _token Token address for the fees\n    function claimFees(IERC20 _token) public {\n        feeSplitter.releaseToken(_token);\n    }\n\n    /// @notice Update the nested reserve address\n    /// @param _nstReserve New reserve contract address\n    function setNestedReserve(address _nstReserve) external onlyOwner {\n        nstReserve = _nstReserve;\n        emit ReserveUpdated(nstReserve);\n    }\n\n    /// @notice Update the fee splitter address\n    /// @param _feeSplitter The new fee splitter contract address\n    function setFeeSplitter(FeeSplitter _feeSplitter) external onlyOwner {\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(feeSplitter);\n    }\n\n    /// @notice Update parts deciding what amount is sent to reserve or burned\n    /// @param _burnPercentage The new burn percentage\n    function setBurnPart(uint256 _burnPercentage) public onlyOwner {\n        require(_burnPercentage <= 1000, \"NestedBuybacker::setBurnPart: Burn part to high\");\n        burnPercentage = _burnPercentage;\n        emit BurnPartUpdated(burnPercentage);\n    }\n\n    /// @notice Triggers the purchase of NST sent to reserve and burn\n    /// @param _swapCallData Call data provided by 0x to fill quotes\n    /// @param _swapTarget Target contract for the swap (could be Uniswap router for example)\n    /// @param _sellToken Token to sell in order to buy NST\n    function triggerForToken(\n        bytes calldata _swapCallData,\n        address payable _swapTarget,\n        IERC20 _sellToken\n    ) external onlyOwner {\n        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) {\n            claimFees(_sellToken);\n        }\n\n        uint256 balance = _sellToken.balanceOf(address(this));\n        ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);\n        trigger();\n        emit BuybackTriggered(_sellToken);\n    }\n\n    /// @dev burns part of the bought NST and send the rest to the reserve\n    function trigger() internal {\n        uint256 balance = NST.balanceOf(address(this));\n        uint256 toBurn = (balance * burnPercentage) / 1000;\n        uint256 toSendToReserve = balance - toBurn;\n        _burnNST(toBurn);\n        NST.safeTransfer(nstReserve, toSendToReserve);\n    }\n\n    /// @dev Burn NST token from the smart contract\n    /// @param _amount The amount to burn\n    function _burnNST(uint256 _amount) private {\n        NST.burn(_amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "NestedBuybacker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "reserve",
                    "setReserve()"
                ],
                "Type": "  setReserve()  can be front-run",
                "Description": "\nThe reserve address variable in NestedFactory.sol remains equal to 0 before the setReserve() function is called by an owner. This may lead to incorrect transfers of tokens or invalid comparison with e.g., the asset reserve (nestedRecords.getAssetReserve(_nftId) == address(reserve)), should they occur before the value for reserve was set.\nIn addition, the immutabiliy of the reserve variable requires extra caution when setting the value.\n\nsetReserve(): NestedFactory.sol L89(https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L89)\n\nManual Analysis\n\n",
                "Repair": "Consider initializing the value for the reserve variable in the constructor.\n\nmaximebrugel (Nested) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/82#issuecomment-970327769):\n  The main issue is duplicated : #60\n\n The following comment can be considered as a duplicate of #83 if the extra caution is checking the zero address.\n  In addition, the immutabiliy of the reserve variable requires extra caution when setting the value.\n\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/82#issuecomment-985410734):\n  The fact that the call to setReserve can be front-run is not being taken into account by the sponsor. I'm marking this one as not a duplicate.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "_sendFee()"
                ],
                "Type": " FeeSplitter: No sanity check to prevent shareholder from being added twice.",
                "Description": "\nIt is possible for duplicate shareholders to be added. These shareholders will get more than intended when _sendFee() is called.\n\n",
                "Repair": "Ensure that the _accounts array is sorted in setShareholders().\n\njsx\nfor (uint256 i = 0; i < _accounts.length; i++) {\n\tif (i  0) {\n\t\trequire(_accounts[i 1] < _accounts[i], \"FeeSplitter: ACCOUNTS_NOT_SORTED\");\n\t}\n\t_addShareholder(_accounts[i], _weights[i]);\n}\n\n\nadrien-supizet (Nested) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/135#issuecomment-975351632):\n  Duplicate #231\n\nadrien-supizet (Nested) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/135#issuecomment-975352623):\n  Indeed there is a fix to do here, we'll prevent adding the same shareholders instead as suggested in #231\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/135#issuecomment-985366841):\n  Taking this issue as the principal, and raising #231 to medium severity.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\ncontract NestedAsset is ERC721Enumerable, Ownable {\n    using Counters for Counters.Counter;\n\n    event FactoryAdded(address newFactory);\n    event FactoryRemoved(address oldFactory);\n\n    Counters.Counter private _tokenIds;\n\n    /// @dev Supported factories to interact with\n    mapping(address => bool) public supportedFactories;\n\n    /// @dev Stores the URI of each asset\n    mapping(uint256 => string) private _tokenURIs;\n\n    /// @dev Stores the original asset of each asset\n    mapping(uint256 => uint256) public originalAsset;\n\n    /// @dev Stores owners of burnt assets\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\n\n    constructor() ERC721(\"NestedNFT\", \"NESTED\") {}\n\n    /// @dev Reverts the transaction if the caller is not the factory\n    modifier onlyFactory() {\n        require(supportedFactories[_msgSender()], \"NestedAsset: FORBIDDEN_NOT_FACTORY\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the address is not the token owner\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\n        require(_address == ownerOf(_tokenId), \"NestedAsset: FORBIDDEN_NOT_OWNER\");\n        _;\n    }\n\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @return The token Uniform Resource Identifier (URI)\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(_exists(_tokenId), \"URI query for nonexistent token\");\n        return _tokenURIs[_tokenId];\n    }\n\n    /// @notice Returns the owner of the original token if the token was replicated\n    /// If the original asset was burnt, the last owner before burn is returned\n    /// @param _tokenId The asset for which we want to know the original owner\n    /// @return The owner of the original asset\n    function originalOwner(uint256 _tokenId) public view returns (address) {\n        uint256 originalAssetId = originalAsset[_tokenId];\n\n        if (originalAssetId != 0) {\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\n        }\n        return address(0);\n    }\n\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\n    /// @param _owner The account address that signed the transaction\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 tokenId = _tokenIds.current();\n        _safeMint(_owner, tokenId);\n\n        // Stores the first asset of the replication chain as the original\n        if (_replicatedTokenId == 0) {\n            return tokenId;\n        }\n\n        require(\n            _exists(_replicatedTokenId) && tokenId != _replicatedTokenId,\n            \"NestedAsset::mint: Invalid replicated token ID\"\n        );\n\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\n\n        return tokenId;\n    }\n\n    /// @notice Mints an ERC721 token and sets the tokenUri\n    /// @param _owner The account address that signed the transaction\n    /// @param _metadataURI he metadata URI string\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mintWithMetadata(\n        address _owner,\n        string memory _metadataURI,\n        uint256 _replicatedTokenId\n    ) external onlyFactory returns (uint256) {\n        uint256 tokenId = mint(_owner, _replicatedTokenId);\n        _setTokenURI(tokenId, _metadataURI);\n        return tokenId;\n    }\n\n    /// @notice Backfills the token URI if it had never set\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _owner The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function backfillTokenURI(\n        uint256 _tokenId,\n        address _owner,\n        string memory _metadataURI\n    ) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        require(bytes(tokenURI(_tokenId)).length == 0, \"NestedAsset: TOKEN_URI_IMMUTABLE\");\n        _setTokenURI(_tokenId, _metadataURI);\n    }\n\n    /// @notice Burns an ERC721 token\n    /// @param _owner The account address that signed the transaction\n    /// @param _tokenId The id of the NestedAsset\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        lastOwnerBeforeBurn[_tokenId] = _owner;\n        _burn(_tokenId);\n\n        if (bytes(_tokenURIs[_tokenId]).length != 0) {\n            delete _tokenURIs[_tokenId];\n        }\n    }\n\n    /// @notice Sets the factory for Nested assets\n    /// @param _factory the address of the new factory\n    function setFactory(address _factory) external onlyOwner {\n        require(_factory != address(0), \"NestedAsset: INVALID_ADDRESS\");\n        supportedFactories[_factory] = true;\n        emit FactoryAdded(_factory);\n    }\n\n    /// @notice Remove a supported factory from NestedAssets\n    /// @param _factory The address of the factory to remove\n    function removeFactory(address _factory) external onlyOwner {\n        require(supportedFactories[_factory] == true, \"NestedAsset: ALREADY_NOT_SUPPORTED\");\n        supportedFactories[_factory] = false;\n        emit FactoryRemoved(_factory);\n    }\n\n    /// @dev Sets the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @param _metadataURI The metadata URI string\n    function _setTokenURI(uint256 _tokenId, string memory _metadataURI) internal {\n        _tokenURIs[_tokenId] = _metadataURI;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "NestedAsset.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "addToken()",
                    "create()",
                    "inputToken"
                ],
                "Type": " NestedFactory: Ensure zero msg.value if transferring from user and  inputToken  is not ETH ",
                "Description": "\nA user that mistakenly calls either create() or addToken() with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.\n\n",
                "Repair": "It is best to ensure that msg.value = 0 in _transferInputTokens() for the scenario mentioned above.\n\njsx\n} else if (address(_inputToken) == ETH) {\n\t...\n} else {\n\trequire(msg.value == 0, \"NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer\");\n  _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n}\n\n\nadrien-supizet (Nested) confirmed(https://github.com/code-423n4/2021-11-nested-findings/issues/136)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "destroy()",
                    "_sendFees()",
                    "withdraw()"
                ],
                "Type": " FeeSplitter: Unbounded number of shareholders can cause DOS",
                "Description": "\nThere is no limit to the number of shareholders. It is therefore possible to set a large number of shareholders such that _sendFees() will run out of gas when adding shares to each shareholder.\nThis will cause denial of service to all NestedFactory functions, especially the ones that will remove funds like withdraw() and destroy().\n\n",
                "Repair": "It would be best to set a sanity maximum number of shareholders that can be added.\n\nadrien-supizet (Nested) acknowledged(https://github.com/code-423n4/2021-11-nested-findings/issues/137)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./OperatorResolver.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, address destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public resolver;\n\n    /// @dev Cache operators map of the name and address\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) {\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    /// invoked via super in subclasses\n    function resolverAddressesRequired() public view virtual returns (bytes32[] memory addresses) {}\n\n    /// @notice Rebuild the addressCache\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination = resolver.getAddress(name);\n            if (destination != address(0)) {\n                addressCache[name] = destination;\n            } else {\n                delete addressCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of addressCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint256 i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing operator : \", name)));\n        return _foundAddress;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol",
            "MixinOperatorResolver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "resolverAddressesRequired()",
                    "addOperator()",
                    "importOperators([",
                    "addressCache[",
                    "addressCache",
                    "removeOperator(",
                    "isResolverCached",
                    "rebuildCache()",
                    "removeOperator()",
                    "address",
                    "bytes",
                    "operators"
                ],
                "Type": " isResolverCached() will always return false after removing operator",
                "Description": "\nWhile there is no loss of funds, removing an operator will cause the cache functionality to be permanently broken. If there was a function that had a modifier which requires the cache to be synced before the function can be called, it would not be callable as well.\n\nThe underlying issue is how the bytes32 operator is removed from the array when removeOperator() is called. Its value gets deleted (set to 0x0), but isn't taken out of the array.\n\nFor ease of reading, we use abbreviated strings like 0xA, 0xB for bytes32 and address types.\n\n1.  Import 3 operators by calling OperatorResolver.importOperators([0xA, 0xB, 0xC], 0x1, 0x2, 0x3).\n2.  Call NestedFactory.addOperator() 3 times to push these 3 operators into the operators state variable.\n3.  Call NestedFactory.rebuildCache() to build the cache.\n4.  Let's say the second operator 0xB is to be removed. Taking reference from the removeOperator.ts script, OperatorResolver.importOperators([0xA, 0xB, 0xC], 0x1, 0x2, 0x3) is called first. This works because OperatorResolver uses a mapping(bytes32 \u21d2 address) to represent the operators. Hence, by setting 0xB's destination address to be the null address, it is like as if he was never an operator.\n5.  Call NestedFactory.rebuildCache() to rebuild the cache. resolverAddressesRequired() will return [0xA, 0xB, 0xC]. 0xB will be removed from addressCache because resolver.getAddress(0xB) returns 0x000 since it has been deleted from the OperatorResolver.\n6.  Call NestedFactory.removeOperator(0xB). The operators array now looks like this: [0xA, 0x0, 0xC].\n7.  When you try to call NestedFactory.isResolverCached, it will always return false because of the null bytes32 value, where addressCache[0x0] will always return the null address.\n\n",
                "Repair": "Instead of doing an element deletion, it should be replaced with the last element, then have the last element popped in removeOperator().\n\njsx\nfunction removeOperator(bytes32 operator) external override onlyOwner {\n\tfor (uint256 i = 0; i < operators.length; i++) {\n\t\tif (operators[i] == operator) {\n\t\t\toperators[i] = operators[operators.length 1];\n\t\t\toperators.pop();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nmaximebrugel (Nested) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/139#issuecomment-975378231):\n  Duplicated : #58\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/139#issuecomment-985431604):\n  Taking this issue apart as a non-duplicate, for finding the most severe consequence of the incorrect implementation.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction _submitInOrders(\n    uint256 _nftId,\n    IERC20 _inputToken,\n    uint256 _inputTokenAmount,\n    Order[] calldata _orders,\n    bool _reserved,\n    bool _fromReserve\n) private returns (uint256 feesAmount, IERC20 tokenSold) {\n    _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n    uint256 amountSpent;\n    for (uint256 i = 0; i < _orders.length; i++) {\n        amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n    }\n    feesAmount = _calculateFees(_msgSender(), amountSpent);\n    assert(amountSpent <= _inputTokenAmount feesAmount); // overspent\n\n    // If input is from the reserve, update the records\n    if (_fromReserve) {\n        _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n    }\n\n    _handleUnderSpending(_inputTokenAmount feesAmount, amountSpent, _inputToken);\n\n    tokenSold = _inputToken;\n}\n"
                ],
                "Type": "  NestedFactory.sol#_submitInOrders()  Wrong implementation cause users to be overcharged",
                "Description": "\nWhen executing orders, the actual amountSpent + feesAmount can be lower than _inputTokenAmount, the unspent amount should be returned to the user.\n\nHowever, in the current implementation, the unspent amount will be taken as part of the fee.\nNestedFactory.sol L285-L309(https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L285-L309)\n\nsolidity\nfunction _submitInOrders(\n    uint256 _nftId,\n    IERC20 _inputToken,\n    uint256 _inputTokenAmount,\n    Order[] calldata _orders,\n    bool _reserved,\n    bool _fromReserve\n) private returns (uint256 feesAmount, IERC20 tokenSold) {\n    _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n    uint256 amountSpent;\n    for (uint256 i = 0; i < _orders.length; i++) {\n        amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n    }\n    feesAmount = _calculateFees(_msgSender(), amountSpent);\n    assert(amountSpent <= _inputTokenAmount feesAmount); // overspent\n\n    // If input is from the reserve, update the records\n    if (_fromReserve) {\n        _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n    }\n\n    _handleUnderSpending(_inputTokenAmount feesAmount, amountSpent, _inputToken);\n\n    tokenSold = _inputToken;\n}\n\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction _submitInOrders(\n    uint256 _nftId,\n    IERC20 _inputToken,\n    uint256 _inputTokenAmount,\n    Order[] calldata _orders,\n    bool _reserved,\n    bool _fromReserve\n) private returns (uint256 feesAmount, IERC20 tokenSold) {\n    _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n    uint256 amountSpent;\n    for (uint256 i = 0; i < _orders.length; i++) {\n        amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n    }\n    feesAmount = _calculateFees(_msgSender(), amountSpent);\n    assert(amountSpent <= _inputTokenAmount feesAmount); // overspent\n\n    // If input is from the reserve, update the records\n    if (_fromReserve) {\n        _decreaseHoldingAmount(_nftId, address(_inputToken), amountSpent+feesAmount);\n    }\n\n    ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n    feeSplitter.sendFees(_token, feesAmount);\n\n    if (_inputTokenAmount  amountSpent + feesAmount) {\n        _inputToken.transfer(_fromReserve ? address(reserve) : _msgSender(), _inputTokenAmount amountSpent feesAmount);\n    }\n\n    tokenSold = _inputToken;\n}\n\n\nadrien-supizet (Nested) disputed and then confirmed(https://github.com/code-423n4/2021-11-nested-findings/issues/160#issuecomment-976658334):\n  ## Rationale\n We don't consider this an issue as this was done on purpose. We wanted to treat the positive slippage as regular fees.\n Most times, the dust of positive slippage will cost more to the user if they are transferred rather than passed along fees.\n\n We made it possible for us to retrieve overcharged amounts in case of mistakes to give them back to users.\n\n ## New behavior\n But for the sake of transparency, and in the spirit of DeFi, we have reviewed the business model of the protocol and decided to transfer back any amount that was unspent and which exceeds the 1% fixed fee.\n\n ## Resolution\n Selecting \"disputed\" for now but I'll let a judge review if this should be included in the report, and if the severity was correct, as we were able to give back tokens to users if they made a mistake calling the protocol.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/160#issuecomment-985607076):\n  If stated in the README or comments, the issue would be invalid. The sponsor can choose whichever behaviour suits their business model. When not stated in the README, any asset loss to users or protocol is a valid issue. User losses are expected to be a severity 3, but in this case, and given that those losses are inferior to the gas, the issue is downgraded to severity 2.\n\n In the future, please state in the code any asset losses that are accepted by the protocol.\n\n\n"
            },
            {
                "Name": "M-08",
                "Location": [
                    "submitOutOrders",
                    "transferInputTokens",
                    "sellTokensToWallet",
                    "submitInOrders",
                    "sellTokensToNft",
                    "addTokens"
                ],
                "Type": " Passing multiple ETH deposits in orders array will use the same  msg.value  many times",
                "Description": "\nContract holdings can be emptied as malicious user will do deposit/withdraw to extract value. This is possible because after transferInputTokens system uses contract balance for user's operations, assuming that equivalent value was transferred.\n\nmsg.value persist over calls, so passing 'Order[] calldata _orders' holding multiple ETH deposits will use the same msg.value in each of them, resulting in multiple deposits, that sums up to much bigger accounted value than actually deposited value, up to contract's ETH holdings.\n\ncreate / addTokens - submitInOrders - transferInputTokens\nNestedFactory.sol L103(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L103)\nNestedFactory.sol L119(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119)\n\nsellTokensToWallet - submitOutOrders - transferInputTokens\nNestedFactory.sol L172(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L172)\n\nsellTokensToNft - submitOutOrders - transferInputTokens\nNestedFactory.sol L152(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L152)\ntransferInputTokens uses msg.value:\n\nNestedFactory.sol L462(https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L462)\n",
                "Repair": "\nControlling ETH to be only once in orders will not help, as NestedFactory inherits from Multicall, which multicall(bytes[] calldata data) function allows same reusage of msg.value, which will persist over calls.\n\nSo, it is recommended to treat ETH exclusively, not allowing ETH operations to be batched at all.\n\nadrien-supizet (Nested) disagreed with severity(https://github.com/code-423n4/2021-11-nested-findings/issues/226#issuecomment-972785893):\n  Multicall is not currently used, and the funds exposed would be the NestedFactory's which should hold no funds.\n\n To avoid future bugs, we're going to remove the multicall library, but we don't think this is a high severity issue.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-11-nested-findings/issues/226#issuecomment-985376568):\n  Downgrading severity to 2 because the NestedFactory is not expected to hold funds, and therefore there is no risk of a loss. You can't deposit the same Ether twice in the WETH contract.\n\n Also keeping this as the main over #13.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NestedFactory::withdraw: Can't withdraw the last asset\");\n\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(\n            _nftId,\n            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]\n        );\n        reserve.withdraw(IERC20(holding.token), holding.amount);\n        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        _token.transfer(owner(), _token.balanceOf(address(this)));\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit buy orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _inputToken Token used to make the orders\n    /// @param _inputTokenAmount Amount of input tokens to use\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);\n        uint256 amountSpent;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);\n        }\n        feesAmount = _calculateFees(_msgSender(), amountSpent);\n        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);\n        }\n\n        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);\n\n        tokenSold = _inputToken;\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _outputToken Token received for every orders\n    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)\n    /// @param _orders Orders calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    /// @param _fromReserve True if the input tokens are from the reserve\n    /// @return feesAmount The total amount of fees\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        IERC20 _outputToken,\n        uint256[] memory _inputTokenAmounts,\n        Order[] calldata _orders,\n        bool _reserved,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IERC20 _inputToken = _transferInputTokens(\n                _nftId,\n                IERC20(_orders[i].token),\n                _inputTokenAmounts[i],\n                _fromReserve\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);\n            assert(amountSpent <= _inputTokenAmounts[i]);\n\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);\n            }\n\n            // Under spent input amount send to fee splitter\n            if (_inputTokenAmounts[i] - amountSpent > 0) {\n                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);\n            }\n        }\n\n        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;\n        feesAmount = _calculateFees(_msgSender(), amountBought);\n\n        if (_reserved) {\n            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _reserved True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _reserved\n    ) private returns (uint256 amountSpent) {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        require(success, \"NestedFactory::_submitOrder: Operator call failed\");\n\n        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n            data,\n            _inputToken,\n            _outputToken\n        );\n\n        if (_reserved) {\n            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order (commit/revert) but dont stop if\n    /// the call to the operator fail. It will send the input token back to the msg.sender.\n    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        address operator = requireAndGetAddress(_order.operator);\n        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);\n        if (success) {\n            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(\n                data,\n                _inputToken,\n                _outputToken\n            );\n            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token address\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        address _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));\n\n        // Send output to reserve\n        IERC20(_token).safeTransfer(address(reserve), _amount);\n\n        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));\n\n        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return tokenUsed Token transfered (in case of ETH)\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20 tokenUsed) {\n        if (_fromReserve) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));\n            require(holding.amount >= _inputTokenAmount, \"NestedFactory:_transferInputTokens: Insufficient amount\");\n\n            // Get input from reserve\n            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);\n        } else if (address(_inputToken) == ETH) {\n            require(msg.value == _inputTokenAmount, \"NestedFactory::_transferInputTokens: Insufficient amount in\");\n            weth.deposit{ value: msg.value }();\n            _inputToken = IERC20(address(weth));\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        tokenUsed = _inputToken;\n    }\n\n    /// @dev Send the under spent amount to the FeeSplitter without the royalties.\n    ///      The \"under spent\" amount is the positive difference between the amount supposed\n    ///      to be spent and the amount really spent.\n    /// @param _amountToSpent The amount supposed to be spent\n    /// @param _amountSpent The amount really spent\n    /// @param _token The amount-related token\n    function _handleUnderSpending(\n        uint256 _amountToSpent,\n        uint256 _amountSpent,\n        IERC20 _token\n    ) private {\n        if (_amountToSpent - _amountSpent > 0) {\n            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);\n        }\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);\n        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _calculateFees(_dest, _amount);\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Calculate the fees for a specific user and amount (1%)\n    /// @param _user The user address\n    /// @param _amount The amount\n    /// @return The fees amount\n    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {\n        return _amount / 100;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => address) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getAddress(bytes32 name) external view override returns (address) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view override returns (address) {\n        address _foundAddress = operators[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        for (uint256 i = 0; i < names.length; i++) {\n            if (operators[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(bytes32[] calldata names, address[] calldata destinations) external override onlyOwner {\n        require(names.length == destinations.length, \"OperatorResolver::importOperators: Input lengths must match\");\n\n        for (uint256 i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) external {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "OperatorResolver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "swapTokenForTokens()",
                    "create()",
                    "importOperators()",
                    "rebuildCache()"
                ],
                "Type": " Ensure on-chain that cache is synced",
                "Description": "\nCurrently, many core operations (like NestedFactory.create(), NestedFactory.swapTokenForTokens()) are dependent on the assumption that the cache is synced before these functions are executed however this may not necessarily be the case.\n\n1.  OperatorResolver.importOperators() is called to remove an operator.\n2.  A user calls NestedFactory.create() that uses the operator that was being removed / updated.\n3.  NestedFactory.rebuildCache() is called to rebuild cache.\n\nThis flow is not aware that the cache is not in synced.\n\n",
                "Repair": "Add a modifier to require that the cache is synced to all functions that interact with the operators.\n\n\n"
            }
        ]
    }
]