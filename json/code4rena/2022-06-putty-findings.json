[
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (finance/PaymentSplitter.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @title PaymentSplitter\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\n * that the Ether will be split in this way, since it is handled transparently by the contract.\n *\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\n * an amount proportional to the percentage of total shares they were assigned.\n *\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\n * function.\n *\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\n * to run tests before sending real value to this contract.\n */\ncontract PaymentSplitter is Context {\n    event PayeeAdded(address account, uint256 shares);\n    event PaymentReleased(address to, uint256 amount);\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\n    event PaymentReceived(address from, uint256 amount);\n\n    uint256 private _totalShares;\n    uint256 private _totalReleased;\n\n    mapping(address => uint256) private _shares;\n    mapping(address => uint256) private _released;\n    address[] private _payees;\n\n    mapping(IERC20 => uint256) private _erc20TotalReleased;\n    mapping(IERC20 => mapping(address => uint256)) private _erc20Released;\n\n    /**\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n     * the matching position in the `shares` array.\n     *\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n     * duplicates in `payees`.\n     */\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\n        require(payees.length == shares_.length, \"PaymentSplitter: payees and shares length mismatch\");\n        require(payees.length > 0, \"PaymentSplitter: no payees\");\n\n        for (uint256 i = 0; i < payees.length; i++) {\n            _addPayee(payees[i], shares_[i]);\n        }\n    }\n\n    /**\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\n     * reliability of the events, and not the actual splitting of Ether.\n     *\n     * To learn more about this see the Solidity documentation for\n     * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\n     * functions].\n     */\n    receive() external payable virtual {\n        emit PaymentReceived(_msgSender(), msg.value);\n    }\n\n    /**\n     * @dev Getter for the total shares held by payees.\n     */\n    function totalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @dev Getter for the total amount of Ether already released.\n     */\n    function totalReleased() public view returns (uint256) {\n        return _totalReleased;\n    }\n\n    /**\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\n     * contract.\n     */\n    function totalReleased(IERC20 token) public view returns (uint256) {\n        return _erc20TotalReleased[token];\n    }\n\n    /**\n     * @dev Getter for the amount of shares held by an account.\n     */\n    function shares(address account) public view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @dev Getter for the amount of Ether already released to a payee.\n     */\n    function released(address account) public view returns (uint256) {\n        return _released[account];\n    }\n\n    /**\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function released(IERC20 token, address account) public view returns (uint256) {\n        return _erc20Released[token][account];\n    }\n\n    /**\n     * @dev Getter for the address of the payee number `index`.\n     */\n    function payee(uint256 index) public view returns (address) {\n        return _payees[index];\n    }\n\n    /**\n     * @dev Getter for the amount of payee's releasable Ether.\n     */\n    function releasable(address account) public view returns (uint256) {\n        uint256 totalReceived = address(this).balance + totalReleased();\n        return _pendingPayment(account, totalReceived, released(account));\n    }\n\n    /**\n     * @dev Getter for the amount of payee's releasable `token` tokens. `token` should be the address of an\n     * IERC20 contract.\n     */\n    function releasable(IERC20 token, address account) public view returns (uint256) {\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\n        return _pendingPayment(account, totalReceived, released(token, account));\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n     * total shares and their previous withdrawals.\n     */\n    function release(address payable account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 payment = releasable(account);\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _released[account] += payment;\n        _totalReleased += payment;\n\n        Address.sendValue(account, payment);\n        emit PaymentReleased(account, payment);\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\n     * contract.\n     */\n    function release(IERC20 token, address account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 payment = releasable(token, account);\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _erc20Released[token][account] += payment;\n        _erc20TotalReleased[token] += payment;\n\n        SafeERC20.safeTransfer(token, account, payment);\n        emit ERC20PaymentReleased(token, account, payment);\n    }\n\n    /**\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\n     * already released amounts.\n     */\n    function _pendingPayment(\n        address account,\n        uint256 totalReceived,\n        uint256 alreadyReleased\n    ) private view returns (uint256) {\n        return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;\n    }\n\n    /**\n     * @dev Add a new payee to the contract.\n     * @param account The address of the payee to add.\n     * @param shares_ The number of shares owned by the payee.\n     */\n    function _addPayee(address account, uint256 shares_) private {\n        require(account != address(0), \"PaymentSplitter: account is the zero address\");\n        require(shares_ > 0, \"PaymentSplitter: shares are 0\");\n        require(_shares[account] == 0, \"PaymentSplitter: account already has shares\");\n\n        _payees.push(account);\n        _shares[account] = shares_;\n        _totalShares = _totalShares + shares_;\n        emit PayeeAdded(account, shares_);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.23;\n\nimport \"../src/test.sol\";\n\ncontract DemoTest is DSTest {\n    function test_this() public pure {\n        require(true);\n    }\n    function test_logs() public {\n        emit log(\"-- log(string)\");\n        emit log(\"a string\");\n\n        emit log(\"-- log_named_uint(string, uint)\");\n        log_named_uint(\"uint\", 512);\n\n        emit log(\"-- log_named_int(string, int)\");\n        log_named_int(\"int\", -512);\n\n        emit log(\"-- log_named_address(string, address)\");\n        log_named_address(\"address\", address(this));\n\n        emit log(\"-- log_named_bytes32(string, bytes32)\");\n        log_named_bytes32(\"bytes32\", \"a string\");\n\n        emit log(\"-- log_named_bytes(string, bytes)\");\n        log_named_bytes(\"bytes\", hex\"cafefe\");\n\n        emit log(\"-- log_named_string(string, string)\");\n        log_named_string(\"string\", \"a string\");\n\n        emit log(\"-- log_named_decimal_uint(string, uint, uint)\");\n        log_named_decimal_uint(\"decimal uint\", 1.0e18, 18);\n\n        emit log(\"-- log_named_decimal_int(string, int, uint)\");\n        log_named_decimal_int(\"decimal int\", -1.0e18, 18);\n    }\n    event log_old_named_uint(bytes32,uint);\n    function test_old_logs() public {\n        log_old_named_uint(\"key\", 500);\n        log_named_bytes32(\"bkey\", \"val\");\n    }\n    function test_trace() public view {\n        this.echo(\"string 1\", \"string 2\");\n    }\n    function test_multiline() public {\n        emit log(\"a multiline\\\\n\" \"string\");\n        emit log(\"a multiline \" \"string\");\n        log_bytes(\"a string\");\n        log_bytes(\"a multiline\\n\" \"string\");\n        log_bytes(\"a multiline\\\\n\" \"string\");\n        emit log(unicode\"\u038f\");\n        logs(hex\"0000\");\n        log_named_bytes(\"0x0000\", hex\"0000\");\n        logs(hex\"ff\");\n    }\n    function echo(string memory s1, string memory s2) public pure\n        returns (string memory, string memory)\n    {\n        return (s1, s2);\n    }\n\n    function prove_this(uint x) public {\n        log_named_uint(\"sym x\", x);\n        assertGt(x + 1, 0);\n    }\n\n    function test_logn() public {\n        assembly {\n            log0(0x01, 0x02)\n            log1(0x01, 0x02, 0x03)\n            log2(0x01, 0x02, 0x03, 0x04)\n            log3(0x01, 0x02, 0x03, 0x04, 0x05)\n        }\n    }\n\n    event MyEvent(uint, uint indexed, uint, uint indexed);\n    function test_events() public {\n        emit MyEvent(1, 2, 3, 4);\n    }\n\n    function test_asserts() public {\n        string memory err = \"this test has failed!\";\n        emit log(\"## assertTrue(bool)\\n\");\n        assertTrue(false);\n        emit log(\"\\n\");\n        assertTrue(false, err);\n\n        emit log(\"\\n## assertEq(address,address)\\n\");\n        assertEq(address(this), msg.sender);\n        emit log(\"\\n\");\n        assertEq(address(this), msg.sender, err);\n\n        emit log(\"\\n## assertEq32(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(bytes32,bytes32)\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\");\n        emit log(\"\\n\");\n        assertEq32(\"bytes 1\", \"bytes 2\", err);\n\n        emit log(\"\\n## assertEq(uint,uint)\\n\");\n        assertEq(uint(0), 1);\n        emit log(\"\\n\");\n        assertEq(uint(0), 1, err);\n\n        emit log(\"\\n## assertEq(int,int)\\n\");\n        assertEq(-1, -2);\n        emit log(\"\\n\");\n        assertEq(-1, -2, err);\n\n        emit log(\"\\n## assertEqDecimal(int,int,uint)\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertEqDecimal(uint,uint,uint)\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGt(uint,uint)\\n\");\n        assertGt(uint(0), 0);\n        emit log(\"\\n\");\n        assertGt(uint(0), 0, err);\n\n        emit log(\"\\n## assertGt(int,int)\\n\");\n        assertGt(-1, -1);\n        emit log(\"\\n\");\n        assertGt(-1, -1, err);\n\n        emit log(\"\\n## assertGtDecimal(int,int,uint)\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGtDecimal(uint,uint,uint)\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertGe(uint,uint)\\n\");\n        assertGe(uint(0), 1);\n        emit log(\"\\n\");\n        assertGe(uint(0), 1, err);\n\n        emit log(\"\\n## assertGe(int,int)\\n\");\n        assertGe(-1, 0);\n        emit log(\"\\n\");\n        assertGe(-1, 0, err);\n\n        emit log(\"\\n## assertGeDecimal(int,int,uint)\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(-2.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertGeDecimal(uint,uint,uint)\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLt(uint,uint)\\n\");\n        assertLt(uint(0), 0);\n        emit log(\"\\n\");\n        assertLt(uint(0), 0, err);\n\n        emit log(\"\\n## assertLt(int,int)\\n\");\n        assertLt(-1, -1);\n        emit log(\"\\n\");\n        assertLt(-1, -1, err);\n\n        emit log(\"\\n## assertLtDecimal(int,int,uint)\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLtDecimal(uint,uint,uint)\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertLe(uint,uint)\\n\");\n        assertLe(uint(1), 0);\n        emit log(\"\\n\");\n        assertLe(uint(1), 0, err);\n\n        emit log(\"\\n## assertLe(int,int)\\n\");\n        assertLe(0, -1);\n        emit log(\"\\n\");\n        assertLe(0, -1, err);\n\n        emit log(\"\\n## assertLeDecimal(int,int,uint)\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(-1.0e18, -1.1e18, 18, err);\n\n        emit log(\"\\n## assertLeDecimal(uint,uint,uint)\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18);\n        emit log(\"\\n\");\n        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);\n\n        emit log(\"\\n## assertEq(string,string)\\n\");\n        string memory s1 = \"string 1\";\n        string memory s2 = \"string 2\";\n        assertEq(s1, s2);\n        emit log(\"\\n\");\n        assertEq(s1, s2, err);\n\n        emit log(\"\\n## assertEq0(bytes,bytes)\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\");\n        log(\"\\n\");\n        assertEq0(hex\"abcdef01\", hex\"abcdef02\", err);\n    }\n}\n\ncontract DemoTestWithSetUp {\n    function setUp() public {\n    }\n    function test_pass() public pure {\n    }\n}\n\n\n",
        "CodeNames": [
            "PaymentSplitter.sol",
            "PuttyV2.sol",
            "demo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "feeAmount",
                    "isExercised",
                    "exercise()",
                    "setFee()",
                    "PuttyV",
                    "false",
                    "withdraw()"
                ],
                "Type": " Fee is being deducted when Put is expired and not when it is exercised.",
                "Description": "\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451\n\n\nFee is being deducted when Put is expired and not when it is exercised in PuttyV2.sol.\nComment section of the setFee() function mentions \"fee rate that is applied on exercise\" which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).\n\nBut, in function withdraw() at PuttyV2.solL#495-L503(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired.\n\nAlso, in function exercise() there is no fee deduction from the order.strike when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).\n\nThis unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\n\n\nif condition present at PuttyV2.solL#495(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if order.isCall is false and isExercised is false.\n\nfeeAmount becomes positive if fee  0 and it gets deducted from the order.strike which gets transferred to msg.sender at line number PuttyV2.solL#503(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).\n\n",
                "Repair": "\n1.  Update if condition at PuttyV2.sol#L498(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with (fee  0 && order.isCall && isExercised)\n\n2.  Add feeAmount calculation and deduction after put is exercised and strike is transferred at PuttyV2.sol#L451(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:\n\nsolidity\nuint256 feeAmount = 0;\nif (fee  0) {\n    feeAmount = (order.strike * fee) / 1000;\n    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n}\nERC20(order.baseAsset).safeTransfer(msg.sender, order.strike feeAmount);\n\n\noutdoteth (Putty Finance) confirmed and commented(https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1178999683):\n  Report: Fees are only applied on puts if they are expired.\n\nHickupHH3 (judge) increased severity to High and commented(https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1179899567):\n  Due to incorrect logic, there are 2 consequences of separate severities:\n \n 1) Expired put option being charged the admin fee. As @berndartmueller mentioned in #380(https://github.com/code-423n4/2022-06-putty-findings/issues/380), the fee should be charged on the premium (actually this is another issue, see #373(https://github.com/code-423n4/2022-06-putty-findings/issues/373)). Since it is possible for the fee amount to be greater than expected, I consider this to be a loss of assets and therefore given a high severity rating.\n \n 2) Put option not being charged fee upon exercising it. This can be considered to the \"protocol leaked value\" and thus be given a medium severity rating.\n \n Issues that mention (1) or both (1) and (2) will be given a high severity rating, those that mention only (2) will be given a medium.\n\noutdoteth (Putty Finance) resolved(https://github.com/code-423n4/2022-06-putty-findings/issues/269#issuecomment-1185405136):\n  PR with fix: https://github.com/outdoteth/putty-v2/pull/4.\n\nhyh (warden) reviewed mitigation:\n  Fixed by changing the fee base to be order.premium PR#4(https://github.com/outdoteth/putty-v2/pull/4), which is now paid uniformly for all option types on order filling. Utilizing order.strike as the fee base was the root cause for M-04(https://github.com/code-423n4/2022-06-putty-findings/issues/285), M-06(https://github.com/code-423n4/2022-06-putty-findings/issues/296), M-11(https://github.com/code-423n4/2022-06-putty-findings/issues/422), M-15(https://github.com/code-423n4/2022-06-putty-findings/issues/373), so the change to order.premium was a shared mitigation for all of them.\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../munged/governance/Governor.sol\";\nimport \"../munged/governance/extensions/GovernorCountingSimple.sol\";\nimport \"../munged/governance/extensions/GovernorVotes.sol\";\nimport \"../munged/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"../munged/governance/extensions/GovernorTimelockControl.sol\";\nimport \"../munged/governance/extensions/GovernorProposalThreshold.sol\";\n\n/* \nWizard options:\nProposalThreshhold = 10\nERC20Votes\nTimelockController\n*/\n\ncontract WizardControlFirstPriority is Governor, GovernorProposalThreshold, GovernorCountingSimple, GovernorVotes, GovernorVotesQuorumFraction, GovernorTimelockControl {\n    constructor(ERC20Votes _token, TimelockController _timelock, string memory name, uint256 quorumFraction)\n        Governor(name)\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(quorumFraction)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    //HARNESS\n\n    function isExecuted(uint256 proposalId) public view returns (bool) {\n        return _proposals[proposalId].executed;\n    }\n    \n    function isCanceled(uint256 proposalId) public view returns (bool) {\n        return _proposals[proposalId].canceled;\n    }\n\n    uint256 _votingDelay;\n\n    uint256 _votingPeriod;\n\n    uint256 _proposalThreshold;\n\n    mapping(uint256 => uint256) public ghost_sum_vote_power_by_id;\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal override virtual returns (uint256) {\n        \n        uint256 deltaWeight = super._castVote(proposalId, account, support, reason);  //HARNESS\n        ghost_sum_vote_power_by_id[proposalId] += deltaWeight;\n\n        return deltaWeight;        \n    }\n    \n    function snapshot(uint256 proposalId) public view returns (uint64) {\n        return _proposals[proposalId].voteStart._deadline;\n    }\n\n\n    function getExecutor() public view returns (address){\n        return _executor();\n    }\n\n    // original code, harnessed\n\n    function votingDelay() public view override returns (uint256) {     // HARNESS: pure -> view\n        return _votingDelay;                                            // HARNESS: parametric\n    }\n\n    function votingPeriod() public view override returns (uint256) {    // HARNESS: pure -> view\n        return _votingPeriod;                                           // HARNESS: parametric\n    }\n\n    function proposalThreshold() public view override returns (uint256) {   // HARNESS: pure -> view\n        return _proposalThreshold;                                          // HARNESS: parametric\n    }\n\n    // original code, not harnessed\n    // The following functions are overrides required by Solidity.\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function getVotes(address account, uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotes)\n        returns (uint256)\n    {\n        return super.getVotes(account, blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)\n        public\n        override(Governor, GovernorProposalThreshold, IGovernor)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n    {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n    // Set block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Set block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Set environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Read environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Read environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Record all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expect a call to an address with the specified calldata.\n    // Calldata can either be strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expect a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Set block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n}\n\n\n",
        "CodeNames": [
            "WizardControlFirstPriority.sol",
            "PuttyV2.sol",
            "Vm.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[(0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n",
                    "//solidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n"
                ],
                "Type": "  acceptCounterOffer()  May Result In Both Orders Being Filled",
                "Description": "\nWhen a user is attempting to accept a counter offer they call the function acceptCounterOffer()(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the originalOrder to be cancelled and the new order to fill. It is possible for an attacker (or any other user who happens to call fillOrder() at the same time) to fill the originalOrder before acceptCounterOffer() cancels it.\n\nThe impact is that both originalOrder and order are filled. The msg.sender of acceptCounterOffer() is twice as leveraged as they intended to be if the required token transfers succeed.\n\n\nacceptCounterOffer()(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls cancel() on the original order, however it will not revert if the order has already been filled.\n\nsolidity\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[(0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n\ncancel()(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future fillOrder() transactions from succeeding.\n\nsolidity\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n\n        bytes32 orderHash = hashOrder(order);\n\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n\nTherefore any user may front-run the acceptCounterOffer() transaction with a fillOrder() transaction that fills the original order. As a result the user ends up filling both order and originalOrder. Then acceptCounterOffer() cancels the originalOrder which is essentially a no-op since it's been filled and continues to fill the new order resulting in both orders being filled.\n\n",
                "Repair": "\nConsider having cancel() revert if an order has already been filled. This can be done by adding the following line require(_ownerOf[uint256(orderHash)] == 0).\n\noutdoteth (Putty Finance) confirmed and commented(https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1179004913):\n  Report: It\u2019s possible to fill an order twice by accepting a counter offer for an already filled order.\n\noutdoteth (Putty Finance) resolved(https://github.com/code-423n4/2022-06-putty-findings/issues/44#issuecomment-1185411950):\n  PR with fix: https://github.com/outdoteth/putty-v2/pull/2.\n\nhyh (warden) reviewed mitigation:\n  Fixed by requiring that order can't be in the filled state on cancel. This fully adheres to the original logic, but wasn't controlled for before.\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n",
        "CodeNames": [
            "PuttyV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n// case 1\n  // PuttyV2.sol: _transferFloorsIn called by exercise\n  // The floorTokens and floorTokenIds do not match the lenghts\n  // floorTokens.length is not zero, while floorTokenIds.length is zero\n\n       ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n",
                    "//solidity\n// maker trying to withdraw\n// PuttyV2.sol: withdraw\n\n  _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n"
                ],
                "Type": " Create a short call order with non empty floor makes the option impossible to exercise and withdraw",
                "Description": "\nHIGH assets can be lost\n\nIf a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s.\n\nThis bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the Create a short put order with zero tokenAmount makes the option impossible to exercise, therefore reported separately.\n\n\n*   proof of concept(https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202)\n*   reference case(https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)\n\nThe proof of concept shows a scenario where babe makes an short call order with non empty floorTokens array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls exercise. There are two cases.\n\n*   case 1: he calls exercise with empty floorAssetTokenIds array\n*   case 2: he calls exercise with non-empty floorAssetTokenIds array with matching length to the orders.floorTokens\n\nIn the case1, the input floorAssetTokenIds were checked to be empty for put orders(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually _transferFloorsIn was called and he gets Index out of bounds error, because floorTokens is not empty which does not match with empty floorAssetTokenIds(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629).\n\nsolidity\n// case 1\n  // PuttyV2.sol: _transferFloorsIn called by exercise\n  // The floorTokens and floorTokenIds do not match the lenghts\n  // floorTokens.length is not zero, while floorTokenIds.length is zero\n\n       ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n\n\nIn the case2, the input floorAssetTokenIds were checked to be empty for put orders(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts.\n\n    // case2\n    // PuttyV2.sol: exercise\n    // non empty floorAssetTokenIds array is passed for put option, it will revert\n\n            !order.isCall\n                ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n                : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\nAfter the option is expired, the maker babe is trying to withdraw but fails due to the same issue with the case1(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516).\n\nsolidity\n// maker trying to withdraw\n// PuttyV2.sol: withdraw\n\n  _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n\nNote on the PoC:\n\n*   The test for case1 is commented out(https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with Index out of bounds.\n*   For the same reason the withdraw(https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out\n*   The reference case just shows that it works as intended when the order does not contain non-empty floorTokens.\n\n\nFoundry.\n\n",
                "Repair": "\nIt happens because the fillOrder does not ensure(https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the order.floorTokens to be empty when the order is short call.\n\nSTYJ (warden) commented(https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1174764713):\n  Note that it is possible to cause loss of funds for others through this.\n \n Assume that maker (A) creates a long call and taker (B) fills it, transferring floor tokens (XYZ) into putty. \n \n If maker (C) creates a short call with floorTokens (XYZ), taker (D) is able to fill and exercise his long call since XYZ already resides on Putty. This will however invalidate the options pair that was created between A and B since A cannot exercise and B cannot withdraw.\n\noutdoteth (Putty Finance) commented(https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995529):\n  Agree that this should be marked as high severity given the exploit scenario provided by @STYJ above.\n\noutdoteth (Putty Finance) confirmed and commented(https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1178995764):\n  Report: Short call with floorTokens will result in a revert when exercising.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1181790939):\n  Agreed, all wardens gave the same scenario that leads to a direct loss of NFTs and premium, but @STYJ's exploit scenario raises the gravity of the situation since users can be griefed.\n\noutdoteth (Putty Finance) resolved(https://github.com/code-423n4/2022-06-putty-findings/issues/369#issuecomment-1185411060):\n  PR with fix: https://github.com/outdoteth/putty-v2/pull/1.\n\nhyh (warden) reviewed mitigation:\n  Fixed by prohibiting non-empty order.floorTokens for short calls.\n \n  Other option types do need floorTokens: long calls' taker provides floor tokens on filling, while long put owner brings in the floor tokens on exercise, taking the strike. Short put owner can thereafter retrieve the tokens on withdraw.\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n",
                    "//solidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        ...\n\n        if (order.isCall) {\n            // -exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value  0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        }\n",
                    "//solidity\n            if (weth == order.baseAsset && msg.value  0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n",
                    "//solidity\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n",
                    "//solidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n",
                    "//solidity\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n"
                ],
                "Type": " Zero strike call options can be systemically used to steal premium from the taker",
                "Description": "\nSome non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.\n\nMarking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.\n\n\nCurrently system do not check the strike value, unconditionally attempting to transfer it:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437\n\nsolidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n\nAs a part of call exercise logic:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443\n\nsolidity\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        ...\n\n        if (order.isCall) {\n            // -exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value  0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        }\n\n\nSome tokens do not allow zero amount transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nThis way for such a token and zero strike option the maker can create short call order, receive the premium:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339\n\nsolidity\n            if (weth == order.baseAsset && msg.value  0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n\n\nTransfer in the assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371\n\nsolidity\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n\nAnd wait for expiration, knowing that all attempts to exercise will revert:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437\n\nsolidity\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n\nThen recover her assets:\n\n<https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519\n\nsolidity\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n\n\n",
                "Repair": "\nConsider checking that strike is positive before transfer in all the cases, for example:\n\nsolidity\n            } else {\n+               if (order.strike  0) {\n                    ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n+               }\n            }\n\n\nAlex the Entreprenerd (warden) commented(https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1174522101):\n  Seems contingent on token implementation, however certain ERC20 do revert on 0 transfer and there would be no way to exercise the contract in that case.\n\noutdoteth (Putty Finance) confirmed and commented(https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1178989277):\n  Report: Cannot exercise call contract if strike is 0 and baseAsset reverts on 0 transfers.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1182684476):\n  There is a pre-requisite for the ERC20 token to revert on 0 amount transfers. However, the warden raised a key point: zero strike calls are common, and their premium is substantial. The information asymmetry of the ERC20 token between the maker and taker is another aggravating factor.\n\noutdoteth (Putty Finance) resolved(https://github.com/code-423n4/2022-06-putty-findings/issues/418#issuecomment-1185410362):\n  PR with fix: https://github.com/outdoteth/putty-v2/pull/3.\n\nhyh (warden) reviewed mitigation:\n  Fixed by conditioning call's logic on order.strike  0. There is no use case for zero strike puts and so this case remains unconditioned, i.e. still always require successful order.strike transfer. \n\n*\n\n \n\n"
            }
        ]
    }
]