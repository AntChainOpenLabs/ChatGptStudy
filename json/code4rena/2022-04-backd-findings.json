[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/tokenomics/IRewardsGauge.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../interfaces/IERC20Full.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./Controller.sol\";\nimport \"./pool/LiquidityPool.sol\";\nimport \"./access/Authorization.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @notice This contract handles staked tokens from Backd pools\n * However, not that this is NOT an ERC-20 compliant contract and these\n * tokens should never be integrated with any protocol assuming ERC-20 compliant\n * tokens\n * @dev When paused, allows only withdraw/unstake\n */\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = _controller;\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        address spender = msg.sender;\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][spender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        uint256 allowanceNew = startingAllowance - amount;\n        uint256 srcTokensNew = srcTokens - amount;\n        uint256 dstTokensNew = balances[dst] + amount;\n\n        /* Update token balances */\n        balances[src] = srcTokensNew;\n        balances[dst] = dstTokensNew;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][spender] = allowanceNew;\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        address src = msg.sender;\n        _allowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] -= amount;\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = controller.addressProvider().allActions();\n        uint256 total;\n        for (uint256 i = 0; i < actions.length; i++) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../interfaces/ILpToken.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../libraries/Errors.sol\";\n\ncontract LpToken is ILpToken, ERC20Upgradeable {\n    using ScaledMath for uint256;\n\n    uint8 private _decimals;\n\n    address public override minter;\n\n    /**\n     * @notice Make a function only callable by the minter contract.\n     * @dev Fails if msg.sender is not the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor() ERC20Upgradeable() {}\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address _minter\n    ) external override initializer returns (bool) {\n        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        __ERC20_init(name_, symbol_);\n        _decimals = decimals_;\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Mint tokens.\n     * @param account Account from which tokens should be burned.\n     * @param amount Amount of tokens to mint.\n     */\n    function mint(address account, uint256 amount) external override onlyMinter {\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice Burns tokens of msg.sender.\n     * @param amount Amount of tokens to burn.\n     */\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn tokens.\n     * @param owner Account from which tokens should be burned.\n     * @param burnAmount Amount of tokens to burn.\n     * @return Aamount of tokens burned.\n     */\n    function burn(address owner, uint256 burnAmount)\n        external\n        override\n        onlyMinter\n        returns (uint256)\n    {\n        _burn(owner, burnAmount);\n        return burnAmount;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev We notify that LP tokens have been transfered\n     * this is currently used to keep track of the withdrawal fees\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../../interfaces/tokenomics/IRewardsGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract LpGauge is ILpGauge, IRewardsGauge, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n\n    IController public immutable controller;\n    IStakerVault public immutable stakerVault;\n    IInflationManager public immutable inflationManager;\n\n    uint256 public poolStakedIntegral;\n    uint256 public poolLastUpdate;\n    mapping(address => uint256) public perUserStakedIntegral;\n    mapping(address => uint256) public perUserShare;\n\n    constructor(IController _controller, address _stakerVault)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = IController(_controller);\n        stakerVault = IStakerVault(_stakerVault);\n        IInflationManager _inflationManager = IController(_controller).inflationManager();\n        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        inflationManager = _inflationManager;\n    }\n\n    /**\n     * @notice Checkpoint function for the pool statistics.\n     * @return `true` if successful.\n     */\n    function poolCheckpoint() external override returns (bool) {\n        return _poolCheckpoint();\n    }\n\n    /**\n     * @notice Calculates the token rewards a user should receive and mints these.\n     * @param beneficiary Address to claim rewards for.\n     * @return `true` if success.\n     */\n    function claimRewards(address beneficiary) external override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        _mintRewards(beneficiary, amount);\n        return amount;\n    }\n\n    function claimableRewards(address beneficiary) external view override returns (uint256) {\n        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();\n        uint256 poolStakedIntegral_ = poolStakedIntegral;\n        if (poolTotalStaked > 0) {\n            poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) *\n                (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);\n        }\n\n        return\n            perUserShare[beneficiary] +\n            stakerVault.stakedAndActionLockedBalanceOf(beneficiary).scaledMul(\n                poolStakedIntegral_ - perUserStakedIntegral[beneficiary]\n            );\n    }\n\n    /**\n     * @notice Checkpoint function for the statistics for a particular user.\n     * @param user Address of the user to checkpoint.\n     * @return `true` if successful.\n     */\n    function userCheckpoint(address user) public override returns (bool) {\n        _poolCheckpoint();\n\n        // No checkpoint for the actions and strategies, since this does not accumulate tokens\n        if (\n            IController(controller).addressProvider().isAction(user) || stakerVault.isStrategy(user)\n        ) {\n            return false;\n        }\n        uint256 poolStakedIntegral_ = poolStakedIntegral;\n        perUserShare[user] += (\n            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(\n                (poolStakedIntegral_ - perUserStakedIntegral[user])\n            )\n        );\n\n        perUserStakedIntegral[user] = poolStakedIntegral_;\n\n        return true;\n    }\n\n    function _mintRewards(address beneficiary, uint256 amount) internal {\n        inflationManager.mintRewards(beneficiary, amount);\n    }\n\n    function _poolCheckpoint() internal returns (bool) {\n        uint256 currentRate = inflationManager.getLpRateForStakerVault(address(stakerVault));\n        // Update the integral of total token supply for the pool\n        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();\n        if (poolTotalStaked > 0) {\n            poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv(\n                poolTotalStaked\n            );\n        }\n        poolLastUpdate = block.timestamp;\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./access/Authorization.sol\";\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/vendor/IRewardStaking.sol\";\nimport \"../interfaces/vendor/ICrvDepositor.sol\";\nimport \"../interfaces/vendor/IDelegation.sol\";\nimport \"../interfaces/vendor/IvlCvxExtraRewardDistribution.sol\";\nimport \"../interfaces/vendor/ICurveSwap.sol\";\nimport \"../interfaces/vendor/ICvxLocker.sol\";\nimport \"../interfaces/ICvxCrvRewardsLocker.sol\";\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\ncontract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    using SafeERC20 for IERC20;\n\n    // ERC20 tokens\n    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    address public constant CVX_CRV_CRV_CURVE_POOL =\n        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool\n    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV\n    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards\n    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker\n    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =\n        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);\n\n    uint256 public spendRatio;\n    bool public prepareWithdrawal;\n    address public treasury;\n\n    int128 private constant _CRV_INDEX = 0;\n    int128 private constant _CVX_CRV_INDEX = 1;\n\n    event NewSpendRatio(uint256 newSpendRatio);\n    event NewTreasury(address newTreasury);\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        // Approve for locking CRV for cvxCRV\n        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);\n\n        // Approve for staking cvxCRV\n        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);\n\n        // Approve for cvxCRV/CRV Curve Pool Swaps\n        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);\n\n        // Approve CVX Locker\n        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);\n\n        treasury = _addressProvider.getTreasury();\n    }\n\n    function lockCvx() external override {\n        _lockCvx();\n    }\n\n    function lockCrv() external override {\n        _lockCrv();\n    }\n\n    /**\n     * @notice Set spend ratio for CVX locking.\n     * @dev Spend ratio is the amount of CVX that should be donated to\n     * the Convex treasury to boost vote power. This needs to be enabled\n     * by Convex.\n     * @param _spendRatio New spend ratio to be used.\n     */\n    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {\n        require(\n            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),\n            Error.EXCEEDS_MAX_BOOST\n        );\n        spendRatio = _spendRatio;\n        emit NewSpendRatio(_spendRatio);\n        return true;\n    }\n\n    /**\n     * @notice Claim rewards from Convex.\n     * @dev Rewards to claim are for staked cvxCRV and locked CVX.\n     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).\n     */\n    function claimRewards(bool lockAndStake) external override returns (bool) {\n        ICvxLocker(CVX_LOCKER).getReward(address(this), false);\n\n        IRewardStaking(CVX_CRV_STAKING).getReward();\n\n        if (lockAndStake) {\n            lockRewards();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.\n     */\n    function stakeCvxCrv() external override returns (bool) {\n        return _stakeCvxCrv();\n    }\n\n    /**\n     * @notice Prepares a withdrawal of funds.\n     * @dev If this is set then no idle funds can get locked or staked.\n     */\n    function setWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = true;\n    }\n\n    /**\n     * @notice Resets prepared withdrawal of funds.\n     */\n    function resetWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = false;\n    }\n\n    /**\n     * @notice Processes exipred locks.\n     */\n    function processExpiredLocks(bool relock) external override returns (bool) {\n        if (relock) {\n            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);\n        }\n\n        if (relock) {\n            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);\n        } else {\n            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Set treasury to receive withdrawn funds.\n     */\n    function setTreasury(address _treasury) external onlyGovernance returns (bool) {\n        treasury = _treasury;\n        emit NewTreasury(treasury);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw full amount of a token to the treasury.\n     * @param token Token to withdraw entire balance of.\n     */\n    function withdraw(address token) external onlyGovernance returns (bool) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(treasury, balance);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cvxCRV to treasury.\n     * @dev Unstakes cvxCRV if it is staked.\n     */\n    function withdrawCvxCrv(uint256 amount) external onlyGovernance {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));\n        if (cvxcrvBal > 0) {\n            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);\n        }\n    }\n\n    function unstakeCvxCrv() external onlyGovernance {\n        unstakeCvxCrv(false);\n    }\n\n    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {\n        _unstakeCvxCrv(amount, withdrawal);\n    }\n\n    /**\n     * @notice Set delegate to receive vote weight.\n     */\n    function setDelegate(address delegateContract, address delegate) external onlyGovernance {\n        IDelegation(delegateContract).setDelegate(\"cvx.eth\", delegate);\n    }\n\n    /**\n     * @notice Clears a delegate for the msg.sender and a specific id.\n     */\n    function clearDelegate(address delegateContract) external onlyGovernance {\n        IDelegation(delegateContract).clearDelegate(\"cvx.eth\");\n    }\n\n    function forfeitRewards(address token, uint256 index) external onlyGovernance {\n        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(\n            token,\n            index\n        );\n    }\n\n    /**\n     * @notice Lock CRV and CVX tokens.\n     * @dev CRV get locked for cvxCRV and staked on Convex.\n     */\n    function lockRewards() public returns (bool) {\n        _lockCrv();\n        _lockCvx();\n        return true;\n    }\n\n    /**\n     * @notice Withdraw an amount of a token to the treasury.\n     * @param token Token to withdraw.\n     * @param amount Amount of token to withdraw.\n     */\n    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {\n        IERC20(token).safeTransfer(treasury, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake cvxCRV from Convex.\n     */\n    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {\n        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));\n        _unstakeCvxCrv(staked, withdrawal);\n    }\n\n    function _lockCrv() internal {\n        if (prepareWithdrawal) return;\n\n        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));\n        if (currentBalance != 0) {\n            // Checks if we can get a better rate on Curve Pool\n            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(\n                _CRV_INDEX,\n                _CVX_CRV_INDEX,\n                currentBalance\n            );\n            if (amountOut > currentBalance) {\n                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(\n                    _CRV_INDEX,\n                    _CVX_CRV_INDEX,\n                    currentBalance,\n                    0\n                );\n            } else {\n                // Swap CRV for cxvCRV and stake\n                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));\n            }\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n            return;\n        }\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n    }\n\n    function _lockCvx() internal {\n        // Locks CVX for vlCVX\n        if (prepareWithdrawal) return;\n        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));\n        if (currentBalance == 0) return;\n        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);\n    }\n\n    function _stakeCvxCrv() internal returns (bool) {\n        if (prepareWithdrawal) return false;\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;\n        IRewardStaking(CVX_CRV_STAKING).stakeAll();\n        return true;\n    }\n\n    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        if (withdrawal) {\n            IERC20(CVX_CRV).safeTransfer(treasury, amount);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../interfaces/tokenomics/IMigrationContract.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract BkdLocker is IBkdLocker, Authorization, Preparable {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n\n    bytes32 internal constant _START_BOOST = \"startBoost\";\n    bytes32 internal constant _MAX_BOOST = \"maxBoost\";\n    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";\n    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\";\n\n    // User-specific data\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public boostFactors;\n    mapping(address => uint256) public lastUpdated;\n    mapping(address => WithdrawStash[]) public stashedGovTokens;\n    mapping(address => uint256) public totalStashed;\n\n    // Global data\n    uint256 public totalLocked;\n    uint256 public totalLockedBoosted;\n    uint256 public lastMigrationEvent;\n    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;\n\n    // Reward token data\n    mapping(address => RewardTokenData) public rewardTokenData;\n    address public rewardToken;\n    IERC20 public immutable govToken;\n\n    constructor(\n        address _rewardToken,\n        address _govToken,\n        IRoleManager roleManager\n    ) Authorization(roleManager) {\n        rewardToken = _rewardToken;\n        govToken = IBkdToken(_govToken);\n    }\n\n    function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n\n    /**\n     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.\n     * @dev Previously used rewardTokens can be set again here.\n     */\n    function migrate(address newRewardToken) external override onlyGovernance {\n        _replacedRewardTokens.remove(newRewardToken);\n        _replacedRewardTokens.set(rewardToken, block.timestamp);\n        lastMigrationEvent = block.timestamp;\n        rewardToken = newRewardToken;\n    }\n\n    /**\n     * @notice Lock gov. tokens.\n     * @dev The amount needs to be approved in advance.\n     */\n    function lock(uint256 amount) external override {\n        return lockFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.\n     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called\n     * @param amount Amount of rewardToken to deposit.\n     */\n    function depositFees(uint256 amount) external {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n\n    function claimFees() external override {\n        claimFees(rewardToken);\n    }\n\n    /**\n     * @notice Checkpoint function to update user data, in particular the boost factor.\n     */\n    function userCheckpoint(address user) external override {\n        _userCheckpoint(user, 0, balances[user]);\n    }\n\n    /**\n     * @notice Prepare unlocking of locked gov. tokens.\n     * @dev A delay is enforced and unlocking can only be executed after that.\n     * @param amount Amount of gov. tokens to prepare for unlocking.\n     */\n    function prepareUnlock(uint256 amount) external override {\n        require(\n            totalStashed[msg.sender] + amount <= balances[msg.sender],\n            \"Amount exceeds locked balance\"\n        );\n        totalStashed[msg.sender] += amount;\n        stashedGovTokens[msg.sender].push(\n            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)\n        );\n        emit WithdrawPrepared(msg.sender, amount);\n    }\n\n    /**\n     * @notice Execute all prepared gov. token withdrawals.\n     */\n    function executeUnlocks() external override {\n        uint256 totalAvailableToWithdraw = 0;\n        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];\n        uint256 length = stashedWithdraws.length;\n        require(length > 0, \"No entries\");\n        uint256 i = length;\n        while (i > 0) {\n            i = i - 1;\n            if (stashedWithdraws[i].releaseTime <= block.timestamp) {\n                totalAvailableToWithdraw += stashedWithdraws[i].amount;\n\n                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];\n\n                stashedWithdraws.pop();\n            }\n        }\n        totalStashed[msg.sender] -= totalAvailableToWithdraw;\n        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;\n        _userCheckpoint(msg.sender, 0, newTotal);\n        totalLocked -= totalAvailableToWithdraw;\n        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);\n        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);\n    }\n\n    function getUserShare(address user) external view override returns (uint256) {\n        return getUserShare(user, rewardToken);\n    }\n\n    /**\n     * @notice Get the boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the boosted balance for.\n     * @return boosted balance for user.\n     */\n    function boostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the vote weight for a user.\n     * @dev This does not invlude the gov. tokens queued for withdrawal.\n     * @param user Address to get the vote weight for.\n     * @return vote weight for user.\n     */\n    function balanceOf(address user) external view override returns (uint256) {\n        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);\n    }\n\n    /**\n     * @notice Get the share of the total boosted locked balance for a user.\n     * @dev This includes the gov. tokens queued for withdrawal.\n     * @param user Address to get the share of the total boosted balance for.\n     * @return share of the total boosted balance for user.\n     */\n    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {\n        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);\n    }\n\n    function getStashedGovTokens(address user)\n        external\n        view\n        override\n        returns (WithdrawStash[] memory)\n    {\n        return stashedGovTokens[user];\n    }\n\n    function claimableFees(address user) external view override returns (uint256) {\n        return claimableFees(user, rewardToken);\n    }\n\n    /**\n     * @notice Claim fees accumulated in the Locker.\n     */\n    function claimFees(address _rewardToken) public override {\n        require(\n            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),\n            Error.INVALID_ARGUMENT\n        );\n        _userCheckpoint(msg.sender, 0, balances[msg.sender]);\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n        uint256 claimable = curRewardTokenData.userShares[msg.sender];\n        curRewardTokenData.userShares[msg.sender] = 0;\n        curRewardTokenData.feeBalance -= claimable;\n        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);\n        emit RewardsClaimed(msg.sender, _rewardToken, claimable);\n    }\n\n    /**\n     * @notice Lock gov. tokens on behalf of another user.\n     * @dev The amount needs to be approved in advance.\n     * @param user Address of user to lock on behalf of.\n     * @param amount Amount of gov. tokens to lock.\n     */\n    function lockFor(address user, uint256 amount) public override {\n        govToken.safeTransferFrom(msg.sender, address(this), amount);\n        _userCheckpoint(user, amount, balances[user] + amount);\n        totalLocked += amount;\n        emit Locked(user, amount);\n    }\n\n    function getUserShare(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return rewardTokenData[_rewardToken].userShares[user];\n    }\n\n    function claimableFees(address user, address _rewardToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 currentShare;\n        uint256 userBalance = balances[user];\n        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];\n\n        // Compute the share earned by the user since he last updated\n        if (userBalance > 0) {\n            currentShare += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n        return curRewardTokenData.userShares[user] + currentShare;\n    }\n\n    function computeNewBoost(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) public view override returns (uint256) {\n        uint256 newBoost;\n        uint256 balance = balances[user];\n        uint256 startBoost = currentUInts256[_START_BOOST];\n        if (balance == 0 || newTotal == 0) {\n            newBoost = startBoost;\n        } else {\n            uint256 maxBoost = currentUInts256[_MAX_BOOST];\n            newBoost = boostFactors[user];\n            newBoost += (block.timestamp - lastUpdated[user])\n                .scaledDiv(currentUInts256[_INCREASE_PERIOD])\n                .scaledMul(maxBoost - startBoost);\n            if (newBoost > maxBoost) {\n                newBoost = maxBoost;\n            }\n            if (newTotal <= balance) {\n                return newBoost;\n            }\n            newBoost =\n                newBoost.scaledMul(balance.scaledDiv(newTotal)) +\n                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));\n        }\n        return newBoost;\n    }\n\n    function _userCheckpoint(\n        address user,\n        uint256 amountAdded,\n        uint256 newTotal\n    ) internal {\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        // Compute the share earned by the user since he last updated\n        uint256 userBalance = balances[user];\n        if (userBalance > 0) {\n            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -\n                curRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                    userBalance.scaledMul(boostFactors[user])\n                );\n        }\n\n        // Update values for previous rewardTokens\n        if (lastUpdated[user] < lastMigrationEvent && userBalance > 0) {\n            uint256 length = _replacedRewardTokens.length();\n            for (uint256 i = 0; i < length; i++) {\n                (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);\n                if (lastUpdated[user] < replacedAt) {\n                    RewardTokenData storage prevRewardTokenData = rewardTokenData[token];\n                    prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -\n                        prevRewardTokenData.userFeeIntegrals[user]).scaledMul(\n                            userBalance.scaledMul(boostFactors[user])\n                        );\n                    prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData.feeIntegral;\n                }\n            }\n        }\n\n        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);\n        totalLockedBoosted =\n            totalLockedBoosted +\n            newTotal.scaledMul(newBoost) -\n            balances[user].scaledMul(boostFactors[user]);\n\n        // Update user values\n        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;\n        lastUpdated[user] = block.timestamp;\n        boostFactors[user] = newBoost;\n        balances[user] = newTotal;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\n\nimport \"../../interfaces/vendor/IBooster.sol\";\nimport \"../../interfaces/vendor/IRewardStaking.sol\";\nimport \"../../interfaces/tokenomics/IAmmConvexGauge.sol\";\nimport \"./AmmGauge.sol\";\nimport \"../utils/CvxMintAmount.sol\";\n\ncontract AmmConvexGauge is IAmmConvexGauge, AmmGauge, CvxMintAmount {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    address public immutable cvx;\n    address public immutable crv;\n    address public immutable booster;\n    address public inflationRecipient;\n\n    uint256 public immutable bkdPoolPID; // bkd pool id on Convex\n    IRewardStaking public immutable crvRewardsContract; // Staking contract for bkd convex deposit token\n\n    // Additional integrals etc. for crv and cvx rewards\n    uint256 public crvStakedIntegral;\n    uint256 public cvxStakedIntegral;\n    mapping(address => uint256) public perUserCrvStakedIntegral;\n    mapping(address => uint256) public perUserCvxStakedIntegral;\n    mapping(address => uint256) public perUserShareCrv;\n    mapping(address => uint256) public perUserShareCvx;\n\n    uint256 private _crvLastEarned;\n    uint256 private _cvxLastEarned;\n    uint256 private _preClaimRewardsCrvEarned;\n\n    event RewardClaimed(\n        address indexed beneficiary,\n        uint256 bkdAmount,\n        uint256 crvAmount,\n        uint256 cvxAmount\n    );\n\n    constructor(\n        IController _controller,\n        address _ammToken,\n        uint256 _bkdPoolPID,\n        address _crv,\n        address _cvx,\n        address _booster\n    ) AmmGauge(_controller, _ammToken) {\n        cvx = _cvx;\n        crv = _crv;\n        booster = _booster;\n        bkdPoolPID = _bkdPoolPID;\n        (, , , address _crvRewards, , ) = IBooster(booster).poolInfo(_bkdPoolPID);\n        crvRewardsContract = IRewardStaking(_crvRewards);\n\n        // approve for Convex deposit\n        IERC20(ammToken).safeApprove(booster, type(uint256).max);\n    }\n\n    function claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        uint256 crvAmount = perUserShareCrv[beneficiary];\n        uint256 cvxAmount = perUserShareCvx[beneficiary];\n        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0;\n        crvRewardsContract.getReward();\n        _crvLastEarned = 0;\n        _cvxLastEarned = 0;\n        perUserShare[beneficiary] = 0;\n        perUserShareCrv[beneficiary] = 0;\n        perUserShareCvx[beneficiary] = 0;\n        IController(controller).inflationManager().mintRewards(beneficiary, amount);\n        IERC20(crv).safeTransfer(beneficiary, crvAmount);\n        IERC20(cvx).safeTransfer(beneficiary, cvxAmount);\n        _preClaimRewardsCrvEarned = IERC20(crv).balanceOf(address(this));\n        emit RewardClaimed(beneficiary, amount, crvAmount, cvxAmount);\n        return amount;\n    }\n\n    function setInflationRecipient(address recipient) external override onlyGovernance {\n        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET);\n        poolCheckpoint();\n        inflationRecipient = recipient;\n    }\n\n    function deactivateInflationRecipient() external override onlyGovernance {\n        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND);\n        poolCheckpoint();\n        inflationRecipient = address(0);\n    }\n\n    function claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (user == inflationRecipient) {\n            return\n                perUserShare[inflationRecipient] +\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed;\n        }\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ +=\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed.scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n    function allClaimableRewards(address user) external view override returns (uint256[3] memory) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        uint256 crvStakedIntegral_ = crvStakedIntegral;\n        uint256 cvxStakedIntegral_ = cvxStakedIntegral;\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -\n            _preClaimRewardsCrvEarned +\n            crvRewardsContract.earned(address(this));\n        uint256 cvxEarned = getCvxMintAmount(crvEarned);\n\n        if (!killed && totalStaked > 0) {\n            if (inflationRecipient == address(0)) {\n                ammStakedIntegral_ +=\n                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *\n                    (timeElapsed).scaledDiv(totalStaked);\n            }\n            crvStakedIntegral_ += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);\n            cvxStakedIntegral_ += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);\n        }\n        uint256 bkdRewards;\n        if (user == inflationRecipient) {\n            bkdRewards =\n                perUserShare[user] +\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed;\n        } else {\n            bkdRewards =\n                perUserShare[user] +\n                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n        }\n        uint256 crvRewards = perUserShareCrv[user] +\n            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);\n        uint256 cvxRewards = perUserShareCvx[user] +\n            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);\n        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];\n        return allRewards;\n    }\n\n    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n\n        _userCheckpoint(account);\n\n        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);\n        IBooster(booster).deposit(bkdPoolPID, amount, true);\n        balances[account] += amount;\n        totalStaked += amount;\n        emit AmmStaked(account, ammToken, amount);\n        return true;\n    }\n\n    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _userCheckpoint(msg.sender);\n\n        crvRewardsContract.withdrawAndUnwrap(amount, false);\n        IERC20(ammToken).safeTransfer(dst, amount);\n        balances[msg.sender] -= amount;\n        totalStaked -= amount;\n        emit AmmUnstaked(msg.sender, ammToken, amount);\n        return true;\n    }\n\n    function poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        uint256 currentRate = IController(controller).inflationManager().getAmmRateForToken(\n            ammToken\n        );\n        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -\n            _preClaimRewardsCrvEarned +\n            crvRewardsContract.earned(address(this));\n        uint256 cvxEarned = getCvxMintAmount(crvEarned);\n\n        // Update the integral of total token supply for the pool\n        if (totalStaked > 0) {\n            if (inflationRecipient == address(0)) {\n                ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n            } else {\n                perUserShare[inflationRecipient] += currentRate * timeElapsed;\n            }\n            crvStakedIntegral += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);\n            cvxStakedIntegral += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);\n        }\n        _crvLastEarned = crvEarned;\n        _cvxLastEarned = cvxEarned;\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual override returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserShareCrv[user] += balances[user].scaledMul(\n            crvStakedIntegral - perUserCrvStakedIntegral[user]\n        );\n        perUserShareCvx[user] += balances[user].scaledMul(\n            cvxStakedIntegral - perUserCvxStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        perUserCrvStakedIntegral[user] = crvStakedIntegral;\n        perUserCvxStakedIntegral[user] = cvxStakedIntegral;\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "StakerVault.sol",
            "LpToken.sol",
            "LpGauge.sol",
            "CvxCrvRewardsLocker.sol",
            "BkdLocker.sol",
            "AmmConvexGauge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nperUserShare[user] += (\n            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(\n                (poolStakedIntegral_ perUserStakedIntegral[user])\n            )\n        );\n"
                ],
                "Type": " User can steal all rewards due to checkpoint after transfer",
                "Description": "\nStakerVault.sol#L112-L119(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/StakerVault.sol#L112-L119)<br\n\nI believe this to be a high severity vulnerability that is potentially included in the currently deployed StakerVault.sol contract also. The team will be contacted immediately following the submission of this report.\n\nIn StakerVault.sol, the user checkpoints occur AFTER the balances are updated in the transfer() function. The user checkpoints update the amount of rewards claimable by the user. Since their rewards will be updated after transfer, a user can send funds between their own accounts and repeatedly claim maximum rewards since the pool's inception.\n\nIn every actionable function except transfer() of StakerVault.sol, a call to ILpGauge(lpGauge).userCheckpoint() is correctly made BEFORE the action effects.\n\n\nAssume a certain period of time has passed since the pool's inception. For easy accounting, assume poolStakedIntegral of LpGauge.sol equals 1. The poolStakedIntegral is used to keep track of the current reward rate.\n\nSteps:\n\n*   Account A stakes 1000 LP tokens. balances[A] += 1000\n*   In the same stakeFor() function, userCheckpoint() was already called so A will already have perUserShare[A] set correctly based on their previously 0 balance and the current poolStakedIntegral.\n*   Account A can immediately send all balance to Account B via transfer().\n*   Since the checkpoint occurs after the transfer, B's balance will increase and then perUserShare[B] will be updated. The calculation for perUserShare looks as follows.\n\n<!----\nsolidity\nperUserShare[user] += (\n            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(\n                (poolStakedIntegral_ perUserStakedIntegral[user])\n            )\n        );\n\n\nAssuming Account B is new to the protocol, their perUserStakedIntegral[user] will default to 0.\n\nperUserShare[B] += 1000 * (1 0) = 1000\n\n*   B is able to call claimRewards() and mint all 1000 reward tokens.\n*   B then calls transfer() and sends all 1000 staked tokens to Account C.\n*   Same calculation occurs, and C can claim all 1000 reward tokens.\n*   This process can be repeated until the contract is drained of reward tokens.\n\n",
                "Repair": "\nIn StakerVault.transfer(), move the call to ILpGauge(lpGauge).userCheckpoint() to before the balances are updated.\n\nchase-manning (Backd) confirmed and resolved(https://github.com/code-423n4/2022-04-backd-findings/issues/36)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas <=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance < vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly `vars.actionTokenAmount`\n        // (at least `position.singleTopUpAmount`) of action token\n        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                \"topUp(bytes32,address,uint256,bytes)\",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new \"balance\" of the position\n        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance > 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return `true` if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /**\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /**\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     */\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /**\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /**\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who's position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /**\n     * @dev \"Locks\" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of `token` to lock\n     * @param depositAmount Amount of `token` that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than `requiredAmount` more tokens will be locked.\n     */\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account && positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n\n\n",
        "CodeNames": [
            "TopUpAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "TopUpActionLibrary",
                    "lockFunds"
                ],
                "Type": " function  lockFunds  in  TopUpActionLibrary  can cause serious fund lose. fee and Capped bypass. It's not calling  stakerVault.increaseActionLockedBalance  when transfers stakes.",
                "Description": "\nTopUpAction.sol#L57-L65(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L57-L65)<br\n\nIn function TopUpActionLibrary.lockFunds when transfers stakes from payer it doesn't call stakerVault.increaseActionLockedBalance for that payer so stakerVault.actionLockedBalances[payer] is not get updated for payer and stakerVault.stakedAndActionLockedBalanceOf(payer) is going to show wrong value and any calculation based on this function is gonna be wrong which will cause fund lose and theft and some restriction bypasses.\n\n\nWhen user wants to create a TopUpAction. so he deposit his funds to Pool and get LP token. then stake the LP token in StakerVault and use that stakes to create a TopUp position with function TopUpAction.register. This function transfer user stakes (locks user staks) and create his position.<br\n\nFor transferring and locking user stakes it uses TopUpActionLibrary.lockFunds. function lockFunds transfers user stakes but don't call stakerVault.increaseActionLockedBalance for the payer which cause that stakerVault.actionLockedBalances[payer] to get different values(not equal to position.depositTokenBalance).<br\n\nFunction StakerVault.stakedAndActionLockedBalanceOf(account) uses stakerVault.actionLockedBalances[account] so it will return wrong value and any where in code that uses stakedAndActionLockedBalanceOf() is going to cause problems.<br\n\nthree part of the codes uses stakerVault.stakedAndActionLockedBalanceOf():<br\n1. LiqudityPool.depositFor() for checking user total deposits to be less than depositCap.<br\n2. LiqudityPool._updateUserFeesOnDeposit() for updating user fee on new deposits.<br\n3. userCheckpoint() for calculating user rewards.<br\nattacker can use #1 and #2 to bypass high fee payment and max depositCap and #3 will cause users to lose\nrewards.<br\n\nThe detail steps:<br\n1user deposit fund to Pool and get LP token.<br\n2user stakes LP token in StakerVault.<br\n3user approve TopUpAction address to transfer his staks in StakerVault.<br\n3user use all his stakes to create a position with TopUpAction.register() function.<br\n3.1register() will call lockFunds to transfer and lock user stakes.<br\n3.2lockFunds() will transfer user stakes with stakerVault.transferFrom() but don't call stakerVault.increaseActionLockedBalance() so StakerVault.actionLockedBalances[user] will be zero.<br\n3.3StakerVault.balance[useer] will be zero too because his stakes get transfers in 3.2<br\n4StakerVault.stakedAndActionLockedBalanceOf(user) will return zero (user has some locked stakes in TopUpAction but because of the bug calculation get out of sync)<br\n\nIn this moment user will lose all the rewards that are minted in LpGauge. because userCheckpoint() use stakerVault.stakedAndActionLockedBalanceOf(user) for calculating rewards which is zero  and new rewards will be zero too.<br\n\nAttacker can use this process to bypass \"max deposit Cap\" and deposit any amount of assets he wants. because LiqudityPool.depositFor(address,uint256,uint256) uses stakedAndActionLockedBalanceOf to check user deposits which is zero so Attacker can deposit & stake & register to make his balance zero and repeat this and in the end reset his TopUp positions to get back his large stakes which are multiple time bigger than \"max deposit Cap\"\n\nAttacker can also use this process to bypass fee penalties for early withdraw. because LiqudityPool._updateUserFeesOnDeposit() to get user current balance use stakedAndActionLockedBalanceOf() which is zero. so the value of shareExisting variable become zero and newFeeRatio will be calculated based on feeOnDeposit which can be minFee if asset is already in wallet for some time.\n\n\nVIM\n\n",
                "Repair": "\nAdd this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():\n\nstakerVault.increaseActionLockedBalance(payer, amountLeft);\n\nchase-manning (Backd) confirmed and resolved(https://github.com/code-423n4/2022-04-backd-findings/issues/60)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"./BaseHandler.sol\";\nimport \"../../../../interfaces/ICTokenRegistry.sol\";\nimport \"../../../../interfaces/vendor/CToken.sol\";\nimport \"../../../../interfaces/vendor/ExponentialNoError.sol\";\nimport \"../../../../interfaces/vendor/Comptroller.sol\";\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/ScaledMath.sol\";\n\ncontract CompoundHandler is BaseHandler, ExponentialNoError {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrow;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    Comptroller public immutable comptroller;\n    ICTokenRegistry public immutable cTokenRegistry;\n\n    constructor(address comptrollerAddress, address _cTokenRegistry) {\n        comptroller = Comptroller(comptrollerAddress);\n        cTokenRegistry = ICTokenRegistry(_cTokenRegistry);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n        uint256 initialTokens = ctoken.balanceOf(address(this));\n\n        address addr = account.addr();\n\n        if (repayDebt) {\n            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n            if (amount == 0) return true;\n        }\n\n        uint256 err;\n        if (underlying == address(0)) {\n            err = ctoken.mint{value: amount}(amount);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), amount);\n            err = ctoken.mint(amount);\n        }\n        require(err == 0, Error.FAILED_MINT);\n\n        uint256 newTokens = ctoken.balanceOf(address(this));\n        uint256 mintedTokens = newTokens - initialTokens;\n\n        bool success = ctoken.transfer(addr, mintedTokens);\n        require(success, Error.FAILED_TRANSFER);\n        return true;\n    }\n\n    /**\n     * @notice Returns the collaterization ratio of the user.\n     *         A result of 1.5 (x1e18) means that the user has a 150% collaterization ratio.\n     * @param account account for which to check the factor.\n     * @return User factor.\n     */\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (uint256 sumCollateral, uint256 sumBorrow) = _getAccountBorrowsAndSupply(account.addr());\n        if (sumBorrow == 0) {\n            return type(uint256).max;\n        }\n        return sumCollateral.scaledDiv(sumBorrow);\n    }\n\n    /**\n     * @notice Repays any existing debt for the given underlying.\n     * @param account Account for which to repay the debt.\n     * @param underlying The underlying token to repay the debt for.\n     * @param maximum The maximum amount of debt to repay.\n     * @return The amount of debt that was repayed in the underlying.\n     */\n    function _repayAnyDebt(\n        address account,\n        address underlying,\n        uint256 maximum,\n        CToken ctoken\n    ) internal returns (uint256) {\n        uint256 debt = ctoken.borrowBalanceCurrent(account);\n        if (debt == 0) return 0;\n        if (debt > maximum) debt = maximum;\n\n        uint256 err;\n        if (underlying == address(0)) {\n            CEther cether = CEther(address(ctoken));\n            err = cether.repayBorrowBehalf{value: debt}(account);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), debt);\n            err = ctoken.repayBorrowBehalf(account, debt);\n        }\n        require(err == 0, Error.FAILED_REPAY_BORROW);\n\n        return debt;\n    }\n\n    function _getAccountBorrowsAndSupply(address account) internal view returns (uint256, uint256) {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        PriceOracle oracle = comptroller.oracle();\n        // For each asset the account is in\n        CToken[] memory assets = comptroller.getAssetsIn(account);\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset\n                .getAccountSnapshot(account);\n            require(oErr == 0, Error.FAILED_METHOD_CALL);\n            (, uint256 collateralFactorMantissa, ) = comptroller.markets(address(asset));\n            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            require(vars.oraclePriceMantissa != 0, Error.FAILED_METHOD_CALL);\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(\n                mul_(vars.collateralFactor, vars.exchangeRate),\n                vars.oraclePrice\n            );\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                vars.cTokenBalance,\n                vars.sumCollateral\n            );\n\n            // sumBorrow += oraclePrice * borrowBalance\n            vars.sumBorrow = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrow\n            );\n        }\n\n        return (vars.sumCollateral, vars.sumBorrow);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas <=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance < vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly `vars.actionTokenAmount`\n        // (at least `position.singleTopUpAmount`) of action token\n        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                \"topUp(bytes32,address,uint256,bytes)\",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new \"balance\" of the position\n        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance > 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return `true` if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /**\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /**\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     */\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /**\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /**\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who's position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /**\n     * @dev \"Locks\" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of `token` to lock\n     * @param depositAmount Amount of `token` that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than `requiredAmount` more tokens will be locked.\n     */\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account && positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"../../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../../interfaces/vendor/ILendingPool.sol\";\nimport \"../../../../interfaces/vendor/IWETH.sol\";\nimport \"../../../../libraries/vendor/DataTypes.sol\";\n\ncontract AaveHandler is ITopUpHandler {\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    uint16 public constant BACKD_REFERRAL_CODE = 62314;\n\n    ILendingPool public immutable lendingPool;\n    IWETH public immutable weth;\n\n    constructor(address lendingPoolAddress, address wethAddress) {\n        lendingPool = ILendingPool(lendingPoolAddress);\n        weth = IWETH(wethAddress);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        if (underlying == address(0)) {\n            weth.deposit{value: amount}();\n            underlying = address(weth);\n        }\n\n        address addr = account.addr();\n\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n        require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n\n        IERC20(underlying).safeApprove(address(lendingPool), amount);\n\n        if (repayDebt) {\n            uint256 stableDebt = IERC20(reserve.stableDebtTokenAddress).balanceOf(addr);\n            uint256 variableDebt = IERC20(reserve.variableDebtTokenAddress).balanceOf(addr);\n            if (variableDebt + stableDebt > 0) {\n                uint256 rateMode = stableDebt > variableDebt ? 1 : 2;\n                amount -= lendingPool.repay(underlying, amount, rateMode, addr);\n                if (amount == 0) return true;\n            }\n        }\n\n        lendingPool.deposit(underlying, amount, addr, BACKD_REFERRAL_CODE);\n        return true;\n    }\n\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(account.addr());\n        return healthFactor;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IGasBank.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/oracles/IOracleProvider.sol\";\n\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/EnumerableMapping.sol\";\nimport \"../libraries/AddressProviderKeys.sol\";\nimport \"../libraries/AddressProviderMeta.sol\";\nimport \"../libraries/Roles.sol\";\n\nimport \"./access/AuthorizationBase.sol\";\nimport \"./utils/Preparable.sol\";\n\n// solhint-disable ordering\n\ncontract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;\n    using AddressProviderMeta for AddressProviderMeta.Meta;\n\n    // LpToken -> stakerVault\n    EnumerableMapping.AddressToAddressMap internal _stakerVaults;\n\n    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;\n\n    // value is encoded as (bool freezable, bool frozen)\n    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;\n\n    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered\n\n    EnumerableSet.AddressSet internal _vaults; // list of all active vaults\n\n    EnumerableMapping.AddressToAddressMap internal _tokenToPools;\n\n    constructor(address treasury) {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);\n        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);\n    }\n\n    function initialize(address roleManager) external initializer {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);\n    }\n\n    function getKnownAddressKeys() external view returns (bytes32[] memory) {\n        return _addressKeyMetas.keysArray();\n    }\n\n    function addFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);\n        _whiteListedFeeHandlers.add(feeHandler);\n        return true;\n    }\n\n    function removeFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);\n        _whiteListedFeeHandlers.remove(feeHandler);\n        return true;\n    }\n\n    /**\n     * @notice Adds action.\n     * @param action Address of action to add.\n     */\n    function addAction(address action) external onlyGovernance returns (bool) {\n        bool result = _actions.add(action);\n        if (result) {\n            emit ActionListed(action);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Adds pool.\n     * @param pool Address of pool to add.\n     */\n    function addPool(address pool)\n        external\n        override\n        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)\n    {\n        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n\n        ILiquidityPool ipool = ILiquidityPool(pool);\n        address poolToken = ipool.getLpToken();\n        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        if (_tokenToPools.set(poolToken, pool)) {\n            address vault = address(ipool.getVault());\n            if (vault != address(0)) {\n                _vaults.add(vault);\n            }\n            emit PoolListed(pool);\n        }\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        bool removed = _tokenToPools.remove(lpToken);\n        if (removed) {\n            address vault = address(ILiquidityPool(pool).getVault());\n            if (vault != address(0)) {\n                _vaults.remove(vault);\n            }\n            emit PoolDelisted(pool);\n        }\n\n        return removed;\n    }\n\n    /** Vault functions  */\n\n    /**\n     * @notice returns all the registered vaults\n     */\n    function allVaults() external view returns (address[] memory) {\n        return _vaults.toArray();\n    }\n\n    /**\n     * @notice returns the vault at the given index\n     */\n    function getVaultAtIndex(uint256 index) external view returns (address) {\n        return _vaults.at(index);\n    }\n\n    /**\n     * @notice returns the number of vaults\n     */\n    function vaultsCount() external view returns (uint256) {\n        return _vaults.length();\n    }\n\n    function isVault(address vault) external view returns (bool) {\n        return _vaults.contains(vault);\n    }\n\n    function updateVault(address previousVault, address newVault) external onlyRole(Roles.POOL) {\n        if (previousVault != address(0)) {\n            _vaults.remove(previousVault);\n        }\n        if (newVault != address(0)) {\n            _vaults.add(newVault);\n        }\n        emit VaultUpdated(previousVault, newVault);\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     */\n    function getAddress(bytes32 key) public view returns (address) {\n        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     * @dev if `checkExists` is true, it will fail if the key does not exist\n     */\n    function getAddress(bytes32 key, bool checkExists) public view returns (address) {\n        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice returns the address metadata for the given key\n     */\n    function getAddressMeta(bytes32 key) public view returns (AddressProviderMeta.Meta memory) {\n        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);\n        require(exists, Error.ADDRESS_DOES_NOT_EXIST);\n        return AddressProviderMeta.fromUInt(metadata);\n    }\n\n    function initializeAddress(bytes32 key, address initialAddress) external {\n        initializeAddress(key, initialAddress, false);\n    }\n\n    /**\n     * @notice Initializes an address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        bool freezable\n    ) public override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Initializes and freezes address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAndFreezeAddress(bytes32 key, address initialAddress)\n        external\n        override\n        onlyGovernance\n    {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Freezes a configuration key, making it immutable\n     * @param key Key to feeze\n     */\n    function freezeAddress(bytes32 key) external override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        require(meta.freezable, Error.INVALID_ARGUMENT);\n        meta.frozen = true;\n        _addressKeyMetas.set(key, meta.toUInt());\n    }\n\n    /**\n     * @notice Prepare update of an address\n     * @param key Key to update\n     * @param newAddress New address for `key`\n     * @return `true` if successful.\n     */\n    function prepareAddress(bytes32 key, address newAddress)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _prepare(key, newAddress);\n    }\n\n    /**\n     * @notice Execute update of `key`\n     * @return New address.\n     */\n    function executeAddress(bytes32 key) external override returns (address) {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _executeAddress(key);\n    }\n\n    /**\n     * @notice Reset `key`\n     * @return true if it was reset\n     */\n    function resetAddress(bytes32 key) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(key);\n    }\n\n    /**\n     * @notice Add a new staker vault and add it's lpGauge if set in vault.\n     * @dev This fails if the token of the staker vault is the token of an existing staker vault.\n     * @param stakerVault Vault to add.\n     * @return `true` if successful.\n     */\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n        returns (bool)\n    {\n        address token = IStakerVault(stakerVault).getToken();\n        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);\n        _stakerVaults.set(token, stakerVault);\n        emit StakerVaultListed(stakerVault);\n        return true;\n    }\n\n    function isWhiteListedFeeHandler(address feeHandler) external view override returns (bool) {\n        return _whiteListedFeeHandlers.contains(feeHandler);\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Does not revert if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function safeGetPoolForToken(address token) external view override returns (address) {\n        (, address poolAddress) = _tokenToPools.tryGet(token);\n        return poolAddress;\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Reverts if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function getPoolForToken(address token) external view override returns (ILiquidityPool) {\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(token);\n        require(exists, Error.ADDRESS_NOT_FOUND);\n        return ILiquidityPool(poolAddress);\n    }\n\n    /**\n     * @notice Get list of all action addresses.\n     * @return Array with action addresses.\n     */\n    function allActions() external view override returns (address[] memory) {\n        return _actions.toArray();\n    }\n\n    /**\n     * @notice Check whether an address is an action.\n     * @param action Address to check whether it is action.\n     * @return True if address is an action.\n     */\n    function isAction(address action) external view override returns (bool) {\n        return _actions.contains(action);\n    }\n\n    /**\n     * @notice Check whether an address is an pool.\n     * @param pool Address to check whether it is a pool.\n     * @return True if address is a pool.\n     */\n    function isPool(address pool) external view returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(lpToken);\n        return exists && pool == poolAddress;\n    }\n\n    /**\n     * @notice Get list of all pool addresses.\n     * @return Array with pool addresses.\n     */\n    function allPools() external view override returns (address[] memory) {\n        return _tokenToPools.valuesArray();\n    }\n\n    /**\n     * @notice returns the pool at the given index\n     */\n    function getPoolAtIndex(uint256 index) external view returns (address) {\n        return _tokenToPools.valueAt(index);\n    }\n\n    /**\n     * @notice returns the number of pools\n     */\n    function poolsCount() external view returns (uint256) {\n        return _tokenToPools.length();\n    }\n\n    /**\n     * @notice Returns all the staker vaults.\n     */\n    function allStakerVaults() external view override returns (address[] memory) {\n        return _stakerVaults.valuesArray();\n    }\n\n    /**\n     * @notice Get the staker vault for a given token\n     * @dev There can only exist one staker vault per unique token.\n     * @param token Token for which to get the vault.\n     * @return Vault address.\n     */\n    function getStakerVault(address token) external view override returns (address) {\n        return _stakerVaults.get(token);\n    }\n\n    /**\n     * @notice Tries to get the staker vault for a given token but does not throw if it does not exist\n     * @return A boolean set to true if the vault exists and the vault address.\n     */\n    function tryGetStakerVault(address token) external view override returns (bool, address) {\n        return _stakerVaults.tryGet(token);\n    }\n\n    /**\n     * @notice Check if a vault is registered (exists).\n     * @param stakerVault Address of staker vault to check.\n     * @return `true` if registered, `false` if not.\n     */\n    function isStakerVaultRegistered(address stakerVault) external view override returns (bool) {\n        address token = IStakerVault(stakerVault).getToken();\n        return isStakerVault(stakerVault, token);\n    }\n\n    function isStakerVault(address stakerVault, address token) public view override returns (bool) {\n        (bool exists, address vault) = _stakerVaults.tryGet(token);\n        return exists && vault == stakerVault;\n    }\n\n    function _roleManager() internal view override returns (IRoleManager) {\n        return IRoleManager(getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));\n    }\n\n    function _initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        AddressProviderMeta.Meta memory meta\n    ) internal {\n        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);\n        _addKnownAddressKey(key, meta);\n        _setConfig(key, initialAddress);\n    }\n\n    function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal {\n        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT);\n        emit KnownAddressKeyAdded(key);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./access/Authorization.sol\";\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/vendor/IRewardStaking.sol\";\nimport \"../interfaces/vendor/ICrvDepositor.sol\";\nimport \"../interfaces/vendor/IDelegation.sol\";\nimport \"../interfaces/vendor/IvlCvxExtraRewardDistribution.sol\";\nimport \"../interfaces/vendor/ICurveSwap.sol\";\nimport \"../interfaces/vendor/ICvxLocker.sol\";\nimport \"../interfaces/ICvxCrvRewardsLocker.sol\";\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\ncontract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    using SafeERC20 for IERC20;\n\n    // ERC20 tokens\n    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    address public constant CVX_CRV_CRV_CURVE_POOL =\n        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool\n    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV\n    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards\n    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker\n    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =\n        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);\n\n    uint256 public spendRatio;\n    bool public prepareWithdrawal;\n    address public treasury;\n\n    int128 private constant _CRV_INDEX = 0;\n    int128 private constant _CVX_CRV_INDEX = 1;\n\n    event NewSpendRatio(uint256 newSpendRatio);\n    event NewTreasury(address newTreasury);\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        // Approve for locking CRV for cvxCRV\n        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);\n\n        // Approve for staking cvxCRV\n        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);\n\n        // Approve for cvxCRV/CRV Curve Pool Swaps\n        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);\n\n        // Approve CVX Locker\n        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);\n\n        treasury = _addressProvider.getTreasury();\n    }\n\n    function lockCvx() external override {\n        _lockCvx();\n    }\n\n    function lockCrv() external override {\n        _lockCrv();\n    }\n\n    /**\n     * @notice Set spend ratio for CVX locking.\n     * @dev Spend ratio is the amount of CVX that should be donated to\n     * the Convex treasury to boost vote power. This needs to be enabled\n     * by Convex.\n     * @param _spendRatio New spend ratio to be used.\n     */\n    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {\n        require(\n            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),\n            Error.EXCEEDS_MAX_BOOST\n        );\n        spendRatio = _spendRatio;\n        emit NewSpendRatio(_spendRatio);\n        return true;\n    }\n\n    /**\n     * @notice Claim rewards from Convex.\n     * @dev Rewards to claim are for staked cvxCRV and locked CVX.\n     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).\n     */\n    function claimRewards(bool lockAndStake) external override returns (bool) {\n        ICvxLocker(CVX_LOCKER).getReward(address(this), false);\n\n        IRewardStaking(CVX_CRV_STAKING).getReward();\n\n        if (lockAndStake) {\n            lockRewards();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.\n     */\n    function stakeCvxCrv() external override returns (bool) {\n        return _stakeCvxCrv();\n    }\n\n    /**\n     * @notice Prepares a withdrawal of funds.\n     * @dev If this is set then no idle funds can get locked or staked.\n     */\n    function setWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = true;\n    }\n\n    /**\n     * @notice Resets prepared withdrawal of funds.\n     */\n    function resetWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = false;\n    }\n\n    /**\n     * @notice Processes exipred locks.\n     */\n    function processExpiredLocks(bool relock) external override returns (bool) {\n        if (relock) {\n            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);\n        }\n\n        if (relock) {\n            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);\n        } else {\n            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Set treasury to receive withdrawn funds.\n     */\n    function setTreasury(address _treasury) external onlyGovernance returns (bool) {\n        treasury = _treasury;\n        emit NewTreasury(treasury);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw full amount of a token to the treasury.\n     * @param token Token to withdraw entire balance of.\n     */\n    function withdraw(address token) external onlyGovernance returns (bool) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(treasury, balance);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cvxCRV to treasury.\n     * @dev Unstakes cvxCRV if it is staked.\n     */\n    function withdrawCvxCrv(uint256 amount) external onlyGovernance {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));\n        if (cvxcrvBal > 0) {\n            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);\n        }\n    }\n\n    function unstakeCvxCrv() external onlyGovernance {\n        unstakeCvxCrv(false);\n    }\n\n    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {\n        _unstakeCvxCrv(amount, withdrawal);\n    }\n\n    /**\n     * @notice Set delegate to receive vote weight.\n     */\n    function setDelegate(address delegateContract, address delegate) external onlyGovernance {\n        IDelegation(delegateContract).setDelegate(\"cvx.eth\", delegate);\n    }\n\n    /**\n     * @notice Clears a delegate for the msg.sender and a specific id.\n     */\n    function clearDelegate(address delegateContract) external onlyGovernance {\n        IDelegation(delegateContract).clearDelegate(\"cvx.eth\");\n    }\n\n    function forfeitRewards(address token, uint256 index) external onlyGovernance {\n        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(\n            token,\n            index\n        );\n    }\n\n    /**\n     * @notice Lock CRV and CVX tokens.\n     * @dev CRV get locked for cvxCRV and staked on Convex.\n     */\n    function lockRewards() public returns (bool) {\n        _lockCrv();\n        _lockCvx();\n        return true;\n    }\n\n    /**\n     * @notice Withdraw an amount of a token to the treasury.\n     * @param token Token to withdraw.\n     * @param amount Amount of token to withdraw.\n     */\n    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {\n        IERC20(token).safeTransfer(treasury, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake cvxCRV from Convex.\n     */\n    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {\n        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));\n        _unstakeCvxCrv(staked, withdrawal);\n    }\n\n    function _lockCrv() internal {\n        if (prepareWithdrawal) return;\n\n        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));\n        if (currentBalance != 0) {\n            // Checks if we can get a better rate on Curve Pool\n            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(\n                _CRV_INDEX,\n                _CVX_CRV_INDEX,\n                currentBalance\n            );\n            if (amountOut > currentBalance) {\n                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(\n                    _CRV_INDEX,\n                    _CVX_CRV_INDEX,\n                    currentBalance,\n                    0\n                );\n            } else {\n                // Swap CRV for cxvCRV and stake\n                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));\n            }\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n            return;\n        }\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n    }\n\n    function _lockCvx() internal {\n        // Locks CVX for vlCVX\n        if (prepareWithdrawal) return;\n        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));\n        if (currentBalance == 0) return;\n        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);\n    }\n\n    function _stakeCvxCrv() internal returns (bool) {\n        if (prepareWithdrawal) return false;\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;\n        IRewardStaking(CVX_CRV_STAKING).stakeAll();\n        return true;\n    }\n\n    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        if (withdrawal) {\n            IERC20(CVX_CRV).safeTransfer(treasury, amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CompoundHandler.sol",
            "TopUpAction.sol",
            "AaveHandler.sol",
            "AddressProvider.sol",
            "CvxCrvRewardsLocker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n",
                    "//solidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1\n\n50       function topUp(\n51           bytes32 account,\n52           address underlying,\n53           uint256 amount,\n54           bytes memory extra\n55       ) external override returns (bool) {\n56           bool repayDebt = abi.decode(extra, (bool));\n57           CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n58           uint256 initialTokens = ctoken.balanceOf(address(this));\n59   \n60           address addr = account.addr();\n61   \n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n66   \n67           uint256 err;\n68           if (underlying == address(0)) {\n69               err = ctoken.mint{value: amount}(amount);\n70           } else {\n71               IERC20(underlying).safeApprove(address(ctoken), amount);\n",
                    "//solidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2\n\n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n",
                    "//solidity\nFile: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3\n\n36       function topUp(\n37           bytes32 account,\n38           address underlying,\n39           uint256 amount,\n40           bytes memory extra\n41       ) external override returns (bool) {\n42           bool repayDebt = abi.decode(extra, (bool));\n43           if (underlying == address(0)) {\n44               weth.deposit{value: amount}();\n45               underlying = address(weth);\n46           }\n47   \n48           address addr = account.addr();\n49   \n50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n52   \n53           IERC20(underlying).safeApprove(address(lendingPool), amount);\n",
                    "//solidity\nFile: backd/contracts/actions/topup/TopUpAction.sol   #4\n\n840       function _payFees(\n841           address payer,\n842           address beneficiary,\n843           uint256 feeAmount,\n844           address depositToken\n845       ) internal {\n846           address feeHandler = getFeeHandler();\n847           IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n"
                ],
                "Type": " Customers cannot be  topUp() ed a second time",
                "Description": "\nCompoundHandler.sol#L71(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71)<br\nCompoundHandler.sol#L120(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120)<br\nAaveHandler.sol#L53(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53)<br\nTopUpAction.sol#L847(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847)<br\n\nOpenZeppelin's safeApprove() will revert if the account already is approved and the new safeApprove() is done with a non-zero value.\n\nsolidity\nfunction safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n\n\nOpenZeppelin/SafeERC20.sol#L45-L58(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58)<br\n\n\nCustomers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected.\n\n\nThere are multiple places where safeApprove() is called a second time without setting the value to zero first. The instances below are all related to topping up.\n\nCompound-specific top-ups will fail the second time around when approving the ctoken again:\n\nsolidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1\n\n50       function topUp(\n51           bytes32 account,\n52           address underlying,\n53           uint256 amount,\n54           bytes memory extra\n55       ) external override returns (bool) {\n56           bool repayDebt = abi.decode(extra, (bool));\n57           CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n58           uint256 initialTokens = ctoken.balanceOf(address(this));\n59   \n60           address addr = account.addr();\n61   \n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n66   \n67           uint256 err;\n68           if (underlying == address(0)) {\n69               err = ctoken.mint{value: amount}(amount);\n70           } else {\n71               IERC20(underlying).safeApprove(address(ctoken), amount);\n\n\nCompoundHandler.sol#L50-L71(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71)<br\n\nCompound-specific top-ups will also fail when trying to repay debt:\n\nsolidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2\n\n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n\n\nCompoundHandler.sol#L62-L65(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65)<br\n\nAave-specific top-ups will fail for the lendingPool:\n\nsolidity\nFile: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3\n\n36       function topUp(\n37           bytes32 account,\n38           address underlying,\n39           uint256 amount,\n40           bytes memory extra\n41       ) external override returns (bool) {\n42           bool repayDebt = abi.decode(extra, (bool));\n43           if (underlying == address(0)) {\n44               weth.deposit{value: amount}();\n45               underlying = address(weth);\n46           }\n47   \n48           address addr = account.addr();\n49   \n50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n52   \n53           IERC20(underlying).safeApprove(address(lendingPool), amount);\n\n\nAaveHandler.sol#L36-L53(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53)<br\n\nThe TopUpAction itself fails for the feeHandler:\n\nsolidity\nFile: backd/contracts/actions/topup/TopUpAction.sol   #4\n\n840       function _payFees(\n841           address payer,\n842           address beneficiary,\n843           uint256 feeAmount,\n844           address depositToken\n845       ) internal {\n846           address feeHandler = getFeeHandler();\n847           IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n\n\nTopUpAction.sol#L840-L847(https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847)<br\n\nI've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report.\n\n",
                "Repair": "\nAlways do safeApprove(0) if the allowance is being changed, or use safeIncreaseAllowance().\n\nchase-manning (Backd) confirmed and resolved(https://github.com/code-423n4/2022-04-backd-findings/issues/178)\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]