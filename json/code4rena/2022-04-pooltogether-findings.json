[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n  /\n   * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.\n   * @param _tokens Amount of asset tokens\n   * @return Number of shares.\n   */\n  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply\n    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));\n  }\n\n  /\n   * @notice Calculates the number of asset tokens a user has in the yield source.\n   * @param _shares Amount of shares\n   * @return Number of asset tokens.\n   */\n  function _sharesToToken(uint256 _shares) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares\n    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);\n  }\n",
                    "//solidity\n  function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {\n    address _underlyingAssetAddress = _tokenAddress();\n    IERC20 _assetToken = IERC20(_underlyingAssetAddress);\n\n    uint256 _shares = _tokenToShares(_redeemAmount);\n    _burn(msg.sender, _shares);\n    ...\n"
                ],
                "Type": " A malicious early user/attacker can manipulate the vault's  pricePerShare  to take an unfair share of future users' deposits",
                "Description": "\nThis is a well-known attack vector for new contracts that utilize pricePerShare for accounting.\n\nAaveV3YieldSource.sol#L352-L374(https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L352-L374)<br\n\nsolidity\n  /\n   * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.\n   * @param _tokens Amount of asset tokens\n   * @return Number of shares.\n   */\n  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply\n    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));\n  }\n\n  /\n   * @notice Calculates the number of asset tokens a user has in the yield source.\n   * @param _shares Amount of shares\n   * @return Number of asset tokens.\n   */\n  function _sharesToToken(uint256 _shares) internal view returns (uint256) {\n    uint256 _supply = totalSupply();\n\n    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares\n    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);\n  }\n\n\nA malicious early user can supplyTokenTo() with 1 wei of _underlyingAssetAddress token as the first depositor of the AaveV3YieldSource.sol, and get 1 wei of shares token.\n\nThen the attacker can send 10000e18 1 of aToken and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from (1 + 10000e18 1) / 1) .\n\nAs a result, the future user who deposits 19999e18 will only receive 1 wei (from 19999e18 * 1 / 10000e18) of shares token.\n\nThey will immediately lose 9999e18 or half of their deposits if they redeemToken() right after the supplyTokenTo().\n\nAaveV3YieldSource.sol#L251-L256(https://github.com/pooltogether/aave-v3-yield-source/blob/e63d1b0e396a5bce89f093630c282ca1c6627e44/contracts/AaveV3YieldSource.sol#L251-L256)<br\n\nsolidity\n  function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {\n    address _underlyingAssetAddress = _tokenAddress();\n    IERC20 _assetToken = IERC20(_underlyingAssetAddress);\n\n    uint256 _shares = _tokenToShares(_redeemAmount);\n    _burn(msg.sender, _shares);\n    ...\n\n\nFurthermore, after the PPS has been inflated to an extremely high value (10000e18), the attacker can also redeem tokens up to 9999e18 for free, (burn 0 shares) due to the precision loss.\n\n",
                "Repair": "\nConsider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO address so that the pricePerShare can be more resistant to manipulation.\n\nAlso, consder adding require(_shares  0, \"AaveV3YS/shares-gt-zero\"); before _burn(msg.sender, _shares);.\n\nPierrickGT (PoolTogether) confirmed and commented(https://github.com/code-423n4/2022-04-pooltogether-findings/issues/44#issuecomment-1119085805):\n  PR: https://github.com/pooltogether/aave-v3-yield-source/pull/15\n\n\n\n*\n \n\n"
            }
        ]
    }
]