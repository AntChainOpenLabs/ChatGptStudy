[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\npragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 1 days;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.timestamp;\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.timestamp);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n        require(newRatio >= minIbRatio);\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.timestamp);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "CodeNames": [
            "Basket.sol",
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "handleFees",
                    "startSupply == 0",
                    "totalSupply",
                    "lastFee"
                ],
                "Type": " Wrong fee calculation after  totalSupply  was 0",
                "Description": "\nhandleFees does not update lastFee if startSupply == 0.\nThis means that wrongly, extra fee tokens would be minted once the basket is resupplied and handleFees is called again.\n\n\nLoss of user funds.\nThe extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.\n\n\nScenario:\n\n*   All basket token holders are burning their tokens. The last burn would set totalSupply to 0.\n*   After 1 day, somebody mints basket tokens.\n\nhandleFees would be called upon mint, and would just return since totalSupply == 0. Note: It does not update lastFee.\n\n    } else if (startSupply == 0) {\n                return;\n\nBasket.sol#L136:#L137(https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137)\n\n*   The next block, somebody else mints a token. Now handleFees will be called and will calculate the fees according to the current supply and the time diff between now and lastFee:\n\n<!----\n\n    uint256 timeDiff = (block.timestamp lastFee);\n\nBasket.sol#L139(https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139)<br\nBut as we saw, lastFee wasn't updated in the previous step. lastFee is still the time of 1 day before when the last person burned his tokens and the basket supply was 0.\nSo now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.\n\n",
                "Repair": "\nSet lastFee = block.timestamp if startSupply == 0.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/58)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/58#issuecomment-1079627201):\n The issue can be outlined as follows:\n  A user interacts with the basket and mints some amount of tokens, which sets lastFee = block.timestamp.\n  The same user decides to exit the basket and burn their tokens.\n  Some amount of time passes and another user enters the basket, but handleFees() did not set lastFee = block.timestamp. As a result, fees are charged on the user's deposit for the entire time that the basket was inactive for.\n \n It seems that the basket is severely flawed in calculating fees on partially inactive baskets. This puts users' funds at direct risk of being lost. Malicious publishers can setup baskets as a sort of honeypot to abuse this behaviour.\n\n This was an interesting find! Kudos to the warden.\n\n\n\n*\n\n \n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "startSupply",
                    "handleFees()",
                    "pushUnderlying()",
                    "ibRatio",
                    "uint",
                    "newIbRatio",
                    "pullUnderlying()",
                    "auctionBurn",
                    "sol#auctionBurn",
                    "totalSupply",
                    "handleFees"
                ],
                "Type": "  Basket.sol#auctionBurn  calculates  ibRatio  wrong",
                "Description": "\nThe function is implemented as follows:\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n            uint256 startSupply = totalSupply();\n            handleFees(startSupply);\n            _burn(msg.sender, amount);\n\n            uint256 newIbRatio = ibRatio * startSupply / (startSupply amount);\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(newIbRatio);\n            emit Burned(msg.sender, amount);\n        }\n\nWhen handleFees is called, totalSupply and ibRatio changes accordingly, but for newIbRatio calculation tokens minted in handleFees is not included. Therefore, ibRatio is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, newIbRatio will increase the miscalculation even faster and can result in serious amount of funds missing. At each time auctionBurn is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on ibRatio, this behaviour can create serious miscalculations.\n\n\nRather than\n\nuint256 newIbRatio = ibRatio * startSupply / (startSupply amount);\n\nA practical solution to this problem is calculating newIbRatio as follows:\n\n    uint256 supply = totalSupply();\n    uint256 newIbRatio = ibRatio * (supply + amount) / supply;\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/144)\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/144#issuecomment-1079628195):\n  The warden has identified an issue whereby newIbRatio uses an incorrect startSupply variable which is under-represented. As new tokens may be minted in handleFees(), this will lead to an incorrect ibRatio which is used in all other areas of the protocol. A lower ibRatio causes pushUnderlying() and pullUnderlying() to be improperly accounted for. As a result, burning basket tokens will redeem a smaller amount of underlying tokens and minting basket tokens will require a smaller amount of underlying tokens.\n \n This causes the protocol to leak value from all basket token holders but it does not allow assets to be stolen. As such, I think this is better put as a medium severity issue.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-04",
                "Location": [
                    "auction",
                    "factory",
                    "initialize()",
                    "approve()",
                    "approveUnderlying(address(auction))"
                ],
                "Type": " Reentrancy vulnerability in  Basket  contract's  initialize()  method.",
                "Description": "\nA malicious \"publisher\" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's approve() method. When the initialize() method is called on the newly cloned Basket contract, a method called approveUnderlying(address(auction)) is called, which would trigger the reentrancy, call initialize() again, passing in altered critical values such as auction and factory, and then removes its self from proposal.tokens and proposal.weights so it doesn't appear in the token list to basket users.\n\nBasket.sol#L44-L61(https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61)\n\n\nAuction and Factory can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. Auction controls ibRatio, which a malicious version could send back a manipulated value to Basket, allowing the malicious \"publisher\" to burn basket tokens till all users underlying tokens are drained.\n\n\nManual review and Hardhat.\n\n",
                "Repair": "\nSince Basket inherits from ERC20Upgradeable the initializer modifier should be available and therefore used here. It has an inititializing variable that would prevent this kind of reentrancy attack.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/176)\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/176#issuecomment-1079636401):\n  While the warden is correct, a malicious publisher could re-enter the Basket.initialize() function and overwrite factory and auction with their own addresses, this does not lead to a direct loss of funds for users. It would require that users interact with their malicious contracts which is entirely possible if baskets created via the factory are deemed as trusted. I think this fits the criteria of a medium severity issue.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "minLicenseFee",
                    "LicenseFee"
                ],
                "Type": " Missing cap on  LicenseFee ",
                "Description": "\nThere is no cap on LicenseFee. While change of LicenseFee is under 1 day timelock, introducing a\nmaxLicenseFee can improve credibility by removing the \"rug\" vector. There is a minLicenseFee in the contracts, while imo make little sense to have minLicenseFee but not maxLicenseFee.\n\nAn incorrectly set LicenseFee can potentially lead to over/underflow in Basket.sol#L140-141(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L140-141) which is used in most of the function.\n\n\nBasket.sol#L177(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L177)<br\nFactory.sol#L77(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L77)<br\nBasket.sol#L49(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L49)\n\n",
                "Repair": "\nDefine a maxLicenseFee\n\nfrank-beard (Kuiper) acknowledged, but disagreed with High severity and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/154#issuecomment-1048121652):\n  Generally it is intended for the publishers to act correctly and the timelock is intended to prevent incorrect values from making it all the way through, however there is validity in reducing how the fee can be modified, such as reducing how much any one fee change can change the fee. I would consider this a low risk issue.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/154#issuecomment-1079621078):\n  It seems like changes to licenseFee could potentially brick the contract as handleFees() underflows, preventing users from minting/burning tokens. I'd deem this as medium severity due to compromised protocol availability.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 1 days;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.timestamp;\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.timestamp);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n        require(newRatio >= minIbRatio);\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.timestamp);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "minIbRatio",
                    "bondBurn",
                    "IbRatio"
                ],
                "Type": " Publisher can lock all user funds in the  Basket  in order to force a user to have their bond burned",
                "Description": "\nAll user funds in a basket being held hostage by the publisher\n\n\nThe Basket publisher can propose an auction in order to set new tokens and weights with a 1 day timelock.\n\nBasket.sol#L216-L244(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244)<br\n\nAs part of this call they can set the minIbRatio variable which determines what the maximum slippage on the auction is allowed to be. If it's set to the current IbRatio then the Basket accepts no slippage.\n\nThe publisher can choose to set minIbRatio = type(uint256).max which will prevent any auction bids from being successful, locking the basket in the auction state.\n\nIt's not possible to enter or exit the basket while an auction is going on, so any users who hold any funds in the basket are forced to take the only option to kill the auction available to them.\n\nBasket.sol#L91-L119(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L91-L119)<br\n\nIf a user makes a bond and then waits a day to then call Auction.bondBurn, it will reset the auction and allow users to withdraw but it requires 0.25% of the supply of the basket token to be burned.\n\nAuction.sol#L121-L134(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L121-L134)<br\n\nOne of the basket's users is then forced to give up some of their assets to secure the release of the remaining assets in the basket (for a 24hr period until the publisher starts a new auction).\n\nThis attack can be launched at any time with only 24 hours warning. This is a very short amount of time which near guarantees that if other users hold funds in the basket that not all of them will successfully withdraw in that time and so will have funds locked.\n\n",
                "Repair": "\nAgain this is tricky to mitigate as there are legitimate scenarios where we would expect the ibRatio to increase. e.g. a basket containing WBTC being changed to contain USDC as each basket token should be worth much more USDC than it was in terms of WBTC.\n\nTo be frank the entire auction mechanism is a bit shaky as it doesn't account for changes in the values of the tokens over time.\n\nfrank-beard (Kuiper) acknowledged, but disagreed with High severity and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/53#issuecomment-1048140154):\n  This is where community action and the timelock should mitigate attacks of these types. Users should be able to hold publishers accountable for their rebalances, whether that is through a dao or other means. We acknowledge there is some level of trust required between the user and the publisher however this is also intentional, for the types of products this protocol is for.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/53#issuecomment-1079625679):\n  Because a timelock is used in this instance, exploiting this issue proves more difficult and requires that the publisher is malicious. As we are dealing with an abuse of privileges, I think this fits the criteria of a medium severity issue as the issue can only be exploited by a trusted account.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/53#issuecomment-1079816317):\n  Actually I'm not sure if I understand the exploit:\n  The publisher must wait a day to call Basket.publishNewIndex(), setting new values and starting an auction. In that time, users are free to exit the protocol as they wish.\n  However, users who were not able to exit in time are obligated to call Auction.bondForRebalance() in order to unlock the basket's underlying assets. But because Auction.settleAuction() will always revert, this user forfeits their bond to unlock the rest of their tokens.\n \n In this case, I see this as an abuse of the publisher's privileges and lack of oversight by the users. medium severity seems correct in this situation.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "bondForRebalance",
                    "newRatio",
                    "auctionBonder",
                    "auctionDecrement",
                    "startAuction",
                    "auctionMultiplier",
                    "minIbRatio",
                    "= minIbRatio",
                    "settleAuction"
                ],
                "Type": " Change in  auctionMultiplier/auctionDecrement  change profitability of auctions and factory can steal all tokens from a basket abusing it",
                "Description": "\nWhen factory changes auctionMultiplier or auctionDecrement profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.\n\n\n1Factory owners call bondForRebalance for an auction.\n\n2Factory owners sets auctionMultiplier as 0 and auctionDecrement as maximum value\n\n3settleAuction is called. newRatio = 0, since a = b = 0. All tokens can be withdrawn with this call, since tokensNeeded = 0.\n\n\nFurthermore, even the factory owners does not try to scam users. In case auctionMultiplier or auctionDecrement is changed, all current auctionBonder from Auctions can only call settleAuction with different constraints. Because of different constraints, users/bonder will lose/gain funds.\n\n\nSave auctionDecrement and auctionMultiplier to global variables in Auction.sol, when startAuction is called.\n\nfrank-beard (Kuiper) confirmed and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/145#issuecomment-1049059976):\n  Adding in protection from the global governance is definitely important.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/145#issuecomment-1079812584):\n  The warden has identified an issue whereby the factory owner can rug-pull baskets through the re-balancing mechanism. Because newRatio = 0, the basket improperly checks the tokens needed in the contract. However, this assumes that the factory owner is malicious which satisfies medium severity due to assets not being at direct risk.\n \n The sponsor has decided to add additional protections (potentially via timelock) to mitigate this issue.\n\n  This rug-pull is made even more difficult by the fact that newRatio must be = minIbRatio. Because minIbRatio is behind timelock, I think this rug vector is unlikely or at least can only be used to steal a fixed amount of funds.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\n  for (uint256 i = 0; i < pendingWeights.length; i++) {\n      uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n      require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n  }\n",
                    "//solidity\n  uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n  uint256 b = (bondBlock auctionStart) * BASE / factory.auctionDecrement();\n  uint256 newRatio = a b;\n",
                    "js\n      it.only(\"should allow me to steal funds\", async() = {\n        // start an auction\n        let NEW_UNI_WEIGHT = \"2400000000000000000\";\n        let NEW_COMP_WEIGHT = \"2000000000000000000\";\n        let NEW_AAVE_WEIGHT = \"400000000000000000\";\n\n        await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address], \n            NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;\n        await increaseTime(60 * 60 * 24)\n        await increaseTime(60 * 60 * 24)\n        await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address], \n          NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;\n\n        let auctionAddr = await basket.auction();\n        let auction = AuctionImpl.attach(auctionAddr);\n\n        ethers.provider.getBlockNumber();\n        // increase the block number for `bondBlock auctionStart` to be 20000.\n        // When that's the case, the result of `newRatio` in `settleAuction()` \n        // is `0`. And that means `tokensNeeded` is 0. Which means,\n        // we can take out all the tokens we want using the `outputTokens` array\n        // without having to worry about basket's balance at the end.\n        // The math changes depending on the settings of the factory contract or the\n        // Basket contract. But, the gist is that you try to get newRatio to be 0.\n        // The only values you can control as a attacker is the bondBlock after the auction\n        // was started.\n        for (let i = 0; i < 20000; i++) {\n          await hre.network.provider.send(\"evm_mine\")\n        }\n        await basket.approve(auction.address, '5000000000000000');\n        await expect(auction.bondForRebalance()).to.be.ok;\n        await expect(auction.settleAuction([], ], ], UNI.address, AAVE.address], \"200720000000000000\", \"200120000000000000\"])).to.be.ok;\n      });\n"
                ],
                "Type": " Basket can be fully drained if the auction is settled within a specific block",
                "Description": "\nThe settleAuction() function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic:\n\nsolidity\n  for (uint256 i = 0; i < pendingWeights.length; i++) {\n      uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n      require(IERC20(pendingTokens[i]).balanceOf(address(basket)) = tokensNeeded);\n  }\n\n\nThe attack vector here is to manipulate tokensNeeded to be 0. That way we can drain the basket completely without the function reverting.\n\nFor that, we manipulate newRatio to be 0 then the whole thing will be 0.\nnewRatio is defined as:\n\nsolidity\n  uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n  uint256 b = (bondBlock auctionStart) * BASE / factory.auctionDecrement();\n  uint256 newRatio = a b;\n\n\nThere's 1 value the attacker controls, bondBlock. That value is the block in which the bondForRebalance() function was triggered.\nSo the goal is to get newRatio to be 0. With the base settings of the contract:\n\n*   auctionMultiplier == 2\n*   ibRatio == 1e18\n*   BASE == 1e18\n*   auctionDecrement == 10000\n\nbondBlock has to be auctionStart + 20000. Meaning, the bondForRebalance() function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.\n\nAt that point, newRatio is 0, and thus tokensNeeded is 0. The only thing left to do is to call settleAuction() and pass the basket's tokens and balance as the output tokens and weight.\n\n\nHere's a test implementing the above scenario as a test. You can add it to Auction.test.js.:\n\njs\n      it.only(\"should allow me to steal funds\", async() = {\n        // start an auction\n        let NEW_UNI_WEIGHT = \"2400000000000000000\";\n        let NEW_COMP_WEIGHT = \"2000000000000000000\";\n        let NEW_AAVE_WEIGHT = \"400000000000000000\";\n\n        await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address], \n            NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;\n        await increaseTime(60 * 60 * 24)\n        await increaseTime(60 * 60 * 24)\n        await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address], \n          NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;\n\n        let auctionAddr = await basket.auction();\n        let auction = AuctionImpl.attach(auctionAddr);\n\n        ethers.provider.getBlockNumber();\n        // increase the block number for bondBlock auctionStart to be 20000.\n        // When that's the case, the result of newRatio in settleAuction() \n        // is 0. And that means tokensNeeded is 0. Which means,\n        // we can take out all the tokens we want using the outputTokens array\n        // without having to worry about basket's balance at the end.\n        // The math changes depending on the settings of the factory contract or the\n        // Basket contract. But, the gist is that you try to get newRatio to be 0.\n        // The only values you can control as a attacker is the bondBlock after the auction\n        // was started.\n        for (let i = 0; i < 20000; i++) {\n          await hre.network.provider.send(\"evm_mine\")\n        }\n        await basket.approve(auction.address, '5000000000000000');\n        await expect(auction.bondForRebalance()).to.be.ok;\n        await expect(auction.settleAuction([], ], ], UNI.address, AAVE.address], \"200720000000000000\", \"200120000000000000\"])).to.be.ok;\n      });\n\n\nAgain, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.\n\n",
                "Repair": "\n*   Verify that newRatio != 0\n\nfrank-beard (Kuiper) confirmed and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/74#issuecomment-1048137500):\n  This is the reasoning for the minIbRatio value that the publisher sets when rebalancing weights. However we do need a check to make sure that minIbRatio is above 0.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/74#issuecomment-1079813752):\n  I don't think this deserves a high severity rating. There are a number of assumptions made:\n  minIbRatio has not been set to an expected value.\n  The bonded user must be able to wait a certain number of blocks, likely exceeding the maximum amount of time allowed to settle the auction. This is currently set to one day. However, I understand that there might be some time that passes before a user bonds tokens and when the auction started.\n \n Because this issue is not directly exploitable, I think this behaviour fits the criteria of a medium severity issue.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\n    uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n    uint256 b = (bondBlock auctionStart) * BASE / factory.auctionDecrement();\n    uint256 newRatio = a b;\n\n    (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n    require(newRatio = minIbRatio);\n"
                ],
                "Type": "  Auction.sol#settleAuction()  Bonder may not be able to settle a bonded auction, leading to loss of funds",
                "Description": "\nAuction.sol#L97-L102(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102)\n\nsolidity\n    uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n    uint256 b = (bondBlock auctionStart) * BASE / factory.auctionDecrement();\n    uint256 newRatio = a b;\n\n    (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n    require(newRatio = minIbRatio);\n\n\nIn the current implementation, newRatio is calculated and compared with minIbRatio in settleAuction().\n\nHowever, if newRatio is less than minIbRatio, settleAuction() will always fail and there is no way for the bonder to cancel and get a refund.\n\n\nGiven:\n\n*   bondPercentDiv = 400\n*   basketToken.totalSupply = 40,000\n*   factory.auctionMultiplier = 2\n*   factory.auctionDecrement = 10,000\n*   basket.ibRatio = 1e18\n*   pendingWeights.minIbRatio = 1.9 * 1e18\n\n1.  Alice called bondForRebalance() 2,000 blocks after the auction started, paid 100 basketToken for the bond;\n2.  Alice tries to settleAuction(), it will always fail because newRatio < minIbRatio;\n\n*   a = 2 * 1e18\n*   b = 0.2 * 1e18\n*   newRatio = 1.8 * 1e18;\n\n3.  Bob calls bondBurn() one day after, 100 basketToken from Alice will been burned.\n\n",
                "Repair": "\nMove the minIbRatio check to bondForRebalance():\n\nsolidity\nfunction bondForRebalance() public override {\n    require(auctionOngoing);\n    require(!hasBonded);\n\n    bondTimestamp = block.timestamp;\n    bondBlock = block.number;\n\n    uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n    uint256 b = (bondBlock auctionStart) * BASE / factory.auctionDecrement();\n    uint256 newRatio = a b;\n\n    (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n    require(newRatio = minIbRatio);\n\n    IERC20 basketToken = IERC20(address(basket));\n    bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n    basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n    hasBonded = true;\n    auctionBonder = msg.sender;\n\n    emit Bonded(msg.sender, bondAmount);\n}\n\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106)\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106#issuecomment-1079817328):\n  While this issue is correct and I think this is a safer way to handle the require(newRatio = minIbRatio) check, there are a few assumptions that are made. For example, it is assumed that the user bonds their tokens without checking minIbRatio and a publisher is able to maliciously update minIbRatio which must first go through timelock. Based on this, I'm more inclined to downgrade this to medium severity as I think this more accurately reflects the threat model.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "//solidity\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;\nuint256 fee = startSupply * feePct / (BASE feePct);\n\n_mint(publisher, fee * (BASE factory.ownerSplit()) / BASE);\n_mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n"
                ],
                "Type": " Lost fees due to precision loss in fees calculation",
                "Description": "\nIn fees calculation, division is being used in the midst of the calculation, not at the end of it.\nThis leads to lost precision in fee amount (as solidity doesn't save remainder of division).\nDivision should happen at the end to maintain precision.\n\n\nLost fees.\nThe exact amount depends on the parameters set and being tested.\nAccording to a few tests I ran, it seems that in normal usage, 1% of fees are lost.\nIn some cases even 7.5% of fees.\n\n\nDivision in the midst of a calculation:\nsolidity\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;\nuint256 fee = startSupply * feePct / (BASE feePct);\n\n_mint(publisher, fee * (BASE factory.ownerSplit()) / BASE);\n_mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n\n\nBasket.sol#L140:#L145(https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L140:#L145)<br\nIt's a little hard to share a POC script as it involves changing the .sol file so I tested it manually. But after moving the division to the end using the mitigation below, I saw 1%-7% increases in fees minted. Usually 1%.\n\n",
                "Repair": "\nWe want to firstly do all multiplication and lastly do all the division.\nSo remove the usage of feePct and instead set fee to be:\nsolidity\nuint256 fee = startSupply * licenseFee * timeDiff / ONE_YEAR / (BASE licenseFee);\n\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/60)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/60#issuecomment-1079826919):\n  Nice find! I think this qualifies as medium risk due to the protocol regularly leaking value. This can be mitigated by performing division at the very end of the fee calculation.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-09",
                "Location": [],
                "Type": "  Basket:handleFees  fee calculation is wrong",
                "Description": "\nThe fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE feePct)\n\n\nThis shows dividing only by BASE is correct:<br\nAssumptions:\n\n*   BASE is 1e18 accordign to the code\n*   timeDiff is exactly ONE_YEAR (for easier calculations)\n*   startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms)\n*   licenseFee is 1e15 (0.1%)\n\nIf we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),\n\nuint256 timeDiff = ONE_YEAR;<br\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;<br\n= therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions<br\nuint256 fee = startSupply * feePct / BASE; // only divide by BASE<br\n= insert values = fee = 1e18 * licenseFee  / 1e18 = licenseFee\n\nThis shows the math is wrong:\n\nAssumptions:\n\n*   BASE is 1e18 according to the code\n*   timeDiff is exactly ONE_YEAR (for easier calculations)\n*   startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms)\n*   licenseFee is 1e15 (0.1%)\n\nIf we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.\n\nuint256 timeDiff = ONE_YEAR;<br\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;<br\n= therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions\n\nuint256 fee = startSupply * feePct / (BASE feePct);<br\ninsert the values = fee = 1e18 * 1e15 / (1e18 1e15) = (factor out 1e15) = fee = 1e15 * 1e18 / (1e15 * ( 1e3 1) = (cancel 1e15) = 1e18 / ( 1e3 1)\n\nmath: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2)<br\napply this here = 1e18 / ( 1e3 1)  1e18 / 1e3 = 1e18 / ( 1e3 1)  1e15  this shows that the fee is higher than 1e15\n\nBasket.sol#L133(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133)<br\nBasket.sol#L141(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141)\n\n",
                "Repair": "\nOnly divide by BASE.\n\nfrank-beard (Kuiper) confirmed(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/43)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/43#issuecomment-1079828004):\n  I think this is valid. Calculating fees as startSupply * feePct / (BASE feePct) leads to an overestimation of fees charged on users.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "//solidity\nuint256 timeDiff = (block.timestamp lastFee);\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;\nuint256 fee = startSupply * feePct / (BASE feePct);\n"
                ],
                "Type": " Fee calculation is slightly off",
                "Description": "\nThe fee calculation\nsolidity\nuint256 timeDiff = (block.timestamp lastFee);\nuint256 feePct = timeDiff * licenseFee / ONE_YEAR;\nuint256 fee = startSupply * feePct / (BASE feePct);\n\ntries to calculate a fee such that fee/(supply+fee) = %fee using a simple interest formula (i.e. no compounding), this lead to slightly less fee collected when fee are collected more frequently (small timeDiff) vs less frequently (big timeDiff).\n\n\nBasket.sol#L133(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133)\n\nfrank-beard (Kuiper) acknowledged, but disagreed with Medium severity and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/152#issuecomment-1048146206):\n  While this is technically true, the actual precision loss should be very negligible.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/152#issuecomment-1079829640):\n  I think any precision loss or value leakage qualifies for a medium severity issue. This seems like it would lead to an inconsistent fee calculation and is probably worthwhile fixing long-term.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "M-11",
                "Location": [],
                "Type": "  Basket:handleFees():  fees are overcharged",
                "Description": "\nThe fee calculation is based on the totalSupply of the basket token. But some amount of the totalSupply represents the fees paid to the publisher/ protocol owner. Therefore the fees are \"overcharged\":  because the fee amount is calculated on a part of already \"paid\" fees, should only take into account what is \"owned\"\nby the users and not the publisher/protocol owner.\n\n\nL141: the fee percent is multiplied by startSupply (=basket token total supply)<br\nL144 & L145: publisher / protocol owner receive basket tokens as fees payment<br\nBasket.sol#L141(https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141)\n\n",
                "Repair": "\n*   account the fee amount in a storage variable: uint256 feeAmount;\n*   subtract feeAmount from startSupply L141: uint256 fee = (startSupply feeAmount) * feePct / (BASE feePct); // note the other bug about only dividing by BASE\n*   add the fee to feeAmount after the calculation:  feeAmount += fee;\n*   if publisher/protocol owner burn basket token, reduce the feeAmount etc.\n\nfrank-beard (Kuiper) acknowledged and commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/170#issuecomment-1049062352):\n  Generally we think that the amount of overcharged fees from this matter will be very negligible in the long term. It is worth noting that the fix proposed would not really solve the problem as not all tokens owned by the publisher/owner may be fees as well as they could just transfer those fees to another account and burn from there.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/170#issuecomment-1079820186):\n  I'm not sure if this is correct. startSupply is indeed equal to totalSupply() but it is queried before new tokens are minted to the factory owner and publisher. As such, the fees appear to be correctly charged. I'll have @frank-beard confirm this as I may have missed something.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/170#issuecomment-1087492580):\n  Considering @frank-beard has not replied to this, I'm gonna make the final judgement and keep this open. I think it makes sense to track the fees paid out to the factory owner and publisher and have this amount excluded from the fee calculations. Upon either party burning tokens, this fee amount tracker must be updated accordingly. Due to the added complexity, it is understandable that this issue would be deemed a wontfix by the sponsor.\n\nfrank-beard (Kuiper) commented(https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/170#issuecomment-1087614572):\n  Yeah so I do agree that it does make sense generally to track the fees paid out and exclude, however in this case the impact is very low and yeah the complexity to deal with it doesn't seem worth it.\n\n\n\n*\n\n\n"
            }
        ]
    }
]