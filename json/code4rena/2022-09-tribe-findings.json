[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}\n\n\n",
        "CodeNames": [
            "TribeRedeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "tokensReceived",
                    "redeemedToken"
                ],
                "Type": " A malicious user can send tokens to the  TribeRedeemer  contract to make the redeem function work, and other users may lose assets as a result",
                "Description": "\nIn the TribeRedeemer contract, the user provides redeemedToken to redeem the tokens in the list.<br\nThe transaction will revert when the balance of tokens in the list is 0. This prevents the user from losing their redeemedToken if they redeem when there are no tokens in the contract.\n\n            for (uint256 i = 0; i < tokensReceived.length; i++) {\n                uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n                require(balance != 0, \"ZERO_BALANCE\");\n                // @dev, this assumes all of tokensReceived and redeemedToken\n                // have the same number of decimals\n                uint256 redeemedAmount = (amountIn * balance) / base;   // 10^6 * 10^18 / 10^8*10^6\n                amountsOut[i] = redeemedAmount;\n            }\n\nHowever, a malicious user could send tokens in the list to the TribeRedeemer contract so that the token balance is not 0. This would allow the redeem function to work, and the user would suffer a loss when they redeem early by mistake.\n\n\nTribeRedeemer.sol#L44-L61(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L44-L61)\n\n",
                "Repair": "\nConsider making the TribeRedeemer contract inherit the Pausable contract and allow users to redeem when a sufficient number of tokens have been sent to the contract.\n\nthomas-waite (FEI and TRIBE) disputed and commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/145#issuecomment-1251041522):\n  Do not understand what the issue presented is. If the attacker sends funds to the contract so the balances are not 0, then the user would be able to redeem as normal. How do they suffer any loss if they 'redeem early'?\n \n The balances will only be 0 when all users have redeemed. Not an issue.\n\ncccz (warden) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/145#issuecomment-1252333562):\n  @thomas-waite, consider the following scenario.\n 1. there are no reward tokens in the TribeRedeemer contract now, (the administrator will transfer 100M reward tokens to the contract in exchange for the user's redeemedToken only after some time).\n 2. when the user provides redeemedToken to call the redeem function, the transaction reverts in the previewRedeem function because the reward token balance is 0 (this prevents the user from getting 0 reward tokens).\n \n         for (uint256 i = 0; i < tokensReceived.length; i++) {\n             uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n             require(balance != 0, \"ZERO_BALANCE\");\n \n 3. a malicious user can send 100 reward tokens to the contract in  advance.\n 4. At this point, if the user calls the redeem function, the transaction will not revert and the contract will exchange the 100 reward tokens for the user's redeemedToken.\n The user could have exchanged the redeemedToken for more reward tokens, but the user only got a small amount of reward tokens\n\nhickuphh3 (judge) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/145#issuecomment-1260468321):\n  Redemptions can only begin when the contract has non-zero balances for all redeemed tokens, but the start redemption time isn't explicitly stated.\n \n Malicious users can break this assumption by sending paltry amounts to the contract as explained above. Naiive users might begin redemptions early, thus losing out on the tokens they would've otherwise received after the full redemption token amounts have been sent to the contract.\n \n It is unclear if there is a time lag between the contract deployment and time at which redemption funds are sent, and if so, its duration.\n \n While unlikely to happen, it would be a case of users losing out on rewards they should be entitled to. Hence, I'm siding with the warden in this instance.\n\nthomas-waite (FEI and TRIBE) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/145#issuecomment-1282382601):\n  @hickuphh3 , the contract gets deployed ahead of time by necessity (the address is needed for the DAO vote). The DAO vote which funds the contract executes after deployment, there is a time lag of = 3 days. \n \n I do not agree that the situation described is a vulnerability in the contract and instead it would be down to user/deployer error. Clearly, no user was encouraged to redeem before funds were available and the contract address was not publicised. So no user attempted to redeem before funds were available. \n\nhickuphh3 (judge) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/145#issuecomment-1282470073):\n  I respectfully disagree.\n \n There is no doubt that there are a number of prerequisites to enable this attack, which makes the likelihood low:\n Malicious actor has to know what the redeemer contract is\n Malicious actor has to deposit some tokens into redeemer contract\n Malicious actor must be able to trick users into redeeming early\n \n From a game theory POV, small TRIBE holders could band together to target a few large TRIBE holders.\n \n With these external requirements, it is only then that we will see what could be deemed as \"protocol leaked value\".\n \n  2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n \n The scenario thankfully remained hypothetical.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface ISaddleSwap {\n    // pool data view functions\n    function getA() external view returns (uint256);\n\n    function getToken(uint8 index) external view returns (IERC20);\n\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n    function getTokenBalance(uint8 index) external view returns (uint256);\n\n    function getVirtualPrice() external view returns (uint256);\n\n    // min return calculation functions\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\n\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n        external\n        view\n        returns (uint256 availableTokenAmount);\n\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function addLiquidity(\n        uint256[] calldata amounts,\n        uint256 minToMint,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256[] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline\n    ) external returns (uint256);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./Permissions.sol\";\nimport \"./ICore.sol\";\nimport \"../fei/Fei.sol\";\nimport \"../tribe/Tribe.sol\";\n\n/// @title Source of truth for Fei Protocol\n/// @author Fei Protocol\n/// @notice maintains roles, access control, fei, tribe, genesisGroup, and the TRIBE treasury\ncontract Core is ICore, Permissions, Initializable {\n    /// @notice the address of the FEI contract\n    IFei public override fei;\n\n    /// @notice the address of the TRIBE contract\n    IERC20 public override tribe;\n\n    function init() external override initializer {\n        _setupGovernor(msg.sender);\n\n        Fei _fei = new Fei(address(this));\n        _setFei(address(_fei));\n\n        Tribe _tribe = new Tribe(address(this), msg.sender);\n        _setTribe(address(_tribe));\n    }\n\n    /// @notice sets Fei address to a new address\n    /// @param token new fei address\n    function setFei(address token) external override onlyGovernor {\n        _setFei(token);\n    }\n\n    /// @notice sets Tribe address to a new address\n    /// @param token new tribe address\n    function setTribe(address token) external override onlyGovernor {\n        _setTribe(token);\n    }\n\n    /// @notice sends TRIBE tokens from treasury to an address\n    /// @param to the address to send TRIBE to\n    /// @param amount the amount of TRIBE to send\n    function allocateTribe(address to, uint256 amount) external override onlyGovernor {\n        IERC20 _tribe = tribe;\n        require(_tribe.balanceOf(address(this)) >= amount, \"Core: Not enough Tribe\");\n\n        _tribe.transfer(to, amount);\n\n        emit TribeAllocation(to, amount);\n    }\n\n    function _setFei(address token) internal {\n        fei = IFei(token);\n        emit FeiUpdate(token);\n    }\n\n    function _setTribe(address token) internal {\n        tribe = IERC20(token);\n        emit TribeUpdate(token);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\n\nlibrary Constants {\n    /// @notice the denominator for basis points granularity (10,000)\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    uint256 public constant ONE_YEAR = 365.25 days;\n\n    /// @notice the denominator for basis points granularity (10,000) expressed as an int data type\n    int256 public constant BP_INT = int256(BASIS_POINTS_GRANULARITY);\n\n    /// @notice WETH9 address\n    IWETH public constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /// @notice USD stand-in address\n    address public constant USD = 0x1111111111111111111111111111111111111111;\n\n    /// @notice Wei per ETH, i.e. 10**18\n    uint256 public constant ETH_GRANULARITY = 1e18;\n\n    /// @notice number of decimals in ETH, 18\n    uint256 public constant ETH_DECIMALS = 18;\n\n    /// @notice max-uint\n    uint256 public constant MAX_UINT = type(uint256).max;\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../../refs/CoreRef.sol\";\nimport \"../../core/TribeRoles.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IVeToken {\n    function balanceOf(address) external view returns (uint256);\n\n    function locked(address) external view returns (uint256);\n\n    function create_lock(uint256 value, uint256 unlock_time) external;\n\n    function increase_amount(uint256 value) external;\n\n    function increase_unlock_time(uint256 unlock_time) external;\n\n    function withdraw() external;\n\n    function locked__end(address) external view returns (uint256);\n\n    function checkpoint() external;\n\n    function commit_smart_wallet_checker(address) external;\n\n    function apply_smart_wallet_checker() external;\n}\n\n/// @title Vote-escrowed Token Manager\n/// Used to permanently lock tokens in a vote-escrow contract, and refresh\n/// the lock duration as needed.\n/// @author Fei Protocol\nabstract contract VoteEscrowTokenManager is CoreRef {\n    // Events\n    event Lock(uint256 cummulativeTokensLocked, uint256 lockHorizon);\n    event Unlock(uint256 tokensUnlocked);\n\n    /// @notice One week, in seconds. Vote-locking is rounded down to weeks.\n    uint256 private constant WEEK = 7 * 86400; // 1 week, in seconds\n\n    /// @notice The lock duration of veTokens\n    uint256 public lockDuration;\n\n    /// @notice The vote-escrowed token address\n    IVeToken public immutable veToken;\n\n    /// @notice The token address\n    IERC20 public immutable liquidToken;\n\n    /// @notice VoteEscrowTokenManager token Snapshot Delegator PCV Deposit constructor\n    /// @param _liquidToken the token to lock for vote-escrow\n    /// @param _veToken the vote-escrowed token used in governance\n    /// @param _lockDuration amount of time (in seconds) tokens will  be vote-escrowed for\n    constructor(\n        IERC20 _liquidToken,\n        IVeToken _veToken,\n        uint256 _lockDuration\n    ) {\n        liquidToken = _liquidToken;\n        veToken = _veToken;\n        lockDuration = _lockDuration;\n    }\n\n    /// @notice Set the amount of time tokens will be vote-escrowed for in lock() calls\n    function setLockDuration(uint256 newLockDuration) external onlyTribeRole(TribeRoles.METAGOVERNANCE_TOKEN_STAKING) {\n        lockDuration = newLockDuration;\n    }\n\n    /// @notice Deposit tokens to get veTokens. Set lock duration to lockDuration.\n    /// The only way to withdraw tokens will be to pause this contract\n    /// for lockDuration and then call exitLock().\n    function lock() external whenNotPaused onlyTribeRole(TribeRoles.METAGOVERNANCE_TOKEN_STAKING) {\n        uint256 tokenBalance = liquidToken.balanceOf(address(this));\n        uint256 locked = veToken.locked(address(this));\n        uint256 lockHorizon = ((block.timestamp + lockDuration) / WEEK) * WEEK;\n\n        // First lock\n        if (tokenBalance != 0 && locked == 0) {\n            liquidToken.approve(address(veToken), tokenBalance);\n            veToken.create_lock(tokenBalance, lockHorizon);\n        }\n        // Increase amount of tokens locked & refresh duration to lockDuration\n        else if (tokenBalance != 0 && locked != 0) {\n            liquidToken.approve(address(veToken), tokenBalance);\n            veToken.increase_amount(tokenBalance);\n            if (veToken.locked__end(address(this)) != lockHorizon) {\n                veToken.increase_unlock_time(lockHorizon);\n            }\n        }\n        // No additional tokens to lock, just refresh duration to lockDuration\n        else if (tokenBalance == 0 && locked != 0) {\n            veToken.increase_unlock_time(lockHorizon);\n        }\n        // If tokenBalance == 0 and locked == 0, there is nothing to do.\n\n        emit Lock(tokenBalance + locked, lockHorizon);\n    }\n\n    /// @notice Exit the veToken lock. For this function to be called and not\n    /// revert, tokens had to be locked previously, and the contract must have\n    /// been paused for lockDuration in order to prevent lock extensions\n    /// by calling lock(). This function will recover tokens on the contract,\n    /// which can then be moved by calling withdraw() as a PCVController if the\n    /// contract is also a PCVDeposit, for instance.\n    function exitLock() external onlyTribeRole(TribeRoles.METAGOVERNANCE_TOKEN_STAKING) {\n        veToken.withdraw();\n\n        emit Unlock(liquidToken.balanceOf(address(this)));\n    }\n\n    /// @notice returns total balance of tokens, vote-escrowed or liquid.\n    function _totalTokensManaged() internal view returns (uint256) {\n        return liquidToken.balanceOf(address(this)) + veToken.locked(address(this));\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./InterestRateModel.sol\";\n\nabstract contract CErc20Delegator is IERC20 {\n    address public implementation;\n    address public admin;\n    address public pendingAdmin;\n    address public interestRateModel;\n\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint256);\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public virtual returns (uint256);\n\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external virtual;\n\n    function redeemUnderlying(uint256 underlying) external virtual;\n\n    function _acceptAdmin() external virtual returns (uint256);\n\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256);\n\n    function borrow(uint256 mintAmount) external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external view virtual returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "ISaddleSwap.sol",
            "Core.sol",
            "Constants.sol",
            "TribeRedeemer.sol",
            "VoteEscrowTokenManager.sol",
            "CErc20Delegator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "_redeemedToken",
                    "redeemBase",
                    "ERC",
                    "_redeemBase",
                    "(x * tokenB.balanceOf(address(this))) / redeemBase",
                    "IERC",
                    "redeem",
                    "tokenA",
                    "_tokensReceived",
                    "tokenB"
                ],
                "Type": "  TribeRedeemer  will start redeeming incorrectly if someone transfer redeem tokens directly to it",
                "Description": "\nTribeRedeemer contract has one goal. It should take _redeemedToken(token that contract will accept from users), _tokensReceived list of exchange tokens(this are created exactly to be changed for redeemedToken) and _redeemBase amount of tokens that should be redeemed(this actually should be IERC20(_redeemedToken).totalSupply()). After that it will start redeeming _redeemedToken in exchange to _tokensReceived tokens.\n\nSuppose we have redeemed token tokenA with total supply of 10000 and redeemBase == 10000 . And in  _tokensReceived list we have only 1 token tokenB with total supply of 10000(all tokens are controlled by TribeRedeemer). According to logic of TribeRedeemer if user wants to redeem X tokens then he will receive (x * tokenB.balanceOf(address(this))) / redeemBase that in our case will be just amount X. So user send X tokenA and receive back X tokenB. Now because redeemBase == 10000 and contract balance of tokenB is 10000 the exchange ratio is 1:1.\n\nHowever if someone will transfer some amount of tokenA to TribeRedeemer contract directly using ERC20.transfer for example 500 tokens then it not call redeem function and redeemBase value will not be decreased with amount sent. That means that right now the exchange ratio should not be 1:1 as TribeRedeemer contract received more 500 tokens and didn't pay user for them(it should redeem that amount then with the next users, they share should be increased). So the next users will receive less amount then they should(TribeRedeemer should spend all tokenB amount in exchange of all tokenA tokens).\n\n\nHere is where amounOut is calculated.<br\nTribeRedeemer.sol#L58(https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L58)\n\nThis is where the redeemBase is decreased with redeem amount, but is not called because of direct transfer.<br\nTribeRedeemer.sol#L70(https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/shutdown/redeem/TribeRedeemer.sol#L70)\n\n",
                "Repair": "\nDo not use redeemBase for calculation amount of tokens that are left for redeeming. Use IERC20(_redeemedToken).totalSupply()) IERC20(_redeemedToken).balanceOf(address(this)).\n\nthomas-waite (FEI and TRIBE) disputed and commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1251061798):\n  Any redeemedTokens  sent to this contract will be locked and effectively burned. They are not to be used in the accounting of redemptions or redeemBase.\n\nhickuphh3 (judge) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1263045549):\n  Hmmm, the warden has a point actually. Currently, the rewards tied to TRIBE tokens that were sent directly to the contract instead of via redeem() becomes unrecoverable (burnt) as well.\n \n It's not a bad suggestion; it at least helps to split the rewards of directly sent TRIBE tokens with the remaining TRIBE holders, which acts as a form of reward recovery. \n \n The recommended mitigation is good, but perhaps modified to be an immutable value / constant _redeemBase, then the calculation becomes\n solidity\n uint256 redeemedAmount = (amountIn * balance) / (_redeemBase IERC20(_redeemedToken).balanceOf(address(this));\n \n \n Keeping the medium severity as it's an indirect loss of rewards that can be recovered / re-distributed.\n\nthomas-waite (FEI and TRIBE) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1282433980):\n  @hickuphh3 All TRIBE tokens have an equal claim to the funds that are locked in this contract, irrespective of what other TRIBE tokens do. \n \n The situation described is just a special case of TRIBE tokens being locked out of circulation. It's not feasible for this contract to account for all locations where user circulating TRIBE is subsequently locked/removed from circulation and nor is it particularly desired all TRIBE has an equal claim to the funds held on the contract. Dispute that this is an issue\n\nhickuphh3 (judge) decreased severity and commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1283041573):\n  Agree with the intention to keep all claims equal, and that it's not feasible to handle all outlier cases.\n \n Implementing the suggestion would change user behaviour to claim as late as possible, since the TRIBE amount that's mistakenly sent only increases over time.\n \n Downgrading to QA.\n\nrvierdiiev (warden) commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1283719350):\n  First of all I would like to say that current implementation of TribeRedeemer is not going to pay redeemers equal claims. This is important because the sponsor argues that if we change the implementation like I have suggested in submission, then next users will get more rewards. Also hickuphh3 said that this incentivize people to call redeem as late as possible to get bigger reward.\n \n I will explain why current implementation is not going to pay equal claims. This is because you can top up any exchange tokens directly(transfer to TribeRedeemer) and then next users will get bigger share than previous, because the formula uses exchange token balance to calculate reward amount.<br\n uint256 redeemedAmount = (amountIn * balance) / base;<br\n where balance is<br\n uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n \n So the assumption of sponsor about equal claims is not true.<br\n And also hickuphh3 assumption that my proposed change will push users to redeem tokens later is partly wrong. They are incentivized to do so already in current implementation(as someone can transfer some exchange token to the TribeReddemer).<br\n Why i suggested to use redeem token balance, because i saw in the code that TribeRedeemer is going to spend all exchange tokens for the redeemed tokens.\n \n All exhange tokens(tokensReceived in the code) are sent to the TribeRedeemer contract before and there is no way for TribeRedeemer to return any funds that are still controlled by contract. <br\n That means that the purpose of TribeRedeemer is to distribute all exchange tokens to the redeemers(there is no logic to leave some part of that tokens locked in the contract, it's better to distribute everything).\n \n Let's see 3 situations.<br\n 1. Someone top ups exchange tokens. Then TribeRedeemer will send more reward to all next users. Finally, TribeRedeemer will send users all the exchange tokens he had(so in the end when the last redeemed token is sent to TribeRedeemer, there is no exchange tokens controlled by TribeRedeemer).\n 2. Someone top ups redeem token(as i described in the submission). TribeRedeemer will still send users same part of exchange tokens. Finally, when all redeem tokens are controlled by TribeRedeemer, exchange token will have funds of TribeRedeemer that is not distributed among the redeemers. This funds are locked.\n 3. Someone top ups both exchange token and redeem token. At this time next users will have bigger reward than previous(so sponsors assumption is broken) and in the end some exchange token will still be controlled by TribeRedeemer.\n \n I hope, that I showed that current implementation can't guarantee equal rewards for users and it will be logical to use the way that i proposed to not just burn exchange tokens but distribute them among redeemers.<br\n If sponsor wants to pay equal claims, then he need to initialize TribeRedeemer with one more param exchangeTokensPerRedeemToken array where he can provide fixed amount of tokens to pay for redeemed token and use smth like this<br\n uint256 redeemedAmount = (amountIn * exchangeTokensPerRedeemToken) / base;\n \n Only in this case it's possible to get users equal claims.\n\nhickuphh3 (judge) increased severity to Medium and commented(https://github.com/code-423n4/2022-09-tribe-findings/issues/114#issuecomment-1285135454):\n  In the course of my investigation to see if a user has accidentally directly sent TRIBE to the redeemer contract, I have discovered that what @rvierdiiev said about equal claims is true:\n \n  And also hickuphh3 assumption that my proposed change will push users to redeem tokens later is partly wrong. They are incentivized to do so already in current implementation(as someone can transfer some exchange token to the TribeReddemer).\n \n The RGT reserve and timelock sent an additional ~430k DAI to the redeemer contract recently, after redemptions have begun:\n https://etherscan.io/tx/0xe0d2a879e05c8de8ebe23cef2f380fc68c1e52b21961b6650d076e9f839128f7\n https://etherscan.io/tx/0xab80a9982d45ced06f3f63e45a4fde5def2bc9270df0e639e9a9e84ba5a24528\n \n This user who redeemed close to 17M TRIBE(https://etherscan.io/tx/0xcd4d5e86e1b618f0fd0d9f919b7e9b559ed5c389c8c91ced361df6c00f3034e6) missed out on about 16856213429000000000000000 / 458964340000000000000000000 * 430000 ~= 15792.45 additional DAI.\n \n Hence, it is a fact that not all claims are equal; later claims have already benefitted from additional tokens that were sent to the redeemer contract.\n \n ---\n \n I've flipped flopped on my decision, but in light of what I found, my rationale for the downgrade no longer stands.\n \n  Implementing the suggestion would change user behaviour to claim as late as possible, since the TRIBE amount that's mistakenly sent only increases over time.\n \n As @rvierdiiev pointed out, this is already true, although I would argue that implementing this suggestion would worsen the problem.\n \n  The situation described is just a special case of TRIBE tokens being locked out of circulation. It's not feasible for this contract to account for all locations where user circulating TRIBE is subsequently locked/removed from circulation and nor is it particularly desired.\n \n I agree that the protocol should not be expected to handle all outlier cases; and that accidentally sending tokens to the redeemer contract is a special case. However, it is precisely because it is a boundary / special case that the protocol is able to handle and remedy; it most cases, it doesn't have the ability to do so. It's akin to token contracts blocking address(this) in to addresses. If a path exists to recover rewards that would've been lost together with the TRIBE tokens by redistributing it, why not?\n \n Keeping the medium severity as it fulfils the condition: protocol leaking value (rewards lost that in this case can be remedied) with a hypothetical attack path with stated assumptions, but external requirements. This vulnerability can also be classified as a user-error bug, which have been awarded up to medium severity in previous contests Eg. overpaying with ETH.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 101 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-09-tribe-findings/issues/237) by GalloDaSballo received the top score from the judge.\n\n*The following wardens also submitted reports: pauliax(https://github.com/code-423n4/2022-09-tribe-findings/issues/270), CertoraInc(https://github.com/code-423n4/2022-09-tribe-findings/issues/119), 0x1f8b(https://github.com/code-423n4/2022-09-tribe-findings/issues/92), hansfriese(https://github.com/code-423n4/2022-09-tribe-findings/issues/185), R2(https://github.com/code-423n4/2022-09-tribe-findings/issues/91), rbserver(https://github.com/code-423n4/2022-09-tribe-findings/issues/279), KIntern_NA(https://github.com/code-423n4/2022-09-tribe-findings/issues/199), Lambda(https://github.com/code-423n4/2022-09-tribe-findings/issues/53), rvierdiiev(https://github.com/code-423n4/2022-09-tribe-findings/issues/121), brgltd(https://github.com/code-423n4/2022-09-tribe-findings/issues/216), horsefacts(https://github.com/code-423n4/2022-09-tribe-findings/issues/257), Jeiwan(https://github.com/code-423n4/2022-09-tribe-findings/issues/32), pashov(https://github.com/code-423n4/2022-09-tribe-findings/issues/254), rotcivegaf(https://github.com/code-423n4/2022-09-tribe-findings/issues/255), unforgiven(https://github.com/code-423n4/2022-09-tribe-findings/issues/107), c3phas(https://github.com/code-423n4/2022-09-tribe-findings/issues/252), csanuragjain(https://github.com/code-423n4/2022-09-tribe-findings/issues/20), hyh(https://github.com/code-423n4/2022-09-tribe-findings/issues/233), izhuer(https://github.com/code-423n4/2022-09-tribe-findings/issues/248), ladboy233(https://github.com/code-423n4/2022-09-tribe-findings/issues/39), RaymondFam(https://github.com/code-423n4/2022-09-tribe-findings/issues/41), sorrynotsorry(https://github.com/code-423n4/2022-09-tribe-findings/issues/206), Tointer(https://github.com/code-423n4/2022-09-tribe-findings/issues/6), V_B(https://github.com/code-423n4/2022-09-tribe-findings/issues/266), 0xNazgul(https://github.com/code-423n4/2022-09-tribe-findings/issues/159), yixxas(https://github.com/code-423n4/2022-09-tribe-findings/issues/21), 0xSky(https://github.com/code-423n4/2022-09-tribe-findings/issues/222), cccz(https://github.com/code-423n4/2022-09-tribe-findings/issues/173), datapunk(https://github.com/code-423n4/2022-09-tribe-findings/issues/27), dipp(https://github.com/code-423n4/2022-09-tribe-findings/issues/122), Junnon(https://github.com/code-423n4/2022-09-tribe-findings/issues/138), Picodes(https://github.com/code-423n4/2022-09-tribe-findings/issues/31), Randyyy(https://github.com/code-423n4/2022-09-tribe-findings/issues/272), __141345__(https://github.com/code-423n4/2022-09-tribe-findings/issues/128), _Adam(https://github.com/code-423n4/2022-09-tribe-findings/issues/112), Aymen0909(https://github.com/code-423n4/2022-09-tribe-findings/issues/220), cryptphi(https://github.com/code-423n4/2022-09-tribe-findings/issues/200), d3e4(https://github.com/code-423n4/2022-09-tribe-findings/issues/253), innertia(https://github.com/code-423n4/2022-09-tribe-findings/issues/126), TomJ(https://github.com/code-423n4/2022-09-tribe-findings/issues/49), 0x4non(https://github.com/code-423n4/2022-09-tribe-findings/issues/103), 0x52(https://github.com/code-423n4/2022-09-tribe-findings/issues/224), Deivitto(https://github.com/code-423n4/2022-09-tribe-findings/issues/174), smiling_heretic(https://github.com/code-423n4/2022-09-tribe-findings/issues/51), wagmi(https://github.com/code-423n4/2022-09-tribe-findings/issues/209), djxploit(https://github.com/code-423n4/2022-09-tribe-findings/issues/258), fatherOfBlocks(https://github.com/code-423n4/2022-09-tribe-findings/issues/45), leosathya(https://github.com/code-423n4/2022-09-tribe-findings/issues/135), Mohandes(https://github.com/code-423n4/2022-09-tribe-findings/issues/171), simon135(https://github.com/code-423n4/2022-09-tribe-findings/issues/101), Sm4rty(https://github.com/code-423n4/2022-09-tribe-findings/issues/225), Tomo(https://github.com/code-423n4/2022-09-tribe-findings/issues/149), oyc_109(https://github.com/code-423n4/2022-09-tribe-findings/issues/48), rokinot(https://github.com/code-423n4/2022-09-tribe-findings/issues/108), Samatak(https://github.com/code-423n4/2022-09-tribe-findings/issues/58), 0xSmartContract(https://github.com/code-423n4/2022-09-tribe-findings/issues/247), Waze(https://github.com/code-423n4/2022-09-tribe-findings/issues/104), ak1(https://github.com/code-423n4/2022-09-tribe-findings/issues/215), Bnke0x0(https://github.com/code-423n4/2022-09-tribe-findings/issues/22), Chom(https://github.com/code-423n4/2022-09-tribe-findings/issues/193), cryptonue(https://github.com/code-423n4/2022-09-tribe-findings/issues/204), delfin454000(https://github.com/code-423n4/2022-09-tribe-findings/issues/156), JC(https://github.com/code-423n4/2022-09-tribe-findings/issues/262), lucacez(https://github.com/code-423n4/2022-09-tribe-findings/issues/265), prasantgupta52(https://github.com/code-423n4/2022-09-tribe-findings/issues/238), robee(https://github.com/code-423n4/2022-09-tribe-findings/issues/73), Rohan16(https://github.com/code-423n4/2022-09-tribe-findings/issues/245), scaraven(https://github.com/code-423n4/2022-09-tribe-findings/issues/164), ajtra(https://github.com/code-423n4/2022-09-tribe-findings/issues/221), erictee(https://github.com/code-423n4/2022-09-tribe-findings/issues/7), lukris02(https://github.com/code-423n4/2022-09-tribe-findings/issues/168), ReyAdmirado(https://github.com/code-423n4/2022-09-tribe-findings/issues/14), sach1r0(https://github.com/code-423n4/2022-09-tribe-findings/issues/43), a12jmx(https://github.com/code-423n4/2022-09-tribe-findings/issues/280), cryptostellar5(https://github.com/code-423n4/2022-09-tribe-findings/issues/250), Diana(https://github.com/code-423n4/2022-09-tribe-findings/issues/251), Funen(https://github.com/code-423n4/2022-09-tribe-findings/issues/180), Rolezn(https://github.com/code-423n4/2022-09-tribe-findings/issues/3), 0x040(https://github.com/code-423n4/2022-09-tribe-findings/issues/269), asutorufos(https://github.com/code-423n4/2022-09-tribe-findings/issues/260), Chandr(https://github.com/code-423n4/2022-09-tribe-findings/issues/139), durianSausage(https://github.com/code-423n4/2022-09-tribe-findings/issues/44), gogo(https://github.com/code-423n4/2022-09-tribe-findings/issues/74), mics(https://github.com/code-423n4/2022-09-tribe-findings/issues/78), ret2basic(https://github.com/code-423n4/2022-09-tribe-findings/issues/196), bharg4v(https://github.com/code-423n4/2022-09-tribe-findings/issues/259), got_targ(https://github.com/code-423n4/2022-09-tribe-findings/issues/261), ignacio(https://github.com/code-423n4/2022-09-tribe-findings/issues/236), karanctf(https://github.com/code-423n4/2022-09-tribe-findings/issues/207), Noah3o6(https://github.com/code-423n4/2022-09-tribe-findings/issues/26), Ocean_Sky(https://github.com/code-423n4/2022-09-tribe-findings/issues/191), sikorico(https://github.com/code-423n4/2022-09-tribe-findings/issues/79), Tagir2003(https://github.com/code-423n4/2022-09-tribe-findings/issues/84), 0x85102(https://github.com/code-423n4/2022-09-tribe-findings/issues/123), bobirichman(https://github.com/code-423n4/2022-09-tribe-findings/issues/76), CodingNameKiki(https://github.com/code-423n4/2022-09-tribe-findings/issues/8), rfa(https://github.com/code-423n4/2022-09-tribe-findings/issues/263), SnowMan(https://github.com/code-423n4/2022-09-tribe-findings/issues/127), SooYa(https://github.com/code-423n4/2022-09-tribe-findings/issues/219), and StevenL(https://github.com/code-423n4/2022-09-tribe-findings/issues/124).*\n\n## Executive Summary\n\nPersonally haven't found any glaring vulnerability.\n\nBecause of the mix of immutability and Admin Trust, end users should review the deployment settings at that time to ensure that no misconfigurations have happened.\n\nIn case any misconfigurations happens, a new deployment will be required.\n\nListed below are some observations of things that could be refactored to make the code more consistent, as well as some gotchas that are introduced by the choice of architecture.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Abstract contract for exchange a number of ERC20 tokens for specific base token, permissioned via Merkle root(s)\n/// @notice This contract assumes that the users must sign a message to redeem tokens\n/// @author kryptoklob\nabstract contract MultiMerkleRedeemer {\n    /** ---------- Events ----------------------- **/\n\n    /// @notice Emitted when a user signs for the first time; should only be emitted once per user\n    /// @param signer the person singing; msg.sender\n    /// @param signature the signed message hash\n    event Signed(address indexed signer, bytes signature);\n\n    /// @notice Emitted when a user completes a claim on a cToken; should only be emitted once per user per cToken at most\n    /// @param claimant the person claiming; msg.sender\n    /// @param cToken the cToken being claimed on\n    /// @param claimAmount the amount the user says he has claim to; verified by Merkle root\n    event Claimed(address indexed claimant, address indexed cToken, uint256 claimAmount);\n\n    /// @notice Emitted when a user exchanges an amount of cTokens for the base token; can happen any number of times per user & cToken\n    /// @param recipient the user; msg.sender\n    /// @param cToken the cToken being exchange for the baseToken\n    /// @param cTokenAmount the amount of cTokens being exchanged\n    /// @param baseTokenAmount the amount of baseTokens being received\n    event Redeemed(address indexed recipient, address indexed cToken, uint256 cTokenAmount, uint256 baseTokenAmount);\n\n    /** ---------- Storage / Configuration ------ **/\n\n    /// @notice The address of the token that will be exchange for cTokens\n    address public baseToken;\n\n    /// @notice The merkle roots that permission users to claim cTokens; one root per cToken\n    mapping(address => bytes32) public merkleRoots;\n\n    /// @notice Exchange rate of the base asset per each cToken\n    mapping(address => uint256) public cTokenExchangeRates;\n\n    /// @notice Stores user signatures; one signature per user, can only be provided once\n    mapping(address => bytes) public userSignatures;\n\n    /// @notice The amount of cTokens a user has redeemed, indexed first by user address, then by cToken address\n    /// @dev This value starts at zero and can only increase\n    mapping(address => mapping(address => uint256)) public redemptions;\n\n    /// @notice The amount of cTokens a user in their claim, total; indexed first by user address, then by cToken address\n    /// @dev This value is set when a user proves their claim on a particular cToken, and cannot change once set\n    mapping(address => mapping(address => uint256)) public claims;\n\n    /// @notice The message to be signed by any users claiming on cTokens\n    string public constant MESSAGE = \"Sample message, please update.\";\n\n    /// @notice The hash of the message to be signed by any users claiming on cTokens\n    bytes32 public MESSAGE_HASH = ECDSA.toEthSignedMessageHash(bytes(MESSAGE));\n\n    /** ---------- Public State-Changing Funcs ----------------- **/\n\n    /// @notice Stores a user's signature (of the message stored in MESSAGE)\n    /// @param _signature the user's signature, encoded as a bytes array\n    /// @dev Signature must be encoded into a packed length of 65 bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    function sign(bytes calldata _signature) external virtual;\n\n    /// @notice Prove a claim on a particular cToken. Amount provided must match the amount in the merkle tree\n    /// @param _cToken the cToken being claimed\n    /// @param _amount the amount of the particular cToken to claim\n    /// @param _merkleProof the merkle proof for the claim\n    /// @dev This should set the user's claim for this cToken in the \"claims\" mapping\n    function claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external virtual;\n\n    /// @notice Plural version of claim. Amounts provided must match the amounts in the merkle trees\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amounts the amounts of each particular cToken to claim\n    /// @param _merkleProofs the merkle proofs for each claim\n    /// @dev This should set the user's claim for *each* cToken in the \"claims\" mapping\n    function multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /// @notice Redeem an amount of the specified cToken.\n    /// @dev Requires an approval of the specified amount of the specified cToken to this contract.\n    /// Should increment the user's redeemed amount for this cToken in the \"redeemed\" mapping.\n    function redeem(address cToken, uint256 cTokenAmount) external virtual;\n\n    /// @notice Redeem an amount of each of the specified cTokens\n    /// @dev Requires an approval of the specified amount of each of the specified cTokens to this contract\n    /// Should increment the user's redeemed amount for each cToken in the \"redeemed\" mapping\n    function multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts) external virtual;\n\n    /// @notice Combines sign and claim into a single function\n    /// @param _signature the user's signature, encoded as a 65-length bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amounts the amounts of each cToken to claim\n    /// @param _merkleProofs the merkle proofs for each claim\n    function signAndClaim(\n        bytes calldata _signature,\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /// @notice Combines sign, claim, and redeem into a single function\n    /// @param _signature the user's signature, encoded as a 65-length bytes: bytes.concat(bytes32(r), bytes32(s), bytes1(v));\n    /// @param _cTokens the cTokens being claimed\n    /// @param _amountsToClaim the amounts of each cToken to claim; should match the merkle proofs\n    /// @param _amountsToRedeem the amounts of each cToken to redeem; must be greater than 0 for each cToken provided\n    /// @param _merkleProofs the merkle proofs for each claim\n    function signAndClaimAndRedeem(\n        bytes calldata _signature,\n        address[] calldata _cTokens,\n        uint256[] calldata _amountsToClaim,\n        uint256[] calldata _amountsToRedeem,\n        bytes32[][] calldata _merkleProofs\n    ) external virtual;\n\n    /** ---------- Public View/Pure Functions ---------- **/\n\n    /// @notice Returns the amount of the base token that can be exchanged for the specified cToken\n    function previewRedeem(address cToken, uint256 amount) external virtual returns (uint256 baseTokenAmount);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity =0.8.10;\n\nimport \"../../refs/CoreRef.sol\";\nimport \"./MultiMerkleRedeemer.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Contract for exchanging cTokens for a specific base token, permissioned via Merkle Roots\n/// @notice This implementation is specific to the Rari Redemption as described in TIP-121\n/// @dev See MultiMerkleRedeemer natspec for most public functions\n/// @author kryptoklob\ncontract RariMerkleRedeemer is MultiMerkleRedeemer, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    modifier hasSigned() {\n        require(keccak256(userSignatures[msg.sender]) != keccak256(userSignatures[address(0)]), \"User has not signed.\");\n        _;\n    }\n\n    modifier hasNotSigned() {\n        require(\n            keccak256(userSignatures[msg.sender]) == keccak256(userSignatures[address(0)]),\n            \"User has already signed\"\n        );\n        _;\n    }\n\n    /// @param token The token that will be received when exchanging cTokens\n    /// @param cTokens The supported cTokens; must be exactly 27 tokens\n    /// @param rates The exchange rate for each cToken; must be exactly 27 rates\n    /// @param roots The merkle root for each cToken; must be exactly 27 roots\n    constructor(\n        address token,\n        address[] memory cTokens,\n        uint256[] memory rates,\n        bytes32[] memory roots\n    ) {\n        _configureExchangeRates(cTokens, rates);\n        _configureMerkleRoots(cTokens, roots);\n        _configureBaseToken(token);\n    }\n\n    /** ---------- Public State-Changing Funcs ----------------- **/\n\n    function sign(bytes calldata signature) external override hasNotSigned nonReentrant {\n        _sign(signature);\n    }\n\n    function claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) external override hasSigned nonReentrant {\n        _claim(_cToken, _amount, _merkleProof);\n    }\n\n    function multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) external override hasSigned nonReentrant {\n        _multiClaim(_cTokens, _amounts, _merkleProofs);\n    }\n\n    function redeem(address cToken, uint256 cTokenAmount) external override hasSigned nonReentrant {\n        _redeem(cToken, cTokenAmount);\n    }\n\n    function multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts)\n        external\n        override\n        hasSigned\n        nonReentrant\n    {\n        _multiRedeem(cTokens, cTokenAmounts);\n    }\n\n    function previewRedeem(address cToken, uint256 amount) public view override returns (uint256 baseTokenAmount) {\n        // Each ctoken exchange rate is stored as how much you should get for 1e18 of the particular cToken\n        // Thus, we divide by 1e18 when returning the amount that a person should get when they provide\n        // the amount of cTokens they're turning into the contract\n        return (cTokenExchangeRates[cToken] * amount) / 1e18;\n    }\n\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n\n    function claimAndRedeem(\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external hasSigned nonReentrant {\n        _multiClaim(cTokens, amounts, merkleProofs);\n        _multiRedeem(cTokens, amounts);\n    }\n\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n\n    /** ---------- Internal Funcs --------------- **/\n\n    // The exchange rates provided should represent how much of the base token will be given\n    // in exchange for 1e18 cTokens. This increases precision.\n    function _configureExchangeRates(address[] memory _cTokens, uint256[] memory _exchangeRates) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 exchange rates.\");\n        require(_cTokens.length == _exchangeRates.length, \"Exchange rates must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(\n                _exchangeRates[i] > 1e10,\n                \"Exchange rate must be greater than 1e10. Did you forget to multiply by 1e18?\"\n            );\n            cTokenExchangeRates[_cTokens[i]] = _exchangeRates[i];\n        }\n    }\n\n    function _configureMerkleRoots(address[] memory _cTokens, bytes32[] memory _roots) internal {\n        require(_cTokens.length == 27, \"Must provide exactly 27 merkle roots\");\n        require(_cTokens.length == _roots.length, \"Merkle roots must be provided for each cToken\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            require(_roots[i] != bytes32(0), \"Merkle root must be non-zero\");\n            merkleRoots[_cTokens[i]] = _roots[i];\n        }\n    }\n\n    function _configureBaseToken(address _baseToken) internal {\n        require(_baseToken != address(0), \"Base token must be non-zero\");\n        baseToken = _baseToken;\n    }\n\n    // User provides signature, which is checked against their address and the string constant \"message\"\n    function _sign(bytes calldata _signature) internal virtual {\n        // check: to ensure the signature is a valid signature for the constant message string from msg.sender\n        require(ECDSA.recover(MESSAGE_HASH, _signature) == msg.sender, \"Signature not valid\");\n\n        // effect: update user's stored signature\n        userSignatures[msg.sender] = _signature;\n\n        emit Signed(msg.sender, _signature);\n    }\n\n    // User provides the the cToken & the amount they should get, and it is verified against the merkle root for that cToken\n    /// Should set the user's claim amount int he claims mapping for the provided cToken\n    function _claim(\n        address _cToken,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal virtual {\n        // check: verify that claimableAmount is zero, revert if not\n        require(claims[msg.sender][_cToken] == 0, \"User has already claimed for this cToken.\");\n\n        // check: verify cToken and amount and msg.sender against merkle root\n        bytes32 leafHash = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verifyCalldata(_merkleProof, merkleRoots[_cToken], leafHash), \"Merkle proof not valid.\");\n\n        // effect: update claimableAmount for the user\n        claims[msg.sender][_cToken] = _amount;\n\n        emit Claimed(msg.sender, _cToken, _amount);\n    }\n\n    // User provides the cTokens & the amounts they should get, and it is verified against the merkle root for that cToken (for each cToken provided)\n    // Should set the user's claim amount in the claims mapping for each cToken provided\n    function _multiClaim(\n        address[] calldata _cTokens,\n        uint256[] calldata _amounts,\n        bytes32[][] calldata _merkleProofs\n    ) internal virtual {\n        require(_cTokens.length == _amounts.length, \"Number of cTokens and amounts must match\");\n        require(_cTokens.length == _merkleProofs.length, \"Number of cTokens and merkle proofs must match\");\n\n        for (uint256 i = 0; i < _cTokens.length; i++) {\n            _claim(_cTokens[i], _amounts[i], _merkleProofs[i]);\n        }\n\n        // no events needed here, they happen in _claim\n    }\n\n    // Transfers in a particular amount of the user's cToken, and increments their redeemed amount in the redemption mapping\n    function _redeem(address cToken, uint256 cTokenAmount) internal virtual {\n        // check: amount must be greater than 0\n        require(cTokenAmount != 0, \"Invalid amount\");\n\n        // check: verify that the user's claimedAmount+amount of this cToken doesn't exceed claimableAmount for this cToken\n        require(\n            redemptions[msg.sender][cToken] + cTokenAmount <= claims[msg.sender][cToken],\n            \"Amount exceeds available remaining claim.\"\n        );\n\n        // effect: increment the user's claimedAmount\n        redemptions[msg.sender][cToken] += cTokenAmount;\n\n        uint256 baseTokenAmountReceived = previewRedeem(cToken, cTokenAmount);\n\n        // interaction: safeTransferFrom the user \"amount\" of \"cToken\" to this contract\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount);\n        IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n\n        emit Redeemed(msg.sender, cToken, cTokenAmount, baseTokenAmountReceived);\n    }\n\n    // Plural form of _redeem\n    // Doesn't actually call _redeem so that we can separate out the interactions into their own section\n    function _multiRedeem(address[] calldata cTokens, uint256[] calldata cTokenAmounts) internal virtual {\n        // check : cTokens.length must equal amounts.length\n        require(cTokens.length == cTokenAmounts.length, \"Length of cTokens and amounts must match.\");\n\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            // check: cToken cannot be the zero address\n            require(cTokens[i] != address(0), \"Invalid cToken address\");\n\n            // check: amount must be greater than 0\n            require(cTokenAmounts[i] != 0, \"Invalid amount\");\n\n            // check: amount is less than or equal to the user's claimableAmount-claimedAmount for this cToken\n            require(\n                redemptions[msg.sender][cTokens[i]] + cTokenAmounts[i] <= claims[msg.sender][cTokens[i]],\n                \"Amount exceeds available remaining claim.\"\n            );\n\n            // effect: increment the user's claimedAmount\n            redemptions[msg.sender][cTokens[i]] += cTokenAmounts[i];\n        }\n\n        // We give the interactions (the safeTransferFroms) their own for loop, juuuuust to be safe\n        for (uint256 i = 0; i < cTokens.length; i++) {\n            uint256 baseTokenAmountReceived = previewRedeem(cTokens[i], cTokenAmounts[i]);\n            IERC20(cTokens[i]).safeTransferFrom(msg.sender, address(this), cTokenAmounts[i]);\n            IERC20(baseToken).safeTransfer(msg.sender, baseTokenAmountReceived);\n            emit Redeemed(msg.sender, cTokens[i], cTokenAmounts[i], baseTokenAmountReceived);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "MultiMerkleRedeemer.sol",
            "RariMerkleRedeemer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": [
                    "//solidity\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n",
                    "//solidity\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n"
                ],
                "Type": " Inconsistent usage of  hasNotSigned ",
                "Description": "\nsignAndClaimAndRedeem has the modifier while signAndClaim doesn't.\n\nRariMerkleRedeemer.sol#L108-L118(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L108-L118)\n\nsolidity\n    function signAndClaimAndRedeem(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amountsToClaim,\n        uint256[] calldata amountsToRedeem,\n        bytes32[][] calldata merkleProofs\n    ) external override hasNotSigned nonReentrant {\n        _sign(signature);\n        _multiClaim(cTokens, amountsToClaim, merkleProofs);\n        _multiRedeem(cTokens, amountsToRedeem);\n    }\n\n\nDoesn't have the modifier<br\nRariMerkleRedeemer.sol#L88-L97(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/RariMerkleRedeemer.sol#L88-L97)\n\nsolidity\n    function signAndClaim(\n        bytes calldata signature,\n        address[] calldata cTokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata merkleProofs\n    ) external override nonReentrant {\n        // both sign and claim/multiclaim will revert on invalid signatures/proofs\n        _sign(signature);\n        _multiClaim(cTokens, amounts, merkleProofs);\n    }\n\n\n\nAdd the modifier hasNotSigned for consistency, or remove the modifier altogether and allow to sign multiple times the same message.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../shutdown/fuse/RariMerkleRedeemer.sol\";\n\ncontract MockRariMerkleRedeemerNoSigs is RariMerkleRedeemer {\n    constructor(\n        address token,\n        address[] memory cTokens,\n        uint256[] memory rates,\n        bytes32[] memory roots\n    ) RariMerkleRedeemer(token, cTokens, rates, roots) {}\n\n    // User provides signature, which is checked against their address and the string constant \"message\"\n    function _sign(bytes calldata _signature) internal override {\n        // check: ensure that the user hasn't yet signed\n        // note: you can't directly compare bytes storage ref's to each other, but you can keccak the empty bytes\n        // such as the one from address zero, and compare this with the keccak'd other bytes; msg.sender *cannot* be the zero address\n        require(\n            keccak256(userSignatures[msg.sender]) == keccak256(userSignatures[address(0)]),\n            \"User has already signed\"\n        );\n\n        // check: to ensure the signature is a valid signature for the constant message string from msg.sender\n        // @todo - do we want to use this, which supports ERC1271, or *just* EOA signatures?\n        // @dev signature check *reomved* for testing\n        //require(SignatureChecker.isValidSignatureNow(msg.sender, MESSAGE_HASH, _signature), \"Signature not valid.\");\n\n        // effect: update user's stored signature\n        userSignatures[msg.sender] = _signature;\n    }\n}\n\n\n",
        "CodeNames": [
            "MockRariMerkleRedeemerNoSigs.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "2",
                "Location": [
                    "//solidity\n    string public constant MESSAGE = \"Sample message, please update.\";\n\n"
                ],
                "Type": " Left the Default  MESSAGE_HASH ",
                "Description": "\nFor the in-scope code MESSAGE is left to the default value\n\nMultiMerkleRedeemer.sol#L53-L54(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/MultiMerkleRedeemer.sol#L53-L54)\n\nsolidity\n    string public constant MESSAGE = \"Sample message, please update.\";\n\n\n\nThis could cause the signature to be replayable in other applications that use the same message.\n\n\nAdd the proper message, most likely a TOS acknowledgement or a ipfs hash to a document.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.4;\n\nimport \"./../PCVDeposit.sol\";\nimport \"./../../utils/Timed.sol\";\n\ncontract ERC20Dripper is PCVDeposit, Timed {\n    using Address for address payable;\n\n    /// @notice event emitted when tokens are dripped\n    event Dripped(uint256 amount);\n\n    /// @notice target address to drip tokens to\n    address public target;\n    /// @notice target token address to send\n    address public token;\n    /// @notice amount to drip after each window\n    uint256 public amountToDrip;\n\n    /// @notice ERC20 PCV Dripper constructor\n    /// @param _core Fei Core for reference\n    /// @param _target address to drip to\n    /// @param _frequency frequency of dripping (note: not actually frequency, but 1/frequency, aka period)\n    /// @param _amountToDrip amount to drip on each drip\n    /// @param _token amount to drip on each drip\n    constructor(\n        address _core,\n        address _target,\n        uint256 _frequency,\n        uint256 _amountToDrip,\n        address _token\n    ) CoreRef(_core) Timed(_frequency) {\n        require(_target != address(0), \"ERC20Dripper: invalid address\");\n        require(_token != address(0), \"ERC20Dripper: invalid token address\");\n        require(_amountToDrip > 0, \"ERC20Dripper: invalid drip amount\");\n\n        target = _target;\n        amountToDrip = _amountToDrip;\n        token = _token;\n\n        // start timer\n        _initTimed();\n    }\n\n    /// @notice drip ERC20 tokens to target\n    function drip() public virtual afterTime whenNotPaused {\n        // reset timer\n        _initTimed();\n\n        // drip\n        _withdrawERC20(token, target, amountToDrip);\n        emit Dripped(amountToDrip);\n    }\n\n    /// @notice withdraw tokens from the PCV allocation\n    /// @param amountUnderlying of tokens withdrawn\n    /// @param to the address to send PCV to\n    function withdraw(address to, uint256 amountUnderlying) external override onlyPCVController {\n        _withdrawERC20(address(token), to, amountUnderlying);\n    }\n\n    /// @notice no-op\n    function deposit() external override {}\n\n    /// @notice returns total balance of PCV in the Deposit\n    function balance() public view override returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n\n    /// @notice display the related token of the balance reported\n    function balanceReportedIn() public view override returns (address) {\n        return token;\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20Dripper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "3",
                "Location": [
                    "//solidity\n            IERC20(token).balanceOf(target) < amountToDrip,\n\n"
                ],
                "Type": " Technically the maximum amount at risk is  amountToDrip &ast; 2 - 1 ",
                "Description": "\nWhile the code is meant to limit the total asset at risk, it's important to notice that because of the following check:\n\nMerkleRedeemerDripper.sol#L23-L24(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/fuse/MerkleRedeemerDripper.sol#L23-L24)\n\nsolidity\n            IERC20(token).balanceOf(target) < amountToDrip,\n\n\n\nAny balance below amountToDrip, after enough time has passed, will alow to drip more, meaning the total amount at risk is not amountToDrip but up to 2 * amountToDrip 1.\n\n\nI recommend commenting this.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../fei/Fei.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @notice contract to create a permanent governanceless FEI-DAI PSM\n/// As long as Tribe DAO's governance is active, the funds in this contract\n/// can still be accessed : the Tribe DAO can mint FEI at will and get the DAI\n/// in this contract, and could revoke the MINTER role from this contract,\n/// preventing it to create new FEI.\n/// This contract acts as a FEI sink and can burn the FEI it holds.\n/// Burning the MINTER_ROLE from the Tribe DAO will make this PSM act\n/// like a permanent feeless FEI-DAI wrapper.\ncontract SimpleFeiDaiPSM {\n    using SafeERC20 for Fei;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    Fei private constant FEI = Fei(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);\n\n    // ----------------------------------------------------------------------------\n    // Peg Stability Module functionalities\n    // ----------------------------------------------------------------------------\n\n    /// @notice event emitted upon a redemption\n    event Redeem(address to, uint256 amountFeiIn, uint256 amountAssetOut);\n    /// @notice event emitted when fei gets minted\n    event Mint(address to, uint256 amountIn, uint256 amountFeiOut);\n\n    /// @notice mint `amountFeiOut` FEI to address `to` for `amountIn` underlying tokens\n    /// @dev see getMintAmountOut() to pre-calculate amount out\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountFeiOut) {\n        amountFeiOut = amountIn;\n        require(amountFeiOut >= minAmountOut, \"SimpleFeiDaiPSM: Mint not enough out\");\n        DAI.safeTransferFrom(msg.sender, address(this), amountIn);\n        FEI.mint(to, amountFeiOut);\n        emit Mint(to, amountIn, amountIn);\n    }\n\n    /// @notice redeem `amountFeiIn` FEI for `amountOut` underlying tokens and send to address `to`\n    /// @dev see getRedeemAmountOut() to pre-calculate amount out\n    /// @dev FEI received is not burned, see `burnFeiHeld()` below to batch-burn the FEI redeemed\n    function redeem(\n        address to,\n        uint256 amountFeiIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        amountOut = amountFeiIn;\n        require(amountOut >= minAmountOut, \"SimpleFeiDaiPSM: Redeem not enough out\");\n        FEI.safeTransferFrom(msg.sender, address(this), amountFeiIn);\n        DAI.safeTransfer(to, amountOut);\n        emit Redeem(to, amountFeiIn, amountFeiIn);\n    }\n\n    /// @notice calculate the amount of FEI out for a given `amountIn` of underlying\n    function getMintAmountOut(uint256 amountIn) external pure returns (uint256) {\n        return amountIn;\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountFeiIn` of FEI\n    function getRedeemAmountOut(uint256 amountIn) external pure returns (uint256) {\n        return amountIn;\n    }\n\n    // ----------------------------------------------------------------------------\n    // Functions to make this contract compatible with the PCVDeposit interface\n    // and accounted for in the Fei Protocol's Collateralization Oracle\n    // ----------------------------------------------------------------------------\n\n    address public constant balanceReportedIn = address(DAI);\n\n    /// @notice gets the effective balance of \"balanceReportedIn\" token if the deposit were fully withdrawn\n    function balance() external view returns (uint256) {\n        return DAI.balanceOf(address(this));\n    }\n\n    /// @notice gets the resistant token balance and protocol owned fei of this deposit\n    function resistantBalanceAndFei() external view returns (uint256, uint256) {\n        return (DAI.balanceOf(address(this)), FEI.balanceOf(address(this)));\n    }\n\n    // ----------------------------------------------------------------------------\n    // These view functions are meant to make this contract's interface\n    // as similar as possible to the FixedPricePSM as possible.\n    // ----------------------------------------------------------------------------\n\n    uint256 public constant mintFeeBasisPoints = 0;\n    uint256 public constant redeemFeeBasisPoints = 0;\n    address public constant underlyingToken = address(DAI);\n    uint256 public constant getMaxMintAmountOut = type(uint256).max;\n    bool public constant paused = false;\n    bool public constant redeemPaused = false;\n    bool public constant mintPaused = false;\n\n    // ----------------------------------------------------------------------------\n    // This contract should act as a FEI sink if needed\n    // ----------------------------------------------------------------------------\n\n    /// @notice Burns all FEI on this contract.\n    function burnFeiHeld() external {\n        uint256 feiBalance = FEI.balanceOf(address(this));\n        if (feiBalance != 0) {\n            FEI.burn(feiBalance);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "SimpleFeiDaiPSM.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "4",
                "Location": [
                    "//solidity\n        require(amountOut = minAmountOut, \"SimpleFeiDaiPSM: Redeem not enough out\");\n\n"
                ],
                "Type": " Tautology, slippage check is ineffective",
                "Description": "\nBecause amountOut = amountFeiIn; and amountFeiOut = amountIn; there is no slippage, and no risk for any front-run.\n\nThe check below is always true for that reason:\n\nSimpleFeiDaiPSM.sol#L54-L55(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/peg/SimpleFeiDaiPSM.sol#L54-L55)\n\nsolidity\n        require(amountOut = minAmountOut, \"SimpleFeiDaiPSM: Redeem not enough out\");\n\n\n\n\nA better require would be to check if the balance of the token that will be transferred out is sufficient to avoid a revert on the low level balance subtraction.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title contract used to redeem a list of tokens, by permanently\n/// taking another token out of circulation.\n/// @author Fei Protocol\ncontract TribeRedeemer is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice event to track redemptions\n    event Redeemed(address indexed owner, address indexed receiver, uint256 amount, uint256 base);\n\n    /// @notice token to redeem\n    address public immutable redeemedToken;\n\n    /// @notice tokens to receive when redeeming\n    address[] private tokensReceived;\n\n    /// @notice base used to compute the redemption amounts.\n    /// For instance, if the base is 100, and a user provides 100 `redeemedToken`,\n    /// they will receive all the balances of each `tokensReceived` held on this contract.\n    uint256 public redeemBase;\n\n    constructor(\n        address _redeemedToken,\n        address[] memory _tokensReceived,\n        uint256 _redeemBase\n    ) {\n        redeemedToken = _redeemedToken;\n        tokensReceived = _tokensReceived;\n        redeemBase = _redeemBase;\n    }\n\n    /// @notice Public function to get `tokensReceived`\n    function tokensReceivedOnRedeem() public view returns (address[] memory) {\n        return tokensReceived;\n    }\n\n    /// @notice Return the balances of `tokensReceived` that would be\n    /// transferred if redeeming `amountIn` of `redeemedToken`.\n    function previewRedeem(uint256 amountIn)\n        public\n        view\n        returns (address[] memory tokens, uint256[] memory amountsOut)\n    {\n        tokens = tokensReceivedOnRedeem();\n        amountsOut = new uint256[](tokens.length);\n\n        uint256 base = redeemBase;\n        for (uint256 i = 0; i < tokensReceived.length; i++) {\n            uint256 balance = IERC20(tokensReceived[i]).balanceOf(address(this));\n            require(balance != 0, \"ZERO_BALANCE\");\n            // @dev, this assumes all of `tokensReceived` and `redeemedToken`\n            // have the same number of decimals\n            uint256 redeemedAmount = (amountIn * balance) / base;\n            amountsOut[i] = redeemedAmount;\n        }\n    }\n\n    /// @notice Redeem `redeemedToken` for a pro-rata basket of `tokensReceived`\n    function redeem(address to, uint256 amountIn) external nonReentrant {\n        IERC20(redeemedToken).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        (address[] memory tokens, uint256[] memory amountsOut) = previewRedeem(amountIn);\n\n        uint256 base = redeemBase;\n        redeemBase = base - amountIn; // decrement the base for future redemptions\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).safeTransfer(to, amountsOut[i]);\n        }\n\n        emit Redeemed(msg.sender, to, amountIn, base);\n    }\n}\n\n\n/**\n *Submitted for verification at Etherscan.io on 2017-12-12\n */\n\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.4.18;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function() public payable {\n        deposit();\n    }\n\n    function init() external {\n        decimals = 18;\n        name = \"Wrapped Ether\";\n        symbol = \"WETH\";\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return this.balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "TribeRedeemer.sol",
            "WETH9.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "5",
                "Location": [
                    "//solidity\n        redeemBase = _redeemBase;\n\n"
                ],
                "Type": " Trust in Deployer - No guarantee that base will be  totalSupply ",
                "Description": "[TribeRedeemer.sol#L34-L35(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L34-L35)\n\nsolidity\n        redeemBase = _redeemBase;\n\n\n\nBecause redeemedToken is known, you could just retrieve the totalSupply from it to ensure the claims are for all tokens available.\n\nEnd users will have to verify that redeemBase is consistent with the Circulating Supply.\n\n\nComment and let end users know of this, or use totalSupply from the token.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "6",
                "Location": [
                    "//solidity\n        tokensReceived = _tokensReceived;\n\n"
                ],
                "Type": " Trust in Deployer - Lack of check for same decimals",
                "Description": "\nBecause TribeRedeemer assumes all assets will have the same decimals, tokens can remain stuck if they have a different amount of decimals.\n\nA simple check for decimals in the constructor can avoid this scenario\nTribeRedeemer.sol#L33-L34(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/shutdown/redeem/TribeRedeemer.sol#L33-L34)\n\nsolidity\n        tokensReceived = _tokensReceived;\n\n\n\nIn lack of a check, end users will have to verify all tokens have 18 decimals.\n\nAll of the tokens in the README have 18 decimals at this time.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./IPermissionsRead.sol\";\n\n/// @title Permissions interface\n/// @author Fei Protocol\ninterface IPermissions is IAccessControl, IPermissionsRead {\n    // ----------- Governor only state changing api -----------\n\n    function createRole(bytes32 role, bytes32 adminRole) external;\n\n    function grantMinter(address minter) external;\n\n    function grantBurner(address burner) external;\n\n    function grantPCVController(address pcvController) external;\n\n    function grantGovernor(address governor) external;\n\n    function grantGuardian(address guardian) external;\n\n    function revokeMinter(address minter) external;\n\n    function revokeBurner(address burner) external;\n\n    function revokePCVController(address pcvController) external;\n\n    function revokeGovernor(address governor) external;\n\n    function revokeGuardian(address guardian) external;\n\n    // ----------- Revoker only state changing api -----------\n\n    function revokeOverride(bytes32 role, address account) external;\n\n    // ----------- Getters -----------\n\n    function GUARDIAN_ROLE() external view returns (bytes32);\n\n    function GOVERN_ROLE() external view returns (bytes32);\n\n    function BURNER_ROLE() external view returns (bytes32);\n\n    function MINTER_ROLE() external view returns (bytes32);\n\n    function PCV_CONTROLLER_ROLE() external view returns (bytes32);\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./InterestRateModel.sol\";\n\nabstract contract CErc20Delegator is IERC20 {\n    address public implementation;\n    address public admin;\n    address public pendingAdmin;\n    address public interestRateModel;\n\n    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint256);\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public virtual returns (uint256);\n\n    function _setImplementationSafe(\n        address implementation_,\n        bool allowResign,\n        bytes calldata becomeImplementationData\n    ) external virtual;\n\n    function redeemUnderlying(uint256 underlying) external virtual;\n\n    function _acceptAdmin() external virtual returns (uint256);\n\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256);\n\n    function borrow(uint256 mintAmount) external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external view virtual returns (uint256);\n}\n\n\n",
        "CodeNames": [
            "IPermissions.sol",
            "CErc20Delegator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "7",
                "Location": [
                    "//solidity\n    function burnFeiHeld() external {\n\n"
                ],
                "Type": " Notice - Slippage and Interest Free Loan for Arbitrageurs",
                "Description": "\nBecause redeem doesn't burn FEI, any caller can mint and redeem multiple times in the same tx with the goal of arbing out the FEI DAI pair.\n\nSimpleFeiDaiPSM.sol#L105-L106(https://github.com/code-423n4/2022-09-tribe/blob/769b0586b4975270b669d7d1581aa5672d6999d5/contracts/peg/SimpleFeiDaiPSM.sol#L105-L106)\n\nsolidity\n    function burnFeiHeld() external {\n\n\n\nWhile FEI being tradeable for DAI is enforcing a 1-1 trade (FEI price goes up due to arbing, up to 100% + FEE), allowing the opposite swap is a easy target for arbitrageurs.\n\n##  08] Usual Suspects: Lack of Zero Checks for new addresses\n\nConstructors don't have zero-checks, which could force a re-deployment, funds are not at risk in those cases.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]