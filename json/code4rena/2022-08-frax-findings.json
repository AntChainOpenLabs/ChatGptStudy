[
    {
        "Code": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.15;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= FraxlendPairCore =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./FraxlendPairConstants.sol\";\nimport \"./libraries/VaultAccount.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IFraxlendWhitelist.sol\";\nimport \"./interfaces/IRateCalculator.sol\";\nimport \"./interfaces/ISwapper.sol\";\n\n/// @title FraxlendPairCore\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\n/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair\nabstract contract FraxlendPairCore is FraxlendPairConstants, IERC4626, ERC20, Ownable, Pausable, ReentrancyGuard {\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    string public version = \"1.0.0\";\n\n    // ============================================================================================\n    // Settings set by constructor() & initialize()\n    // ============================================================================================\n\n    // Asset and collateral contracts\n    IERC20 internal immutable assetContract;\n    IERC20 public immutable collateralContract;\n\n    // Oracle wrapper contract and oracleData\n    address public immutable oracleMultiply;\n    address public immutable oracleDivide;\n    uint256 public immutable oracleNormalization;\n\n    // LTV Settings\n    uint256 public immutable maxLTV;\n\n    // Liquidation Fee\n    uint256 public immutable cleanLiquidationFee;\n    uint256 public immutable dirtyLiquidationFee;\n\n    // Interest Rate Calculator Contract\n    IRateCalculator public immutable rateContract; // For complex rate calculations\n    bytes public rateInitCallData; // Optional extra data from init function to be passed to rate calculator\n\n    // Swapper\n    mapping(address => bool) public swappers; // approved swapper addresses\n\n    // Deployer\n    address public immutable DEPLOYER_ADDRESS;\n\n    // Admin contracts\n    address public immutable CIRCUIT_BREAKER_ADDRESS;\n    address public immutable COMPTROLLER_ADDRESS;\n    address public TIME_LOCK_ADDRESS;\n\n    // Dependencies\n    address public immutable FRAXLEND_WHITELIST_ADDRESS;\n\n    // ERC20 token name, accessible via name()\n    string internal nameOfContract;\n\n    // Maturity Date & Penalty Interest Rate (per Sec)\n    uint256 public immutable maturityDate;\n    uint256 public immutable penaltyRate;\n\n    // ============================================================================================\n    // Storage\n    // ============================================================================================\n\n    /// @notice Stores information about the current interest rate\n    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec is 1e18 precision\n    CurrentRateInfo public currentRateInfo;\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 feeToProtocolRate; // Fee amount 1e5 precision\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio\n    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token\n    ExchangeRateInfo public exchangeRateInfo;\n    struct ExchangeRateInfo {\n        uint32 lastTimestamp;\n        uint224 exchangeRate; // collateral:asset ratio. i.e. how much collateral to buy 1e18 asset\n    }\n\n    // Contract Level Accounting\n    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding\n    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding\n    uint256 public totalCollateral; // total amount of collateral in contract\n\n    // User Level Accounting\n    /// @notice Stores the balance of collateral for each user\n    mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed\n    /// @notice Stores the balance of borrow shares for each user\n    mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals\n    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()\n\n    // Internal Whitelists\n    bool public immutable borrowerWhitelistActive;\n    mapping(address => bool) public approvedBorrowers;\n\n    bool public immutable lenderWhitelistActive;\n    mapping(address => bool) public approvedLenders;\n\n    // ============================================================================================\n    // Initialize\n    // ============================================================================================\n\n    /// @notice The ```constructor``` function is called on deployment\n    /// @param _configData abi.encode(address _asset, address _collateral, address _oracleMultiply, address _oracleDivide, uint256 _oracleNormalization, address _rateContract, bytes memory _rateInitData)\n    /// @param _maxLTV The Maximum Loan-To-Value for a borrower to be considered solvent (1e5 precision)\n    /// @param _liquidationFee The fee paid to liquidators given as a % of the repayment (1e5 precision)\n    /// @param _maturityDate The maturityDate date of the Pair\n    /// @param _penaltyRate The interest rate after maturity date\n    /// @param _isBorrowerWhitelistActive Enables borrower whitelist\n    /// @param _isLenderWhitelistActive Enables lender whitelist\n    constructor(\n        bytes memory _configData,\n        bytes memory _immutables,\n        uint256 _maxLTV,\n        uint256 _liquidationFee,\n        uint256 _maturityDate,\n        uint256 _penaltyRate,\n        bool _isBorrowerWhitelistActive,\n        bool _isLenderWhitelistActive\n    ) {\n        // Handle Immutables Configuration\n        {\n            (\n                address _circuitBreaker,\n                address _comptrollerAddress,\n                address _timeLockAddress,\n                address _fraxlendWhitelistAddress\n            ) = abi.decode(_immutables, (address, address, address, address));\n\n            // Deployer contract\n            DEPLOYER_ADDRESS = msg.sender;\n            CIRCUIT_BREAKER_ADDRESS = _circuitBreaker;\n            COMPTROLLER_ADDRESS = _comptrollerAddress;\n            TIME_LOCK_ADDRESS = _timeLockAddress;\n            FRAXLEND_WHITELIST_ADDRESS = _fraxlendWhitelistAddress;\n        }\n\n        {\n            (\n                address _asset,\n                address _collateral,\n                address _oracleMultiply,\n                address _oracleDivide,\n                uint256 _oracleNormalization,\n                address _rateContract,\n\n            ) = abi.decode(_configData, (address, address, address, address, uint256, address, bytes));\n\n            // Pair Settings\n            assetContract = IERC20(_asset);\n            collateralContract = IERC20(_collateral);\n            currentRateInfo.feeToProtocolRate = DEFAULT_PROTOCOL_FEE;\n            cleanLiquidationFee = _liquidationFee;\n            dirtyLiquidationFee = (_liquidationFee * 9000) / LIQ_PRECISION; // 90% of clean fee\n\n            if (_maxLTV >= LTV_PRECISION && !_isBorrowerWhitelistActive) revert BorrowerWhitelistRequired();\n            maxLTV = _maxLTV;\n\n            // Swapper Settings\n            swappers[FRAXSWAP_ROUTER_ADDRESS] = true;\n\n            // Oracle Settings\n            {\n                IFraxlendWhitelist _fraxlendWhitelist = IFraxlendWhitelist(FRAXLEND_WHITELIST_ADDRESS);\n                // Check that oracles are on the whitelist\n                if (_oracleMultiply != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleMultiply)) {\n                    revert NotOnWhitelist(_oracleMultiply);\n                }\n\n                if (_oracleDivide != address(0) && !_fraxlendWhitelist.oracleContractWhitelist(_oracleDivide)) {\n                    revert NotOnWhitelist(_oracleDivide);\n                }\n\n                // Write oracleData to storage\n                oracleMultiply = _oracleMultiply;\n                oracleDivide = _oracleDivide;\n                oracleNormalization = _oracleNormalization;\n\n                // Rate Settings\n                if (!_fraxlendWhitelist.rateContractWhitelist(_rateContract)) {\n                    revert NotOnWhitelist(_rateContract);\n                }\n            }\n\n            rateContract = IRateCalculator(_rateContract);\n        }\n\n        // Set approved borrowers whitelist\n        borrowerWhitelistActive = _isBorrowerWhitelistActive;\n\n        // Set approved lenders whitlist active\n        lenderWhitelistActive = _isLenderWhitelistActive;\n\n        // Set maturity date & penalty interest rate\n        maturityDate = _maturityDate;\n        penaltyRate = _penaltyRate;\n    }\n\n    /// @notice The ```initialize``` function is called immediately after deployment\n    /// @dev This function can only be called by the deployer\n    /// @param _name The name of the contract\n    /// @param _approvedBorrowers An array of approved borrower addresses\n    /// @param _approvedLenders An array of approved lender addresses\n    /// @param _rateInitCallData The configuration data for the Rate Calculator contract\n    function initialize(\n        string calldata _name,\n        address[] calldata _approvedBorrowers,\n        address[] calldata _approvedLenders,\n        bytes calldata _rateInitCallData\n    ) external {\n        if (msg.sender != DEPLOYER_ADDRESS) {\n            revert NotDeployer();\n        }\n        if (bytes(_name).length == 0) {\n            revert NameEmpty();\n        }\n        if (bytes(nameOfContract).length != 0) {\n            revert AlreadyInitialized();\n        }\n\n        // Set name\n        nameOfContract = _name;\n\n        // Set approved borrowers\n        for (uint256 i = 0; i < _approvedBorrowers.length; ++i) {\n            approvedBorrowers[_approvedBorrowers[i]] = true;\n        }\n\n        // Set approved lenders\n        for (uint256 i = 0; i < _approvedLenders.length; ++i) {\n            approvedLenders[_approvedLenders[i]] = true;\n        }\n\n        // Reverts if init data is not valid\n        IRateCalculator(rateContract).requireValidInitData(_rateInitCallData);\n\n        // Set rate init Data\n        rateInitCallData = _rateInitCallData;\n\n        // Instantiate Interest\n        _addInterest();\n\n        // Instantiate Exchange Rate\n        _updateExchangeRate();\n    }\n\n    // ============================================================================================\n    // Internal Helpers\n    // ============================================================================================\n\n    /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract\n    /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets\n    /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows\n    /// @return The balance of Asset Tokens held by contract\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate\n    /// @param _borrower The borrower address to check\n    /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset\n    /// @return Whether borrower is solvent\n    function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {\n        if (maxLTV == 0) return true;\n        uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);\n        if (_borrowerAmount == 0) return true;\n        uint256 _collateralAmount = userCollateralBalance[_borrower];\n        if (_collateralAmount == 0) return false;\n\n        uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;\n        return _ltv <= maxLTV;\n    }\n\n    /// @notice The ```_isPastMaturity``` function determines if the current block timestamp is past the maturityDate date\n    /// @return Whether or not the debt is past maturity\n    function _isPastMaturity() internal view returns (bool) {\n        return maturityDate != 0 && block.timestamp > maturityDate;\n    }\n\n    // ============================================================================================\n    // Modifiers\n    // ============================================================================================\n\n    /// @notice Checks for solvency AFTER executing contract code\n    /// @param _borrower The borrower whose solvency we will check\n    modifier isSolvent(address _borrower) {\n        _;\n        if (!_isSolvent(_borrower, exchangeRateInfo.exchangeRate)) {\n            revert Insolvent(\n                totalBorrow.toAmount(userBorrowShares[_borrower], true),\n                userCollateralBalance[_borrower],\n                exchangeRateInfo.exchangeRate\n            );\n        }\n    }\n\n    /// @notice Checks if msg.sender is an approved Borrower\n    modifier approvedBorrower() {\n        if (borrowerWhitelistActive && !approvedBorrowers[msg.sender]) {\n            revert OnlyApprovedBorrowers();\n        }\n        _;\n    }\n\n    /// @notice Checks if msg.sender and _receiver are both an approved Lender\n    /// @param _receiver An additional receiver address to check\n    modifier approvedLender(address _receiver) {\n        if (lenderWhitelistActive && (!approvedLenders[msg.sender] || !approvedLenders[_receiver])) {\n            revert OnlyApprovedLenders();\n        }\n        _;\n    }\n\n    /// @notice Ensure function is not called when passed maturity\n    modifier isNotPastMaturity() {\n        if (_isPastMaturity()) {\n            revert PastMaturity();\n        }\n        _;\n    }\n\n    // ============================================================================================\n    // Functions: Interest Accumulation and Adjustment\n    // ============================================================================================\n\n    /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers\n    /// @param _interestEarned The total interest accrued by all borrowers\n    /// @param _rate The interest rate used to calculate accrued interest\n    /// @param _deltaTime The time elapsed since last interest accrual\n    /// @param _feesAmount The amount of fees paid to protocol\n    /// @param _feesShare The amount of shares distributed to protocol\n    event AddInterest(\n        uint256 _interestEarned,\n        uint256 _rate,\n        uint256 _deltaTime,\n        uint256 _feesAmount,\n        uint256 _feesShare\n    );\n\n    /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated\n    /// @param _ratePerSec The old interest rate (per second)\n    /// @param _deltaTime The time elapsed since last update\n    /// @param _utilizationRate The utilization of assets in the Pair\n    /// @param _newRatePerSec The new interest rate (per second)\n    event UpdateRate(uint256 _ratePerSec, uint256 _deltaTime, uint256 _utilizationRate, uint256 _newRatePerSec);\n\n    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate\n    /// @dev Can only called once per block\n    /// @return _interestEarned The amount of interest accrued by all borrowers\n    function _addInterest()\n        internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest accrues and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            if (_isPastMaturity()) {\n                _newRate = uint64(penaltyRate);\n            } else {\n                bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n            }\n\n            // Event must be here to use non-mutated values\n            emit UpdateRate(_currentRateInfo.ratePerSec, _deltaTime, _utilizationRate, _newRate);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest accrued\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n                if (_currentRateInfo.feeToProtocolRate > 0) {\n                    _feesAmount = (_interestEarned * _currentRateInfo.feeToProtocolRate) / FEE_PRECISION;\n\n                    _feesShare = (_feesAmount * _totalAsset.shares) / (_totalAsset.amount - _feesAmount);\n\n                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees\n                    // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128\n                    _totalAsset.shares += uint128(_feesShare);\n\n                    // Effects: write to storage\n                    _mint(address(this), _feesShare);\n                }\n                emit AddInterest(_interestEarned, _currentRateInfo.ratePerSec, _deltaTime, _feesAmount, _feesShare);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n    }\n\n    // ============================================================================================\n    // Functions: ExchangeRate\n    // ============================================================================================\n    /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated\n    /// @param _rate The new rate given as the amount of Collateral Token to buy 1e18 Asset Token\n    event UpdateExchangeRate(uint256 _rate);\n\n    /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function updateExchangeRate() external nonReentrant returns (uint256 _exchangeRate) {\n        _exchangeRate = _updateExchangeRate();\n    }\n\n    /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.\n    /// @dev This function is invoked at most once per block as these queries can be expensive\n    /// @return _exchangeRate The new exchange rate\n    function _updateExchangeRate() internal returns (uint256 _exchangeRate) {\n        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;\n        if (_exchangeRateInfo.lastTimestamp == block.timestamp) {\n            return _exchangeRate = _exchangeRateInfo.exchangeRate;\n        }\n\n        uint256 _price = uint256(1e36);\n        if (oracleMultiply != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleMultiply);\n            }\n            _price = _price * uint256(_answer);\n        }\n\n        if (oracleDivide != address(0)) {\n            (, int256 _answer, , , ) = AggregatorV3Interface(oracleDivide).latestRoundData();\n            if (_answer <= 0) {\n                revert OracleLTEZero(oracleDivide);\n            }\n            _price = _price / uint256(_answer);\n        }\n\n        _exchangeRate = _price / oracleNormalization;\n\n        // write to storage, if no overflow\n        if (_exchangeRate > type(uint224).max) revert PriceTooLarge();\n        _exchangeRateInfo.exchangeRate = uint224(_exchangeRate);\n        _exchangeRateInfo.lastTimestamp = uint32(block.timestamp);\n        exchangeRateInfo = _exchangeRateInfo;\n        emit UpdateExchangeRate(_exchangeRate);\n    }\n\n    // ============================================================================================\n    // Functions: Lending\n    // ============================================================================================\n\n    /// @notice The ```_deposit``` function is the internal implementation for lending assets\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token\n    /// @param _amount The amount of Asset Token to be transferred\n    /// @param _shares The amount of Asset Shares (fTokens) to be minted\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    function _deposit(\n        VaultAccount memory _totalAsset,\n        uint128 _amount,\n        uint128 _shares,\n        address _receiver\n    ) internal {\n        // Effects: bookkeeping\n        _totalAsset.amount += _amount;\n        _totalAsset.shares += _shares;\n\n        // Effects: write back to storage\n        _mint(_receiver, _shares);\n        totalAsset = _totalAsset;\n\n        // Interactions\n        assetContract.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposit(msg.sender, _receiver, _amount, _shares);\n    }\n\n    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _amount The amount of Asset Token to transfer to Pair\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _sharesReceived The number of fTokens received for the deposit\n    function deposit(uint256 _amount, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _sharesReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _sharesReceived = _totalAsset.toShares(_amount, false);\n        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver);\n    }\n\n    /// @notice The ```mint``` function allows a user to Lend assets by specifying the number of Assets Shares (fTokens) to mint\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _shares The number of Asset Shares (fTokens) that a user wants to mint\n    /// @param _receiver The address to receive the Asset Shares (fTokens)\n    /// @return _amountReceived The amount of Asset Tokens transferred to the Pair\n    function mint(uint256 _shares, address _receiver)\n        external\n        nonReentrant\n        isNotPastMaturity\n        whenNotPaused\n        approvedLender(_receiver)\n        returns (uint256 _amountReceived)\n    {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountReceived = _totalAsset.toAmount(_shares, true);\n        _deposit(_totalAsset, _amountReceived.toUint128(), _shares.toUint128(), _receiver);\n    }\n\n    /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function\n    /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)\n    /// @param _amountToReturn The number of Asset Tokens to return\n    /// @param _shares The number of Asset Shares (fTokens) to burn\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    function _redeem(\n        VaultAccount memory _totalAsset,\n        uint128 _amountToReturn,\n        uint128 _shares,\n        address _receiver,\n        address _owner\n    ) internal {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance(_owner, msg.sender);\n            // NOTE: This will revert on underflow ensuring that allowance > shares\n            if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);\n        }\n\n        // Check for sufficient withdraw liquidity\n        uint256 _assetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow);\n        if (_assetsAvailable < _amountToReturn) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _amountToReturn);\n        }\n\n        // Effects: bookkeeping\n        _totalAsset.amount -= _amountToReturn;\n        _totalAsset.shares -= _shares;\n\n        // Effects: write to storage\n        totalAsset = _totalAsset;\n        _burn(_owner, _shares);\n\n        // Interactions\n        assetContract.safeTransfer(_receiver, _amountToReturn);\n        emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);\n    }\n\n    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens\n    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _amountToReturn The amount of Asset Tokens to be transferred\n    function redeem(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _amountToReturn) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _amountToReturn = _totalAsset.toAmount(_shares, false);\n        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    /// @notice The ```withdraw``` function allows a user to redeem their Asset Shares for a specified amount of Asset Tokens\n    /// @param _amount The amount of Asset Tokens to be transferred in exchange for burning Asset Shares\n    /// @param _receiver The address to which the Asset Tokens will be transferred\n    /// @param _owner The owner of the Asset Shares (fTokens)\n    /// @return _shares The number of Asset Shares (fTokens) burned\n    function withdraw(\n        uint256 _amount,\n        address _receiver,\n        address _owner\n    ) external nonReentrant returns (uint256 _shares) {\n        _addInterest();\n        VaultAccount memory _totalAsset = totalAsset;\n        _shares = _totalAsset.toShares(_amount, true);\n        _redeem(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, _owner);\n    }\n\n    // ============================================================================================\n    // Functions: Borrowing\n    // ============================================================================================\n\n    /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position\n    /// @param _borrower The borrower whose account was debited\n    /// @param _receiver The address to which the Asset Tokens were transferred\n    /// @param _borrowAmount The amount of Asset Tokens transferred\n    /// @param _sharesAdded The number of Borrow Shares the borrower was debited\n    event BorrowAsset(\n        address indexed _borrower,\n        address indexed _receiver,\n        uint256 _borrowAmount,\n        uint256 _sharesAdded\n    );\n\n    /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets\n    /// @param _borrowAmount The amount of the Asset Token to borrow\n    /// @param _receiver The address to receive the Asset Tokens\n    /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited\n    function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert InsufficientAssetsInContract(_assetsAvailable, _borrowAmount);\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_sharesAdded);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _sharesAdded;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            assetContract.safeTransfer(_receiver, _borrowAmount);\n        }\n        emit BorrowAsset(msg.sender, _receiver, _borrowAmount, _sharesAdded);\n    }\n\n    /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position\n    /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable\n    /// @param _borrowAmount The amount of Asset Token to borrow\n    /// @param _collateralAmount The amount of Collateral Token to transfer to Pair\n    /// @param _receiver The address which will receive the Asset Tokens\n    /// @return _shares The number of borrow Shares the msg.sender will be debited\n    function borrowAsset(\n        uint256 _borrowAmount,\n        uint256 _collateralAmount,\n        address _receiver\n    )\n        external\n        isNotPastMaturity\n        whenNotPaused\n        nonReentrant\n        isSolvent(msg.sender)\n        approvedBorrower\n        returns (uint256 _shares)\n    {\n        _addInterest();\n        _updateExchangeRate();\n        if (_collateralAmount > 0) {\n            _addCollateral(msg.sender, _collateralAmount, msg.sender);\n        }\n        _shares = _borrowAsset(_borrowAmount.toUint128(), _receiver);\n    }\n\n    event AddCollateral(address indexed _sender, address indexed _borrower, uint256 _collateralAmount);\n\n    /// @notice The ```_addCollateral``` function is an internal implementation for adding collateral to a borrowers position\n    /// @param _sender The source of funds for the new collateral\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _borrower The borrower account for which the collateral should be credited\n    function _addCollateral(\n        address _sender,\n        uint256 _collateralAmount,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        userCollateralBalance[_borrower] += _collateralAmount;\n        totalCollateral += _collateralAmount;\n\n        // Interactions\n        if (_sender != address(this)) {\n            collateralContract.safeTransferFrom(_sender, address(this), _collateralAmount);\n        }\n        emit AddCollateral(_sender, _borrower, _collateralAmount);\n    }\n\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(uint256 _collateralAmount, address _borrower) external nonReentrant isNotPastMaturity {\n        _addInterest();\n        _addCollateral(msg.sender, _collateralAmount, _borrower);\n    }\n\n    /// @notice The ```RemoveCollateral``` event is emitted when collateral is removed from a borrower's position\n    /// @param _sender The account from which funds are transferred\n    /// @param _collateralAmount The amount of Collateral Token to be transferred\n    /// @param _receiver The address to which Collateral Tokens will be transferred\n    event RemoveCollateral(\n        address indexed _sender,\n        uint256 _collateralAmount,\n        address indexed _receiver,\n        address indexed _borrower\n    );\n\n    /// @notice The ```_removeCollateral``` function is the internal implementation for removing collateral from a borrower's position\n    /// @param _collateralAmount The amount of Collateral Token to remove from the borrower's position\n    /// @param _receiver The address to receive the Collateral Token transferred\n    /// @param _borrower The borrower whose account will be debited the Collateral amount\n    function _removeCollateral(\n        uint256 _collateralAmount,\n        address _receiver,\n        address _borrower\n    ) internal {\n        // Effects: write to state\n        // Following line will revert on underflow if _collateralAmount > userCollateralBalance\n        userCollateralBalance[_borrower] -= _collateralAmount;\n        // Following line will revert on underflow if totalCollateral < _collateralAmount\n        totalCollateral -= _collateralAmount;\n\n        // Interactions\n        if (_receiver != address(this)) {\n            collateralContract.safeTransfer(_receiver, _collateralAmount);\n        }\n        emit RemoveCollateral(msg.sender, _collateralAmount, _receiver, _borrower);\n    }\n\n    /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender's borrow position\n    /// @dev msg.sender must be solvent after invocation or transaction will revert\n    /// @param _collateralAmount The amount of Collateral Token to transfer\n    /// @param _receiver The address to receive the transferred funds\n    function removeCollateral(uint256 _collateralAmount, address _receiver)\n        external\n        nonReentrant\n        isSolvent(msg.sender)\n    {\n        _addInterest();\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        if (userBorrowShares[msg.sender] > 0) {\n            _updateExchangeRate();\n        }\n        _removeCollateral(_collateralAmount, _receiver, msg.sender);\n    }\n\n    /// @notice The ```RepayAsset``` event is emitted whenever a debt position is repaid\n    /// @param _sender The msg.sender of the transaction\n    /// @param _borrower The borrower whose account will be credited\n    /// @param _amountToRepay The amount of Asset token to be transferred\n    /// @param _shares The amount of Borrow Shares which will be debited from the borrower after repayment\n    event RepayAsset(address indexed _sender, address indexed _borrower, uint256 _amountToRepay, uint256 _shares);\n\n    /// @notice The ```_repayAsset``` function is the internal implementation for repaying a borrow position\n    /// @dev The payer must have called ERC20.approve() on the Asset Token contract prior to invocation\n    /// @param _totalBorrow An in memory copy of the totalBorrow VaultAccount struct\n    /// @param _amountToRepay The amount of Asset Token to transfer\n    /// @param _shares The number of Borrow Shares the sender is repaying\n    /// @param _payer The address from which funds will be transferred\n    /// @param _borrower The borrower account which will be credited\n    function _repayAsset(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        // Interactions\n        if (_payer != address(this)) {\n            assetContract.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n        emit RepayAsset(msg.sender, _borrower, _amountToRepay, _shares);\n    }\n\n    /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.\n    /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract\n    /// @param _shares The number of Borrow Shares which will be repaid by the call\n    /// @param _borrower The account for which the debt will be reduced\n    /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares\n    function repayAsset(uint256 _shares, address _borrower) external nonReentrant returns (uint256 _amountToRepay) {\n        _addInterest();\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower);\n    }\n\n    // ============================================================================================\n    // Functions: Liquidations\n    // ============================================================================================\n    /// @notice The ```Liquidate``` event is emitted when a liquidation occurs\n    /// @param _borrower The borrower account for which the liquidation occured\n    /// @param _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    /// @param _sharesToLiquidate The number of Borrow Shares the liquidator repaid on behalf of the borrower\n    /// @param _sharesToAdjust The number of Borrow Shares that were adjusted on liabilites and assets (a writeoff)\n    event Liquidate(\n        address indexed _borrower,\n        uint256 _collateralForLiquidator,\n        uint256 _sharesToLiquidate,\n        uint256 _amountLiquidatorToRepay,\n        uint256 _sharesToAdjust,\n        uint256 _amountToAdjust\n    );\n\n    /// @notice The ```liquidate``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _shares The number of Borrow Shares repaid by the liquidator\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidate(uint256 _shares, address _borrower)\n        external\n        whenNotPaused\n        nonReentrant\n        approvedLender(msg.sender)\n        returns (uint256 _collateralForLiquidator)\n    {\n        _addInterest();\n\n        // Get best available exchange rate\n        uint256 _exchangeRate = _updateExchangeRate();\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Determine how much of the borrow and collateral will be repaid\n        _collateralForLiquidator =\n            (((_totalBorrow.toAmount(_shares, false) * _exchangeRate) / EXCHANGE_PRECISION) *\n                (LIQ_PRECISION + cleanLiquidationFee)) /\n            LIQ_PRECISION;\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        uint256 _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(_borrower, _collateralForLiquidator, _shares, 0, 0, 0);\n    }\n\n    /// @notice The ```liquidateClean``` function allows a third party to repay a borrower's debt if they have become insolvent\n    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```\n    /// @param _sharesToLiquidate The number of Borrow Shares repaid by the liquidator\n    /// @param _deadline The timestamp after which tx will revert\n    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken\n    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator\n    function liquidateClean(\n        uint128 _sharesToLiquidate,\n        uint256 _deadline,\n        address _borrower\n    ) external whenNotPaused nonReentrant approvedLender(msg.sender) returns (uint256 _collateralForLiquidator) {\n        if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline);\n\n        _addInterest();\n        uint256 _exchangeRate = _updateExchangeRate();\n\n        if (_isSolvent(_borrower, _exchangeRate)) {\n            revert BorrowerSolvent();\n        }\n\n        // Read from state\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _userCollateralBalance = userCollateralBalance[_borrower];\n        uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();\n\n        // Prevent stack-too-deep\n        int256 _leftoverCollateral;\n        {\n            // Checks & Calculations\n            // Determine the liquidation amount in collateral units (i.e. how much debt is liquidator going to repay)\n            uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *\n                _exchangeRate) / EXCHANGE_PRECISION);\n\n            // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee\n            // This fee only applies if the liquidator does a full liquidation\n            uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *\n                (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;\n\n            // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value\n            // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)\n            _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());\n\n            // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral\n            // This will only be true when there liquidator is cleaning out the position\n            _collateralForLiquidator = _leftoverCollateral <= 0\n                ? _userCollateralBalance\n                : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;\n        }\n        // Calced here for use during repayment, grouped with other calcs before effects start\n        uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();\n\n        // Determine if and how much debt to writeoff\n        // Note: ensures that sharesToLiquidate is never larger than borrowerShares\n        uint128 _sharesToAdjust;\n        uint128 _amountToAdjust;\n        {\n            if (_leftoverCollateral <= 0) {\n                uint128 _leftoverBorrowShares = _borrowerShares - _sharesToLiquidate;\n                if (_leftoverBorrowShares > 0) {\n                    // Write off bad debt\n                    _sharesToAdjust = _leftoverBorrowShares;\n                    _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();\n\n                    // Effects: write to state\n                    totalAsset.amount -= _amountToAdjust;\n\n                    // Note: Ensure this memory stuct will be passed to _repayAsset for write to state\n                    _totalBorrow.amount -= _amountToAdjust;\n                    _totalBorrow.shares -= _sharesToAdjust;\n                }\n            }\n        }\n\n        // Effects & Interactions\n        // NOTE: reverts if _shares > userBorrowShares\n        _repayAsset(_totalBorrow, _amountLiquidatorToRepay, _sharesToLiquidate, msg.sender, _borrower); // liquidator repays shares on behalf of borrower\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        // Collateral is removed on behalf of borrower and sent to liquidator\n        // NOTE: reverts if _collateralForLiquidator > userCollateralBalance\n        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);\n        emit Liquidate(\n            _borrower,\n            _collateralForLiquidator,\n            _sharesToLiquidate,\n            _amountLiquidatorToRepay,\n            _sharesToAdjust,\n            _amountToAdjust\n        );\n    }\n\n    // ============================================================================================\n    // Functions: Leverage\n    // ============================================================================================\n\n    /// @notice The ```LeveragedPosition``` event is emitted when a borrower takes out a new leveraged position\n    /// @param _borrower The account for which the debt is debited\n    /// @param _swapperAddress The address of the swapper which conforms the FraxSwap interface\n    /// @param _borrowAmount The amount of Asset Token to be borrowed to be borrowed\n    /// @param _borrowShares The number of Borrow Shares the borrower is credited\n    /// @param _initialCollateralAmount The amount of initial Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOut The amount of Collateral Token which was received for the Asset Tokens\n    event LeveragedPosition(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _borrowShares,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOut\n    );\n\n    /// @notice The ```leveragedPosition``` function allows a user to enter a leveraged borrow position with minimal upfront Collateral\n    /// @dev Caller must invoke ```ERC20.approve()``` on the Collateral Token contract prior to calling function\n    /// @param _swapperAddress The address of the whitelisted swapper to use to swap borrowed Asset Tokens for Collateral Tokens\n    /// @param _borrowAmount The amount of Asset Tokens borrowed\n    /// @param _initialCollateralAmount The initial amount of Collateral Tokens supplied by the borrower\n    /// @param _amountCollateralOutMin The minimum amount of Collateral Tokens to be received in exchange for the borrowed Asset Tokens\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _totalCollateralBalance The total amount of Collateral Tokens added to a users account (initial + swap)\n    function leveragedPosition(\n        address _swapperAddress,\n        uint256 _borrowAmount,\n        uint256 _initialCollateralAmount,\n        uint256 _amountCollateralOutMin,\n        address[] memory _path\n    )\n        external\n        isNotPastMaturity\n        nonReentrant\n        whenNotPaused\n        approvedBorrower\n        isSolvent(msg.sender)\n        returns (uint256 _totalCollateralBalance)\n    {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[_path.length - 1]);\n        }\n\n        // Add initial collateral\n        if (_initialCollateralAmount > 0) {\n            _addCollateral(msg.sender, _initialCollateralAmount, msg.sender);\n        }\n\n        // Debit borrowers account\n        // setting recipient to address(this) means no transfer will happen\n        uint256 _borrowShares = _borrowAsset(_borrowAmount.toUint128(), address(this));\n\n        // Interactions\n        _assetContract.approve(_swapperAddress, _borrowAmount);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialCollateralBalance = _collateralContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _borrowAmount,\n            _amountCollateralOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalCollateralBalance = _collateralContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping & write to state\n        uint256 _amountCollateralOut = _finalCollateralBalance - _initialCollateralBalance;\n        if (_amountCollateralOut < _amountCollateralOutMin) {\n            revert SlippageTooHigh(_amountCollateralOutMin, _amountCollateralOut);\n        }\n\n        // address(this) as _sender means no transfer occurs as the pair has already received the collateral during swap\n        _addCollateral(address(this), _amountCollateralOut, msg.sender);\n\n        _totalCollateralBalance = _initialCollateralAmount + _amountCollateralOut;\n        emit LeveragedPosition(\n            msg.sender,\n            _swapperAddress,\n            _borrowAmount,\n            _borrowShares,\n            _initialCollateralAmount,\n            _amountCollateralOut\n        );\n    }\n\n    /// @notice The ```RepayAssetWithCollateral``` event is emitted whenever ```repayAssetWithCollateral()``` is invoked\n    /// @param _borrower The borrower account for which the repayment is taking place\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Token to swap and use for repayment\n    /// @param _amountAssetOut The amount of Asset Token which was repaid\n    /// @param _sharesRepaid The number of Borrow Shares which were repaid\n    event RepayAssetWithCollateral(\n        address indexed _borrower,\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOut,\n        uint256 _sharesRepaid\n    );\n\n    /// @notice The ```repayAssetWithCollateral``` function allows a borrower to repay their debt using existing collateral in contract\n    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps\n    /// @param _collateralToSwap The amount of Collateral Tokens to swap for Asset Tokens\n    /// @param _amountAssetOutMin The minimum amount of Asset Tokens to receive during the swap\n    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.\n    /// @return _amountAssetOut The amount of Asset Tokens received for the Collateral Tokens, the amount the borrowers account was credited\n    function repayAssetWithCollateral(\n        address _swapperAddress,\n        uint256 _collateralToSwap,\n        uint256 _amountAssetOutMin,\n        address[] calldata _path\n    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _amountAssetOut) {\n        _addInterest();\n        _updateExchangeRate();\n\n        IERC20 _assetContract = assetContract;\n        IERC20 _collateralContract = collateralContract;\n\n        if (!swappers[_swapperAddress]) {\n            revert BadSwapper();\n        }\n        if (_path[0] != address(_collateralContract)) {\n            revert InvalidPath(address(_collateralContract), _path[0]);\n        }\n        if (_path[_path.length - 1] != address(_assetContract)) {\n            revert InvalidPath(address(_assetContract), _path[_path.length - 1]);\n        }\n\n        // Effects: bookkeeping & write to state\n        // Debit users collateral balance in preparation for swap, setting _recipient to address(this) means no transfer occurs\n        _removeCollateral(_collateralToSwap, address(this), msg.sender);\n\n        // Interactions\n        _collateralContract.approve(_swapperAddress, _collateralToSwap);\n\n        // Even though swappers are trusted, we verify the balance before and after swap\n        uint256 _initialAssetBalance = _assetContract.balanceOf(address(this));\n        ISwapper(_swapperAddress).swapExactTokensForTokens(\n            _collateralToSwap,\n            _amountAssetOutMin,\n            _path,\n            address(this),\n            block.timestamp\n        );\n        uint256 _finalAssetBalance = _assetContract.balanceOf(address(this));\n\n        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT\n        // Effects: bookkeeping\n        _amountAssetOut = _finalAssetBalance - _initialAssetBalance;\n        if (_amountAssetOut < _amountAssetOutMin) {\n            revert SlippageTooHigh(_amountAssetOutMin, _amountAssetOut);\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n        uint256 _sharesToRepay = _totalBorrow.toShares(_amountAssetOut, false);\n\n        // Effects: write to state\n        // Note: setting _payer to address(this) means no actual transfer will occur.  Contract already has funds\n        _repayAsset(_totalBorrow, _amountAssetOut.toUint128(), _sharesToRepay.toUint128(), address(this), msg.sender);\n\n        emit RepayAssetWithCollateral(msg.sender, _swapperAddress, _collateralToSwap, _amountAssetOut, _sharesToRepay);\n    }\n}\n\n\n",
        "CodeNames": [
            "FraxlendPairCore.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "_sharesToLiquidate",
                    "liquidateClean"
                ],
                "Type": " Any borrower with bad debt can be liquidated multiple times to lock funds in the lending pair",
                "Description": "\nLeftover shares in liquidateClean are only subtracted from pair totals, but not from user's borrowed shares. This means that after liquidateClean, borrower's shares will be greater than 0 (leftover shares after liquidations), but the user is still insolvent and can be liquidated again and again (with _sharesToLiquidate set to 0). Each subsequent liquidation will write off the bad debt (reduce pair totals by borrower leftover shares/amounts), but doesn't take anything from liquidator nor borrower (since _sharesToLiquidate == 0).\n\nThis messes up the whole pair accounting, with total asset amounts reducing and total borrow amounts and shares reducing. This will make it impossible for borrowers to repay debt (or be liquidated), because borrow totals will underflow, and lenders amount to withdraw will reduce a lot (they will share non-existant huge bad debt).\n\nReducing pair totals scenario:\n\n1.  Alice borrows 1000 FRAX (1000 shares) against 1.5 ETH collateral (1 ETH = 1000, Max LTV = 75%)\n2.  ETH drops to 500 very quickly with liquidators being unable to liquidate Alice due to network congestion\n3.  At ETH = 500, Alice collateral is worth 750 against 1000 FRAX debt, making Alice insolvent and in a bad debt\n4.  Liquidator calls liquidateClean for 800 shares, which cleans up all available collateral of 1.5 ETH.\n5.  At this point Alice has 200 shares debt with 0 collateral\n6.  Liquidator repeatedly calls liquidateClean with 0 shares to liquidate. Each call pair totals are reduced by 200 shares (and total borrow amount by a corresponding amount).\n7.  When pair totals reach close to 0, the pool is effectively locked. Borrowers can't repay, lenders can withdraw severly reduced amounts.\n\n\nCopy this to src/test/e2e/LiquidationBugTest.sol\n\n<https://gist.github.com/panprog/cbdc1658d63c30c9fe94127a4b4b7e72\n\n",
                "Repair": "\nAfter the line\n\n<https://github.com/code-423n4/2022-08-frax/blob/c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f/src/contracts/FraxlendPairCore.sol#L1012\n\nadd\n\n        _sharesToLiquidate += _sharesToAdjust;\n\namirnader-ghazvini (Frax) marked as duplicate and commented(https://github.com/code-423n4/2022-08-frax-findings/issues/102#issuecomment-1230721732):\n  Duplicate of #112(https://github.com/code-423n4/2022-08-frax-findings/issues/112)\n\ngititGoro (judge) commented(https://github.com/code-423n4/2022-08-frax-findings/issues/102#issuecomment-1264719973):\n  Setting to original in set.\n\nDrakeEvans (Frax) confirmed(https://github.com/code-423n4/2022-08-frax-findings/issues/102)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "liquidateClean()",
                    "liquidate()"
                ],
                "Type": "  liquidate()  doesn't mark off bad debt, leading to a 'last lender to withdraw loses' scenario",
                "Description": "\nWhen there's bad debt which wasn't marked off yet, the totalAssets.amount is higher than the actual (solvent) amount the pair has, meaning that lenders who redeem their tokens earlier will get more in return, at the expense of lenders who leave later.\nTherefore bad debt should be marked off as soon as possible, the later it's done the more interest it accumulates and the higher the chances are that some of the lenders will notice and redeem their shares before the bad debt is subtracted from the total assets amount.\n\nHaving the option to liquidate via the liquidate() function (which doesn't mark off bad debt) can lead to users using that function and leaving bad debt alongside zero collateral or near-zero collateral (giving no motivation for other users to liquidate the rest).\n\nMarking off the remaining of the bad debt via liquidateClean() with 0 shares might be possible (not always, some tokens don't allow 0 transfers(https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)), however there's no motivation for outside users to do so. And as for the lenders redeeming their tokens before the bad debt is subtracted from the total amount might be more profitable than staying and marking off the bad debt.\n\n\nSome lenders might be able to dodge the loss of the bad debt (+ interest), while the last one(s) will have to absorb the lost of the lenders who left too.\n\n\nConsider the following scenario:\n\n*   A pair has 10 lenders with 1K$ from each one (10K total)\n*   Borrower borrowed that 10K\n*   The collateral price went down and now it's worth only 7K\n*   A liquidator notices that and liquidates it via liquidate()\n*   The totalAssets.amount is 10K + interest, but the total asset amount is actually less than 7K (subtracting liquidator fees)\n*   6 lenders notice that and redeem their shares, getting back their money + interest\n*   The 7th lender to redeem will only be able to get back part of his money\n*   The remaining 3 lenders will loose all of their money\n\n",
                "Repair": "\nMark off bad debt when remaining collateral reaches zero or near-zero value.\n\n(if only liquidateClean() was available then there would be a motivation to not leave near-zero collateral, but as long as this isn't the case consider marking off also in case of near-zero collateral left).\n\nDrakeEvans (Frax) confirmed(https://github.com/code-423n4/2022-08-frax-findings/issues/142)\n\ngititGoro (judge) commented(https://github.com/code-423n4/2022-08-frax-findings/issues/141#issuecomment-1266170140):\n  Setting to original in set. Severity will be maintained as the wardens couldn't know that only one liquidate function would be included in the final release.\n\n\n\n*\n\n\n\n"
            }
        ]
    }
]