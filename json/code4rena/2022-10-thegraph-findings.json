[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../governance/Managed.sol\";\nimport \"../token/IGraphToken.sol\";\n\n/**\n * @title Bridge Escrow\n * @dev This contracts acts as a gateway for an L2 bridge (or several). It simply holds GRT and has\n * a set of spenders that can transfer the tokens; the L1 side of each L2 bridge has to be\n * approved as a spender.\n */\ncontract BridgeEscrow is GraphUpgradeable, Managed {\n    /**\n     * @dev Initialize this contract.\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n    }\n\n    /**\n     * @dev Approve a spender (i.e. a bridge that manages the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be approved\n     */\n    function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Revoke a spender (i.e. a bridge that will no longer manage the GRT funds held by the escrow)\n     * @param _spender Address of the spender that will be revoked\n     */\n    function revokeAll(address _spender) external onlyGovernor {\n        IGraphToken grt = graphToken();\n        grt.decreaseAllowance(_spender, grt.allowance(address(this), _spender));\n    }\n}\n\n\n",
        "CodeNames": [
            "BridgeEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\n initializer\n",
                    "//solidity\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n",
                    "//solidity\n     function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n"
                ],
                "Type": " Initialize function in  L2GraphToken.sol ,  BridgeEscrow.sol ,  L2GraphTokenGateway.sol ,  L1GraphTokenGateway.sol  can be invoked multiple times from the implementation contract",
                "Description": "*Submitted by ladboy233, also found by csanuragjain*\n\nL2GraphTokenGateway.sol#L87(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L87)<br\nL2GraphToken.sol#L48(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/token/L2GraphToken.sol#L48)<br\nL1GraphTokenGateway.sol#L99(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/L1GraphTokenGateway.sol#L99)<br\nBridgeEscrow.sol#L20(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/BridgeEscrow.sol#L20)<br\n\nInitialize function in L2GraphToken.sol, BridgeEscrow.sol, L2GraphTokenGateway.sol, and L1GraphTokenGateway.sol can be invoked multiple times from the implementation contract. This means a compromised implementation can reinitialize the contract above and become the owner to complete the privilege escalation then drain the user's fund.\n\nUsually in Upgradeable contract, an initialize function is protected by the modifier\n\nsolidity\n initializer\n\n\nto make sure the contract can only be initialized once.\n\n\n1.  The implementation contract is compromised,\n\n2.  The attacker reinitialize the BridgeEscrow contract\n\n<!----\n\n        function initialize(address _controller) external onlyImpl {\n            Managed._initialize(_controller);\n        }\n\nthe onlyGovernor modifier's result depends on the controller because\n\nsolidity\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n\n3.  The attacker has the governor access to the BridgeEscrow,\n\n4.  The attack can call the approve function to approve malicious contract\n\nsolidity\n     function approveAll(address _spender) external onlyGovernor {\n        graphToken().approve(_spender, type(uint256).max);\n    }\n\n\n5.  The attack can drain all the GRT token from the BridgeEscrow.\n\n",
                "Repair": "\nWe recommend the project use the modifier\n\nsolidity\n initializer\n\n\nto protect the initialize function from being reinitiated\n\nsolidity\n   function initialize(address _owner) external onlyImpl initializer  {\n\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149#issuecomment-1279975526):\n  Sponsor please also review #72(https://github.com/code-423n4/2022-10-thegraph-findings/issues/72) which is a duplicate but has a slightly different impact statement to the same underlying issue. \n\npcarranzav (The Graph) confirmed and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149#issuecomment-1282506646):\n  The impact from #72(https://github.com/code-423n4/2022-10-thegraph-findings/issues/72) was discussed with a warden and I consider it valid and worth fixing.\n \n The impact from this one requires the implementation to be compromised in a way that allows calling initialize(). Since all implementations use GraphUpgradeable, I don't see how that's possible without also compromising the GraphProxyAdmin and therefore compromising the governor, which would mean much bigger problems.\n \n I still consider this risky enough that a Medium severity is reasonable, both in #72(https://github.com/code-423n4/2022-10-thegraph-findings/issues/72) and this one.\n\nTrust (warden) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149#issuecomment-1283007685):\n  Exploit of this bug requires ProxyAdmin compromise, and if attacker has that then there are many ways to severely damage the proxy. It's a good observation and should be fixed, but it seems to be a best practice issue.\n\npcarranzav (The Graph) resolved and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149#issuecomment-1287229657):\n  Fix PRd in https://github.com/graphprotocol/contracts/pull/741\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149#issuecomment-1287460267):\n  @Trust makes reasonable points, but I think it's still correct to award this as Medium.  \n\nTrust (warden) reviewed mitigation:\n   Fixed in standalone PR(https://github.com/graphprotocol/contracts/pull/741). Fixed by using OpenZeppelin's initializer guard in contracts BridgeEscrow, L1GraphTokenGateway, L2GraphTokenGateway and L2GraphToken.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-peripherals\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deployed or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    function pauseCreateRetryables() external;\n\n    function unpauseCreateRetryables() external;\n\n    function startRewriteAddress() external;\n\n    function stopRewriteAddress() external;\n}\n\n\n",
        "CodeNames": [
            "ITokenGateway.sol",
            "IInbox.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "outboundTransfer",
                    "valueRefundAddress",
                    "submissionRefundAddress"
                ],
                "Type": " If L1GraphTokenGateway's  outboundTransfer  is called by a contract, the entire  msg.value  is blackholed, whether the ticket got redeemed or not",
                "Description": "*Submitted by Trust*\n\nL1GraphTokenGateway.sol#L236(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/gateway/L1GraphTokenGateway.sol#L236)<br\n\nThe outboundTransfer function in L1GraphTokenGateway is used to transfer user's Graph tokens to L2. To do that it eventually calls the standard Arbitrum Inbox's createRetryableTicket. The issue is that it passes caller's address in the submissionRefundAddress and valueRefundAddress. This behaves fine if caller is an EOA, but if it's called by a contract it will lead to loss of the submissionRefund (ETH passed to outboundTransfer() minus the total submission fee), or in the event of failed L2 ticket creation, the whole submission fee. The reason it's fine for EOA is because of the fact that ETH and Arbitrum addresses are congruent. However, the calling contract probably does not exist on L2 and even in the rare case it does, it might not have a function to move out the refund.\n\nThe docs don't suggest contracts should not use the TokenGateway, and it is fair to assume it will be used in this way. Multisigs are inherently contracts, which is one of the valid use cases. Since likelihood is high and impact is medium (loss of submission fee), I believe it to be a HIGH severity find.\n\n\nIf L1GraphTokenGateway's outboundTransfer is called by a contract, the entire msg.value is blackholed, whether the ticket got redeemed or not.\n\n\nAlice has a multisig wallet. She sends 100 Graph tokens to L1GraphTokenGateway, and passes X ETH for submission. She receives an L1 ticket, but since the max gas was too low, the creation failed on L2 and the funds got sent to the multisig address at L2. Therefore, Alice loses X ETH.\n\n\n* <https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md\n* Manual audit\n\n",
                "Repair": "\nA possible fix is to add an isContract flag. If sender is a contract, require the flag to be true.\n\nAnother option is to add a refundAddr address parameter to the API.\n\n0xean (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/294#issuecomment-1280009140):\n  I think adding the refundAddr to the API is a good suggestion.  I don't see how this qualifies as High however and think Medium severity would be more appropriate given we are talking about gas refunds.  \n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n This seems like a leak of value situation rather than Assets being directly lost or stolen. \n\npcarranzav (The Graph) acknowledged, but disagreed with severity and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/294#issuecomment-1280944979):\n  The POC described by the warden is no longer valid with Arbitrum Nitro. Retryable ticket submission fee is now checked in L1, so it's impossible that the ticket creation fails in L2 (Arbitrum docs might be outdated on this).\n \n It is true, however, that any _refunded_ value would be lost if the sender is a contract, though they could be reused in future retryable tickets by the same sender (since, if I recall correctly, the refund address will be used to pay for gas in L2). This is standard behavior for retryable tickets though, and users sending funds through the bridge should be aware of this when bridging tokens: in the worst case, the sender has specified a max submission fee, gas price and max gas, and the resulting behavior would be equivalent to _exactly_ those amounts being used.\n \n As for the suggested mitigation, it would require adding a new/overloaded interface, since the existing API is designed to be compatible with Arbitrum's Gateway Router and is standard for Arbitrum token bridges.\n \n For these reasons, I think this finding might be more of a QA severity?\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/294#issuecomment-1287482187):\n  While there may not be a reasonable fix for this, I still think it is a Medium severity issue that integrators / callers from multi-sigs should be aware of.\n\npcarranzav (The Graph) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/294#issuecomment-1287485519):\n  Sounds fair \ud83d\udc4d I'd appreciate it if the final report noted that the ticket creation failure on L2 is not an issue though. \n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-peripherals\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deployed or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n}\n\n\n",
        "CodeNames": [
            "ITokenGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "Solidity\nmodifier onlyL1Counterpart() {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n"
                ],
                "Type": " After proposed 0.8.0 upgrade kicks in, L2  finalizeInboundTransfer  might not work",
                "Description": "*Submitted by Trust*\n\nL2GraphTokenGateway.sol#L70(https://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L70)<br\n\nL2GraphTokenGateway uses the onlyL1Counterpart modifier to make sure finalizeInboundTransfer is only called from L1GraphTokenGateway. Its implementation is:\n\nSolidity\nmodifier onlyL1Counterpart() {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n\nIt uses applyL1ToL2Alias defined as:\n\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n        /// @notice Utility function that converts the address in the L1 that submitted a tx to\n        /// the inbox to the msg.sender viewed in the L2\n        /// @param l1Address the address in the L1 that triggered the tx to L2\n        /// @return l2Address L2 address as viewed in msg.sender\n        function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n\nThis behavior matches with how Arbitrum augments the sender's address to L2. The issue is that I've spoken with the team and they are planning(https://github.com/graphprotocol/contracts/pull/725) an upgrade from Solidity 0.7.6 to 0.8.0. Their proposed changes(https://github.com/graphprotocol/contracts/blob/c4d3cb56cb4032dbb3a0f1b7535b5d94ccf86222/contracts/arbitrum/AddressAliasHelper.sol) will break this function, because under 0.8.0, this line has a ~ 1/15 chance to overflow:\n\nl2Address = address(uint160(l1Address) + offset);\n\nInterestingly, the sum intentionally wraps around using the uint160 type to return a correct address, but this wrapping will overflow in 0.8.0\n\n\nThere is a ~6.5% chance that finalizeInboundTransfer will not work.\n\n\nl1Address is L1GraphTokenGateway, suppose its address is 0xF000000000000000000000000000000000000000.\n\nThen 0xF000000000000000000000000000000000000000 + 0x1111000000000000000000000000000000001111  UINT160_MAX , meaning overflow.\n\n",
                "Repair": "\nWrap the calculation in an unchecked block, which will make it behave correctly.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/289#issuecomment-1279848962):\n  This seems out of scope.  The code has been asked to be audited given a certain compiler version.  Will wait for sponsor review before closing as out of scope.  \n\npcarranzav (The Graph) confirmed and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/289#issuecomment-1282372339):\n  While I agree the submission is technically out of scope, I do consider it valuable. It's unclear if we'll upgrade to 0.8 soon or not, but knowing this does prevent a pretty bad potential issue if we do. Not sure if/how it would fit in the severity scale, but I would appreciate it if you could consider this eligible for awarding.\n\n0xean (judge) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/289#issuecomment-1282380675):\n  Great, happy to leave it as a Medium risk and valid.   \n\npcarranzav (The Graph) resolved and commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/289#issuecomment-1287186126):\n  (Preemptively) fixed in https://github.com/graphprotocol/contracts/pull/738\n\n Trust (warden) reviewed mitigation:\n Fixed in future 0.8.0 upgrade branch PR(https://github.com/graphprotocol/contracts/pull/738). Fixed by wrapping the potential overflowing and underflowing operations in an unchecked block.\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 30 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-10-thegraph-findings/issues/230) by 0xSmartContract received the top score from the judge.\n\n*The following wardens also submitted reports: rbserver(https://github.com/code-423n4/2022-10-thegraph-findings/issues/263), zzzitron(https://github.com/code-423n4/2022-10-thegraph-findings/issues/198), Bnke0x0(https://github.com/code-423n4/2022-10-thegraph-findings/issues/10), RaymondFam(https://github.com/code-423n4/2022-10-thegraph-findings/issues/108), ladboy233(https://github.com/code-423n4/2022-10-thegraph-findings/issues/111), IllIllI(https://github.com/code-423n4/2022-10-thegraph-findings/issues/118), Chom(https://github.com/code-423n4/2022-10-thegraph-findings/issues/168), 0x1f8b(https://github.com/code-423n4/2022-10-thegraph-findings/issues/185), Trust(https://github.com/code-423n4/2022-10-thegraph-findings/issues/293), cccz(https://github.com/code-423n4/2022-10-thegraph-findings/issues/39), chrisdior4(https://github.com/code-423n4/2022-10-thegraph-findings/issues/15), gogo(https://github.com/code-423n4/2022-10-thegraph-findings/issues/19), mcwildy(https://github.com/code-423n4/2022-10-thegraph-findings/issues/28), oyc_109(https://github.com/code-423n4/2022-10-thegraph-findings/issues/38), mics(https://github.com/code-423n4/2022-10-thegraph-findings/issues/60), bobirichman(https://github.com/code-423n4/2022-10-thegraph-findings/issues/62), fatherOfBlocks(https://github.com/code-423n4/2022-10-thegraph-findings/issues/95), Rahoz(https://github.com/code-423n4/2022-10-thegraph-findings/issues/144), Waze(https://github.com/code-423n4/2022-10-thegraph-findings/issues/159), 0xNazgul(https://github.com/code-423n4/2022-10-thegraph-findings/issues/242), nicobevi(https://github.com/code-423n4/2022-10-thegraph-findings/issues/256), bulej93(https://github.com/code-423n4/2022-10-thegraph-findings/issues/261), delfin454000(https://github.com/code-423n4/2022-10-thegraph-findings/issues/262), rotcivegaf(https://github.com/code-423n4/2022-10-thegraph-findings/issues/273), 0x4non(https://github.com/code-423n4/2022-10-thegraph-findings/issues/276), c3phas(https://github.com/code-423n4/2022-10-thegraph-findings/issues/281), brgltd(https://github.com/code-423n4/2022-10-thegraph-findings/issues/282), ajtra(https://github.com/code-423n4/2022-10-thegraph-findings/issues/292), and Josiah(https://github.com/code-423n4/2022-10-thegraph-findings/issues/313).*\n\n## Non-Critical Issues List\n| Number |Issues Details|Context|\n|:--:|:-------|:--:|\n| N-01] | Testing all functions is best practice | |\n| N-02] |Include return parameters in _NatSpec comments_|7|\n| N-03] | 0 address check | 6 |\n| N-04] | Use a more recent version of Solidity | All contracts |\n| N-05] | Require revert cause should be known | 4 |\n| N-06] | Use require instead of assert | 1 |\n| N-07] | For modern and more readable code; update import usages | 13 |\n| N-08] | Function writing that does not comply with the Solidity Style Guide | 7 |\n| N-09] | Implement some type of version counter that will be incremented automatically for contract upgrades| 2 |\n| N-10] | NatSpec is Missing| 4 |\n| N-20] | Omissions in Events| 11 |\n| N-12] | Constant values such as a call to keccak256(), should used to immutable rather than constant|  |\n| N-13] | Floating pragma| All contracts |\n| N-14] | Inconsistent Solidity Versions |  |\n| N-15] | For extended \"using-for\" usage, use the latest pragma version |  |\n| N-16] | For functions, follow Solidity standard naming conventions | 2 |\n|[N-17]| Add to _blacklist function_ | |\n\nTotal 16 issues\n\n## Low Risk Issues List\n| Number |Issues Details|Context\n|:--:|:-------|:--:|\n|[L-02]| Using Vulnerable Version of Openzeppelin| 1 |\n|[L-03]| A protected initializer function that can be called at most once must be defined| 4 |\n|[L-04]| Avoid _shadowing_ inherited state variables | 1 |\n|[L-05]| NatSpec comments should be increased in contracts | 12 |\n\nTotal 5 issues\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "js\n-----------------------------|----------|----------|----------|----------|----------------|\nFile                         |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n-----------------------------|----------|----------|----------|----------|----------------|\n  GNS.sol                    |    88.59 |    82.69 |    91.67 |    88.67 |... 738,741,792 |\n epochs/                     |    85.19 |       50 |    90.91 |    85.19 |                |\n  EpochManager.sol           |    85.19 |       50 |    90.91 |    85.19 |   93,95,96,101 |\n  Managed.sol                |    94.29 |     87.5 |       95 |    94.87 |        154,164 |\n  Pausable.sol               |    86.67 |       75 |      100 |    86.67 |          28,42 |\n libraries/                  |    95.24 |       50 |      100 |    97.67 |                |\n  HexStrings.sol             |    93.33 |       50 |      100 |    93.75 |             13 |\n  Staking.sol                |    96.97 |    94.74 |    93.33 |    96.98 |... 1,1588,1600 |\n  LibFixedMath.sol           |    71.69 |    56.58 |    47.37 |    71.69 |... 403,404,405 |\n statechannels/              |    90.48 |    81.25 |    91.67 |    90.48 |                |\n  AllocationExchange.sol     |    92.59 |       85 |     87.5 |    92.59 |        136,137 |\n  GRTWithdrawHelper.sol      |    86.67 |       75 |      100 |    86.67 |          72,73 |\n upgrades/                   |    98.25 |    65.38 |    96.97 |    95.77 |                |\n  GraphProxy.sol             |      100 |    71.43 |      100 |    96.67 |            200 |\n  GraphProxyStorage.sol      |    91.67 |        0 |    85.71 |    89.47 |          62,63 |\n-----------------------------|----------|----------|----------|----------|----------------|\nAll files                    |    91.71 |    81.07 |    90.79 |    91.77 |                |\n-----------------------------|----------|----------|----------|----------|----------------|\n"
                ],
                "Type": " Testing all functions is best practice ",
                "Description": "\nThe test coverage rate of 91%. Testing all functions is best practice in terms of security criteria.\njs\n-----------------------------|----------|----------|----------|----------|----------------|\nFile                         |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n-----------------------------|----------|----------|----------|----------|----------------|\n  GNS.sol                    |    88.59 |    82.69 |    91.67 |    88.67 |... 738,741,792 |\n epochs/                     |    85.19 |       50 |    90.91 |    85.19 |                |\n  EpochManager.sol           |    85.19 |       50 |    90.91 |    85.19 |   93,95,96,101 |\n  Managed.sol                |    94.29 |     87.5 |       95 |    94.87 |        154,164 |\n  Pausable.sol               |    86.67 |       75 |      100 |    86.67 |          28,42 |\n libraries/                  |    95.24 |       50 |      100 |    97.67 |                |\n  HexStrings.sol             |    93.33 |       50 |      100 |    93.75 |             13 |\n  Staking.sol                |    96.97 |    94.74 |    93.33 |    96.98 |... 1,1588,1600 |\n  LibFixedMath.sol           |    71.69 |    56.58 |    47.37 |    71.69 |... 403,404,405 |\n statechannels/              |    90.48 |    81.25 |    91.67 |    90.48 |                |\n  AllocationExchange.sol     |    92.59 |       85 |     87.5 |    92.59 |        136,137 |\n  GRTWithdrawHelper.sol      |    86.67 |       75 |      100 |    86.67 |          72,73 |\n upgrades/                   |    98.25 |    65.38 |    96.97 |    95.77 |                |\n  GraphProxy.sol             |      100 |    71.43 |      100 |    96.67 |            200 |\n  GraphProxyStorage.sol      |    91.67 |        0 |    85.71 |    89.47 |          62,63 |\n-----------------------------|----------|----------|----------|----------|----------------|\nAll files                    |    91.71 |    81.07 |    90.79 |    91.77 |                |\n-----------------------------|----------|----------|----------|----------|----------------|\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [],
                "Type": " For modern and more readable code; update import usages",
                "Description": "\nICuration.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/curation/ICuration.sol), IGraphCurationToken.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/curation/IGraphCurationToken.sol), BridgeEscrow.sol#L5-L7(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/gateway/BridgeEscrow.sol#L5-L7), L1GraphTokenGateway.sol#L6-L10(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/gateway/L1GraphTokenGateway.sol#L6-L10), Managed.sol#L5-L12(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/governance/Managed.sol#L5-L12), L2GraphTokenGateway.sol#L6-L13(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/l2/gateway/L2GraphTokenGateway.sol#L6-L13), GraphTokenUpgradeable.sol#L5-L10(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/l2/token/GraphTokenUpgradeable.sol#L5-L10), L2GraphToken.sol#L5-L8(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/l2/token/L2GraphToken.sol#L5-L8), IStaking.sol#L6(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/staking/IStaking.sol#L6), IGraphToken.sol#L5(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/token/IGraphToken.sol#L5), GraphProxy.sol#L5-L7(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxy.sol#L5-L7), GraphProxyAdmin.sol#L5-L8(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxyAdmin.sol#L5-L8), GraphUpgradeable.sol#L5(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphUpgradeable.sol#L5)\n\nOur Solidity code is also cleaner in another way that might not be noticeable: the struct Point. We were importing it previously with global import but not using it. The Point struct polluted the source code with an unnecessary object we were not using because we did not need it. This was breaking the rule of modularity and modular programming: only import what you need Specific imports with curly braces allow us to apply this rule better.\n\n",
                "Repair": "import {contract1 , contract2} from \"filename.sol\";\n\n\n"
            },
            {
                "Name": "-08",
                "Location": [],
                "Type": "  Function writing  that does not comply with the  Solidity Style Guide ",
                "Description": "\nGraphUpgradeable.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphUpgradeable.sol), GraphProxyAdmin.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxyAdmin.sol), GraphProxy.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxy.sol), Managed.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/governance/Managed.sol), L2GraphTokenGateway.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/l2/gateway/L2GraphTokenGateway.sol), L1GraphTokenGateway.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/gateway/L1GraphTokenGateway.sol), GraphTokenGateway.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/gateway/GraphTokenGateway.sol)\n\nOrder of Functions; ordering helps readers identify which functions they can call and to find the constructor and fallback definitions easier. But there are contracts in the project that do not comply with this.\n\nhttps://docs.soliditylang.org/en/v0.8.17/style-guide.html\n\nFunctions should be grouped according to their visibility and ordered:\n\nconstructor\nreceive function (if exists)\nfallback function (if exists)\nexternal\npublic\ninternal\nprivate\nwithin a grouping, place the view and pure functions last\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "js\n function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n"
                ],
                "Type": " Implement some type of version counter that will be incremented automatically for contract upgrades",
                "Description": "\nGraphProxyAdmin.sol#L77(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxyAdmin.sol#L77)<br\nGraphProxy.sol#L115(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxy.sol#L115)<br\n\nAs part of the upgradeability of  Proxies , the contract can be upgraded multiple times, where it is a systematic approach to record the version of each upgrade.\n\njs\n function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n\nI suggest implementing some kind of version counter that will be incremented automatically when you upgrade the contract.\n\n",
                "Repair": "js\n\nuint256 public authorizeUpgradeCounter;\n\n function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n       authorizeUpgradeCounter+=1;\n\n    }\n\n\n\n"
            },
            {
                "Name": "-14 ",
                "Location": [
                    "js\ncontracts/governance/IController.sol:\npragma //solidity =0.6.12 <0.8.0;\n\nother contracts:\npragma //solidity ^0.7.6;\n"
                ],
                "Type": " Inconsistent Solidity Versions ",
                "Description": "\nDifferent Solidity compiler versions are used throughout Src repositories. The following contracts mix versions: \n\njs\ncontracts/governance/IController.sol:\npragma solidity =0.6.12 <0.8.0;\n\nother contracts:\npragma solidity ^0.7.6;\n\n\n",
                "Repair": "Versions must be consistent with each other.\n\n\n"
            },
            {
                "Name": "-17",
                "Location": [
                    "js\n     modifier nonBlacklistRequired(address extension) {\n         require(!_blacklistedExtensions.contains(extension), \"Extension blacklisted\");\n         _;\n     }\n"
                ],
                "Type": " Add to  _blacklist function_ ",
                "Description": "\nCryptocurrency mixing service, Tornado Cash, has been blacklisted in the OFAC.<br\nA lot of blockchain companies, token projects, NFT Projects have blacklisted all Ethereum addresses owned by Tornado Cash listed in the US Treasury Department's sanction against the protocol.<br\nhttps://home.treasury.gov/policy-issues/financial-sanctions/recent-actions/20220808<br\nIn addition, these platforms even ban accounts that have received ETH on their account with Tornadocash.\n\nSome of these Projects;\n* USDC (https://www.circle.com/en/usdc)\n* Flashbots (https://www.paradigm.xyz/portfolio/flashbots )\n* Aave (https://aave.com/)\n* Uniswap\n* Balancer\n* Infura\n* Alchemy \n* Opensea\n* dYdX \n\nDetails on the subject;<br\nhttps://twitter.com/bantg/status/1556712790894706688?s=20&t=HUTDTeLikUr6Dv9JdMF7AA\n\nhttps://cryptopotato.com/defi-protocol-aave-bans-justin-sun-after-he-randomly-received-0-1-eth-from-tornado-cash/\n\nFor this reason, every project in the Ethereum network must have a blacklist function, this is a good method to avoid legal problems in the future, apart from the current need.\n\nTransactions from the project by an account funded by Tonadocash or banned by OFAC can lead to legal problems.Especially American citizens may want to get addresses to the blacklist legally, this is not an obligation\n\nIf you think that such legal prohibitions should be made directly by validators, this may not be possible:<br\nhttps://www.paradigm.xyz/2022/09/base-layer-neutrality\n\nThe ban on Tornado Cash makes little sense, because in the end, no one can prevent people from using other mixer smart contracts, or forking the existing ones. It neither hinders cybercrime, nor privacy.\n\nHere is the most beautiful and close to the project example; Manifold\n\nManifold Contract<br\nhttps://etherscan.io/address/0xe4e4003afe3765aca8149a82fc064c0b125b9e5a#code\n\njs\n     modifier nonBlacklistRequired(address extension) {\n         require(!_blacklistedExtensions.contains(extension), \"Extension blacklisted\");\n         _;\n     }\n\n",
                "Repair": "Add to Blacklist function and modifier.\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts/governance/Pausable.sol\n\n/// @audit Variable ordering with 3 slots instead of the current 4:\n///           uint256(32):lastPausePartialTime, uint256(32):lastPauseTime, address(20):pauseGuardian, bool(1):_partialPaused, bool(1):_paused\n8:        bool internal _partialPaused;\n\n"
                ],
                "Type": " State variables can be packed into fewer storage slots",
                "Description": "If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (20000 gas). Reads of the variables can also be cheaper\n\n*There is 1 instance of this issue:*\nsolidity\nFile: contracts/governance/Pausable.sol\n\n/// @audit Variable ordering with 3 slots instead of the current 4:\n///           uint256(32):lastPausePartialTime, uint256(32):lastPauseTime, address(20):pauseGuardian, bool(1):_partialPaused, bool(1):_paused\n8:        bool internal _partialPaused;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Pausable.sol#L8\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n/// @audit approve()\n29:           graphToken().approve(_spender, type(uint256).max);\n\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit bridge()\n77:           IBridge bridge = IInbox(inbox).bridge();\n\n/// @audit l2ToL1Sender()\n81:           address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n\n"
                ],
                "Type": "  Avoid contract existence checks by using low level calls",
                "Description": "Prior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence\n\n*There are 3 instances of this issue:*\nsolidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n/// @audit approve()\n29:           graphToken().approve(_spender, type(uint256).max);\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/BridgeEscrow.sol#L29\n\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit bridge()\n77:           IBridge bridge = IInbox(inbox).bridge();\n\n/// @audit l2ToL1Sender()\n81:           address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L77\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n/// @audit governor on line 62\n65:           emit NewOwnership(oldGovernor, governor);\n\n/// @audit pendingGovernor on line 44\n46:           emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n\n/// @audit pendingGovernor on line 55\n55:               pendingGovernor != address(0) && msg.sender == pendingGovernor,\n\n/// @audit pendingGovernor on line 55\n60:           address oldPendingGovernor = pendingGovernor;\n\n/// @audit pendingGovernor on line 60\n62:           governor = pendingGovernor;\n\n/// @audit pendingGovernor on line 63\n66:           emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n\n",
                    "//solidity\nFile: contracts/governance/Pausable.sol\n\n/// @audit _partialPaused on line 30\n31:           if (_partialPaused) {\n\n/// @audit _partialPaused on line 31\n34:           emit PartialPauseChanged(_partialPaused);\n\n/// @audit _paused on line 44\n45:           if (_paused) {\n\n/// @audit _paused on line 45\n48:           emit PauseChanged(_paused);\n\n"
                ],
                "Type": "  State variables should be cached in stack variables rather than re-reading them from storage",
                "Description": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 10 instances of this issue:*\nsolidity\nFile: contracts/governance/Governed.sol\n\n/// @audit governor on line 62\n65:           emit NewOwnership(oldGovernor, governor);\n\n/// @audit pendingGovernor on line 44\n46:           emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n\n/// @audit pendingGovernor on line 55\n55:               pendingGovernor != address(0) && msg.sender == pendingGovernor,\n\n/// @audit pendingGovernor on line 55\n60:           address oldPendingGovernor = pendingGovernor;\n\n/// @audit pendingGovernor on line 60\n62:           governor = pendingGovernor;\n\n/// @audit pendingGovernor on line 63\n66:           emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L65\n\nsolidity\nFile: contracts/governance/Pausable.sol\n\n/// @audit _partialPaused on line 30\n31:           if (_partialPaused) {\n\n/// @audit _partialPaused on line 31\n34:           emit PartialPauseChanged(_partialPaused);\n\n/// @audit _paused on line 44\n45:           if (_paused) {\n\n/// @audit _paused on line 45\n48:           emit PauseChanged(_paused);\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Pausable.sol#L31\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-14",
                "Location": [
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n43:           address oldPendingGovernor = pendingGovernor;\n\n59:           address oldGovernor = governor;\n\n60:           address oldPendingGovernor = pendingGovernor;\n\n",
                    "//solidity\nFile: contracts/governance/Pausable.sol\n\n56:           address oldPauseGuardian = pauseGuardian;\n\n"
                ],
                "Type": "  Stack variable used as a cheaper cache for a state variable is only used once",
                "Description": "If the variable is only accessed once, it's cheaper to use the state variable directly that one time, and save the 3 gas the extra stack assignment would spend\n\n*There are 4 instances of this issue:*\nsolidity\nFile: contracts/governance/Governed.sol\n\n43:           address oldPendingGovernor = pendingGovernor;\n\n59:           address oldGovernor = governor;\n\n60:           address oldPendingGovernor = pendingGovernor;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L43\n\nsolidity\nFile: contracts/governance/Pausable.sol\n\n56:           address oldPauseGuardian = pauseGuardian;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Pausable.sol#L56\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n",
        "CodeNames": [
            "AddressAliasHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "@return",
                    "/// @return"
                ],
                "Type": " Include   return parameters   in _NatSpec comments_",
                "Description": "\nIRewardsManager.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/rewards/IRewardsManager.sol)<br\nIStaking.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/staking/IStaking.sol)<br\nIGraphToken.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/token/IGraphToken.sol)<br\nGraphTokenGateway.sol#L54(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/gateway/GraphTokenGateway.sol#L54)<br\nIGraphProxy.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/IGraphProxy.sol)<br\nIEpochManager.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/epochs/IEpochManager.sol)<br\nIController.sol(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/governance/IController.sol)<br\n\nIt is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as Defi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.\n\nhttps://docs.soliditylang.org/en/v0.8.15/natspec-format.html\n\nIf Return parameters are declared, you must prefix them with /// @return.\n\nSome code analysis programs do analysis by reading NatSpec details, if they can't see the @return tag, they do incomplete analysis.\n\n",
                "Repair": "Include return parameters in NatSpec comments\n\nRecommendation Code Style:\n js\n    /// @notice information about what a function does\n    /// @param pageId The id of the page to get the URI for.\n    /// @return Returns a page's URI if it has been minted \n    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {\n        if (pageId == 0 || pageId  currentId) revert(\"NOT_MINTED\");\n\n        return string.concat(BASE_URI, pageId.toString());\n    }\n\n\n\n"
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n43        function _notPartialPaused() internal view {\n44:           require(!controller.paused(), \"Paused\");\n\n52        function _onlyGovernor() internal view {\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n56        function _onlyController() internal view {\n57:           require(msg.sender == address(controller), \"Caller must be Controller\");\n\n"
                ],
                "Type": "   internal  functions only called once can be inlined to save gas",
                "Description": "Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\n*There are 3 instances of this issue:*\nsolidity\nFile: contracts/governance/Managed.sol\n\n43        function _notPartialPaused() internal view {\n44:           require(!controller.paused(), \"Paused\");\n\n52        function _onlyGovernor() internal view {\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n56        function _onlyController() internal view {\n57:           require(msg.sender == address(controller), \"Caller must be Controller\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L43-L44\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n19            require(\n20                msg.sender == controller.getGovernor() || msg.sender == pauseGuardian,\n21                \"Only Governor or Guardian can call\"\n22:           );\n\n",
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxy.sol\n\n105:          require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\n141:          require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n32:           require(msg.sender == _implementation(), \"Caller must be the implementation\");\n\n"
                ],
                "Type": "   require() / revert()  strings longer than 32 bytes cost extra gas",
                "Description": "Each extra memory word of bytes past the original 32 incurs an MSTORE(https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs 3 gas\n\n*There are 6 instances of this issue:*\nsolidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n19            require(\n20                msg.sender == controller.getGovernor() || msg.sender == pauseGuardian,\n21                \"Only Governor or Guardian can call\"\n22:           );\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L19-L22\n\nsolidity\nFile: contracts/governance/Managed.sol\n\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L53\n\nsolidity\nFile: contracts/upgrades/GraphProxy.sol\n\n105:          require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\n141:          require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L105\n\nsolidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n32:           require(msg.sender == _implementation(), \"Caller must be the implementation\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L32\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n142:          require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n\n",
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n54            require(\n55                pendingGovernor != address(0) && msg.sender == pendingGovernor,\n56                \"Caller must be pending governor\"\n57:           );\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxy.sol\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n"
                ],
                "Type": "  Splitting  require()  statements that use  &&  saves gas",
                "Description": "See this issue(https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by 3 gas\n\n*There are 3 instances of this issue:*\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n142:          require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L142\n\nsolidity\nFile: contracts/governance/Governed.sol\n\n54            require(\n55                pendingGovernor != address(0) && msg.sender == pendingGovernor,\n56                \"Caller must be pending governor\"\n57:           );\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L54-L57\n\nsolidity\nFile: contracts/upgrades/GraphProxy.sol\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L142-L145\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./GraphProxyStorage.sol\";\n\n/**\n * @title Graph Proxy\n * @dev Graph Proxy contract used to delegate call implementation contracts and support upgrades.\n * This contract should NOT define storage as it is managed by GraphProxyStorage.\n * This contract implements a proxy that is upgradeable by an admin.\n * https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#transparent-proxies-and-function-clashes\n */\ncontract GraphProxy is GraphProxyStorage {\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin or pending implementation.\n     */\n    modifier ifAdminOrPendingImpl() {\n        if (msg.sender == _admin() || msg.sender == _pendingImplementation()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Contract constructor.\n     * @param _impl Address of the initial implementation\n     * @param _admin Address of the proxy admin\n     */\n    constructor(address _impl, address _admin) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        assert(\n            PENDING_IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.pendingImplementation\")) - 1)\n        );\n\n        _setAdmin(_admin);\n        _setPendingImplementation(_impl);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin and implementation can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdminOrPendingImpl returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdminOrPendingImpl returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current pending implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x9e5eddc59e0b171f57125ab86bee043d9128098c3a6b9adb4f2e86333c2f6f8c`\n     */\n    function pendingImplementation() external ifAdminOrPendingImpl returns (address) {\n        return _pendingImplementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function setAdmin(address _newAdmin) external ifAdmin {\n        require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        _setAdmin(_newAdmin);\n    }\n\n    /**\n     * @dev Upgrades to a new implementation contract.\n     * @param _newImplementation Address of implementation contract\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgrade() external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgradeAndCall(bytes calldata data) external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _implementation().delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );\n\n        _setImplementation(_pendingImplementation);\n        _setPendingImplementation(address(0));\n    }\n\n    /**\n     * @dev Delegates the current call to implementation.\n     * This function does not return to its internal call site, it will return directly to the\n     * external caller.\n     */\n    function _fallback() internal {\n        require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n        assembly {\n            // (a) get free memory pointer\n            let ptr := mload(0x40)\n\n            // (b) get address of the implementation\n            let impl := and(sload(IMPLEMENTATION_SLOT), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // (1) copy incoming call data\n            calldatacopy(ptr, 0, calldatasize())\n\n            // (2) forward call to logic contract\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n\n            // (3) retrieve return data\n            returndatacopy(ptr, 0, size)\n\n            // (4) forward return data back to caller\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n}\n\n\n",
        "CodeNames": [
            "AddressAliasHelper.sol",
            "GraphProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "assert",
                    "require"
                ],
                "Type": " Use  require  instead of  assert ",
                "Description": "\nGraphProxy.sol#L47-L54(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxy.sol#L47-L54)\n\nAssert should not be used except for tests, require should be used\n\nPrior to Solidity 0.8.0, pressing a confirm consumes the remainder of the process's available gas instead of returning it, as request()/revert() did.\n\nAssertion() should be avoided even after solidity version 0.8.0, because its documentation states \"The Assert function generates an error of type Panic(uint256). Code that works properly should never Panic, even on invalid external input. If this happens, you need to fix it in your contract. there's a mistake\".\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../base/Multicall.sol\";\nimport \"../bancor/BancorFormula.sol\";\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../utils/TokenUtils.sol\";\n\nimport \"./IGNS.sol\";\nimport \"./GNSStorage.sol\";\n\n/**\n * @title GNS\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\n * used in the scope of the Graph Network. It translates Subgraphs into Subgraph Versions.\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\n * human-readable names. All human readable names emitted in events.\n * The contract implements a multicall behaviour to support batching multiple calls in a single\n * transaction.\n */\ncontract GNS is GNSV2Storage, GraphUpgradeable, IGNS, Multicall {\n    using SafeMath for uint256;\n\n    // -- Constants --\n\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\n\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    // Equates to Connector weight on bancor formula to be CW = 1\n    uint32 private constant defaultReserveRatio = 1000000;\n\n    // -- Events --\n\n    event SubgraphNFTUpdated(address subgraphNFT);\n\n    /**\n     * @dev Emitted when graph account sets its default name\n     */\n    event SetDefaultName(\n        address indexed graphAccount,\n        uint256 nameSystem, // only ENS for now\n        bytes32 nameIdentifier,\n        string name\n    );\n\n    /**\n     * @dev Emitted when the subgraph metadata is updated.\n     */\n    event SubgraphMetadataUpdated(uint256 indexed subgraphID, bytes32 subgraphMetadata);\n\n    /**\n     * @dev Emitted when a subgraph version is updated.\n     */\n    event SubgraphVersionUpdated(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        bytes32 versionMetadata\n    );\n\n    /**\n     * @dev Emitted when a curator mints signal.\n     */\n    event SignalMinted(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalCreated,\n        uint256 vSignalCreated,\n        uint256 tokensDeposited\n    );\n\n    /**\n     * @dev Emitted when a curator burns signal.\n     */\n    event SignalBurned(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 vSignalBurnt,\n        uint256 tokensReceived\n    );\n\n    /**\n     * @dev Emitted when a curator transfers signal.\n     */\n    event SignalTransferred(\n        uint256 indexed subgraphID,\n        address indexed from,\n        address indexed to,\n        uint256 nSignalTransferred\n    );\n\n    /**\n     * @dev Emitted when a subgraph is created.\n     */\n    event SubgraphPublished(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        uint32 reserveRatio\n    );\n\n    /**\n     * @dev Emitted when a subgraph is upgraded to point to a new\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\n     * new vSignal curve.\n     */\n    event SubgraphUpgraded(\n        uint256 indexed subgraphID,\n        uint256 vSignalCreated,\n        uint256 tokensSignalled,\n        bytes32 indexed subgraphDeploymentID\n    );\n\n    /**\n     * @dev Emitted when a subgraph is deprecated.\n     */\n    event SubgraphDeprecated(uint256 indexed subgraphID, uint256 withdrawableGRT);\n\n    /**\n     * @dev Emitted when a curator withdraws GRT from a deprecated subgraph\n     */\n    event GRTWithdrawn(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 withdrawnGRT\n    );\n\n    // -- Modifiers --\n\n    /**\n     * @dev Emitted when a legacy subgraph is claimed\n     */\n    event LegacySubgraphClaimed(address indexed graphAccount, uint256 subgraphNumber);\n\n    /**\n     * @dev Modifier that allows only a subgraph operator to be the caller\n     */\n    modifier onlySubgraphAuth(uint256 _subgraphID) {\n        require(ownerOf(_subgraphID) == msg.sender, \"GNS: Must be authorized\");\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize this contract.\n     */\n    function initialize(\n        address _controller,\n        address _bondingCurve,\n        address _subgraphNFT\n    ) external onlyImpl {\n        Managed._initialize(_controller);\n\n        // Dependencies\n        bondingCurve = _bondingCurve;\n\n        // Settings\n        _setOwnerTaxPercentage(500000);\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Approve curation contract to pull funds.\n     */\n    function approveAll() external override {\n        graphToken().approve(address(curation()), MAX_UINT256);\n    }\n\n    // -- Config --\n\n    /**\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\n    }\n\n    /**\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\n        require(_ownerTaxPercentage <= MAX_PPM, \"Owner tax must be MAX_PPM or less\");\n        ownerTaxPercentage = _ownerTaxPercentage;\n        emit ParameterUpdated(\"ownerTaxPercentage\");\n    }\n\n    /**\n     * @dev Set the NFT registry contract\n     * NOTE: Calling this function will break the ownership model unless\n     * it is replaced with a fully migrated version of the NFT contract state\n     * Use with care.\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function setSubgraphNFT(address _subgraphNFT) public onlyGovernor {\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Internal: Set the NFT registry contract\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function _setSubgraphNFT(address _subgraphNFT) private {\n        require(_subgraphNFT != address(0), \"NFT address cant be zero\");\n        require(Address.isContract(_subgraphNFT), \"NFT must be valid\");\n\n        subgraphNFT = ISubgraphNFT(_subgraphNFT);\n        emit SubgraphNFTUpdated(_subgraphNFT);\n    }\n\n    // -- Actions --\n\n    /**\n     * @dev Allows a graph account to set a default name\n     * @param _graphAccount Account that is setting its name\n     * @param _nameSystem Name system account already has ownership of a name in\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\n     * @param _name The name being set as default\n     */\n    function setDefaultName(\n        address _graphAccount,\n        uint8 _nameSystem,\n        bytes32 _nameIdentifier,\n        string calldata _name\n    ) external override {\n        require(_graphAccount == msg.sender, \"GNS: Only you can set your name\");\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\n    }\n\n    /**\n     * @dev Allows a subgraph owner to update the metadata of a subgraph they have published\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function updateSubgraphMetadata(uint256 _subgraphID, bytes32 _subgraphMetadata)\n        public\n        override\n        onlySubgraphAuth(_subgraphID)\n    {\n        _setSubgraphMetadata(_subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Publish a new subgraph.\n     * @param _subgraphDeploymentID Subgraph deployment for the subgraph\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function publishNewSubgraph(\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata,\n        bytes32 _subgraphMetadata\n    ) external override notPaused {\n        // Subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // Init the subgraph\n        address subgraphOwner = msg.sender;\n        uint256 subgraphID = _nextSubgraphID(subgraphOwner);\n        SubgraphData storage subgraphData = _getSubgraphData(subgraphID);\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n        subgraphData.reserveRatio = defaultReserveRatio;\n\n        // Mint the NFT. Use the subgraphID as tokenID.\n        // This function will check the if tokenID already exists.\n        _mintNFT(subgraphOwner, subgraphID);\n        emit SubgraphPublished(subgraphID, _subgraphDeploymentID, defaultReserveRatio);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n\n        emit SubgraphVersionUpdated(subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Publish a new version of an existing subgraph.\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphDeploymentID Subgraph deployment ID of the new version\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     */\n    function publishNewVersion(\n        uint256 _subgraphID,\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata\n    ) external override notPaused onlySubgraphAuth(_subgraphID) {\n        // Perform the upgrade from the current subgraph deployment to the new one.\n        // This involves burning all signal from the old deployment and using the funds to buy\n        // from the new deployment.\n        // This will also make the change to target to the new deployment.\n\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // New subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // New subgraph deployment must be different than current\n        require(\n            _subgraphDeploymentID != subgraphData.subgraphDeploymentID,\n            \"GNS: Cannot publish a new version with the same subgraph deployment ID\"\n        );\n\n        // This is to prevent the owner from front running its name curators signal by posting\n        // its own signal ahead, bringing the name curators in, and dumping on them\n        ICuration curation = curation();\n        require(\n            !curation.isCurated(_subgraphDeploymentID),\n            \"GNS: Owner cannot point to a subgraphID that has been pre-curated\"\n        );\n\n        // Move all signal from previous version to new version\n        // NOTE: We will only do this as long as there is signal on the subgraph\n        if (subgraphData.nSignal > 0) {\n            // Burn all version signal in the name pool for tokens (w/no slippage protection)\n            // Sell all signal from the old deployment\n            uint256 tokens = curation.burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n\n            // Take the owner cut of the curation tax, add it to the total\n            // Upgrade is only callable by the owner, we assume then that msg.sender = owner\n            address subgraphOwner = msg.sender;\n            uint256 tokensWithTax = _chargeOwnerTax(\n                tokens,\n                subgraphOwner,\n                curation.curationTaxPercentage()\n            );\n\n            // Update pool: constant nSignal, vSignal can change (w/no slippage protection)\n            // Buy all signal from the new deployment\n            (subgraphData.vSignal, ) = curation.mint(_subgraphDeploymentID, tokensWithTax, 0);\n\n            emit SubgraphUpgraded(\n                _subgraphID,\n                subgraphData.vSignal,\n                tokensWithTax,\n                _subgraphDeploymentID\n            );\n        }\n\n        // Update target deployment\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n\n        emit SubgraphVersionUpdated(_subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Deprecate a subgraph. The bonding curve is destroyed, the vSignal is burned, and the GNS\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\n     * Can only be done by the subgraph owner.\n     * @param _subgraphID Subgraph ID\n     */\n    function deprecateSubgraph(uint256 _subgraphID)\n        external\n        override\n        notPaused\n        onlySubgraphAuth(_subgraphID)\n    {\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Burn signal only if it has any available\n        if (subgraphData.nSignal > 0) {\n            subgraphData.withdrawableGRT = curation().burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n        }\n\n        // Deprecate the subgraph and do cleanup\n        subgraphData.disabled = true;\n        subgraphData.vSignal = 0;\n        subgraphData.reserveRatio = 0;\n        // NOTE: We don't reset the following variable as we use it to test if the Subgraph was ever created\n        // subgraphData.subgraphDeploymentID = 0;\n\n        // Burn the NFT\n        _burnNFT(_subgraphID);\n\n        emit SubgraphDeprecated(_subgraphID, subgraphData.withdrawableGRT);\n    }\n\n    /**\n     * @dev Deposit GRT into a subgraph and mint signal.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\n     */\n    function mintSignal(\n        uint256 _subgraphID,\n        uint256 _tokensIn,\n        uint256 _nSignalOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Pull tokens from sender\n        address curator = msg.sender;\n        TokenUtils.pullTokens(graphToken(), curator, _tokensIn);\n\n        // Get name signal to mint for tokens deposited\n        (uint256 vSignal, ) = curation().mint(subgraphData.subgraphDeploymentID, _tokensIn, 0);\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n\n        // Slippage protection\n        require(nSignal >= _nSignalOutMin, \"GNS: Slippage protection\");\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.add(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.add(nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].add(nSignal);\n\n        emit SignalMinted(_subgraphID, curator, nSignal, vSignal, _tokensIn);\n    }\n\n    /**\n     * @dev Burn signal for a subgraph and return the GRT.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\n     */\n    function burnSignal(\n        uint256 _subgraphID,\n        uint256 _nSignal,\n        uint256 _tokensOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Curator balance checks\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(\n            _nSignal <= curatorNSignal,\n            \"GNS: Curator cannot withdraw more nSignal than they have\"\n        );\n\n        // Get tokens for name signal amount to burn\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignal);\n        uint256 tokens = curation().burn(subgraphData.subgraphDeploymentID, vSignal, _tokensOutMin);\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.sub(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.sub(_nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_nSignal);\n\n        // Return the tokens to the nameCurator\n        require(graphToken().transfer(curator, tokens), \"GNS: Error sending tokens\");\n\n        emit SignalBurned(_subgraphID, curator, _nSignal, vSignal, tokens);\n    }\n\n    /**\n     * @dev Move subgraph signal from sender to `_recipient`\n     * @param _subgraphID Subgraph ID\n     * @param _recipient Address to send the signal to\n     * @param _amount The amount of nSignal to transfer\n     */\n    function transferSignal(\n        uint256 _subgraphID,\n        address _recipient,\n        uint256 _amount\n    ) external override notPartialPaused {\n        require(_recipient != address(0), \"GNS: Curator cannot transfer to the zero address\");\n\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Balance checks\n        address curator = msg.sender;\n        uint256 curatorBalance = subgraphData.curatorNSignal[curator];\n        require(curatorBalance >= _amount, \"GNS: Curator transfer amount exceeds balance\");\n\n        // Move the signal\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_amount);\n        subgraphData.curatorNSignal[_recipient] = subgraphData.curatorNSignal[_recipient].add(\n            _amount\n        );\n\n        emit SignalTransferred(_subgraphID, curator, _recipient, _amount);\n    }\n\n    /**\n     * @dev Withdraw tokens from a deprecated subgraph.\n     * When the subgraph is deprecated, any curator can call this function and\n     * withdraw the GRT they are entitled for its original deposit\n     * @param _subgraphID Subgraph ID\n     */\n    function withdraw(uint256 _subgraphID) external override notPartialPaused {\n        // Subgraph validations\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(subgraphData.disabled == true, \"GNS: Must be disabled first\");\n        require(subgraphData.withdrawableGRT > 0, \"GNS: No more GRT to withdraw\");\n\n        // Curator validations\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(curatorNSignal > 0, \"GNS: No signal to withdraw GRT\");\n\n        // Get curator share of tokens to be withdrawn\n        uint256 tokensOut = curatorNSignal.mul(subgraphData.withdrawableGRT).div(\n            subgraphData.nSignal\n        );\n        subgraphData.curatorNSignal[curator] = 0;\n        subgraphData.nSignal = subgraphData.nSignal.sub(curatorNSignal);\n        subgraphData.withdrawableGRT = subgraphData.withdrawableGRT.sub(tokensOut);\n\n        // Return tokens to the curator\n        TokenUtils.pushTokens(graphToken(), curator, tokensOut);\n\n        emit GRTWithdrawn(_subgraphID, curator, curatorNSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\n     * @param _tokens Tokens that were received from deprecating the old subgraph\n     * @param _owner Subgraph owner\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\n     */\n    function _chargeOwnerTax(\n        uint256 _tokens,\n        address _owner,\n        uint32 _curationTaxPercentage\n    ) private returns (uint256) {\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\n            return 0;\n        }\n\n        // Tax on the total bonding curve funds\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\n        // Total after the tax\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\n        // The portion of tax that the owner will pay\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\n\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\n\n        // The total after tax, plus owner partial repay, divided by\n        // the tax, to adjust it slightly upwards. ex:\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\n        // To get 100 in the protocol after tax, Owner deposits\n        // ~5.26, as ~105.26 * .95 = 100\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\n        );\n\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\n\n        // Get the owner of the subgraph to reimburse the curation tax\n        TokenUtils.pullTokens(graphToken(), _owner, ownerTaxAdjustedUp);\n\n        return totalAdjustedUp;\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of tokens.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn Tokens being exchanged for subgraph signal\n     * @return Amount of subgraph signal and curation tax\n     */\n    function tokensToNSignal(uint256 _subgraphID, uint256 _tokensIn)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\n            subgraphData.subgraphDeploymentID,\n            _tokensIn\n        );\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n        return (vSignal, nSignal, curationTax);\n    }\n\n    /**\n     * @dev Calculate tokens returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for tokens\n     * @return Amount of tokens returned for an amount of subgraph signal\n     */\n    function nSignalToTokens(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        // Get subgraph or revert if not published\n        // It does not make sense to convert signal from a disabled or non-existing one\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignalIn);\n        uint256 tokensOut = curation().signalToTokens(subgraphData.subgraphDeploymentID, vSignal);\n        return (vSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of subgraph deployment signal.\n     * @param _subgraphID Subgraph ID\n     * @param _vSignalIn Amount of subgraph deployment signal to exchange for subgraph signal\n     * @return Amount of subgraph signal that can be bought\n     */\n    function vSignalToNSignal(uint256 _subgraphID, uint256 _vSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n\n        // Handle initialization by using 1:1 version to name signal\n        if (subgraphData.vSignal == 0) {\n            return _vSignalIn;\n        }\n\n        return\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _vSignalIn\n            );\n    }\n\n    /**\n     * @dev Calculate subgraph deployment signal to be returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for subgraph deployment signal\n     * @return Amount of subgraph deployment signal that can be returned\n     */\n    function nSignalToVSignal(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        return\n            BancorFormula(bondingCurve).calculateSaleReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _nSignalIn\n            );\n    }\n\n    /**\n     * @dev Get the amount of subgraph signal a curator has.\n     * @param _subgraphID Subgraph ID\n     * @param _curator Curator address\n     * @return Amount of subgraph signal owned by a curator\n     */\n    function getCuratorSignal(uint256 _subgraphID, address _curator)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _getSubgraphData(_subgraphID).curatorNSignal[_curator];\n    }\n\n    /**\n     * @dev Return the total signal on the subgraph.\n     * @param _subgraphID Subgraph ID\n     * @return Total signal on the subgraph\n     */\n    function subgraphSignal(uint256 _subgraphID) external view override returns (uint256) {\n        return _getSubgraphData(_subgraphID).nSignal;\n    }\n\n    /**\n     * @dev Return the total tokens on the subgraph at current value.\n     * @param _subgraphID Subgraph ID\n     * @return Total tokens on the subgraph\n     */\n    function subgraphTokens(uint256 _subgraphID) external view override returns (uint256) {\n        uint256 signal = _getSubgraphData(_subgraphID).nSignal;\n        if (signal > 0) {\n            (, uint256 tokens) = nSignalToTokens(_subgraphID, signal);\n            return tokens;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Create subgraphID for legacy subgraph and mint ownership NFT.\n     * @param _graphAccount Account that created the subgraph\n     * @param _subgraphNumber The sequence number of the created subgraph\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function migrateLegacySubgraph(\n        address _graphAccount,\n        uint256 _subgraphNumber,\n        bytes32 _subgraphMetadata\n    ) external {\n        // Must be an existing legacy subgraph\n        bool legacySubgraphExists = legacySubgraphData[_graphAccount][_subgraphNumber]\n            .subgraphDeploymentID != 0;\n        require(legacySubgraphExists == true, \"GNS: Subgraph does not exist\");\n\n        // Must not be a claimed subgraph\n        uint256 subgraphID = _buildSubgraphID(_graphAccount, _subgraphNumber);\n        require(\n            legacySubgraphKeys[subgraphID].account == address(0),\n            \"GNS: Subgraph was already claimed\"\n        );\n\n        // Store a reference for a legacy subgraph\n        legacySubgraphKeys[subgraphID] = IGNS.LegacySubgraphKey({\n            account: _graphAccount,\n            accountSeqID: _subgraphNumber\n        });\n\n        // Delete state for legacy subgraph\n        legacySubgraphs[_graphAccount][_subgraphNumber] = 0;\n\n        // Mint the NFT and send to owner\n        // The subgraph owner is the graph account that created it\n        _mintNFT(_graphAccount, subgraphID);\n        emit LegacySubgraphClaimed(_graphAccount, _subgraphNumber);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphID Subgraph ID\n     * @return Return true if subgraph is currently published\n     */\n    function isPublished(uint256 _subgraphID) public view override returns (bool) {\n        return _isPublished(_getSubgraphData(_subgraphID));\n    }\n\n    /**\n     * @dev Build a subgraph ID based on the account creating it and a sequence number for that account.\n     * Subgraph ID is the keccak hash of account+seqID\n     * @return Subgraph ID\n     */\n    function _buildSubgraphID(address _account, uint256 _seqID) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_account, _seqID)));\n    }\n\n    /**\n     * @dev Return the next subgraphID given the account that is creating the subgraph.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextSubgraphID(address _account) internal returns (uint256) {\n        return _buildSubgraphID(_account, _nextAccountSeqID(_account));\n    }\n\n    /**\n     * @dev Return a new consecutive sequence ID for an account and update to the next value.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextAccountSeqID(address _account) internal returns (uint256) {\n        uint256 seqID = nextAccountSeqID[_account];\n        nextAccountSeqID[_account] = nextAccountSeqID[_account].add(1);\n        return seqID;\n    }\n\n    /**\n     * @dev Get subgraph data.\n     * This function will first look for a v1 subgraph and return it if found.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphData(uint256 _subgraphID) private view returns (SubgraphData storage) {\n        // If there is a legacy subgraph created return it\n        LegacySubgraphKey storage legacySubgraphKey = legacySubgraphKeys[_subgraphID];\n        if (legacySubgraphKey.account != address(0)) {\n            return legacySubgraphData[legacySubgraphKey.account][legacySubgraphKey.accountSeqID];\n        }\n        // Return new subgraph type\n        return subgraphs[_subgraphID];\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphData Subgraph Data\n     * @return Return true if subgraph is currently published\n     */\n    function _isPublished(SubgraphData storage _subgraphData) internal view returns (bool) {\n        return _subgraphData.subgraphDeploymentID != 0 && _subgraphData.disabled == false;\n    }\n\n    /**\n     * @dev Return the subgraph data or revert if not published or deprecated.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphOrRevert(uint256 _subgraphID)\n        internal\n        view\n        returns (SubgraphData storage)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(_isPublished(subgraphData) == true, \"GNS: Must be active\");\n        return subgraphData;\n    }\n\n    // -- NFT --\n\n    /**\n     * @dev Return the owner of a subgraph.\n     * @param _tokenID Subgraph ID\n     * @return Owner address\n     */\n    function ownerOf(uint256 _tokenID) public view override returns (address) {\n        return subgraphNFT.ownerOf(_tokenID);\n    }\n\n    /**\n     * @dev Mint the NFT for the subgraph.\n     * @param _owner Owner address\n     * @param _tokenID Subgraph ID\n     */\n    function _mintNFT(address _owner, uint256 _tokenID) internal {\n        subgraphNFT.mint(_owner, _tokenID);\n    }\n\n    /**\n     * @dev Burn the NFT for the subgraph.\n     * @param _tokenID Subgraph ID\n     */\n    function _burnNFT(uint256 _tokenID) internal {\n        subgraphNFT.burn(_tokenID);\n    }\n\n    /**\n     * @dev Set the subgraph metadata.\n     * @param _tokenID Subgraph ID\n     * @param _subgraphMetadata IPFS hash of the subgraph metadata\n     */\n    function _setSubgraphMetadata(uint256 _tokenID, bytes32 _subgraphMetadata) internal {\n        subgraphNFT.setSubgraphMetadata(_tokenID, _subgraphMetadata);\n\n        // Even if the following event is emitted in the NFT we emit it here to facilitate\n        // subgraph indexing\n        emit SubgraphMetadataUpdated(_tokenID, _subgraphMetadata);\n    }\n}\n\n\n",
        "CodeNames": [
            "GNS.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-12",
                "Location": [
                    "js\ncontracts/l2/token/GraphTokenUpgradeable.sol:\n\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n        );\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\"Graph Token\");\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\"0\");\n    bytes32 private constant DOMAIN_SALT =\n        0xe33842a7acd1d5a1d28f25a931703e5605152dc48d64dc4716efdae1f5659591; // Randomly generated salt\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n"
                ],
                "Type": " Constant values such as a call to  keccak256() , should used to immutable rather than constant",
                "Description": "\nThere is a difference between constant variables and immutable variables, and they should each be used in their appropriate contexts.\n\nWhile it doesn't save any gas because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand.\n\nConstants should be used for literal values written into the code, and immutable variables should be used for expressions, or values calculated in, or passed into the constructor.\n\nThere are 5 instances of this issue:\njs\ncontracts/l2/token/GraphTokenUpgradeable.sol:\n\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n        );\n    bytes32 private constant DOMAIN_NAME_HASH = keccak256(\"Graph Token\");\n    bytes32 private constant DOMAIN_VERSION_HASH = keccak256(\"0\");\n    bytes32 private constant DOMAIN_SALT =\n        0xe33842a7acd1d5a1d28f25a931703e5605152dc48d64dc4716efdae1f5659591; // Randomly generated salt\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./GraphProxyStorage.sol\";\n\n/**\n * @title Graph Proxy\n * @dev Graph Proxy contract used to delegate call implementation contracts and support upgrades.\n * This contract should NOT define storage as it is managed by GraphProxyStorage.\n * This contract implements a proxy that is upgradeable by an admin.\n * https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#transparent-proxies-and-function-clashes\n */\ncontract GraphProxy is GraphProxyStorage {\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless\n     * the sender is the admin or pending implementation.\n     */\n    modifier ifAdminOrPendingImpl() {\n        if (msg.sender == _admin() || msg.sender == _pendingImplementation()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Contract constructor.\n     * @param _impl Address of the initial implementation\n     * @param _admin Address of the proxy admin\n     */\n    constructor(address _impl, address _admin) {\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        assert(\n            IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n        );\n        assert(\n            PENDING_IMPLEMENTATION_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.pendingImplementation\")) - 1)\n        );\n\n        _setAdmin(_admin);\n        _setPendingImplementation(_impl);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin and implementation can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdminOrPendingImpl returns (address) {\n        return _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdminOrPendingImpl returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @dev Returns the current pending implementation.\n     *\n     * NOTE: Only the admin can call this function.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x9e5eddc59e0b171f57125ab86bee043d9128098c3a6b9adb4f2e86333c2f6f8c`\n     */\n    function pendingImplementation() external ifAdminOrPendingImpl returns (address) {\n        return _pendingImplementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function setAdmin(address _newAdmin) external ifAdmin {\n        require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        _setAdmin(_newAdmin);\n    }\n\n    /**\n     * @dev Upgrades to a new implementation contract.\n     * @param _newImplementation Address of implementation contract\n     *\n     * NOTE: Only the admin can call this function.\n     */\n    function upgradeTo(address _newImplementation) external ifAdmin {\n        _setPendingImplementation(_newImplementation);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgrade() external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function acceptUpgradeAndCall(bytes calldata data) external ifAdminOrPendingImpl {\n        _acceptUpgrade();\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = _implementation().delegatecall(data);\n        require(success);\n    }\n\n    /**\n     * @dev Admin function for new implementation to accept its role as implementation.\n     */\n    function _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );\n\n        _setImplementation(_pendingImplementation);\n        _setPendingImplementation(address(0));\n    }\n\n    /**\n     * @dev Delegates the current call to implementation.\n     * This function does not return to its internal call site, it will return directly to the\n     * external caller.\n     */\n    function _fallback() internal {\n        require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n        assembly {\n            // (a) get free memory pointer\n            let ptr := mload(0x40)\n\n            // (b) get address of the implementation\n            let impl := and(sload(IMPLEMENTATION_SLOT), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // (1) copy incoming call data\n            calldatacopy(ptr, 0, calldatasize())\n\n            // (2) forward call to logic contract\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n\n            // (3) retrieve return data\n            returndatacopy(ptr, 0, size)\n\n            // (4) forward return data back to caller\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to implementation. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n}\n\n\n",
        "CodeNames": [
            "GraphProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    " GraphProxyStorage",
                    "js\nfunction _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );        // Codes...\n"
                ],
                "Type": "  Avoid _shadowing_  inherited state variables ",
                "Description": "\nGraphProxy.sol#L140(https://github.com/code-423n4/2022-10-thegraph/blob/main/contracts/upgrades/GraphProxy.sol#L140)\n\nIn GraphProxy.sol#L140, there is a local variable named _pendingImplementation, but there is a function named _pendingImplementation() in the inherited  GraphProxyStorage with the same name. This use causes compilers to issue warnings, negatively affecting checking and code readability. \n\njs\nfunction _acceptUpgrade() internal {\n        address _pendingImplementation = _pendingImplementation();\n        require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n        require(\n            _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n            \"Caller must be the pending implementation\"\n        );        // Codes...\n\n\n",
                "Repair": "Avoid using variables with the same name, including inherited in the same contract, if used, it must be specified in the NatSpec comments.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../base/Multicall.sol\";\nimport \"../bancor/BancorFormula.sol\";\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../utils/TokenUtils.sol\";\n\nimport \"./IGNS.sol\";\nimport \"./GNSStorage.sol\";\n\n/**\n * @title GNS\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\n * used in the scope of the Graph Network. It translates Subgraphs into Subgraph Versions.\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\n * human-readable names. All human readable names emitted in events.\n * The contract implements a multicall behaviour to support batching multiple calls in a single\n * transaction.\n */\ncontract GNS is GNSV2Storage, GraphUpgradeable, IGNS, Multicall {\n    using SafeMath for uint256;\n\n    // -- Constants --\n\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\n\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    // Equates to Connector weight on bancor formula to be CW = 1\n    uint32 private constant defaultReserveRatio = 1000000;\n\n    // -- Events --\n\n    event SubgraphNFTUpdated(address subgraphNFT);\n\n    /**\n     * @dev Emitted when graph account sets its default name\n     */\n    event SetDefaultName(\n        address indexed graphAccount,\n        uint256 nameSystem, // only ENS for now\n        bytes32 nameIdentifier,\n        string name\n    );\n\n    /**\n     * @dev Emitted when the subgraph metadata is updated.\n     */\n    event SubgraphMetadataUpdated(uint256 indexed subgraphID, bytes32 subgraphMetadata);\n\n    /**\n     * @dev Emitted when a subgraph version is updated.\n     */\n    event SubgraphVersionUpdated(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        bytes32 versionMetadata\n    );\n\n    /**\n     * @dev Emitted when a curator mints signal.\n     */\n    event SignalMinted(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalCreated,\n        uint256 vSignalCreated,\n        uint256 tokensDeposited\n    );\n\n    /**\n     * @dev Emitted when a curator burns signal.\n     */\n    event SignalBurned(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 vSignalBurnt,\n        uint256 tokensReceived\n    );\n\n    /**\n     * @dev Emitted when a curator transfers signal.\n     */\n    event SignalTransferred(\n        uint256 indexed subgraphID,\n        address indexed from,\n        address indexed to,\n        uint256 nSignalTransferred\n    );\n\n    /**\n     * @dev Emitted when a subgraph is created.\n     */\n    event SubgraphPublished(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        uint32 reserveRatio\n    );\n\n    /**\n     * @dev Emitted when a subgraph is upgraded to point to a new\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\n     * new vSignal curve.\n     */\n    event SubgraphUpgraded(\n        uint256 indexed subgraphID,\n        uint256 vSignalCreated,\n        uint256 tokensSignalled,\n        bytes32 indexed subgraphDeploymentID\n    );\n\n    /**\n     * @dev Emitted when a subgraph is deprecated.\n     */\n    event SubgraphDeprecated(uint256 indexed subgraphID, uint256 withdrawableGRT);\n\n    /**\n     * @dev Emitted when a curator withdraws GRT from a deprecated subgraph\n     */\n    event GRTWithdrawn(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 withdrawnGRT\n    );\n\n    // -- Modifiers --\n\n    /**\n     * @dev Emitted when a legacy subgraph is claimed\n     */\n    event LegacySubgraphClaimed(address indexed graphAccount, uint256 subgraphNumber);\n\n    /**\n     * @dev Modifier that allows only a subgraph operator to be the caller\n     */\n    modifier onlySubgraphAuth(uint256 _subgraphID) {\n        require(ownerOf(_subgraphID) == msg.sender, \"GNS: Must be authorized\");\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize this contract.\n     */\n    function initialize(\n        address _controller,\n        address _bondingCurve,\n        address _subgraphNFT\n    ) external onlyImpl {\n        Managed._initialize(_controller);\n\n        // Dependencies\n        bondingCurve = _bondingCurve;\n\n        // Settings\n        _setOwnerTaxPercentage(500000);\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Approve curation contract to pull funds.\n     */\n    function approveAll() external override {\n        graphToken().approve(address(curation()), MAX_UINT256);\n    }\n\n    // -- Config --\n\n    /**\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\n    }\n\n    /**\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\n        require(_ownerTaxPercentage <= MAX_PPM, \"Owner tax must be MAX_PPM or less\");\n        ownerTaxPercentage = _ownerTaxPercentage;\n        emit ParameterUpdated(\"ownerTaxPercentage\");\n    }\n\n    /**\n     * @dev Set the NFT registry contract\n     * NOTE: Calling this function will break the ownership model unless\n     * it is replaced with a fully migrated version of the NFT contract state\n     * Use with care.\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function setSubgraphNFT(address _subgraphNFT) public onlyGovernor {\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Internal: Set the NFT registry contract\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function _setSubgraphNFT(address _subgraphNFT) private {\n        require(_subgraphNFT != address(0), \"NFT address cant be zero\");\n        require(Address.isContract(_subgraphNFT), \"NFT must be valid\");\n\n        subgraphNFT = ISubgraphNFT(_subgraphNFT);\n        emit SubgraphNFTUpdated(_subgraphNFT);\n    }\n\n    // -- Actions --\n\n    /**\n     * @dev Allows a graph account to set a default name\n     * @param _graphAccount Account that is setting its name\n     * @param _nameSystem Name system account already has ownership of a name in\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\n     * @param _name The name being set as default\n     */\n    function setDefaultName(\n        address _graphAccount,\n        uint8 _nameSystem,\n        bytes32 _nameIdentifier,\n        string calldata _name\n    ) external override {\n        require(_graphAccount == msg.sender, \"GNS: Only you can set your name\");\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\n    }\n\n    /**\n     * @dev Allows a subgraph owner to update the metadata of a subgraph they have published\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function updateSubgraphMetadata(uint256 _subgraphID, bytes32 _subgraphMetadata)\n        public\n        override\n        onlySubgraphAuth(_subgraphID)\n    {\n        _setSubgraphMetadata(_subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Publish a new subgraph.\n     * @param _subgraphDeploymentID Subgraph deployment for the subgraph\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function publishNewSubgraph(\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata,\n        bytes32 _subgraphMetadata\n    ) external override notPaused {\n        // Subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // Init the subgraph\n        address subgraphOwner = msg.sender;\n        uint256 subgraphID = _nextSubgraphID(subgraphOwner);\n        SubgraphData storage subgraphData = _getSubgraphData(subgraphID);\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n        subgraphData.reserveRatio = defaultReserveRatio;\n\n        // Mint the NFT. Use the subgraphID as tokenID.\n        // This function will check the if tokenID already exists.\n        _mintNFT(subgraphOwner, subgraphID);\n        emit SubgraphPublished(subgraphID, _subgraphDeploymentID, defaultReserveRatio);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n\n        emit SubgraphVersionUpdated(subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Publish a new version of an existing subgraph.\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphDeploymentID Subgraph deployment ID of the new version\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     */\n    function publishNewVersion(\n        uint256 _subgraphID,\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata\n    ) external override notPaused onlySubgraphAuth(_subgraphID) {\n        // Perform the upgrade from the current subgraph deployment to the new one.\n        // This involves burning all signal from the old deployment and using the funds to buy\n        // from the new deployment.\n        // This will also make the change to target to the new deployment.\n\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // New subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // New subgraph deployment must be different than current\n        require(\n            _subgraphDeploymentID != subgraphData.subgraphDeploymentID,\n            \"GNS: Cannot publish a new version with the same subgraph deployment ID\"\n        );\n\n        // This is to prevent the owner from front running its name curators signal by posting\n        // its own signal ahead, bringing the name curators in, and dumping on them\n        ICuration curation = curation();\n        require(\n            !curation.isCurated(_subgraphDeploymentID),\n            \"GNS: Owner cannot point to a subgraphID that has been pre-curated\"\n        );\n\n        // Move all signal from previous version to new version\n        // NOTE: We will only do this as long as there is signal on the subgraph\n        if (subgraphData.nSignal > 0) {\n            // Burn all version signal in the name pool for tokens (w/no slippage protection)\n            // Sell all signal from the old deployment\n            uint256 tokens = curation.burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n\n            // Take the owner cut of the curation tax, add it to the total\n            // Upgrade is only callable by the owner, we assume then that msg.sender = owner\n            address subgraphOwner = msg.sender;\n            uint256 tokensWithTax = _chargeOwnerTax(\n                tokens,\n                subgraphOwner,\n                curation.curationTaxPercentage()\n            );\n\n            // Update pool: constant nSignal, vSignal can change (w/no slippage protection)\n            // Buy all signal from the new deployment\n            (subgraphData.vSignal, ) = curation.mint(_subgraphDeploymentID, tokensWithTax, 0);\n\n            emit SubgraphUpgraded(\n                _subgraphID,\n                subgraphData.vSignal,\n                tokensWithTax,\n                _subgraphDeploymentID\n            );\n        }\n\n        // Update target deployment\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n\n        emit SubgraphVersionUpdated(_subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Deprecate a subgraph. The bonding curve is destroyed, the vSignal is burned, and the GNS\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\n     * Can only be done by the subgraph owner.\n     * @param _subgraphID Subgraph ID\n     */\n    function deprecateSubgraph(uint256 _subgraphID)\n        external\n        override\n        notPaused\n        onlySubgraphAuth(_subgraphID)\n    {\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Burn signal only if it has any available\n        if (subgraphData.nSignal > 0) {\n            subgraphData.withdrawableGRT = curation().burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n        }\n\n        // Deprecate the subgraph and do cleanup\n        subgraphData.disabled = true;\n        subgraphData.vSignal = 0;\n        subgraphData.reserveRatio = 0;\n        // NOTE: We don't reset the following variable as we use it to test if the Subgraph was ever created\n        // subgraphData.subgraphDeploymentID = 0;\n\n        // Burn the NFT\n        _burnNFT(_subgraphID);\n\n        emit SubgraphDeprecated(_subgraphID, subgraphData.withdrawableGRT);\n    }\n\n    /**\n     * @dev Deposit GRT into a subgraph and mint signal.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\n     */\n    function mintSignal(\n        uint256 _subgraphID,\n        uint256 _tokensIn,\n        uint256 _nSignalOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Pull tokens from sender\n        address curator = msg.sender;\n        TokenUtils.pullTokens(graphToken(), curator, _tokensIn);\n\n        // Get name signal to mint for tokens deposited\n        (uint256 vSignal, ) = curation().mint(subgraphData.subgraphDeploymentID, _tokensIn, 0);\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n\n        // Slippage protection\n        require(nSignal >= _nSignalOutMin, \"GNS: Slippage protection\");\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.add(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.add(nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].add(nSignal);\n\n        emit SignalMinted(_subgraphID, curator, nSignal, vSignal, _tokensIn);\n    }\n\n    /**\n     * @dev Burn signal for a subgraph and return the GRT.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\n     */\n    function burnSignal(\n        uint256 _subgraphID,\n        uint256 _nSignal,\n        uint256 _tokensOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Curator balance checks\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(\n            _nSignal <= curatorNSignal,\n            \"GNS: Curator cannot withdraw more nSignal than they have\"\n        );\n\n        // Get tokens for name signal amount to burn\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignal);\n        uint256 tokens = curation().burn(subgraphData.subgraphDeploymentID, vSignal, _tokensOutMin);\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.sub(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.sub(_nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_nSignal);\n\n        // Return the tokens to the nameCurator\n        require(graphToken().transfer(curator, tokens), \"GNS: Error sending tokens\");\n\n        emit SignalBurned(_subgraphID, curator, _nSignal, vSignal, tokens);\n    }\n\n    /**\n     * @dev Move subgraph signal from sender to `_recipient`\n     * @param _subgraphID Subgraph ID\n     * @param _recipient Address to send the signal to\n     * @param _amount The amount of nSignal to transfer\n     */\n    function transferSignal(\n        uint256 _subgraphID,\n        address _recipient,\n        uint256 _amount\n    ) external override notPartialPaused {\n        require(_recipient != address(0), \"GNS: Curator cannot transfer to the zero address\");\n\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Balance checks\n        address curator = msg.sender;\n        uint256 curatorBalance = subgraphData.curatorNSignal[curator];\n        require(curatorBalance >= _amount, \"GNS: Curator transfer amount exceeds balance\");\n\n        // Move the signal\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_amount);\n        subgraphData.curatorNSignal[_recipient] = subgraphData.curatorNSignal[_recipient].add(\n            _amount\n        );\n\n        emit SignalTransferred(_subgraphID, curator, _recipient, _amount);\n    }\n\n    /**\n     * @dev Withdraw tokens from a deprecated subgraph.\n     * When the subgraph is deprecated, any curator can call this function and\n     * withdraw the GRT they are entitled for its original deposit\n     * @param _subgraphID Subgraph ID\n     */\n    function withdraw(uint256 _subgraphID) external override notPartialPaused {\n        // Subgraph validations\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(subgraphData.disabled == true, \"GNS: Must be disabled first\");\n        require(subgraphData.withdrawableGRT > 0, \"GNS: No more GRT to withdraw\");\n\n        // Curator validations\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(curatorNSignal > 0, \"GNS: No signal to withdraw GRT\");\n\n        // Get curator share of tokens to be withdrawn\n        uint256 tokensOut = curatorNSignal.mul(subgraphData.withdrawableGRT).div(\n            subgraphData.nSignal\n        );\n        subgraphData.curatorNSignal[curator] = 0;\n        subgraphData.nSignal = subgraphData.nSignal.sub(curatorNSignal);\n        subgraphData.withdrawableGRT = subgraphData.withdrawableGRT.sub(tokensOut);\n\n        // Return tokens to the curator\n        TokenUtils.pushTokens(graphToken(), curator, tokensOut);\n\n        emit GRTWithdrawn(_subgraphID, curator, curatorNSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\n     * @param _tokens Tokens that were received from deprecating the old subgraph\n     * @param _owner Subgraph owner\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\n     */\n    function _chargeOwnerTax(\n        uint256 _tokens,\n        address _owner,\n        uint32 _curationTaxPercentage\n    ) private returns (uint256) {\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\n            return 0;\n        }\n\n        // Tax on the total bonding curve funds\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\n        // Total after the tax\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\n        // The portion of tax that the owner will pay\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\n\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\n\n        // The total after tax, plus owner partial repay, divided by\n        // the tax, to adjust it slightly upwards. ex:\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\n        // To get 100 in the protocol after tax, Owner deposits\n        // ~5.26, as ~105.26 * .95 = 100\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\n        );\n\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\n\n        // Get the owner of the subgraph to reimburse the curation tax\n        TokenUtils.pullTokens(graphToken(), _owner, ownerTaxAdjustedUp);\n\n        return totalAdjustedUp;\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of tokens.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn Tokens being exchanged for subgraph signal\n     * @return Amount of subgraph signal and curation tax\n     */\n    function tokensToNSignal(uint256 _subgraphID, uint256 _tokensIn)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\n            subgraphData.subgraphDeploymentID,\n            _tokensIn\n        );\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n        return (vSignal, nSignal, curationTax);\n    }\n\n    /**\n     * @dev Calculate tokens returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for tokens\n     * @return Amount of tokens returned for an amount of subgraph signal\n     */\n    function nSignalToTokens(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        // Get subgraph or revert if not published\n        // It does not make sense to convert signal from a disabled or non-existing one\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignalIn);\n        uint256 tokensOut = curation().signalToTokens(subgraphData.subgraphDeploymentID, vSignal);\n        return (vSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of subgraph deployment signal.\n     * @param _subgraphID Subgraph ID\n     * @param _vSignalIn Amount of subgraph deployment signal to exchange for subgraph signal\n     * @return Amount of subgraph signal that can be bought\n     */\n    function vSignalToNSignal(uint256 _subgraphID, uint256 _vSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n\n        // Handle initialization by using 1:1 version to name signal\n        if (subgraphData.vSignal == 0) {\n            return _vSignalIn;\n        }\n\n        return\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _vSignalIn\n            );\n    }\n\n    /**\n     * @dev Calculate subgraph deployment signal to be returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for subgraph deployment signal\n     * @return Amount of subgraph deployment signal that can be returned\n     */\n    function nSignalToVSignal(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        return\n            BancorFormula(bondingCurve).calculateSaleReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _nSignalIn\n            );\n    }\n\n    /**\n     * @dev Get the amount of subgraph signal a curator has.\n     * @param _subgraphID Subgraph ID\n     * @param _curator Curator address\n     * @return Amount of subgraph signal owned by a curator\n     */\n    function getCuratorSignal(uint256 _subgraphID, address _curator)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _getSubgraphData(_subgraphID).curatorNSignal[_curator];\n    }\n\n    /**\n     * @dev Return the total signal on the subgraph.\n     * @param _subgraphID Subgraph ID\n     * @return Total signal on the subgraph\n     */\n    function subgraphSignal(uint256 _subgraphID) external view override returns (uint256) {\n        return _getSubgraphData(_subgraphID).nSignal;\n    }\n\n    /**\n     * @dev Return the total tokens on the subgraph at current value.\n     * @param _subgraphID Subgraph ID\n     * @return Total tokens on the subgraph\n     */\n    function subgraphTokens(uint256 _subgraphID) external view override returns (uint256) {\n        uint256 signal = _getSubgraphData(_subgraphID).nSignal;\n        if (signal > 0) {\n            (, uint256 tokens) = nSignalToTokens(_subgraphID, signal);\n            return tokens;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Create subgraphID for legacy subgraph and mint ownership NFT.\n     * @param _graphAccount Account that created the subgraph\n     * @param _subgraphNumber The sequence number of the created subgraph\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function migrateLegacySubgraph(\n        address _graphAccount,\n        uint256 _subgraphNumber,\n        bytes32 _subgraphMetadata\n    ) external {\n        // Must be an existing legacy subgraph\n        bool legacySubgraphExists = legacySubgraphData[_graphAccount][_subgraphNumber]\n            .subgraphDeploymentID != 0;\n        require(legacySubgraphExists == true, \"GNS: Subgraph does not exist\");\n\n        // Must not be a claimed subgraph\n        uint256 subgraphID = _buildSubgraphID(_graphAccount, _subgraphNumber);\n        require(\n            legacySubgraphKeys[subgraphID].account == address(0),\n            \"GNS: Subgraph was already claimed\"\n        );\n\n        // Store a reference for a legacy subgraph\n        legacySubgraphKeys[subgraphID] = IGNS.LegacySubgraphKey({\n            account: _graphAccount,\n            accountSeqID: _subgraphNumber\n        });\n\n        // Delete state for legacy subgraph\n        legacySubgraphs[_graphAccount][_subgraphNumber] = 0;\n\n        // Mint the NFT and send to owner\n        // The subgraph owner is the graph account that created it\n        _mintNFT(_graphAccount, subgraphID);\n        emit LegacySubgraphClaimed(_graphAccount, _subgraphNumber);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphID Subgraph ID\n     * @return Return true if subgraph is currently published\n     */\n    function isPublished(uint256 _subgraphID) public view override returns (bool) {\n        return _isPublished(_getSubgraphData(_subgraphID));\n    }\n\n    /**\n     * @dev Build a subgraph ID based on the account creating it and a sequence number for that account.\n     * Subgraph ID is the keccak hash of account+seqID\n     * @return Subgraph ID\n     */\n    function _buildSubgraphID(address _account, uint256 _seqID) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_account, _seqID)));\n    }\n\n    /**\n     * @dev Return the next subgraphID given the account that is creating the subgraph.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextSubgraphID(address _account) internal returns (uint256) {\n        return _buildSubgraphID(_account, _nextAccountSeqID(_account));\n    }\n\n    /**\n     * @dev Return a new consecutive sequence ID for an account and update to the next value.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextAccountSeqID(address _account) internal returns (uint256) {\n        uint256 seqID = nextAccountSeqID[_account];\n        nextAccountSeqID[_account] = nextAccountSeqID[_account].add(1);\n        return seqID;\n    }\n\n    /**\n     * @dev Get subgraph data.\n     * This function will first look for a v1 subgraph and return it if found.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphData(uint256 _subgraphID) private view returns (SubgraphData storage) {\n        // If there is a legacy subgraph created return it\n        LegacySubgraphKey storage legacySubgraphKey = legacySubgraphKeys[_subgraphID];\n        if (legacySubgraphKey.account != address(0)) {\n            return legacySubgraphData[legacySubgraphKey.account][legacySubgraphKey.accountSeqID];\n        }\n        // Return new subgraph type\n        return subgraphs[_subgraphID];\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphData Subgraph Data\n     * @return Return true if subgraph is currently published\n     */\n    function _isPublished(SubgraphData storage _subgraphData) internal view returns (bool) {\n        return _subgraphData.subgraphDeploymentID != 0 && _subgraphData.disabled == false;\n    }\n\n    /**\n     * @dev Return the subgraph data or revert if not published or deprecated.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphOrRevert(uint256 _subgraphID)\n        internal\n        view\n        returns (SubgraphData storage)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(_isPublished(subgraphData) == true, \"GNS: Must be active\");\n        return subgraphData;\n    }\n\n    // -- NFT --\n\n    /**\n     * @dev Return the owner of a subgraph.\n     * @param _tokenID Subgraph ID\n     * @return Owner address\n     */\n    function ownerOf(uint256 _tokenID) public view override returns (address) {\n        return subgraphNFT.ownerOf(_tokenID);\n    }\n\n    /**\n     * @dev Mint the NFT for the subgraph.\n     * @param _owner Owner address\n     * @param _tokenID Subgraph ID\n     */\n    function _mintNFT(address _owner, uint256 _tokenID) internal {\n        subgraphNFT.mint(_owner, _tokenID);\n    }\n\n    /**\n     * @dev Burn the NFT for the subgraph.\n     * @param _tokenID Subgraph ID\n     */\n    function _burnNFT(uint256 _tokenID) internal {\n        subgraphNFT.burn(_tokenID);\n    }\n\n    /**\n     * @dev Set the subgraph metadata.\n     * @param _tokenID Subgraph ID\n     * @param _subgraphMetadata IPFS hash of the subgraph metadata\n     */\n    function _setSubgraphMetadata(uint256 _tokenID, bytes32 _subgraphMetadata) internal {\n        subgraphNFT.setSubgraphMetadata(_tokenID, _subgraphMetadata);\n\n        // Even if the following event is emitted in the NFT we emit it here to facilitate\n        // subgraph indexing\n        emit SubgraphMetadataUpdated(_tokenID, _subgraphMetadata);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../token/IGraphToken.sol\";\n\nimport \"./WithdrawHelper.sol\";\n\n/**\n * @title WithdrawHelper contract for GRT tokens\n * @notice This contract encodes the logic that connects the transfer of funds from a\n * Channel Multisig to the protocol in the context of a withdrawal.\n * A Channel Multisig will atomically transfer the tokens to the WithdrawHelper and then\n * these tokens will get pulled from the Staking contract using the `allocationID` passed\n * in the `callData` of the WithdrawCommitment.\n * Tokens transferred are associated to a particular allocation in the Staking contract.\n * This contract is not meant to hold funds, as they can be stolen by presenting a\n * handcrafted WithdrawalCommitment.\n */\ncontract GRTWithdrawHelper is WithdrawHelper {\n    struct CollectData {\n        address staking;\n        address allocationID;\n        address returnAddress;\n    }\n\n    bytes4 private constant APPROVE_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant COLLECT_SELECTOR = bytes4(keccak256(\"collect(uint256,address)\"));\n\n    // -- State --\n\n    address public immutable tokenAddress;\n\n    /**\n     * @notice Contract constructor.\n     * @param _tokenAddress Token address to use for transfers\n     */\n    constructor(address _tokenAddress) {\n        tokenAddress = _tokenAddress;\n    }\n\n    /**\n     * @notice Returns the ABI encoded representation of a CollectData struct.\n     * @param _collectData CollectData struct with information about how to collect funds\n     */\n    function getCallData(CollectData calldata _collectData) public pure returns (bytes memory) {\n        return abi.encode(_collectData);\n    }\n\n    /**\n     * @notice Execute hook used by a channel to send funds to the protocol.\n     * @param _wd WithdrawData struct for the withdrawal commitment\n     * @param _actualAmount Amount to transfer to the Staking contract\n     */\n    function execute(WithdrawData calldata _wd, uint256 _actualAmount) external override {\n        require(_wd.assetId == tokenAddress, \"GRTWithdrawHelper: !token\");\n\n        // Decode and validate collect data\n        CollectData memory collectData = abi.decode(_wd.callData, (CollectData));\n        require(collectData.staking != address(0), \"GRTWithdrawHelper: !staking\");\n        require(collectData.allocationID != address(0), \"GRTWithdrawHelper: !allocationID\");\n        require(collectData.returnAddress != address(0), \"GRTWithdrawHelper: !returnAddress\");\n\n        // Approve the staking contract to pull the transfer amount\n        (bool success1, ) = tokenAddress.call(\n            abi.encodeWithSelector(APPROVE_SELECTOR, collectData.staking, _actualAmount)\n        );\n\n        // If the call fails return the funds to the return address and bail\n        if (!success1) {\n            _sendTokens(collectData.returnAddress, _actualAmount);\n            return;\n        }\n\n        // Call the Staking contract to collect funds from this contract\n        (bool success2, ) = collectData.staking.call(\n            abi.encodeWithSelector(COLLECT_SELECTOR, _actualAmount, collectData.allocationID)\n        );\n\n        // If the call fails return the funds to the return address\n        if (!success2) {\n            _sendTokens(collectData.returnAddress, _actualAmount);\n        }\n    }\n\n    /**\n     * @notice Send tokens out of the contract.\n     * @param _to Destination address\n     * @param _amount Amount to transfer\n     */\n    function _sendTokens(address _to, uint256 _amount) private {\n        IGraphToken(tokenAddress).transfer(_to, _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "GNS.sol",
            "GRTWithdrawHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n114:          return ICuration(_resolveContract(keccak256(\"Curation\")));\n\n122:          return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n\n130:          return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n\n138:          return IStaking(_resolveContract(keccak256(\"Staking\")));\n\n146:          return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n\n154:          return ITokenGateway(_resolveContract(keccak256(\"GraphTokenGateway\")));\n\n"
                ],
                "Type": "   keccak256()  should only need to be called on a specific string literal once",
                "Description": "It should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to bytes4 should also only be done once\n\n*There are 6 instances of this issue:*\nsolidity\nFile: contracts/governance/Managed.sol\n\n114:          return ICuration(_resolveContract(keccak256(\"Curation\")));\n\n122:          return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n\n130:          return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n\n138:          return IStaking(_resolveContract(keccak256(\"Staking\")));\n\n146:          return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n\n154:          return ITokenGateway(_resolveContract(keccak256(\"GraphTokenGateway\")));\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L114\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract BancorFormula {\n    using SafeMath for uint256;\n\n    uint16 public constant version = 6;\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_RATIO = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\n     */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\n     */\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n     */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\n     */\n    uint256[128] private maxExpArray;\n\n    constructor() {\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\n     * calculates the return for a given conversion (in the main token)\n     *\n     * Formula:\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve balance\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\n     * @param _depositAmount       deposit amount, in reserve token\n     *\n     * @return purchase return amount\n     */\n    function calculatePurchaseReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _depositAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0) return 0;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_reserveBalance);\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\n     * calculates the return for a given conversion (in the reserve token)\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\n     * @param _sellAmount          sell amount, in the token itself\n     *\n     * @return sale return amount\n     */\n    function calculateSaleReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _sellAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _reserveRatio > 0 &&\n                _reserveRatio <= MAX_RATIO &&\n                _sellAmount <= _supply,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0) return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply) return _reserveBalance;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\n     *\n     * Formula:\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\n     *\n     * @param _fromReserveBalance      input reserve balance\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\n     * @param _toReserveBalance        output reserve balance\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\n     * @param _amount                  input reserve amount\n     *\n     * @return second reserve amount\n     */\n    function calculateCrossReserveReturn(\n        uint256 _fromReserveBalance,\n        uint32 _fromReserveRatio,\n        uint256 _toReserveBalance,\n        uint32 _toReserveRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _fromReserveBalance > 0 &&\n                _fromReserveRatio > 0 &&\n                _fromReserveRatio <= MAX_RATIO &&\n                _toReserveBalance > 0 &&\n                _toReserveRatio > 0 &&\n                _toReserveRatio <= MAX_RATIO\n        );\n\n        // special case for equal ratios\n        if (_fromReserveRatio == _toReserveRatio)\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _fromReserveBalance.add(_amount);\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\n        uint256 temp1 = _toReserveBalance.mul(result);\n        uint256 temp2 = _toReserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              requested amount of smart tokens\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateFundCost(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _supply.add(_amount);\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\n        return temp - _reserveBalance;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              amount of smart tokens to liquidate\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateLiquidateReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _totalRatio > 1 &&\n                _totalRatio <= MAX_RATIO * 2 &&\n                _amount <= _supply\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case for liquidating the entire supply\n        if (_amount == _supply) return _reserveBalance;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _amount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\n                precision\n            );\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        } // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        } // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        } // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        } // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        } // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        } // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        } // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        } // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res +=\n            (z * (0x100000000000000000000000000000000 - y)) /\n            0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res +=\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\n            0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res +=\n            (z * (0x099999999999999999999999999999999 - y)) /\n            0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res +=\n            (z * (0x092492492492492492492492492492492 - y)) /\n            0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res +=\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\n            0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res +=\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\n            0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res +=\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\n            0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res +=\n            (z * (0x088888888888888888888888888888888 - y)) /\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    /**\n     * @dev deprecated, backward compatibility\n     */\n    function calculateCrossConnectorReturn(\n        uint256 _fromConnectorBalance,\n        uint32 _fromConnectorWeight,\n        uint256 _toConnectorBalance,\n        uint32 _toConnectorWeight,\n        uint256 _amount\n    ) public view returns (uint256) {\n        return\n            calculateCrossReserveReturn(\n                _fromConnectorBalance,\n                _fromConnectorWeight,\n                _toConnectorBalance,\n                _toConnectorWeight,\n                _amount\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "BancorFormula.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: contracts/curation/ICuration.sol\n\n/// @audit setDefaultReserveRatio(), setMinimumCurationDeposit(), setCurationTaxPercentage(), setCurationTokenMaster(), mint(), burn(), collect(), isCurated(), getCuratorSignal(), getCurationPoolSignal(), getCurationPoolTokens(), tokensToSignal(), signalToTokens(), curationTaxPercentage()\n7:    interface ICuration {\n\n",
                    "//solidity\nFile: contracts/curation/IGraphCurationToken.sol\n\n/// @audit initialize(), burnFrom(), mint()\n7:    interface IGraphCurationToken is IERC20Upgradeable {\n\n",
                    "//solidity\nFile: contracts/epochs/IEpochManager.sol\n\n/// @audit setEpochLength(), runEpoch(), isCurrentEpochRun(), blockNum(), blockHash(), currentEpoch(), currentEpochBlock(), currentEpochBlockSinceStart(), epochsSince(), epochsSinceUpdate()\n5:    interface IEpochManager {\n\n",
                    "//solidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n/// @audit initialize(), approveAll(), revokeAll()\n15:   contract BridgeEscrow is GraphUpgradeable, Managed {\n\n",
                    "//solidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n/// @audit setPauseGuardian(), setPaused(), paused()\n14:   abstract contract GraphTokenGateway is GraphUpgradeable, Pausable, Managed, ITokenGateway {\n\n",
                    "//solidity\nFile: contracts/gateway/ICallhookReceiver.sol\n\n/// @audit onTokenTransfer()\n11:   interface ICallhookReceiver {\n\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit initialize(), setArbitrumAddresses(), setL2TokenAddress(), setL2CounterpartAddress(), setEscrowAddress(), addToCallhookWhitelist(), removeFromCallhookWhitelist(), getOutboundCalldata()\n21:   contract L1GraphTokenGateway is GraphTokenGateway, L1ArbitrumMessenger {\n\n",
                    "//solidity\nFile: contracts/governance/IController.sol\n\n/// @audit getGovernor(), setContractProxy(), unsetContractProxy(), updateController(), getContractProxy(), setPartialPaused(), setPaused(), setPauseGuardian(), paused(), partialPaused()\n5:    interface IController {\n\n",
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n/// @audit syncAllContracts()\n23:   contract Managed {\n\n",
                    "//solidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n/// @audit initialize(), setL2Router(), setL1TokenAddress(), setL1CounterpartAddress(), outboundTransfer(), getOutboundCalldata()\n23:   contract L2GraphTokenGateway is GraphTokenGateway, L2ArbitrumMessenger, ReentrancyGuardUpgradeable {\n\n",
                    "//solidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n/// @audit addMinter(), removeMinter(), renounceMinter(), mint(), isMinter()\n28:   contract GraphTokenUpgradeable is GraphUpgradeable, Governed, ERC20BurnableUpgradeable {\n\n",
                    "//solidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n/// @audit initialize(), setGateway(), setL1Address()\n15:   contract L2GraphToken is GraphTokenUpgradeable, IArbToken {\n\n",
                    "//solidity\nFile: contracts/rewards/IRewardsManager.sol\n\n/// @audit setIssuanceRate(), setMinimumSubgraphSignal(), setSubgraphAvailabilityOracle(), setDenied(), setDeniedMany(), isDenied(), getNewRewardsPerSignal(), getAccRewardsPerSignal(), getAccRewardsForSubgraph(), getAccRewardsPerAllocatedToken(), getRewards(), updateAccRewardsPerSignal(), takeRewards(), onSubgraphSignalUpdate(), onSubgraphAllocationUpdate()\n5:    interface IRewardsManager {\n\n",
                    "//solidity\nFile: contracts/staking/IStaking.sol\n\n/// @audit setMinimumIndexerStake(), setThawingPeriod(), setCurationPercentage(), setProtocolPercentage(), setChannelDisputeEpochs(), setMaxAllocationEpochs(), setRebateRatio(), setDelegationRatio(), setDelegationParameters(), setDelegationParametersCooldown(), setDelegationUnbondingPeriod(), setDelegationTaxPercentage(), setSlasher(), setAssetHolder(), setOperator(), isOperator(), stake(), stakeTo(), unstake(), slash(), withdraw(), setRewardsDestination(), delegate(), undelegate(), withdrawDelegated(), allocate(), allocateFrom(), closeAllocation(), closeAllocationMany(), closeAndAllocate(), collect(), claim(), claimMany(), hasStake(), getIndexerStakedTokens(), getIndexerCapacity(), getAllocation(), getAllocationState(), isAllocation(), getSubgraphAllocatedTokens(), getDelegation(), isDelegator()\n8:    interface IStaking is IStakingData {\n\n",
                    "//solidity\nFile: contracts/token/IGraphToken.sol\n\n/// @audit burn(), burnFrom(), mint(), addMinter(), removeMinter(), renounceMinter(), isMinter()\n7:    interface IGraphToken is IERC20 {\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n/// @audit getProxyImplementation(), getProxyPendingImplementation(), getProxyAdmin(), changeProxyAdmin(), upgrade(), acceptProxy(), acceptProxyAndCall()\n17:   contract GraphProxyAdmin is Governed {\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxy.sol\n\n/// @audit implementation(), pendingImplementation(), setAdmin(), upgradeTo(), acceptUpgrade(), acceptUpgradeAndCall()\n16:   contract GraphProxy is GraphProxyStorage {\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n/// @audit acceptProxy(), acceptProxyAndCall()\n11:   contract GraphUpgradeable {\n\n",
                    "//solidity\nFile: contracts/upgrades/IGraphProxy.sol\n\n/// @audit setAdmin(), implementation(), pendingImplementation(), upgradeTo(), acceptUpgrade(), acceptUpgradeAndCall()\n5:    interface IGraphProxy {\n\n"
                ],
                "Type": "  Optimize names to save gas",
                "Description": "public/external function names and public member variable names can be optimized to save gas. See this(https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save 128 gas each during deployment, and renaming functions to have lower method IDs will save 22 gas per call, per sorted position shifted(https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 19 instances of this issue:*\nsolidity\nFile: contracts/curation/ICuration.sol\n\n/// @audit setDefaultReserveRatio(), setMinimumCurationDeposit(), setCurationTaxPercentage(), setCurationTokenMaster(), mint(), burn(), collect(), isCurated(), getCuratorSignal(), getCurationPoolSignal(), getCurationPoolTokens(), tokensToSignal(), signalToTokens(), curationTaxPercentage()\n7:    interface ICuration {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/curation/ICuration.sol#L7\n\nsolidity\nFile: contracts/curation/IGraphCurationToken.sol\n\n/// @audit initialize(), burnFrom(), mint()\n7:    interface IGraphCurationToken is IERC20Upgradeable {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/curation/IGraphCurationToken.sol#L7\n\nsolidity\nFile: contracts/epochs/IEpochManager.sol\n\n/// @audit setEpochLength(), runEpoch(), isCurrentEpochRun(), blockNum(), blockHash(), currentEpoch(), currentEpochBlock(), currentEpochBlockSinceStart(), epochsSince(), epochsSinceUpdate()\n5:    interface IEpochManager {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/epochs/IEpochManager.sol#L5\n\nsolidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n/// @audit initialize(), approveAll(), revokeAll()\n15:   contract BridgeEscrow is GraphUpgradeable, Managed {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/BridgeEscrow.sol#L15\n\nsolidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n/// @audit setPauseGuardian(), setPaused(), paused()\n14:   abstract contract GraphTokenGateway is GraphUpgradeable, Pausable, Managed, ITokenGateway {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L14\n\nsolidity\nFile: contracts/gateway/ICallhookReceiver.sol\n\n/// @audit onTokenTransfer()\n11:   interface ICallhookReceiver {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/ICallhookReceiver.sol#L11\n\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit initialize(), setArbitrumAddresses(), setL2TokenAddress(), setL2CounterpartAddress(), setEscrowAddress(), addToCallhookWhitelist(), removeFromCallhookWhitelist(), getOutboundCalldata()\n21:   contract L1GraphTokenGateway is GraphTokenGateway, L1ArbitrumMessenger {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L21\n\nsolidity\nFile: contracts/governance/IController.sol\n\n/// @audit getGovernor(), setContractProxy(), unsetContractProxy(), updateController(), getContractProxy(), setPartialPaused(), setPaused(), setPauseGuardian(), paused(), partialPaused()\n5:    interface IController {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/IController.sol#L5\n\nsolidity\nFile: contracts/governance/Managed.sol\n\n/// @audit syncAllContracts()\n23:   contract Managed {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L23\n\nsolidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n/// @audit initialize(), setL2Router(), setL1TokenAddress(), setL1CounterpartAddress(), outboundTransfer(), getOutboundCalldata()\n23:   contract L2GraphTokenGateway is GraphTokenGateway, L2ArbitrumMessenger, ReentrancyGuardUpgradeable {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/gateway/L2GraphTokenGateway.sol#L23\n\nsolidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n/// @audit addMinter(), removeMinter(), renounceMinter(), mint(), isMinter()\n28:   contract GraphTokenUpgradeable is GraphUpgradeable, Governed, ERC20BurnableUpgradeable {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/GraphTokenUpgradeable.sol#L28\n\nsolidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n/// @audit initialize(), setGateway(), setL1Address()\n15:   contract L2GraphToken is GraphTokenUpgradeable, IArbToken {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/L2GraphToken.sol#L15\n\nsolidity\nFile: contracts/rewards/IRewardsManager.sol\n\n/// @audit setIssuanceRate(), setMinimumSubgraphSignal(), setSubgraphAvailabilityOracle(), setDenied(), setDeniedMany(), isDenied(), getNewRewardsPerSignal(), getAccRewardsPerSignal(), getAccRewardsForSubgraph(), getAccRewardsPerAllocatedToken(), getRewards(), updateAccRewardsPerSignal(), takeRewards(), onSubgraphSignalUpdate(), onSubgraphAllocationUpdate()\n5:    interface IRewardsManager {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/rewards/IRewardsManager.sol#L5\n\nsolidity\nFile: contracts/staking/IStaking.sol\n\n/// @audit setMinimumIndexerStake(), setThawingPeriod(), setCurationPercentage(), setProtocolPercentage(), setChannelDisputeEpochs(), setMaxAllocationEpochs(), setRebateRatio(), setDelegationRatio(), setDelegationParameters(), setDelegationParametersCooldown(), setDelegationUnbondingPeriod(), setDelegationTaxPercentage(), setSlasher(), setAssetHolder(), setOperator(), isOperator(), stake(), stakeTo(), unstake(), slash(), withdraw(), setRewardsDestination(), delegate(), undelegate(), withdrawDelegated(), allocate(), allocateFrom(), closeAllocation(), closeAllocationMany(), closeAndAllocate(), collect(), claim(), claimMany(), hasStake(), getIndexerStakedTokens(), getIndexerCapacity(), getAllocation(), getAllocationState(), isAllocation(), getSubgraphAllocatedTokens(), getDelegation(), isDelegator()\n8:    interface IStaking is IStakingData {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/staking/IStaking.sol#L8\n\nsolidity\nFile: contracts/token/IGraphToken.sol\n\n/// @audit burn(), burnFrom(), mint(), addMinter(), removeMinter(), renounceMinter(), isMinter()\n7:    interface IGraphToken is IERC20 {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/token/IGraphToken.sol#L7\n\nsolidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n/// @audit getProxyImplementation(), getProxyPendingImplementation(), getProxyAdmin(), changeProxyAdmin(), upgrade(), acceptProxy(), acceptProxyAndCall()\n17:   contract GraphProxyAdmin is Governed {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxyAdmin.sol#L17\n\nsolidity\nFile: contracts/upgrades/GraphProxy.sol\n\n/// @audit implementation(), pendingImplementation(), setAdmin(), upgradeTo(), acceptUpgrade(), acceptUpgradeAndCall()\n16:   contract GraphProxy is GraphProxyStorage {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L16\n\nsolidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n/// @audit acceptProxy(), acceptProxyAndCall()\n11:   contract GraphUpgradeable {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L11\n\nsolidity\nFile: contracts/upgrades/IGraphProxy.sol\n\n/// @audit setAdmin(), implementation(), pendingImplementation(), upgradeTo(), acceptUpgrade(), acceptUpgradeAndCall()\n5:    interface IGraphProxy {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/IGraphProxy.sol#L5\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-13",
                "Location": [
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n214:                      extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n\n"
                ],
                "Type": "  Don't compare boolean expressions to boolean literals",
                "Description": "if (<x == true) = if (<x), if (<x == false) = if (!<x)\n\n*There is 1 instance of this issue:*\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n214:                      extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L214\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed destAddr,\n        uint256 amount,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../base/Multicall.sol\";\nimport \"../bancor/BancorFormula.sol\";\nimport \"../upgrades/GraphUpgradeable.sol\";\nimport \"../utils/TokenUtils.sol\";\n\nimport \"./IGNS.sol\";\nimport \"./GNSStorage.sol\";\n\n/**\n * @title GNS\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\n * used in the scope of the Graph Network. It translates Subgraphs into Subgraph Versions.\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\n * human-readable names. All human readable names emitted in events.\n * The contract implements a multicall behaviour to support batching multiple calls in a single\n * transaction.\n */\ncontract GNS is GNSV2Storage, GraphUpgradeable, IGNS, Multicall {\n    using SafeMath for uint256;\n\n    // -- Constants --\n\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\n\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    // Equates to Connector weight on bancor formula to be CW = 1\n    uint32 private constant defaultReserveRatio = 1000000;\n\n    // -- Events --\n\n    event SubgraphNFTUpdated(address subgraphNFT);\n\n    /**\n     * @dev Emitted when graph account sets its default name\n     */\n    event SetDefaultName(\n        address indexed graphAccount,\n        uint256 nameSystem, // only ENS for now\n        bytes32 nameIdentifier,\n        string name\n    );\n\n    /**\n     * @dev Emitted when the subgraph metadata is updated.\n     */\n    event SubgraphMetadataUpdated(uint256 indexed subgraphID, bytes32 subgraphMetadata);\n\n    /**\n     * @dev Emitted when a subgraph version is updated.\n     */\n    event SubgraphVersionUpdated(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        bytes32 versionMetadata\n    );\n\n    /**\n     * @dev Emitted when a curator mints signal.\n     */\n    event SignalMinted(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalCreated,\n        uint256 vSignalCreated,\n        uint256 tokensDeposited\n    );\n\n    /**\n     * @dev Emitted when a curator burns signal.\n     */\n    event SignalBurned(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 vSignalBurnt,\n        uint256 tokensReceived\n    );\n\n    /**\n     * @dev Emitted when a curator transfers signal.\n     */\n    event SignalTransferred(\n        uint256 indexed subgraphID,\n        address indexed from,\n        address indexed to,\n        uint256 nSignalTransferred\n    );\n\n    /**\n     * @dev Emitted when a subgraph is created.\n     */\n    event SubgraphPublished(\n        uint256 indexed subgraphID,\n        bytes32 indexed subgraphDeploymentID,\n        uint32 reserveRatio\n    );\n\n    /**\n     * @dev Emitted when a subgraph is upgraded to point to a new\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\n     * new vSignal curve.\n     */\n    event SubgraphUpgraded(\n        uint256 indexed subgraphID,\n        uint256 vSignalCreated,\n        uint256 tokensSignalled,\n        bytes32 indexed subgraphDeploymentID\n    );\n\n    /**\n     * @dev Emitted when a subgraph is deprecated.\n     */\n    event SubgraphDeprecated(uint256 indexed subgraphID, uint256 withdrawableGRT);\n\n    /**\n     * @dev Emitted when a curator withdraws GRT from a deprecated subgraph\n     */\n    event GRTWithdrawn(\n        uint256 indexed subgraphID,\n        address indexed curator,\n        uint256 nSignalBurnt,\n        uint256 withdrawnGRT\n    );\n\n    // -- Modifiers --\n\n    /**\n     * @dev Emitted when a legacy subgraph is claimed\n     */\n    event LegacySubgraphClaimed(address indexed graphAccount, uint256 subgraphNumber);\n\n    /**\n     * @dev Modifier that allows only a subgraph operator to be the caller\n     */\n    modifier onlySubgraphAuth(uint256 _subgraphID) {\n        require(ownerOf(_subgraphID) == msg.sender, \"GNS: Must be authorized\");\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize this contract.\n     */\n    function initialize(\n        address _controller,\n        address _bondingCurve,\n        address _subgraphNFT\n    ) external onlyImpl {\n        Managed._initialize(_controller);\n\n        // Dependencies\n        bondingCurve = _bondingCurve;\n\n        // Settings\n        _setOwnerTaxPercentage(500000);\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Approve curation contract to pull funds.\n     */\n    function approveAll() external override {\n        graphToken().approve(address(curation()), MAX_UINT256);\n    }\n\n    // -- Config --\n\n    /**\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\n    }\n\n    /**\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\n     * @param _ownerTaxPercentage Owner tax percentage\n     */\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\n        require(_ownerTaxPercentage <= MAX_PPM, \"Owner tax must be MAX_PPM or less\");\n        ownerTaxPercentage = _ownerTaxPercentage;\n        emit ParameterUpdated(\"ownerTaxPercentage\");\n    }\n\n    /**\n     * @dev Set the NFT registry contract\n     * NOTE: Calling this function will break the ownership model unless\n     * it is replaced with a fully migrated version of the NFT contract state\n     * Use with care.\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function setSubgraphNFT(address _subgraphNFT) public onlyGovernor {\n        _setSubgraphNFT(_subgraphNFT);\n    }\n\n    /**\n     * @dev Internal: Set the NFT registry contract\n     * @param _subgraphNFT Address of the ERC721 contract\n     */\n    function _setSubgraphNFT(address _subgraphNFT) private {\n        require(_subgraphNFT != address(0), \"NFT address cant be zero\");\n        require(Address.isContract(_subgraphNFT), \"NFT must be valid\");\n\n        subgraphNFT = ISubgraphNFT(_subgraphNFT);\n        emit SubgraphNFTUpdated(_subgraphNFT);\n    }\n\n    // -- Actions --\n\n    /**\n     * @dev Allows a graph account to set a default name\n     * @param _graphAccount Account that is setting its name\n     * @param _nameSystem Name system account already has ownership of a name in\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\n     * @param _name The name being set as default\n     */\n    function setDefaultName(\n        address _graphAccount,\n        uint8 _nameSystem,\n        bytes32 _nameIdentifier,\n        string calldata _name\n    ) external override {\n        require(_graphAccount == msg.sender, \"GNS: Only you can set your name\");\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\n    }\n\n    /**\n     * @dev Allows a subgraph owner to update the metadata of a subgraph they have published\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function updateSubgraphMetadata(uint256 _subgraphID, bytes32 _subgraphMetadata)\n        public\n        override\n        onlySubgraphAuth(_subgraphID)\n    {\n        _setSubgraphMetadata(_subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Publish a new subgraph.\n     * @param _subgraphDeploymentID Subgraph deployment for the subgraph\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function publishNewSubgraph(\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata,\n        bytes32 _subgraphMetadata\n    ) external override notPaused {\n        // Subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // Init the subgraph\n        address subgraphOwner = msg.sender;\n        uint256 subgraphID = _nextSubgraphID(subgraphOwner);\n        SubgraphData storage subgraphData = _getSubgraphData(subgraphID);\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n        subgraphData.reserveRatio = defaultReserveRatio;\n\n        // Mint the NFT. Use the subgraphID as tokenID.\n        // This function will check the if tokenID already exists.\n        _mintNFT(subgraphOwner, subgraphID);\n        emit SubgraphPublished(subgraphID, _subgraphDeploymentID, defaultReserveRatio);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n\n        emit SubgraphVersionUpdated(subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Publish a new version of an existing subgraph.\n     * @param _subgraphID Subgraph ID\n     * @param _subgraphDeploymentID Subgraph deployment ID of the new version\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\n     */\n    function publishNewVersion(\n        uint256 _subgraphID,\n        bytes32 _subgraphDeploymentID,\n        bytes32 _versionMetadata\n    ) external override notPaused onlySubgraphAuth(_subgraphID) {\n        // Perform the upgrade from the current subgraph deployment to the new one.\n        // This involves burning all signal from the old deployment and using the funds to buy\n        // from the new deployment.\n        // This will also make the change to target to the new deployment.\n\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // New subgraph deployment must be non-empty\n        require(_subgraphDeploymentID != 0, \"GNS: Cannot set deploymentID to 0 in publish\");\n\n        // New subgraph deployment must be different than current\n        require(\n            _subgraphDeploymentID != subgraphData.subgraphDeploymentID,\n            \"GNS: Cannot publish a new version with the same subgraph deployment ID\"\n        );\n\n        // This is to prevent the owner from front running its name curators signal by posting\n        // its own signal ahead, bringing the name curators in, and dumping on them\n        ICuration curation = curation();\n        require(\n            !curation.isCurated(_subgraphDeploymentID),\n            \"GNS: Owner cannot point to a subgraphID that has been pre-curated\"\n        );\n\n        // Move all signal from previous version to new version\n        // NOTE: We will only do this as long as there is signal on the subgraph\n        if (subgraphData.nSignal > 0) {\n            // Burn all version signal in the name pool for tokens (w/no slippage protection)\n            // Sell all signal from the old deployment\n            uint256 tokens = curation.burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n\n            // Take the owner cut of the curation tax, add it to the total\n            // Upgrade is only callable by the owner, we assume then that msg.sender = owner\n            address subgraphOwner = msg.sender;\n            uint256 tokensWithTax = _chargeOwnerTax(\n                tokens,\n                subgraphOwner,\n                curation.curationTaxPercentage()\n            );\n\n            // Update pool: constant nSignal, vSignal can change (w/no slippage protection)\n            // Buy all signal from the new deployment\n            (subgraphData.vSignal, ) = curation.mint(_subgraphDeploymentID, tokensWithTax, 0);\n\n            emit SubgraphUpgraded(\n                _subgraphID,\n                subgraphData.vSignal,\n                tokensWithTax,\n                _subgraphDeploymentID\n            );\n        }\n\n        // Update target deployment\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\n\n        emit SubgraphVersionUpdated(_subgraphID, _subgraphDeploymentID, _versionMetadata);\n    }\n\n    /**\n     * @dev Deprecate a subgraph. The bonding curve is destroyed, the vSignal is burned, and the GNS\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\n     * Can only be done by the subgraph owner.\n     * @param _subgraphID Subgraph ID\n     */\n    function deprecateSubgraph(uint256 _subgraphID)\n        external\n        override\n        notPaused\n        onlySubgraphAuth(_subgraphID)\n    {\n        // Subgraph check\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Burn signal only if it has any available\n        if (subgraphData.nSignal > 0) {\n            subgraphData.withdrawableGRT = curation().burn(\n                subgraphData.subgraphDeploymentID,\n                subgraphData.vSignal,\n                0\n            );\n        }\n\n        // Deprecate the subgraph and do cleanup\n        subgraphData.disabled = true;\n        subgraphData.vSignal = 0;\n        subgraphData.reserveRatio = 0;\n        // NOTE: We don't reset the following variable as we use it to test if the Subgraph was ever created\n        // subgraphData.subgraphDeploymentID = 0;\n\n        // Burn the NFT\n        _burnNFT(_subgraphID);\n\n        emit SubgraphDeprecated(_subgraphID, subgraphData.withdrawableGRT);\n    }\n\n    /**\n     * @dev Deposit GRT into a subgraph and mint signal.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\n     */\n    function mintSignal(\n        uint256 _subgraphID,\n        uint256 _tokensIn,\n        uint256 _nSignalOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Pull tokens from sender\n        address curator = msg.sender;\n        TokenUtils.pullTokens(graphToken(), curator, _tokensIn);\n\n        // Get name signal to mint for tokens deposited\n        (uint256 vSignal, ) = curation().mint(subgraphData.subgraphDeploymentID, _tokensIn, 0);\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n\n        // Slippage protection\n        require(nSignal >= _nSignalOutMin, \"GNS: Slippage protection\");\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.add(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.add(nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].add(nSignal);\n\n        emit SignalMinted(_subgraphID, curator, nSignal, vSignal, _tokensIn);\n    }\n\n    /**\n     * @dev Burn signal for a subgraph and return the GRT.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\n     */\n    function burnSignal(\n        uint256 _subgraphID,\n        uint256 _nSignal,\n        uint256 _tokensOutMin\n    ) external override notPartialPaused {\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Curator balance checks\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(\n            _nSignal <= curatorNSignal,\n            \"GNS: Curator cannot withdraw more nSignal than they have\"\n        );\n\n        // Get tokens for name signal amount to burn\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignal);\n        uint256 tokens = curation().burn(subgraphData.subgraphDeploymentID, vSignal, _tokensOutMin);\n\n        // Update pools\n        subgraphData.vSignal = subgraphData.vSignal.sub(vSignal);\n        subgraphData.nSignal = subgraphData.nSignal.sub(_nSignal);\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_nSignal);\n\n        // Return the tokens to the nameCurator\n        require(graphToken().transfer(curator, tokens), \"GNS: Error sending tokens\");\n\n        emit SignalBurned(_subgraphID, curator, _nSignal, vSignal, tokens);\n    }\n\n    /**\n     * @dev Move subgraph signal from sender to `_recipient`\n     * @param _subgraphID Subgraph ID\n     * @param _recipient Address to send the signal to\n     * @param _amount The amount of nSignal to transfer\n     */\n    function transferSignal(\n        uint256 _subgraphID,\n        address _recipient,\n        uint256 _amount\n    ) external override notPartialPaused {\n        require(_recipient != address(0), \"GNS: Curator cannot transfer to the zero address\");\n\n        // Subgraph checks\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n\n        // Balance checks\n        address curator = msg.sender;\n        uint256 curatorBalance = subgraphData.curatorNSignal[curator];\n        require(curatorBalance >= _amount, \"GNS: Curator transfer amount exceeds balance\");\n\n        // Move the signal\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_amount);\n        subgraphData.curatorNSignal[_recipient] = subgraphData.curatorNSignal[_recipient].add(\n            _amount\n        );\n\n        emit SignalTransferred(_subgraphID, curator, _recipient, _amount);\n    }\n\n    /**\n     * @dev Withdraw tokens from a deprecated subgraph.\n     * When the subgraph is deprecated, any curator can call this function and\n     * withdraw the GRT they are entitled for its original deposit\n     * @param _subgraphID Subgraph ID\n     */\n    function withdraw(uint256 _subgraphID) external override notPartialPaused {\n        // Subgraph validations\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(subgraphData.disabled == true, \"GNS: Must be disabled first\");\n        require(subgraphData.withdrawableGRT > 0, \"GNS: No more GRT to withdraw\");\n\n        // Curator validations\n        address curator = msg.sender;\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\n        require(curatorNSignal > 0, \"GNS: No signal to withdraw GRT\");\n\n        // Get curator share of tokens to be withdrawn\n        uint256 tokensOut = curatorNSignal.mul(subgraphData.withdrawableGRT).div(\n            subgraphData.nSignal\n        );\n        subgraphData.curatorNSignal[curator] = 0;\n        subgraphData.nSignal = subgraphData.nSignal.sub(curatorNSignal);\n        subgraphData.withdrawableGRT = subgraphData.withdrawableGRT.sub(tokensOut);\n\n        // Return tokens to the curator\n        TokenUtils.pushTokens(graphToken(), curator, tokensOut);\n\n        emit GRTWithdrawn(_subgraphID, curator, curatorNSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\n     * @param _tokens Tokens that were received from deprecating the old subgraph\n     * @param _owner Subgraph owner\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\n     */\n    function _chargeOwnerTax(\n        uint256 _tokens,\n        address _owner,\n        uint32 _curationTaxPercentage\n    ) private returns (uint256) {\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\n            return 0;\n        }\n\n        // Tax on the total bonding curve funds\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\n        // Total after the tax\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\n        // The portion of tax that the owner will pay\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\n\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\n\n        // The total after tax, plus owner partial repay, divided by\n        // the tax, to adjust it slightly upwards. ex:\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\n        // To get 100 in the protocol after tax, Owner deposits\n        // ~5.26, as ~105.26 * .95 = 100\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\n        );\n\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\n\n        // Get the owner of the subgraph to reimburse the curation tax\n        TokenUtils.pullTokens(graphToken(), _owner, ownerTaxAdjustedUp);\n\n        return totalAdjustedUp;\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of tokens.\n     * @param _subgraphID Subgraph ID\n     * @param _tokensIn Tokens being exchanged for subgraph signal\n     * @return Amount of subgraph signal and curation tax\n     */\n    function tokensToNSignal(uint256 _subgraphID, uint256 _tokensIn)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\n            subgraphData.subgraphDeploymentID,\n            _tokensIn\n        );\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\n        return (vSignal, nSignal, curationTax);\n    }\n\n    /**\n     * @dev Calculate tokens returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for tokens\n     * @return Amount of tokens returned for an amount of subgraph signal\n     */\n    function nSignalToTokens(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        // Get subgraph or revert if not published\n        // It does not make sense to convert signal from a disabled or non-existing one\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignalIn);\n        uint256 tokensOut = curation().signalToTokens(subgraphData.subgraphDeploymentID, vSignal);\n        return (vSignal, tokensOut);\n    }\n\n    /**\n     * @dev Calculate subgraph signal to be returned for an amount of subgraph deployment signal.\n     * @param _subgraphID Subgraph ID\n     * @param _vSignalIn Amount of subgraph deployment signal to exchange for subgraph signal\n     * @return Amount of subgraph signal that can be bought\n     */\n    function vSignalToNSignal(uint256 _subgraphID, uint256 _vSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n\n        // Handle initialization by using 1:1 version to name signal\n        if (subgraphData.vSignal == 0) {\n            return _vSignalIn;\n        }\n\n        return\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _vSignalIn\n            );\n    }\n\n    /**\n     * @dev Calculate subgraph deployment signal to be returned for an amount of subgraph signal.\n     * @param _subgraphID Subgraph ID\n     * @param _nSignalIn Subgraph signal being exchanged for subgraph deployment signal\n     * @return Amount of subgraph deployment signal that can be returned\n     */\n    function nSignalToVSignal(uint256 _subgraphID, uint256 _nSignalIn)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        return\n            BancorFormula(bondingCurve).calculateSaleReturn(\n                subgraphData.nSignal,\n                subgraphData.vSignal,\n                subgraphData.reserveRatio,\n                _nSignalIn\n            );\n    }\n\n    /**\n     * @dev Get the amount of subgraph signal a curator has.\n     * @param _subgraphID Subgraph ID\n     * @param _curator Curator address\n     * @return Amount of subgraph signal owned by a curator\n     */\n    function getCuratorSignal(uint256 _subgraphID, address _curator)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _getSubgraphData(_subgraphID).curatorNSignal[_curator];\n    }\n\n    /**\n     * @dev Return the total signal on the subgraph.\n     * @param _subgraphID Subgraph ID\n     * @return Total signal on the subgraph\n     */\n    function subgraphSignal(uint256 _subgraphID) external view override returns (uint256) {\n        return _getSubgraphData(_subgraphID).nSignal;\n    }\n\n    /**\n     * @dev Return the total tokens on the subgraph at current value.\n     * @param _subgraphID Subgraph ID\n     * @return Total tokens on the subgraph\n     */\n    function subgraphTokens(uint256 _subgraphID) external view override returns (uint256) {\n        uint256 signal = _getSubgraphData(_subgraphID).nSignal;\n        if (signal > 0) {\n            (, uint256 tokens) = nSignalToTokens(_subgraphID, signal);\n            return tokens;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Create subgraphID for legacy subgraph and mint ownership NFT.\n     * @param _graphAccount Account that created the subgraph\n     * @param _subgraphNumber The sequence number of the created subgraph\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\n     */\n    function migrateLegacySubgraph(\n        address _graphAccount,\n        uint256 _subgraphNumber,\n        bytes32 _subgraphMetadata\n    ) external {\n        // Must be an existing legacy subgraph\n        bool legacySubgraphExists = legacySubgraphData[_graphAccount][_subgraphNumber]\n            .subgraphDeploymentID != 0;\n        require(legacySubgraphExists == true, \"GNS: Subgraph does not exist\");\n\n        // Must not be a claimed subgraph\n        uint256 subgraphID = _buildSubgraphID(_graphAccount, _subgraphNumber);\n        require(\n            legacySubgraphKeys[subgraphID].account == address(0),\n            \"GNS: Subgraph was already claimed\"\n        );\n\n        // Store a reference for a legacy subgraph\n        legacySubgraphKeys[subgraphID] = IGNS.LegacySubgraphKey({\n            account: _graphAccount,\n            accountSeqID: _subgraphNumber\n        });\n\n        // Delete state for legacy subgraph\n        legacySubgraphs[_graphAccount][_subgraphNumber] = 0;\n\n        // Mint the NFT and send to owner\n        // The subgraph owner is the graph account that created it\n        _mintNFT(_graphAccount, subgraphID);\n        emit LegacySubgraphClaimed(_graphAccount, _subgraphNumber);\n\n        // Set the token metadata\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphID Subgraph ID\n     * @return Return true if subgraph is currently published\n     */\n    function isPublished(uint256 _subgraphID) public view override returns (bool) {\n        return _isPublished(_getSubgraphData(_subgraphID));\n    }\n\n    /**\n     * @dev Build a subgraph ID based on the account creating it and a sequence number for that account.\n     * Subgraph ID is the keccak hash of account+seqID\n     * @return Subgraph ID\n     */\n    function _buildSubgraphID(address _account, uint256 _seqID) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_account, _seqID)));\n    }\n\n    /**\n     * @dev Return the next subgraphID given the account that is creating the subgraph.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextSubgraphID(address _account) internal returns (uint256) {\n        return _buildSubgraphID(_account, _nextAccountSeqID(_account));\n    }\n\n    /**\n     * @dev Return a new consecutive sequence ID for an account and update to the next value.\n     * NOTE: This function updates the sequence ID for the account\n     * @return Sequence ID for the account\n     */\n    function _nextAccountSeqID(address _account) internal returns (uint256) {\n        uint256 seqID = nextAccountSeqID[_account];\n        nextAccountSeqID[_account] = nextAccountSeqID[_account].add(1);\n        return seqID;\n    }\n\n    /**\n     * @dev Get subgraph data.\n     * This function will first look for a v1 subgraph and return it if found.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphData(uint256 _subgraphID) private view returns (SubgraphData storage) {\n        // If there is a legacy subgraph created return it\n        LegacySubgraphKey storage legacySubgraphKey = legacySubgraphKeys[_subgraphID];\n        if (legacySubgraphKey.account != address(0)) {\n            return legacySubgraphData[legacySubgraphKey.account][legacySubgraphKey.accountSeqID];\n        }\n        // Return new subgraph type\n        return subgraphs[_subgraphID];\n    }\n\n    /**\n     * @dev Return whether a subgraph is published.\n     * @param _subgraphData Subgraph Data\n     * @return Return true if subgraph is currently published\n     */\n    function _isPublished(SubgraphData storage _subgraphData) internal view returns (bool) {\n        return _subgraphData.subgraphDeploymentID != 0 && _subgraphData.disabled == false;\n    }\n\n    /**\n     * @dev Return the subgraph data or revert if not published or deprecated.\n     * @param _subgraphID Subgraph ID\n     * @return Subgraph Data\n     */\n    function _getSubgraphOrRevert(uint256 _subgraphID)\n        internal\n        view\n        returns (SubgraphData storage)\n    {\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\n        require(_isPublished(subgraphData) == true, \"GNS: Must be active\");\n        return subgraphData;\n    }\n\n    // -- NFT --\n\n    /**\n     * @dev Return the owner of a subgraph.\n     * @param _tokenID Subgraph ID\n     * @return Owner address\n     */\n    function ownerOf(uint256 _tokenID) public view override returns (address) {\n        return subgraphNFT.ownerOf(_tokenID);\n    }\n\n    /**\n     * @dev Mint the NFT for the subgraph.\n     * @param _owner Owner address\n     * @param _tokenID Subgraph ID\n     */\n    function _mintNFT(address _owner, uint256 _tokenID) internal {\n        subgraphNFT.mint(_owner, _tokenID);\n    }\n\n    /**\n     * @dev Burn the NFT for the subgraph.\n     * @param _tokenID Subgraph ID\n     */\n    function _burnNFT(uint256 _tokenID) internal {\n        subgraphNFT.burn(_tokenID);\n    }\n\n    /**\n     * @dev Set the subgraph metadata.\n     * @param _tokenID Subgraph ID\n     * @param _subgraphMetadata IPFS hash of the subgraph metadata\n     */\n    function _setSubgraphMetadata(uint256 _tokenID, bytes32 _subgraphMetadata) internal {\n        subgraphNFT.setSubgraphMetadata(_tokenID, _subgraphMetadata);\n\n        // Even if the following event is emitted in the NFT we emit it here to facilitate\n        // subgraph indexing\n        emit SubgraphMetadataUpdated(_tokenID, _subgraphMetadata);\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract BancorFormula {\n    using SafeMath for uint256;\n\n    uint16 public constant version = 6;\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_RATIO = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\n     */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\n     */\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n     */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\n     */\n    uint256[128] private maxExpArray;\n\n    constructor() {\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\n     * calculates the return for a given conversion (in the main token)\n     *\n     * Formula:\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve balance\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\n     * @param _depositAmount       deposit amount, in reserve token\n     *\n     * @return purchase return amount\n     */\n    function calculatePurchaseReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _depositAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0) return 0;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_reserveBalance);\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\n     * calculates the return for a given conversion (in the reserve token)\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\n     * @param _sellAmount          sell amount, in the token itself\n     *\n     * @return sale return amount\n     */\n    function calculateSaleReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _sellAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _reserveRatio > 0 &&\n                _reserveRatio <= MAX_RATIO &&\n                _sellAmount <= _supply,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0) return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply) return _reserveBalance;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\n     *\n     * Formula:\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\n     *\n     * @param _fromReserveBalance      input reserve balance\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\n     * @param _toReserveBalance        output reserve balance\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\n     * @param _amount                  input reserve amount\n     *\n     * @return second reserve amount\n     */\n    function calculateCrossReserveReturn(\n        uint256 _fromReserveBalance,\n        uint32 _fromReserveRatio,\n        uint256 _toReserveBalance,\n        uint32 _toReserveRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _fromReserveBalance > 0 &&\n                _fromReserveRatio > 0 &&\n                _fromReserveRatio <= MAX_RATIO &&\n                _toReserveBalance > 0 &&\n                _toReserveRatio > 0 &&\n                _toReserveRatio <= MAX_RATIO\n        );\n\n        // special case for equal ratios\n        if (_fromReserveRatio == _toReserveRatio)\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _fromReserveBalance.add(_amount);\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\n        uint256 temp1 = _toReserveBalance.mul(result);\n        uint256 temp2 = _toReserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              requested amount of smart tokens\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateFundCost(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _supply.add(_amount);\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\n        return temp - _reserveBalance;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              amount of smart tokens to liquidate\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateLiquidateReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _totalRatio > 1 &&\n                _totalRatio <= MAX_RATIO * 2 &&\n                _amount <= _supply\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case for liquidating the entire supply\n        if (_amount == _supply) return _reserveBalance;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _amount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\n                precision\n            );\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        } // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        } // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        } // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        } // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        } // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        } // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        } // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        } // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res +=\n            (z * (0x100000000000000000000000000000000 - y)) /\n            0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res +=\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\n            0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res +=\n            (z * (0x099999999999999999999999999999999 - y)) /\n            0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res +=\n            (z * (0x092492492492492492492492492492492 - y)) /\n            0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res +=\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\n            0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res +=\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\n            0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res +=\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\n            0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res +=\n            (z * (0x088888888888888888888888888888888 - y)) /\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    /**\n     * @dev deprecated, backward compatibility\n     */\n    function calculateCrossConnectorReturn(\n        uint256 _fromConnectorBalance,\n        uint32 _fromConnectorWeight,\n        uint256 _toConnectorBalance,\n        uint32 _toConnectorWeight,\n        uint256 _amount\n    ) public view returns (uint256) {\n        return\n            calculateCrossReserveReturn(\n                _fromConnectorBalance,\n                _fromConnectorWeight,\n                _toConnectorBalance,\n                _toConnectorWeight,\n                _amount\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "IBridge.sol",
            "GNS.sol",
            "AddressAliasHelper.sol",
            "BancorFormula.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-08",
                "Location": [
                    "//solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n35:       mapping(address = bool) public callhookWhitelist;\n\n",
                    "//solidity\nFile: contracts/governance/Pausable.sol\n\n8:        bool internal _partialPaused;\n\n10:       bool internal _paused;\n\n",
                    "//solidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n51:       mapping(address = bool) private _minters;\n\n"
                ],
                "Type": "  Using  bool s for storage incurs overhead",
                "Description": "solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess ([100 gas(https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)) for the extra SLOAD, and to avoid Gsset (20000 gas) when changing from false to true, after having been true in the past\n\n*There are 4 instances of this issue:*\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n35:       mapping(address = bool) public callhookWhitelist;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L35\n\nsolidity\nFile: contracts/governance/Pausable.sol\n\n8:        bool internal _partialPaused;\n\n10:       bool internal _paused;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Pausable.sol#L8\n\nsolidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n51:       mapping(address = bool) private _minters;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/GraphTokenUpgradeable.sol#L51\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IMulticall.sol\";\n\n// Inspired by https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol\n// Note: Removed payable from the multicall\n\n/**\n * @title Multicall\n * @notice Enables calling multiple methods in a single call to the contract\n */\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract BancorFormula {\n    using SafeMath for uint256;\n\n    uint16 public constant version = 6;\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_RATIO = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\n     */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\n     */\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n     */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\n     */\n    uint256[128] private maxExpArray;\n\n    constructor() {\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\n     * calculates the return for a given conversion (in the main token)\n     *\n     * Formula:\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve balance\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\n     * @param _depositAmount       deposit amount, in reserve token\n     *\n     * @return purchase return amount\n     */\n    function calculatePurchaseReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _depositAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0) return 0;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_reserveBalance);\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\n     * calculates the return for a given conversion (in the reserve token)\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\n     * @param _sellAmount          sell amount, in the token itself\n     *\n     * @return sale return amount\n     */\n    function calculateSaleReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _sellAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _reserveRatio > 0 &&\n                _reserveRatio <= MAX_RATIO &&\n                _sellAmount <= _supply,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0) return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply) return _reserveBalance;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\n     *\n     * Formula:\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\n     *\n     * @param _fromReserveBalance      input reserve balance\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\n     * @param _toReserveBalance        output reserve balance\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\n     * @param _amount                  input reserve amount\n     *\n     * @return second reserve amount\n     */\n    function calculateCrossReserveReturn(\n        uint256 _fromReserveBalance,\n        uint32 _fromReserveRatio,\n        uint256 _toReserveBalance,\n        uint32 _toReserveRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _fromReserveBalance > 0 &&\n                _fromReserveRatio > 0 &&\n                _fromReserveRatio <= MAX_RATIO &&\n                _toReserveBalance > 0 &&\n                _toReserveRatio > 0 &&\n                _toReserveRatio <= MAX_RATIO\n        );\n\n        // special case for equal ratios\n        if (_fromReserveRatio == _toReserveRatio)\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _fromReserveBalance.add(_amount);\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\n        uint256 temp1 = _toReserveBalance.mul(result);\n        uint256 temp2 = _toReserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              requested amount of smart tokens\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateFundCost(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _supply.add(_amount);\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\n        return temp - _reserveBalance;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              amount of smart tokens to liquidate\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateLiquidateReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _totalRatio > 1 &&\n                _totalRatio <= MAX_RATIO * 2 &&\n                _amount <= _supply\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case for liquidating the entire supply\n        if (_amount == _supply) return _reserveBalance;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _amount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\n                precision\n            );\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        } // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        } // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        } // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        } // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        } // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        } // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        } // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        } // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res +=\n            (z * (0x100000000000000000000000000000000 - y)) /\n            0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res +=\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\n            0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res +=\n            (z * (0x099999999999999999999999999999999 - y)) /\n            0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res +=\n            (z * (0x092492492492492492492492492492492 - y)) /\n            0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res +=\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\n            0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res +=\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\n            0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res +=\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\n            0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res +=\n            (z * (0x088888888888888888888888888888888 - y)) /\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    /**\n     * @dev deprecated, backward compatibility\n     */\n    function calculateCrossConnectorReturn(\n        uint256 _fromConnectorBalance,\n        uint32 _fromConnectorWeight,\n        uint256 _toConnectorBalance,\n        uint32 _toConnectorWeight,\n        uint256 _amount\n    ) public view returns (uint256) {\n        return\n            calculateCrossReserveReturn(\n                _fromConnectorBalance,\n                _fromConnectorWeight,\n                _toConnectorBalance,\n                _toConnectorWeight,\n                _amount\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "Multicall.sol",
            "BancorFormula.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nFile: contracts/curation/ICuration.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/curation/IGraphCurationToken.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/epochs/IEpochManager.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/gateway/ICallhookReceiver.sol\n\n9:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/governance/Pausable.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/rewards/IRewardsManager.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/token/IGraphToken.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxy.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxyStorage.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n3:    pragma //solidity ^0.7.6;\n\n",
                    "//solidity\nFile: contracts/upgrades/IGraphProxy.sol\n\n3:    pragma //solidity ^0.7.6;\n\n"
                ],
                "Type": "  Use a more recent version of solidity",
                "Description": "Use a solidity version of at least 0.8.0 to get overflow protection without SafeMath<br\nUse a solidity version of at least 0.8.2 to get simple compiler automatic inlining<br\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads<br\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings<br\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value<br\n\n*There are 20 instances of this issue:*\nsolidity\nFile: contracts/curation/ICuration.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/curation/ICuration.sol#L3\n\nsolidity\nFile: contracts/curation/IGraphCurationToken.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/curation/IGraphCurationToken.sol#L3\n\nsolidity\nFile: contracts/epochs/IEpochManager.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/epochs/IEpochManager.sol#L3\n\nsolidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/BridgeEscrow.sol#L3\n\nsolidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L3\n\nsolidity\nFile: contracts/gateway/ICallhookReceiver.sol\n\n9:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/ICallhookReceiver.sol#L9\n\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L3\n\nsolidity\nFile: contracts/governance/Governed.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L3\n\nsolidity\nFile: contracts/governance/Managed.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L3\n\nsolidity\nFile: contracts/governance/Pausable.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Pausable.sol#L3\n\nsolidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/gateway/L2GraphTokenGateway.sol#L3\n\nsolidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/GraphTokenUpgradeable.sol#L3\n\nsolidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/L2GraphToken.sol#L3\n\nsolidity\nFile: contracts/rewards/IRewardsManager.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/rewards/IRewardsManager.sol#L3\n\nsolidity\nFile: contracts/token/IGraphToken.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/token/IGraphToken.sol#L3\n\nsolidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxyAdmin.sol#L3\n\nsolidity\nFile: contracts/upgrades/GraphProxy.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L3\n\nsolidity\nFile: contracts/upgrades/GraphProxyStorage.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxyStorage.sol#L3\n\nsolidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L3\n\nsolidity\nFile: contracts/upgrades/IGraphProxy.sol\n\n3:    pragma solidity ^0.7.6;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/IGraphProxy.sol#L3\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IMulticall.sol\";\n\n// Inspired by https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol\n// Note: Removed payable from the multicall\n\n/**\n * @title Multicall\n * @notice Enables calling multiple methods in a single call to the contract\n */\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Multicall.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-10",
                "Location": [
                    "//solidity\nFile: contracts/governance/IController.sol\n\n3:    pragma //solidity =0.6.12 <0.8.0;\n\n",
                    "//solidity\nFile: contracts/staking/IStakingData.sol\n\n3:    pragma //solidity =0.6.12 <0.8.0;\n\n",
                    "//solidity\nFile: contracts/staking/IStaking.sol\n\n3:    pragma //solidity =0.6.12 <0.8.0;\n\n"
                ],
                "Type": "  Use a more recent version of solidity",
                "Description": "Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining<br\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads<br\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than revert()/require() strings<br\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value<br\n\n*There are 3 instances of this issue:*\nsolidity\nFile: contracts/governance/IController.sol\n\n3:    pragma solidity =0.6.12 <0.8.0;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/IController.sol#L3\n\nsolidity\nFile: contracts/staking/IStakingData.sol\n\n3:    pragma solidity =0.6.12 <0.8.0;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/staking/IStakingData.sol#L3\n\nsolidity\nFile: contracts/staking/IStaking.sol\n\n3:    pragma solidity =0.6.12 <0.8.0;\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/staking/IStaking.sol#L3\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-16",
                "Location": [
                    "//solidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n19            require(\n20                msg.sender == controller.getGovernor() || msg.sender == pauseGuardian,\n21                \"Only Governor or Guardian can call\"\n22:           );\n\n31:           require(_newPauseGuardian != address(0), \"PauseGuardian must be set\");\n\n40:           require(!_paused, \"Paused (contract)\");\n\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n74:           require(inbox != address(0), \"INBOX_NOT_SET\");\n\n78:           require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\n\n82:           require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n\n110:          require(_inbox != address(0), \"INVALID_INBOX\");\n\n111:          require(_l1Router != address(0), \"INVALID_L1_ROUTER\");\n\n122:          require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n\n132:          require(_l2Counterpart != address(0), \"INVALID_L2_COUNTERPART\");\n\n142:          require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n\n153:          require(_newWhitelisted != address(0), \"INVALID_ADDRESS\");\n\n154:          require(!callhookWhitelist[_newWhitelisted], \"ALREADY_WHITELISTED\");\n\n165:          require(_notWhitelisted != address(0), \"INVALID_ADDRESS\");\n\n166:          require(callhookWhitelist[_notWhitelisted], \"NOT_WHITELISTED\");\n\n200:          require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n202:          require(_to != address(0), \"INVALID_DESTINATION\");\n\n213                   require(\n214                       extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n215                       \"CALL_HOOK_DATA_NOT_ALLOWED\"\n216:                  );\n\n217:                  require(maxSubmissionCost  0, \"NO_SUBMISSION_COST\");\n\n224:                      require(msg.value = expectedEth, \"WRONG_ETH_VALUE\");\n\n271:          require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n275:          require(_amount <= escrowBalance, \"BRIDGE_OUT_OF_FUNDS\");\n\n",
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n24:           require(msg.sender == governor, \"Only Governor can call\");\n\n41:           require(_newGovernor != address(0), \"Governor must be set\");\n\n54            require(\n55                pendingGovernor != address(0) && msg.sender == pendingGovernor,\n56                \"Caller must be pending governor\"\n57:           );\n\n",
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n44:           require(!controller.paused(), \"Paused\");\n\n45:           require(!controller.partialPaused(), \"Partial-paused\");\n\n49:           require(!controller.paused(), \"Paused\");\n\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n57:           require(msg.sender == address(controller), \"Caller must be Controller\");\n\n104:          require(_controller != address(0), \"Controller must be set\");\n\n",
                    "//solidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n69            require(\n70                msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n71                \"ONLY_COUNTERPART_GATEWAY\"\n72:           );\n\n98:           require(_l2Router != address(0), \"INVALID_L2_ROUTER\");\n\n108:          require(_l1GRT != address(0), \"INVALID_L1_GRT\");\n\n118:          require(_l1Counterpart != address(0), \"INVALID_L1_COUNTERPART\");\n\n145:          require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n\n146:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n147:          require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n148:          require(_to != address(0), \"INVALID_DESTINATION\");\n\n153:          require(outboundCalldata.extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n233:          require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n\n234:          require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n",
                    "//solidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n60:           require(isMinter(msg.sender), \"Only minter can call\");\n\n94:           require(_owner == recoveredAddress, \"GRT: invalid permit\");\n\n95:           require(_deadline == 0 || block.timestamp <= _deadline, \"GRT: expired permit\");\n\n106:          require(_account != address(0), \"INVALID_MINTER\");\n\n115:          require(_minters[_account], \"NOT_A_MINTER\");\n\n123:          require(_minters[msg.sender], \"NOT_A_MINTER\");\n\n",
                    "//solidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n36:           require(msg.sender == gateway, \"NOT_GATEWAY\");\n\n49:           require(_owner != address(0), \"Owner must be set\");\n\n60:           require(_gw != address(0), \"INVALID_GATEWAY\");\n\n70:           require(_addr != address(0), \"INVALID_L1_ADDRESS\");\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxy.sol\n\n105:          require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\n141:          require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n157:          require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxyStorage.sol\n\n62:           require(msg.sender == _admin(), \"Caller must be admin\");\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n24:           require(msg.sender == _proxy.admin(), \"Caller must be the proxy admin\");\n\n32:           require(msg.sender == _implementation(), \"Caller must be the implementation\");\n\n"
                ],
                "Type": "  Use custom errors rather than  revert() / require()  strings to save gas",
                "Description": "Custom errors are available from solidity version 0.8.4. Custom errors save ~50 gas(https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by avoiding having to allocate and store the revert string(https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 60 instances of this issue:*\nsolidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n19            require(\n20                msg.sender == controller.getGovernor() || msg.sender == pauseGuardian,\n21                \"Only Governor or Guardian can call\"\n22:           );\n\n31:           require(_newPauseGuardian != address(0), \"PauseGuardian must be set\");\n\n40:           require(!_paused, \"Paused (contract)\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L19-L22\n\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n74:           require(inbox != address(0), \"INBOX_NOT_SET\");\n\n78:           require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\n\n82:           require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n\n110:          require(_inbox != address(0), \"INVALID_INBOX\");\n\n111:          require(_l1Router != address(0), \"INVALID_L1_ROUTER\");\n\n122:          require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n\n132:          require(_l2Counterpart != address(0), \"INVALID_L2_COUNTERPART\");\n\n142:          require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n\n153:          require(_newWhitelisted != address(0), \"INVALID_ADDRESS\");\n\n154:          require(!callhookWhitelist[_newWhitelisted], \"ALREADY_WHITELISTED\");\n\n165:          require(_notWhitelisted != address(0), \"INVALID_ADDRESS\");\n\n166:          require(callhookWhitelist[_notWhitelisted], \"NOT_WHITELISTED\");\n\n200:          require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n202:          require(_to != address(0), \"INVALID_DESTINATION\");\n\n213                   require(\n214                       extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n215                       \"CALL_HOOK_DATA_NOT_ALLOWED\"\n216:                  );\n\n217:                  require(maxSubmissionCost  0, \"NO_SUBMISSION_COST\");\n\n224:                      require(msg.value = expectedEth, \"WRONG_ETH_VALUE\");\n\n271:          require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n275:          require(_amount <= escrowBalance, \"BRIDGE_OUT_OF_FUNDS\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L74\n\nsolidity\nFile: contracts/governance/Governed.sol\n\n24:           require(msg.sender == governor, \"Only Governor can call\");\n\n41:           require(_newGovernor != address(0), \"Governor must be set\");\n\n54            require(\n55                pendingGovernor != address(0) && msg.sender == pendingGovernor,\n56                \"Caller must be pending governor\"\n57:           );\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L24\n\nsolidity\nFile: contracts/governance/Managed.sol\n\n44:           require(!controller.paused(), \"Paused\");\n\n45:           require(!controller.partialPaused(), \"Partial-paused\");\n\n49:           require(!controller.paused(), \"Paused\");\n\n53:           require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n\n57:           require(msg.sender == address(controller), \"Caller must be Controller\");\n\n104:          require(_controller != address(0), \"Controller must be set\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L44\n\nsolidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n69            require(\n70                msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n71                \"ONLY_COUNTERPART_GATEWAY\"\n72:           );\n\n98:           require(_l2Router != address(0), \"INVALID_L2_ROUTER\");\n\n108:          require(_l1GRT != address(0), \"INVALID_L1_GRT\");\n\n118:          require(_l1Counterpart != address(0), \"INVALID_L1_COUNTERPART\");\n\n145:          require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n\n146:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n147:          require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n148:          require(_to != address(0), \"INVALID_DESTINATION\");\n\n153:          require(outboundCalldata.extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n233:          require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n\n234:          require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/gateway/L2GraphTokenGateway.sol#L69-L72\n\nsolidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n60:           require(isMinter(msg.sender), \"Only minter can call\");\n\n94:           require(_owner == recoveredAddress, \"GRT: invalid permit\");\n\n95:           require(_deadline == 0 || block.timestamp <= _deadline, \"GRT: expired permit\");\n\n106:          require(_account != address(0), \"INVALID_MINTER\");\n\n115:          require(_minters[_account], \"NOT_A_MINTER\");\n\n123:          require(_minters[msg.sender], \"NOT_A_MINTER\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/GraphTokenUpgradeable.sol#L60\n\nsolidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n36:           require(msg.sender == gateway, \"NOT_GATEWAY\");\n\n49:           require(_owner != address(0), \"Owner must be set\");\n\n60:           require(_gw != address(0), \"INVALID_GATEWAY\");\n\n70:           require(_addr != address(0), \"INVALID_L1_ADDRESS\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/L2GraphToken.sol#L36\n\nsolidity\nFile: contracts/upgrades/GraphProxy.sol\n\n105:          require(_newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\n141:          require(Address.isContract(_pendingImplementation), \"Implementation must be a contract\");\n\n142           require(\n143               _pendingImplementation != address(0) && msg.sender == _pendingImplementation,\n144               \"Caller must be the pending implementation\"\n145:          );\n\n157:          require(msg.sender != _admin(), \"Cannot fallback to proxy target\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxy.sol#L105\n\nsolidity\nFile: contracts/upgrades/GraphProxyStorage.sol\n\n62:           require(msg.sender == _admin(), \"Caller must be admin\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxyStorage.sol#L62\n\nsolidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n24:           require(msg.sender == _proxy.admin(), \"Caller must be the proxy admin\");\n\n32:           require(msg.sender == _implementation(), \"Caller must be the implementation\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L24\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract BancorFormula {\n    using SafeMath for uint256;\n\n    uint16 public constant version = 6;\n\n    uint256 private constant ONE = 1;\n    uint32 private constant MAX_RATIO = 1000000;\n    uint8 private constant MIN_PRECISION = 32;\n    uint8 private constant MAX_PRECISION = 127;\n\n    /**\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\n     */\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\n     */\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\n     */\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\n\n    /**\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\n     */\n    uint256[128] private maxExpArray;\n\n    constructor() {\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\n     * calculates the return for a given conversion (in the main token)\n     *\n     * Formula:\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve balance\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\n     * @param _depositAmount       deposit amount, in reserve token\n     *\n     * @return purchase return amount\n     */\n    function calculatePurchaseReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _depositAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 deposit amount\n        if (_depositAmount == 0) return 0;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _depositAmount.add(_reserveBalance);\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\n        uint256 temp = _supply.mul(result) >> precision;\n        return temp - _supply;\n    }\n\n    /**\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\n     * calculates the return for a given conversion (in the reserve token)\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\n     *\n     * @param _supply              token total supply\n     * @param _reserveBalance      total reserve\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\n     * @param _sellAmount          sell amount, in the token itself\n     *\n     * @return sale return amount\n     */\n    function calculateSaleReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _reserveRatio,\n        uint256 _sellAmount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _reserveRatio > 0 &&\n                _reserveRatio <= MAX_RATIO &&\n                _sellAmount <= _supply,\n            \"invalid parameters\"\n        );\n\n        // special case for 0 sell amount\n        if (_sellAmount == 0) return 0;\n\n        // special case for selling the entire supply\n        if (_sellAmount == _supply) return _reserveBalance;\n\n        // special case if the ratio = 100%\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _sellAmount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\n     *\n     * Formula:\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\n     *\n     * @param _fromReserveBalance      input reserve balance\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\n     * @param _toReserveBalance        output reserve balance\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\n     * @param _amount                  input reserve amount\n     *\n     * @return second reserve amount\n     */\n    function calculateCrossReserveReturn(\n        uint256 _fromReserveBalance,\n        uint32 _fromReserveRatio,\n        uint256 _toReserveBalance,\n        uint32 _toReserveRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _fromReserveBalance > 0 &&\n                _fromReserveRatio > 0 &&\n                _fromReserveRatio <= MAX_RATIO &&\n                _toReserveBalance > 0 &&\n                _toReserveRatio > 0 &&\n                _toReserveRatio <= MAX_RATIO\n        );\n\n        // special case for equal ratios\n        if (_fromReserveRatio == _toReserveRatio)\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _fromReserveBalance.add(_amount);\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\n        uint256 temp1 = _toReserveBalance.mul(result);\n        uint256 temp2 = _toReserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              requested amount of smart tokens\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateFundCost(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseN = _supply.add(_amount);\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\n        return temp - _reserveBalance;\n    }\n\n    /**\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\n     *\n     * Formula:\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\n     *\n     * @param _supply              smart token supply\n     * @param _reserveBalance      reserve token balance\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\n     * @param _amount              amount of smart tokens to liquidate\n     *\n     * @return amount of reserve tokens\n     */\n    function calculateLiquidateReturn(\n        uint256 _supply,\n        uint256 _reserveBalance,\n        uint32 _totalRatio,\n        uint256 _amount\n    ) public view returns (uint256) {\n        // validate input\n        require(\n            _supply > 0 &&\n                _reserveBalance > 0 &&\n                _totalRatio > 1 &&\n                _totalRatio <= MAX_RATIO * 2 &&\n                _amount <= _supply\n        );\n\n        // special case for 0 amount\n        if (_amount == 0) return 0;\n\n        // special case for liquidating the entire supply\n        if (_amount == _supply) return _reserveBalance;\n\n        // special case if the total ratio = 100%\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\n\n        uint256 result;\n        uint8 precision;\n        uint256 baseD = _supply - _amount;\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\n        uint256 temp1 = _reserveBalance.mul(result);\n        uint256 temp2 = _reserveBalance << precision;\n        return (temp1 - temp2) / result;\n    }\n\n    /**\n     * @dev General Description:\n     *     Determine a value of precision.\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n     *     Return the result along with the precision used.\n     *\n     * Detailed Description:\n     *     Instead of calculating \"base ^ exp\", we calculate \"e ^ (log(base) * exp)\".\n     *     The value of \"log(base)\" is represented with an integer slightly smaller than \"log(base) * 2 ^ precision\".\n     *     The larger \"precision\" is, the more accurately this value represents the real value.\n     *     However, the larger \"precision\" is, the more bits are required in order to store this value.\n     *     And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\n     *     This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n     *     This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n     *     This functions assumes that \"_expN < 2 ^ 256 / log(MAX_NUM - 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\n     *     Since we rely on unsigned-integer arithmetic and \"base < 1\" ==> \"log(base) < 0\", this function does not support \"_baseN < _baseD\".\n     */\n    function power(\n        uint256 _baseN,\n        uint256 _baseD,\n        uint32 _expN,\n        uint32 _expD\n    ) internal view returns (uint256, uint8) {\n        require(_baseN < MAX_NUM);\n\n        uint256 baseLog;\n        uint256 base = (_baseN * FIXED_1) / _baseD;\n        if (base < OPT_LOG_MAX_VAL) {\n            baseLog = optimalLog(base);\n        } else {\n            baseLog = generalLog(base);\n        }\n\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\n        } else {\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\n            return (\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\n                precision\n            );\n        }\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1.\n     * This functions assumes that \"x >= FIXED_1\", because the output would be negative otherwise.\n     */\n    function generalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n        if (x >= FIXED_2) {\n            uint8 count = floorLog2(x / FIXED_1);\n            x >>= count; // now x < 2\n            res = count * FIXED_1;\n        }\n\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n        if (x > FIXED_1) {\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n                x = (x * x) / FIXED_1; // now 1 < x < 4\n                if (x >= FIXED_2) {\n                    x >>= 1; // now 1 < x < 2\n                    res += ONE << (i - 1);\n                }\n            }\n        }\n\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\n    }\n\n    /**\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\n     */\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\n        uint8 res = 0;\n\n        if (_n < 256) {\n            // At most 8 iterations\n            while (_n > 1) {\n                _n >>= 1;\n                res += 1;\n            }\n        } else {\n            // Exactly 8 iterations\n            for (uint8 s = 128; s > 0; s >>= 1) {\n                if (_n >= (ONE << s)) {\n                    _n >>= s;\n                    res |= s;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    /**\n     * @dev the global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\n     * - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\n     * - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\n     */\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\n        uint8 lo = MIN_PRECISION;\n        uint8 hi = MAX_PRECISION;\n\n        while (lo + 1 < hi) {\n            uint8 mid = (lo + hi) / 2;\n            if (maxExpArray[mid] >= _x) lo = mid;\n            else hi = mid;\n        }\n\n        if (maxExpArray[hi] >= _x) return hi;\n        if (maxExpArray[lo] >= _x) return lo;\n\n        require(false);\n        return 0;\n    }\n\n    /**\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\n     * it approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\n     * it returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\n     * the global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\n     * the maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\n     */\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\n        uint256 xi = _x;\n        uint256 res = 0;\n\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\n        xi = (xi * _x) >> _precision;\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\n\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n    }\n\n    /**\n     * @dev computes log(x / FIXED_1) * FIXED_1\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\n     * Detailed description:\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\n     */\n    function optimalLog(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n        uint256 w;\n\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\n            res += 0x40000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\n        } // add 1 / 2^1\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\n            res += 0x20000000000000000000000000000000;\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\n        } // add 1 / 2^2\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\n            res += 0x10000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\n        } // add 1 / 2^3\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\n            res += 0x08000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\n        } // add 1 / 2^4\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\n            res += 0x04000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\n        } // add 1 / 2^5\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\n            res += 0x02000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\n        } // add 1 / 2^6\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\n            res += 0x01000000000000000000000000000000;\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\n        } // add 1 / 2^7\n        if (x >= 0x808040155aabbbe9451521693554f733) {\n            res += 0x00800000000000000000000000000000;\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\n        } // add 1 / 2^8\n\n        z = y = x - FIXED_1;\n        w = (y * y) / FIXED_1;\n        res +=\n            (z * (0x100000000000000000000000000000000 - y)) /\n            0x100000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n        res +=\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\n            0x200000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n        res +=\n            (z * (0x099999999999999999999999999999999 - y)) /\n            0x300000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n        res +=\n            (z * (0x092492492492492492492492492492492 - y)) /\n            0x400000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n        res +=\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\n            0x500000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n        res +=\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\n            0x600000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n        res +=\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\n            0x700000000000000000000000000000000;\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n        res +=\n            (z * (0x088888888888888888888888888888888 - y)) /\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n\n        return res;\n    }\n\n    /**\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\n     * auto-generated via 'PrintFunctionOptimalExp.py'\n     * Detailed description:\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\n     * - The exponentiation of each binary exponent is given (pre-calculated)\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\n     */\n    function optimalExp(uint256 x) internal pure returns (uint256) {\n        uint256 res = 0;\n\n        uint256 y;\n        uint256 z;\n\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\n        z = (z * y) / FIXED_1;\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n        z = (z * y) / FIXED_1;\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n        if ((x & 0x010000000000000000000000000000000) != 0)\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\n        if ((x & 0x020000000000000000000000000000000) != 0)\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\n        if ((x & 0x040000000000000000000000000000000) != 0)\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\n        if ((x & 0x080000000000000000000000000000000) != 0)\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\n        if ((x & 0x100000000000000000000000000000000) != 0)\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\n        if ((x & 0x200000000000000000000000000000000) != 0)\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\n        if ((x & 0x400000000000000000000000000000000) != 0)\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\n\n        return res;\n    }\n\n    /**\n     * @dev deprecated, backward compatibility\n     */\n    function calculateCrossConnectorReturn(\n        uint256 _fromConnectorBalance,\n        uint32 _fromConnectorWeight,\n        uint256 _toConnectorBalance,\n        uint32 _toConnectorWeight,\n        uint256 _amount\n    ) public view returns (uint256) {\n        return\n            calculateCrossReserveReturn(\n                _fromConnectorBalance,\n                _fromConnectorWeight,\n                _toConnectorBalance,\n                _toConnectorWeight,\n                _amount\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "AddressAliasHelper.sol",
            "BancorFormula.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-11",
                "Location": [
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n217:                  require(maxSubmissionCost  0, \"NO_SUBMISSION_COST\");\n\n",
                    "//solidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n146:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n"
                ],
                "Type": "  Using  > 0  costs more gas than  != 0  when used on a  uint  in a  require()  statement",
                "Description": "This change saves 6 gas(https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png) per instance. The optimization works until solidity version 0.8.13(https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There are 3 instances of this issue:*\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n217:                  require(maxSubmissionCost  0, \"NO_SUBMISSION_COST\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L201\n\nsolidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n146:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/gateway/L2GraphTokenGateway.sol#L146\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IMulticall.sol\";\n\n// Inspired by https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol\n// Note: Removed payable from the multicall\n\n/**\n * @title Multicall\n * @notice Enables calling multiple methods in a single call to the contract\n */\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "AddressAliasHelper.sol",
            "Multicall.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-15",
                "Location": [
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit expensive op on line 199\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n"
                ],
                "Type": "   require()  or  revert()  statements that check input arguments should be at the top of the function",
                "Description": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas*) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n/// @audit expensive op on line 199\n201:          require(_amount  0, \"INVALID_ZERO_AMOUNT\");\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L201\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-peripherals\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deployed or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../arbitrum/L1ArbitrumMessenger.sol\";\nimport \"./GraphTokenGateway.sol\";\n\n/**\n * @title L1 Graph Token Gateway Contract\n * @dev Provides the L1 side of the Ethereum-Arbitrum GRT bridge. Sends GRT to the L2 chain\n * by escrowing them and sending a message to the L2 gateway, and receives tokens from L2 by\n * releasing them from escrow.\n * Based on Offchain Labs' reference implementation and Livepeer's arbitrum-lpt-bridge\n * (See: https://github.com/OffchainLabs/arbitrum/tree/master/packages/arb-bridge-peripherals/contracts/tokenbridge\n * and https://github.com/livepeer/arbitrum-lpt-bridge)\n */\ncontract L1GraphTokenGateway is GraphTokenGateway, L1ArbitrumMessenger {\n    using SafeMath for uint256;\n\n    // Address of the Graph Token contract on L2\n    address public l2GRT;\n    // Address of the Arbitrum Inbox\n    address public inbox;\n    // Address of the Arbitrum Gateway Router on L1\n    address public l1Router;\n    // Address of the L2GraphTokenGateway on L2 that is the counterpart of this gateway\n    address public l2Counterpart;\n    // Address of the BridgeEscrow contract that holds the GRT in the bridge\n    address public escrow;\n    // Addresses for which this mapping is true are allowed to send callhooks in outbound transfers\n    mapping(address => bool) public callhookWhitelist;\n\n    // Emitted when an outbound transfer is initiated, i.e. tokens are deposited from L1 to L2\n    event DepositInitiated(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed sequenceNumber,\n        uint256 amount\n    );\n\n    // Emitted when an incoming transfer is finalized, i.e tokens are withdrawn from L2 to L1\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        uint256 amount\n    );\n\n    // Emitted when the Arbitrum Inbox and Gateway Router addresses have been updated\n    event ArbitrumAddressesSet(address inbox, address l1Router);\n    // Emitted when the L2 GRT address has been updated\n    event L2TokenAddressSet(address l2GRT);\n    // Emitted when the counterpart L2GraphTokenGateway address has been updated\n    event L2CounterpartAddressSet(address l2Counterpart);\n    // Emitted when the escrow address has been updated\n    event EscrowAddressSet(address escrow);\n    // Emitted when an address is added to the callhook whitelist\n    event AddedToCallhookWhitelist(address newWhitelisted);\n    // Emitted when an address is removed from the callhook whitelist\n    event RemovedFromCallhookWhitelist(address notWhitelisted);\n\n    /**\n     * @dev Allows a function to be called only by the gateway's L2 counterpart.\n     * The message will actually come from the Arbitrum Bridge, but the Outbox\n     * can tell us who the sender from L2 is.\n     */\n    modifier onlyL2Counterpart() {\n        require(inbox != address(0), \"INBOX_NOT_SET\");\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        IBridge bridge = IInbox(inbox).bridge();\n        require(msg.sender == address(bridge), \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = IOutbox(bridge.activeOutbox()).l2ToL1Sender();\n        require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * The contract will be paused.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - inbox  and l1Router using setArbitrumAddresses\n     * - l2GRT using setL2TokenAddress\n     * - l2Counterpart using setL2CounterpartAddress\n     * - escrow using setEscrowAddress\n     * - whitelisted callhook callers using addToCallhookWhitelist\n     * - pauseGuardian using setPauseGuardian\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n        _paused = true;\n    }\n\n    /**\n     * @dev Sets the addresses for L1 contracts provided by Arbitrum\n     * @param _inbox Address of the Inbox that is part of the Arbitrum Bridge\n     * @param _l1Router Address of the Gateway Router\n     */\n    function setArbitrumAddresses(address _inbox, address _l1Router) external onlyGovernor {\n        require(_inbox != address(0), \"INVALID_INBOX\");\n        require(_l1Router != address(0), \"INVALID_L1_ROUTER\");\n        inbox = _inbox;\n        l1Router = _l1Router;\n        emit ArbitrumAddressesSet(_inbox, _l1Router);\n    }\n\n    /**\n     * @dev Sets the address of the L2 Graph Token\n     * @param _l2GRT Address of the GRT contract on L2\n     */\n    function setL2TokenAddress(address _l2GRT) external onlyGovernor {\n        require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n        l2GRT = _l2GRT;\n        emit L2TokenAddressSet(_l2GRT);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart gateway on L2\n     * @param _l2Counterpart Address of the corresponding L2GraphTokenGateway on Arbitrum\n     */\n    function setL2CounterpartAddress(address _l2Counterpart) external onlyGovernor {\n        require(_l2Counterpart != address(0), \"INVALID_L2_COUNTERPART\");\n        l2Counterpart = _l2Counterpart;\n        emit L2CounterpartAddressSet(_l2Counterpart);\n    }\n\n    /**\n     * @dev Sets the address of the escrow contract on L1\n     * @param _escrow Address of the BridgeEscrow\n     */\n    function setEscrowAddress(address _escrow) external onlyGovernor {\n        require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\");\n        escrow = _escrow;\n        emit EscrowAddressSet(_escrow);\n    }\n\n    /**\n     * @dev Adds an address to the callhook whitelist.\n     * This address will be allowed to include callhooks when transferring tokens.\n     * @param _newWhitelisted Address to add to the whitelist\n     */\n    function addToCallhookWhitelist(address _newWhitelisted) external onlyGovernor {\n        require(_newWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(!callhookWhitelist[_newWhitelisted], \"ALREADY_WHITELISTED\");\n        callhookWhitelist[_newWhitelisted] = true;\n        emit AddedToCallhookWhitelist(_newWhitelisted);\n    }\n\n    /**\n     * @dev Removes an address from the callhook whitelist.\n     * This address will no longer be allowed to include callhooks when transferring tokens.\n     * @param _notWhitelisted Address to remove from the whitelist\n     */\n    function removeFromCallhookWhitelist(address _notWhitelisted) external onlyGovernor {\n        require(_notWhitelisted != address(0), \"INVALID_ADDRESS\");\n        require(callhookWhitelist[_notWhitelisted], \"NOT_WHITELISTED\");\n        callhookWhitelist[_notWhitelisted] = false;\n        emit RemovedFromCallhookWhitelist(_notWhitelisted);\n    }\n\n    /**\n     * @notice Creates and sends a retryable ticket to transfer GRT to L2 using the Arbitrum Inbox.\n     * The tokens are escrowed by the gateway until they are withdrawn back to L1.\n     * The ticket must be redeemed on L2 to receive tokens at the specified address.\n     * Note that the caller must previously allow the gateway to spend the specified amount of GRT.\n     * @dev maxGas and gasPriceBid must be set using Arbitrum's NodeInterface.estimateRetryableTicket method.\n     * Also note that whitelisted senders (some protocol contracts) can include additional calldata\n     * for a callhook to be executed on the L2 side when the tokens are received. In this case, the L2 transaction\n     * can revert if the callhook reverts, potentially locking the tokens on the bridge if the callhook\n     * never succeeds. This requires extra care when adding contracts to the whitelist, but is necessary to ensure that\n     * the tickets can be retried in the case of a temporary failure, and to ensure the atomicity of callhooks\n     * with token transfers.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L2\n     * @param _amount Amount of tokens to tranfer\n     * @param _maxGas Gas limit for L2 execution of the ticket\n     * @param _gasPriceBid Price per gas on L2\n     * @param _data Encoded maxSubmissionCost and sender address along with additional calldata\n     * @return Sequence number of the retryable ticket created by Inbox\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable override notPaused returns (bytes memory) {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");\n        require(_to != address(0), \"INVALID_DESTINATION\");\n\n        // nested scopes to avoid stack too deep errors\n        address from;\n        uint256 seqNum;\n        {\n            uint256 maxSubmissionCost;\n            bytes memory outboundCalldata;\n            {\n                bytes memory extraData;\n                (from, maxSubmissionCost, extraData) = parseOutboundData(_data);\n                require(\n                    extraData.length == 0 || callhookWhitelist[msg.sender] == true,\n                    \"CALL_HOOK_DATA_NOT_ALLOWED\"\n                );\n                require(maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");\n\n                {\n                    // makes sure only sufficient ETH is supplied as required for successful redemption on L2\n                    // if a user does not desire immediate redemption they should provide\n                    // a msg.value of AT LEAST maxSubmissionCost\n                    uint256 expectedEth = maxSubmissionCost.add(_maxGas.mul(_gasPriceBid));\n                    require(msg.value >= expectedEth, \"WRONG_ETH_VALUE\");\n                }\n                outboundCalldata = getOutboundCalldata(_l1Token, from, _to, _amount, extraData);\n            }\n            {\n                L2GasParams memory gasParams = L2GasParams(\n                    maxSubmissionCost,\n                    _maxGas,\n                    _gasPriceBid\n                );\n                // transfer tokens to escrow\n                token.transferFrom(from, escrow, _amount);\n                seqNum = sendTxToL2(\n                    inbox,\n                    l2Counterpart,\n                    from,\n                    msg.value,\n                    0,\n                    gasParams,\n                    outboundCalldata\n                );\n            }\n        }\n        emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);\n\n        return abi.encode(seqNum);\n    }\n\n    /**\n     * @notice Receives withdrawn tokens from L2\n     * The equivalent tokens are released from escrow and sent to the destination.\n     * @dev can only accept transactions coming from the L2 GRT Gateway.\n     * The last parameter is unused but kept for compatibility with Arbitrum gateways,\n     * and the encoded exitNum is assumed to be 0.\n     * @param _l1Token L1 Address of the GRT contract (needed for compatibility with Arbitrum Gateway Router)\n     * @param _from Address of the sender\n     * @param _to Recepient address on L1\n     * @param _amount Amount of tokens transferred\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // _data, contains exitNum, unused by this contract\n    ) external payable override notPaused onlyL2Counterpart {\n        IGraphToken token = graphToken();\n        require(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n        uint256 escrowBalance = token.balanceOf(escrow);\n        // If the bridge doesn't have enough tokens, something's very wrong!\n        require(_amount <= escrowBalance, \"BRIDGE_OUT_OF_FUNDS\");\n        token.transferFrom(escrow, _to, _amount);\n\n        emit WithdrawalFinalized(_l1Token, _from, _to, 0, _amount);\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev Data must include maxSubmissionCost, extraData can be left empty. When the router\n     * sends an outbound message, data also contains the from address.\n     * @param _data encoded callhook data\n     * @return Sender of the tx\n     * @return Base ether value required to keep retryable ticket alive\n     * @return Additional data sent to L2\n     */\n    function parseOutboundData(bytes memory _data)\n        private\n        view\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address from;\n        uint256 maxSubmissionCost;\n        bytes memory extraData;\n        if (msg.sender == l1Router) {\n            // Data encoded by the Gateway Router includes the sender address\n            (from, extraData) = abi.decode(_data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = _data;\n        }\n        // User-encoded data contains the max retryable ticket submission cost\n        // and additional L2 calldata\n        (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n        return (from, maxSubmissionCost, extraData);\n    }\n\n    /**\n     * @notice Creates calldata required to create a retryable ticket\n     * @dev encodes the target function with its params which\n     * will be called on L2 when the retryable ticket is redeemed\n     * @param _l1Token Address of the Graph token contract on L1\n     * @param _from Address on L1 from which we're transferring tokens\n     * @param _to Address on L2 to which we're transferring tokens\n     * @param _amount Amount of GRT to transfer\n     * @param _data Additional call data for the L2 transaction, which must be empty unless the caller is whitelisted\n     * @return Encoded calldata (including function selector) for the L2 transaction\n     */\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public pure returns (bytes memory) {\n        bytes memory emptyBytes;\n\n        return\n            abi.encodeWithSelector(\n                ITokenGateway.finalizeInboundTransfer.selector,\n                _l1Token,\n                _from,\n                _to,\n                _amount,\n                abi.encode(emptyBytes, _data)\n            );\n    }\n\n    /**\n     * @notice Calculate the L2 address of a bridged token\n     * @dev In our case, this would only work for GRT.\n     * @param _l1ERC20 address of L1 GRT contract\n     * @return L2 address of the bridged GRT token\n     */\n    function calculateL2TokenAddress(address _l1ERC20) external view override returns (address) {\n        IGraphToken token = graphToken();\n        if (_l1ERC20 != address(token)) {\n            return address(0);\n        }\n        return l2GRT;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\n/**\n * @title Graph Governance contract\n * @dev All contracts that will be owned by a Governor entity should extend this contract.\n */\ncontract Governed {\n    // -- State --\n\n    address public governor;\n    address public pendingGovernor;\n\n    // -- Events --\n\n    event NewPendingOwnership(address indexed from, address indexed to);\n    event NewOwnership(address indexed from, address indexed to);\n\n    /**\n     * @dev Check if the caller is the governor.\n     */\n    modifier onlyGovernor() {\n        require(msg.sender == governor, \"Only Governor can call\");\n        _;\n    }\n\n    /**\n     * @dev Initialize the governor to the contract caller.\n     */\n    function _initialize(address _initGovernor) internal {\n        governor = _initGovernor;\n    }\n\n    /**\n     * @dev Admin function to begin change of governor. The `_newGovernor` must call\n     * `acceptOwnership` to finalize the transfer.\n     * @param _newGovernor Address of new `governor`\n     */\n    function transferOwnership(address _newGovernor) external onlyGovernor {\n        require(_newGovernor != address(0), \"Governor must be set\");\n\n        address oldPendingGovernor = pendingGovernor;\n        pendingGovernor = _newGovernor;\n\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n    }\n\n    /**\n     * @dev Admin function for pending governor to accept role and update governor.\n     * This function must called by the pending governor.\n     */\n    function acceptOwnership() external {\n        require(\n            pendingGovernor != address(0) && msg.sender == pendingGovernor,\n            \"Caller must be pending governor\"\n        );\n\n        address oldGovernor = governor;\n        address oldPendingGovernor = pendingGovernor;\n\n        governor = pendingGovernor;\n        pendingGovernor = address(0);\n\n        emit NewOwnership(oldGovernor, governor);\n        emit NewPendingOwnership(oldPendingGovernor, pendingGovernor);\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/e3a6307ad8a2dc2cad35728a2a9908cfd8dd8ef9/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed destAddr,\n        uint256 amount,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Originally copied from:\n * https://github.com/OffchainLabs/arbitrum/tree/84e64dee6ee82adbf8ec34fd4b86c207a61d9007/packages/arb-bridge-eth\n *\n * MODIFIED from Offchain Labs' implementation:\n * - Changed solidity version to 0.7.6 (pablo@edgeandnode.com)\n *\n */\n\npragma solidity ^0.7.6;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\n\nimport \"./IController.sol\";\n\nimport \"../curation/ICuration.sol\";\nimport \"../epochs/IEpochManager.sol\";\nimport \"../rewards/IRewardsManager.sol\";\nimport \"../staking/IStaking.sol\";\nimport \"../token/IGraphToken.sol\";\nimport \"../arbitrum/ITokenGateway.sol\";\n\n/**\n * @title Graph Managed contract\n * @dev The Managed contract provides an interface to interact with the Controller.\n * It also provides local caching for contract addresses. This mechanism relies on calling the\n * public `syncAllContracts()` function whenever a contract changes in the controller.\n *\n * Inspired by Livepeer:\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\n */\ncontract Managed {\n    // -- State --\n\n    // Controller that contract is registered with\n    IController public controller;\n    mapping(bytes32 => address) private addressCache;\n    uint256[10] private __gap;\n\n    // -- Events --\n\n    event ParameterUpdated(string param);\n    event SetController(address controller);\n\n    /**\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\n     */\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\n\n    // -- Modifiers --\n\n    function _notPartialPaused() internal view {\n        require(!controller.paused(), \"Paused\");\n        require(!controller.partialPaused(), \"Partial-paused\");\n    }\n\n    function _notPaused() internal view virtual {\n        require(!controller.paused(), \"Paused\");\n    }\n\n    function _onlyGovernor() internal view {\n        require(msg.sender == controller.getGovernor(), \"Caller must be Controller governor\");\n    }\n\n    function _onlyController() internal view {\n        require(msg.sender == address(controller), \"Caller must be Controller\");\n    }\n\n    modifier notPartialPaused() {\n        _notPartialPaused();\n        _;\n    }\n\n    modifier notPaused() {\n        _notPaused();\n        _;\n    }\n\n    // Check if sender is controller.\n    modifier onlyController() {\n        _onlyController();\n        _;\n    }\n\n    // Check if sender is the governor.\n    modifier onlyGovernor() {\n        _onlyGovernor();\n        _;\n    }\n\n    // -- Functions --\n\n    /**\n     * @dev Initialize the controller.\n     */\n    function _initialize(address _controller) internal {\n        _setController(_controller);\n    }\n\n    /**\n     * @notice Set Controller. Only callable by current controller.\n     * @param _controller Controller contract address\n     */\n    function setController(address _controller) external onlyController {\n        _setController(_controller);\n    }\n\n    /**\n     * @dev Set controller.\n     * @param _controller Controller contract address\n     */\n    function _setController(address _controller) internal {\n        require(_controller != address(0), \"Controller must be set\");\n        controller = IController(_controller);\n        emit SetController(_controller);\n    }\n\n    /**\n     * @dev Return Curation interface.\n     * @return Curation contract registered with Controller\n     */\n    function curation() internal view returns (ICuration) {\n        return ICuration(_resolveContract(keccak256(\"Curation\")));\n    }\n\n    /**\n     * @dev Return EpochManager interface.\n     * @return Epoch manager contract registered with Controller\n     */\n    function epochManager() internal view returns (IEpochManager) {\n        return IEpochManager(_resolveContract(keccak256(\"EpochManager\")));\n    }\n\n    /**\n     * @dev Return RewardsManager interface.\n     * @return Rewards manager contract registered with Controller\n     */\n    function rewardsManager() internal view returns (IRewardsManager) {\n        return IRewardsManager(_resolveContract(keccak256(\"RewardsManager\")));\n    }\n\n    /**\n     * @dev Return Staking interface.\n     * @return Staking contract registered with Controller\n     */\n    function staking() internal view returns (IStaking) {\n        return IStaking(_resolveContract(keccak256(\"Staking\")));\n    }\n\n    /**\n     * @dev Return GraphToken interface.\n     * @return Graph token contract registered with Controller\n     */\n    function graphToken() internal view returns (IGraphToken) {\n        return IGraphToken(_resolveContract(keccak256(\"GraphToken\")));\n    }\n\n    /**\n     * @dev Return GraphTokenGateway (L1 or L2) interface.\n     * @return Graph token gateway contract registered with Controller\n     */\n    function graphTokenGateway() internal view returns (ITokenGateway) {\n        return ITokenGateway(_resolveContract(keccak256(\"GraphTokenGateway\")));\n    }\n\n    /**\n     * @dev Resolve a contract address from the cache or the Controller if not found.\n     * @return Address of the contract\n     */\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\n        address contractAddress = addressCache[_nameHash];\n        if (contractAddress == address(0)) {\n            contractAddress = controller.getContractProxy(_nameHash);\n        }\n        return contractAddress;\n    }\n\n    /**\n     * @dev Cache a contract address from the Controller registry.\n     * @param _name Name of the contract to sync into the cache\n     */\n    function _syncContract(string memory _name) internal {\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        address contractAddress = controller.getContractProxy(nameHash);\n        if (addressCache[nameHash] != contractAddress) {\n            addressCache[nameHash] = contractAddress;\n            emit ContractSynced(nameHash, contractAddress);\n        }\n    }\n\n    /**\n     * @dev Sync protocol contract addresses from the Controller registry.\n     * This function will cache all the contracts using the latest addresses\n     * Anyone can call the function whenever a Proxy contract change in the\n     * controller to ensure the protocol is using the latest version\n     */\n    function syncAllContracts() external {\n        _syncContract(\"Curation\");\n        _syncContract(\"EpochManager\");\n        _syncContract(\"RewardsManager\");\n        _syncContract(\"Staking\");\n        _syncContract(\"GraphToken\");\n        _syncContract(\"GraphTokenGateway\");\n    }\n}\n\n\n/*\nOriginal Author: https://github.com/uport-project/ethr-did-registry\n\nThis contract is included in graphprotocol/contracts for testing purposes\nThe contract is already deployed on mainnet:\nhttps://etherscan.io/address/0xdca7ef03e98e0dc2b855be647c39abe984fcf21b#code\n\nAs well as all testnets\n*/\n\n// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.6;\n\ncontract EthereumDIDRegistry {\n    mapping(address => address) public owners;\n    mapping(address => mapping(bytes32 => mapping(address => uint256))) public delegates;\n    mapping(address => uint256) public changed;\n    mapping(address => uint256) public nonce;\n\n    modifier onlyOwner(address identity, address actor) {\n        require(actor == identityOwner(identity), \"Caller must be the identity owner\");\n        _;\n    }\n\n    event DIDOwnerChanged(address indexed identity, address owner, uint256 previousChange);\n\n    event DIDDelegateChanged(\n        address indexed identity,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validTo,\n        uint256 previousChange\n    );\n\n    event DIDAttributeChanged(\n        address indexed identity,\n        bytes32 name,\n        bytes value,\n        uint256 validTo,\n        uint256 previousChange\n    );\n\n    function identityOwner(address identity) public view returns (address) {\n        address owner = owners[identity];\n        if (owner != address(0)) {\n            return owner;\n        }\n        return identity;\n    }\n\n    function checkSignature(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 hash\n    ) internal returns (address) {\n        address signer = ecrecover(hash, sigV, sigR, sigS);\n        require(signer == identityOwner(identity), \"Signer must be the identity owner\");\n        nonce[signer]++;\n        return signer;\n    }\n\n    function validDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate\n    ) public view returns (bool) {\n        uint256 validity = delegates[identity][keccak256(abi.encode(delegateType))][delegate];\n        /* solium-disable-next-line security/no-block-members*/\n        return (validity > block.timestamp);\n    }\n\n    function changeOwner(\n        address identity,\n        address actor,\n        address newOwner\n    ) internal onlyOwner(identity, actor) {\n        owners[identity] = newOwner;\n        emit DIDOwnerChanged(identity, newOwner, changed[identity]);\n        changed[identity] = block.number;\n    }\n\n    function changeOwner(address identity, address newOwner) public {\n        changeOwner(identity, msg.sender, newOwner);\n    }\n\n    function changeOwnerSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        address newOwner\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"changeOwner\",\n                newOwner\n            )\n        );\n        changeOwner(identity, checkSignature(identity, sigV, sigR, sigS, hash), newOwner);\n    }\n\n    function addDelegate(\n        address identity,\n        address actor,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) internal onlyOwner(identity, actor) {\n        /* solium-disable-next-line security/no-block-members*/\n        delegates[identity][keccak256(abi.encode(delegateType))][delegate] =\n            block.timestamp +\n            validity;\n        emit DIDDelegateChanged(\n            identity,\n            delegateType,\n            delegate,\n            /* solium-disable-next-line security/no-block-members*/\n            block.timestamp + validity,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function addDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) public {\n        addDelegate(identity, msg.sender, delegateType, delegate, validity);\n    }\n\n    function addDelegateSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 delegateType,\n        address delegate,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"addDelegate\",\n                delegateType,\n                delegate,\n                validity\n            )\n        );\n        addDelegate(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            delegateType,\n            delegate,\n            validity\n        );\n    }\n\n    function revokeDelegate(\n        address identity,\n        address actor,\n        bytes32 delegateType,\n        address delegate\n    ) internal onlyOwner(identity, actor) {\n        /* solium-disable-next-line security/no-block-members*/\n        delegates[identity][keccak256(abi.encode(delegateType))][delegate] = block.timestamp;\n        /* solium-disable-next-line security/no-block-members*/\n        emit DIDDelegateChanged(\n            identity,\n            delegateType,\n            delegate,\n            block.timestamp,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function revokeDelegate(\n        address identity,\n        bytes32 delegateType,\n        address delegate\n    ) public {\n        revokeDelegate(identity, msg.sender, delegateType, delegate);\n    }\n\n    function revokeDelegateSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 delegateType,\n        address delegate\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeDelegate\",\n                delegateType,\n                delegate\n            )\n        );\n        revokeDelegate(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            delegateType,\n            delegate\n        );\n    }\n\n    function setAttribute(\n        address identity,\n        address actor,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) internal onlyOwner(identity, actor) {\n        /* solium-disable-next-line security/no-block-members*/\n        emit DIDAttributeChanged(\n            identity,\n            name,\n            value,\n            block.timestamp + validity,\n            changed[identity]\n        );\n        changed[identity] = block.number;\n    }\n\n    function setAttribute(\n        address identity,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) public {\n        setAttribute(identity, msg.sender, name, value, validity);\n    }\n\n    function setAttributeSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 name,\n        bytes memory value,\n        uint256 validity\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"setAttribute\",\n                name,\n                value,\n                validity\n            )\n        );\n        setAttribute(\n            identity,\n            checkSignature(identity, sigV, sigR, sigS, hash),\n            name,\n            value,\n            validity\n        );\n    }\n\n    function revokeAttribute(\n        address identity,\n        address actor,\n        bytes32 name,\n        bytes memory value\n    ) internal onlyOwner(identity, actor) {\n        emit DIDAttributeChanged(identity, name, value, 0, changed[identity]);\n        changed[identity] = block.number;\n    }\n\n    function revokeAttribute(\n        address identity,\n        bytes32 name,\n        bytes memory value\n    ) public {\n        revokeAttribute(identity, msg.sender, name, value);\n    }\n\n    function revokeAttributeSigned(\n        address identity,\n        uint8 sigV,\n        bytes32 sigR,\n        bytes32 sigS,\n        bytes32 name,\n        bytes memory value\n    ) public {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0),\n                this,\n                nonce[identityOwner(identity)],\n                identity,\n                \"revokeAttribute\",\n                name,\n                value\n            )\n        );\n        revokeAttribute(identity, checkSignature(identity, sigV, sigR, sigS, hash), name, value);\n    }\n}\n\n\n",
        "CodeNames": [
            "ITokenGateway.sol",
            "L1GraphTokenGateway.sol",
            "Governed.sol",
            "IBridge.sol",
            "AddressAliasHelper.sol",
            "Managed.sol",
            "EthereumDIDRegistry.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-17",
                "Location": [
                    "//solidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n20:       function initialize(address _controller) external onlyImpl {\n\n28:       function approveAll(address _spender) external onlyGovernor {\n\n36:       function revokeAll(address _spender) external onlyGovernor {\n\n",
                    "//solidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n30:       function setPauseGuardian(address _newPauseGuardian) external onlyGovernor {\n\n47:       function setPaused(bool _newPaused) external onlyGovernorOrGuardian {\n\n",
                    "//solidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n99:       function initialize(address _controller) external onlyImpl {\n\n109:      function setArbitrumAddresses(address _inbox, address _l1Router) external onlyGovernor {\n\n121:      function setL2TokenAddress(address _l2GRT) external onlyGovernor {\n\n131:      function setL2CounterpartAddress(address _l2Counterpart) external onlyGovernor {\n\n141:      function setEscrowAddress(address _escrow) external onlyGovernor {\n\n152:      function addToCallhookWhitelist(address _newWhitelisted) external onlyGovernor {\n\n164:      function removeFromCallhookWhitelist(address _notWhitelisted) external onlyGovernor {\n\n",
                    "//solidity\nFile: contracts/governance/Governed.sol\n\n40:       function transferOwnership(address _newGovernor) external onlyGovernor {\n\n",
                    "//solidity\nFile: contracts/governance/Managed.sol\n\n95:       function setController(address _controller) external onlyController {\n\n",
                    "//solidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n87:       function initialize(address _controller) external onlyImpl {\n\n97:       function setL2Router(address _l2Router) external onlyGovernor {\n\n107:      function setL1TokenAddress(address _l1GRT) external onlyGovernor {\n\n117:      function setL1CounterpartAddress(address _l1Counterpart) external onlyGovernor {\n\n",
                    "//solidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n105:      function addMinter(address _account) external onlyGovernor {\n\n114:      function removeMinter(address _account) external onlyGovernor {\n\n132:      function mint(address _to, uint256 _amount) external onlyMinter {\n\n",
                    "//solidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n48:       function initialize(address _owner) external onlyImpl {\n\n59:       function setGateway(address _gw) external onlyGovernor {\n\n69:       function setL1Address(address _addr) external onlyGovernor {\n\n80:       function bridgeMint(address _account, uint256 _amount) external override onlyGateway {\n\n90:       function bridgeBurn(address _account, uint256 _amount) external override onlyGateway {\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n68:       function changeProxyAdmin(IGraphProxy _proxy, address _newAdmin) public onlyGovernor {\n\n77:       function upgrade(IGraphProxy _proxy, address _implementation) public onlyGovernor {\n\n86:       function acceptProxy(GraphUpgradeable _implementation, IGraphProxy _proxy) public onlyGovernor {\n\n96        function acceptProxyAndCall(\n97            GraphUpgradeable _implementation,\n98            IGraphProxy _proxy,\n99            bytes calldata _data\n100:      ) external onlyGovernor {\n\n",
                    "//solidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n50:       function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\n\n59        function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\n60            external\n61:           onlyProxyAdmin(_proxy)\n\n",
                    "\nfunction _checksBeforeUnpause() internal view override {\n    require(inbox != address(0), \"INBOX_NOT_SET\");\n    require(l1Router != address(0), \"ROUTER_NOT_SET\");\n    require(l2Counterpart != address(0), \"L2_COUNTERPART_NOT_SET\");\n    require(escrow != address(0), \"ESCROW_NOT_SET\");\n}\n",
                    "\nfunction setL2TokenAddress(address _l2GRT) external onlyGovernor {\n    require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n    l2GRT = _l2GRT;\n    emit L2TokenAddressSet(_l2GRT);\n}\n",
                    "\nIGraphToken token = graphToken();\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nrequire(_to != address(0), \"INVALID_DESTINATION\");\n",
                    "\nIGraphToken token = graphToken();\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\nrequire(_to != address(0), \"INVALID_DESTINATION\");\n",
                    "\nrequire(_to != address(0), \"INVALID_DESTINATION\");\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nIGraphToken token = graphToken();\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n",
                    "\n    require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\")\n",
                    "\n    require(_escrow != address(0), \"INVALID_ESCROW\");\n    require(Address.isContract(_escrow), \"MUST_BE_CONTRACT\");\n",
                    "\n    require(\n            oldPendingGovernor != address(0) && msg.sender == oldPendingGovernor,\n            \"Caller must be pending governor\"\n        );\n",
                    "\n    require(oldPendingGovernor != address(0), \"INVALID_PENDING_GOV\");\n    require(msg.sender == oldPendingGovernor, \"INVALID_SENDER\")\n"
                ],
                "Type": "  Functions guaranteed to revert when called by normal users can be marked  payable ",
                "Description": "If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n*There are 32 instances of this issue:*\nsolidity\nFile: contracts/gateway/BridgeEscrow.sol\n\n20:       function initialize(address _controller) external onlyImpl {\n\n28:       function approveAll(address _spender) external onlyGovernor {\n\n36:       function revokeAll(address _spender) external onlyGovernor {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/BridgeEscrow.sol#L20\n\nsolidity\nFile: contracts/gateway/GraphTokenGateway.sol\n\n30:       function setPauseGuardian(address _newPauseGuardian) external onlyGovernor {\n\n47:       function setPaused(bool _newPaused) external onlyGovernorOrGuardian {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/GraphTokenGateway.sol#L30\n\nsolidity\nFile: contracts/gateway/L1GraphTokenGateway.sol\n\n99:       function initialize(address _controller) external onlyImpl {\n\n109:      function setArbitrumAddresses(address _inbox, address _l1Router) external onlyGovernor {\n\n121:      function setL2TokenAddress(address _l2GRT) external onlyGovernor {\n\n131:      function setL2CounterpartAddress(address _l2Counterpart) external onlyGovernor {\n\n141:      function setEscrowAddress(address _escrow) external onlyGovernor {\n\n152:      function addToCallhookWhitelist(address _newWhitelisted) external onlyGovernor {\n\n164:      function removeFromCallhookWhitelist(address _notWhitelisted) external onlyGovernor {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/gateway/L1GraphTokenGateway.sol#L99\n\nsolidity\nFile: contracts/governance/Governed.sol\n\n40:       function transferOwnership(address _newGovernor) external onlyGovernor {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Governed.sol#L40\n\nsolidity\nFile: contracts/governance/Managed.sol\n\n95:       function setController(address _controller) external onlyController {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/governance/Managed.sol#L95\n\nsolidity\nFile: contracts/l2/gateway/L2GraphTokenGateway.sol\n\n87:       function initialize(address _controller) external onlyImpl {\n\n97:       function setL2Router(address _l2Router) external onlyGovernor {\n\n107:      function setL1TokenAddress(address _l1GRT) external onlyGovernor {\n\n117:      function setL1CounterpartAddress(address _l1Counterpart) external onlyGovernor {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/gateway/L2GraphTokenGateway.sol#L87\n\nsolidity\nFile: contracts/l2/token/GraphTokenUpgradeable.sol\n\n105:      function addMinter(address _account) external onlyGovernor {\n\n114:      function removeMinter(address _account) external onlyGovernor {\n\n132:      function mint(address _to, uint256 _amount) external onlyMinter {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/GraphTokenUpgradeable.sol#L105\n\nsolidity\nFile: contracts/l2/token/L2GraphToken.sol\n\n48:       function initialize(address _owner) external onlyImpl {\n\n59:       function setGateway(address _gw) external onlyGovernor {\n\n69:       function setL1Address(address _addr) external onlyGovernor {\n\n80:       function bridgeMint(address _account, uint256 _amount) external override onlyGateway {\n\n90:       function bridgeBurn(address _account, uint256 _amount) external override onlyGateway {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/l2/token/L2GraphToken.sol#L48\n\nsolidity\nFile: contracts/upgrades/GraphProxyAdmin.sol\n\n68:       function changeProxyAdmin(IGraphProxy _proxy, address _newAdmin) public onlyGovernor {\n\n77:       function upgrade(IGraphProxy _proxy, address _implementation) public onlyGovernor {\n\n86:       function acceptProxy(GraphUpgradeable _implementation, IGraphProxy _proxy) public onlyGovernor {\n\n96        function acceptProxyAndCall(\n97            GraphUpgradeable _implementation,\n98            IGraphProxy _proxy,\n99            bytes calldata _data\n100:      ) external onlyGovernor {\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphProxyAdmin.sol#L68\n\nsolidity\nFile: contracts/upgrades/GraphUpgradeable.sol\n\n50:       function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\n\n59        function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\n60            external\n61:           onlyProxyAdmin(_proxy)\n\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/48e7c7cf641847e07ba07e01176cb17ba8ad6432/contracts/upgrades/GraphUpgradeable.sol#L50\n\ntmigone (The Graph) commented(https://github.com/code-423n4/2022-10-thegraph-findings/issues/117#issuecomment-1287387040):\n  We've found this submission to be of high quality.\n\n# Mitigation Review\n\n*Mitigation review by Trust*\n\nProject repository: https://github.com/graphprotocol/contracts<br\n\nReview commit: caf5ab5723353b9062878ade247a060a2b55514f<br\n\n## Mitigation overview\n\nThe C4 Graph contest identified a total of 4 Medium issues and several QA and gas optimization suggestions. The following is the list of issues addressed:\n\nContract unupgradeability issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/244) Fixed in a standalone PR(https://github.com/graphprotocol/contracts/pull/739) as it was initially classified as medium severity but ultimately marked as QA issue. Fixed by inserting a __gap state variable in GraphTokenGateway and GraphTokenUpgradeable. Therefore, those 2 contracts are now upgradeable.\nInsufficient validation of l2Counterpart in L1GraphTokenGateway issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/201) Fixed in a standalone PR(https://github.com/graphprotocol/contracts/pull/740) as it was also initially classified as Medium severity but ultimately marked as QA issue. Fixed by requiring L2Counterpart to not be zero in every instance of L2Counterpart validation.\nContract re-initialization issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/149) Fixed in standalone PR(https://github.com/graphprotocol/contracts/pull/741). Fixed by using OpenZeppelin's initializer guard in contracts BridgeEscrow, L1GraphTokenGateway, L2GraphTokenGateway and L2GraphToken.\nArbitrum address 0.8.0 overflow issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/289) Fixed in future 0.8.0 upgrade branch PR(https://github.com/graphprotocol/contracts/pull/738). Fixed by wrapping the potential overflowing and underflowing operations in an unchecked block.\nNon-empty _data leading to callbacks issue, was identified by The Graph team and fixed in PR(https://github.com/graphprotocol/contracts/pull/745). Fixed by not serializing the data with unused bytes.\nMultiple QA issues, including #198/202(https://github.com/code-423n4/2022-10-thegraph-findings/issues/198): \"L1GraphTokenGateway should not allow l1Router as callhookWhitelist\" Fixed in PR(https://github.com/graphprotocol/contracts/pull/743)\nMultiple gas optimization issues Fixed in PR(https://github.com/graphprotocol/contracts/pull/742)\n\nThe following is a list of issues acknowledged by The Graph:\n\nGovernance centralization issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/300) Governor privileged address can approve any address to spend BridgeEscrow locked funds.\nLeak of gas issue(https://github.com/code-423n4/2022-10-thegraph-findings/issues/294) Contract calls to outboundTransfer() may lose the gas refunds sent on L2.\n\nThe fixes applied by The Graph have been stacked on top of each other in the git commit tree. As such, the Mitigation Review was done on the last PR(https://github.com/graphprotocol/contracts/pull/745) in the fix tree, which covers the result of the aggregation of the fixes.\n\n## Findings\n\nFindings are labeled with the following notation M.S-N, representing Mitigation.Severity-Number.\n\nNo Medium or High severity issues have been uncovered in the Mitigation Review. This can be attributed to the combination of high coding and code review standards of the team, and to the fact that little to no logic has been introduced to any of the contracts.\n\n\nThe PR(https://github.com/graphprotocol/contracts/pull/739) addressed upgradeability of two contracts GraphTokenGateway and GraphTokenUpgradeable. \n\nHowever, the following inherited contracts have not been addressed:\n\n1.  Managed.sol\n2.  Pausable.sol\n3.  Governed.sol\n\nManaged.sol has a 10 slot gap, which is non-standard and may not be sufficient for desired future functionality. The other two contracts have no slot gap. Without introducing __gap slots in the above contracts, they will not be effectively upgradeable once deployed.\n\nContracts that derive from the above contracts are (among others):\n\n1.  GraphTokenGateway\n2.  BridgeEscrow\n3.  L1GraphTokenGateway\n4.  L2GraphTokenGateway\n\nIt is important to note that derived contracts *can* be upgraded, but state variables in the base contracts cannot be introduced.\n\nThe Graph has acknowledged the finding and reasoned that the above contracts are already used by existing Graph facilities. Additionally, those contracts have specific functionality and it is reasonable that they won't need to be upgraded.\n\n\nThe PR contains some refactoring done after an additional audit by Open Zeppelin. Now, every derived GraphTokenGateway implements a _checksBeforeUnpause function. Below is how it is defined for L1GraphTokenGateway.sol:\n\n\nfunction _checksBeforeUnpause() internal view override {\n    require(inbox != address(0), \"INBOX_NOT_SET\");\n    require(l1Router != address(0), \"ROUTER_NOT_SET\");\n    require(l2Counterpart != address(0), \"L2_COUNTERPART_NOT_SET\");\n    require(escrow != address(0), \"ESCROW_NOT_SET\");\n}\n\n\nNote that there is no check for the important l2GRT state variable. It can be set at any time using the setL2TokenAddress function:\n\n\nfunction setL2TokenAddress(address _l2GRT) external onlyGovernor {\n    require(_l2GRT != address(0), \"INVALID_L2_GRT\");\n    l2GRT = _l2GRT;\n    emit L2TokenAddressSet(_l2GRT);\n}\n\n\nWe advise adding the following check:\nrequire(l2GRT != address(0), \"L2GRT_NOT_SET\");\n\n\nOutbound transfer checks previously looked like this:\n\n\nIGraphToken token = graphToken();\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nrequire(_to != address(0), \"INVALID_DESTINATION\");\n\n\nThe Graph implemented a gas optimization suggestion and re-ordered the checks to the code below:\n\n\nIGraphToken token = graphToken();\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\nrequire(_to != address(0), \"INVALID_DESTINATION\");\n\n\nHowever, it is recommended that the expensive \"token\" variable lookup would be delayed until deemed necessary, after the _amount and _to checks:\n\n\nrequire(_to != address(0), \"INVALID_DESTINATION\");\nrequire(_amount != 0, \"INVALID_ZERO_AMOUNT\");\nIGraphToken token = graphToken();\nrequire(_l1Token == address(token), \"TOKEN_NOT_GRT\");\n\n\n\nThe Graph implemented gas optimizations for require() statements which use the && operator. For example\n\n\n    require(_escrow != address(0) && Address.isContract(_escrow), \"INVALID_ESCROW\")\n\n\nwas changed to:\n\n\n    require(_escrow != address(0), \"INVALID_ESCROW\");\n    require(Address.isContract(_escrow), \"MUST_BE_CONTRACT\");\n\n\nWe would advise the team to fix an additional compound require statement in Governed.sol's acceptOwnership():\n\n\n    require(\n            oldPendingGovernor != address(0) && msg.sender == oldPendingGovernor,\n            \"Caller must be pending governor\"\n        );\n\n\nChange to:\n\n\n    require(oldPendingGovernor != address(0), \"INVALID_PENDING_GOV\");\n    require(msg.sender == oldPendingGovernor, \"INVALID_SENDER\")\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    }
]