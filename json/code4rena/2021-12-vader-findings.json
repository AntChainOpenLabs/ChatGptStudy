[
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n\n        if (blockTimestampLast < block.timestamp) {\n            uint256 timeElapsed = block.timestamp - blockTimestampLast;\n            unchecked {\n                price0CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveForeign,\n                                pairInfo[foreignAsset].reserveNative\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n                price1CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveNative,\n                                pairInfo[foreignAsset].reserveForeign\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    // NOTE: Loss is in terms of USDV\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setQueue(bool _queueActive) external override onlyOwner {\n        require(\n            _queueActive != queueActive,\n            \"VaderPoolV2::setQueue: Already At Desired State\"\n        );\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(\n        IERC20 foreignAsset,\n        bool support,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override onlyOwner returns (uint256 liquidity) {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n        if (!support) {\n            PairInfo storage pair = pairInfo[foreignAsset];\n            require(\n                pair.reserveNative == 0 && pair.reserveForeign == 0,\n                \"VaderPoolV2::supportToken: Cannot Unsupport Token w/ Liquidity\"\n            );\n        } else {\n            require(\n                nativeDeposit != 0 && foreignDeposit != 0,\n                \"VaderPoolV2::supportToken: Improper First-Time Liquidity Provision\"\n            );\n            liquidity = _mint(\n                foreignAsset,\n                nativeDeposit,\n                foreignDeposit,\n                from,\n                to\n            );\n        }\n    }\n\n    /*\n     * @dev Allows the gas throttle to be toggled on/off in case of emergency\n     **/\n    function setGasThrottle(bool _gasThrottleEnabled)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            gasThrottleEnabled != _gasThrottleEnabled,\n            \"VaderPoolV2::setGasThrottle: Already At Desired State\"\n        );\n        gasThrottleEnabled = _gasThrottleEnabled;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../dex/math/VaderMath.sol\";\nimport \"../../dex/utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex-v2/pool/IBasePoolV2.sol\";\n\n/*\n * @dev Implementation of {BasePoolV2} contract.\n *\n * The BasePoolV2 contract keeps track of all the Vader pools in the form of\n * pairs. Each pair tracked through {pairInfo} mapping and is mapped against the\n * foreign asset for which the pair is created.\n *\n * Has function to deposited liquidity to any of pair by specifying the mapped\n * foreign asset against the pair.\n *\n * The minted liquidity is associated with a position, that is tracked by a minted NFT.\n * The NFT has information about the pair for which it represents the liquidity.\n *\n * The contract allows redeeming of liquidity against a particular pool by burning the\n * associated position representing NFT.\n *\n * The contract allows swapping of native to foreign assets and vice versa within a pair and\n * allows foreign to foreign asset swap across two different pairs.\n *\n * Keeps track of the cumulative prices for both native and foreign assets for\n * pairs and updates them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePoolV2 is\n    IBasePoolV2,\n    ProtocolConstants,\n    GasThrottle,\n    ERC721,\n    ReentrancyGuard\n{\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset USDV.\n    IERC20 public immutable override nativeAsset;\n\n    // Denotes what tokens are actively supported by the system\n    mapping(IERC20 => bool) public override supported;\n\n    /*\n     * @dev A mapping of foreign asset to the pool's pair.\n     * Each pair is represents a pool of native and foreign assets and\n     * contains data such as the reserves of native and foreign assets and\n     * the liquidity units issues against the deposits of these assets.\n     **/\n    mapping(IERC20 => PairInfo) public pairInfo;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited across different pools of pairs the timestamp at which the position\n     * is created and the amount of liquidity of a particular pool assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // C4-Audit Fix for Issue # 142\n    // A unique id of the position created when liquidity is added to a pool.\n    uint256 public positionId;\n\n    // Address of the router contract (used for restriction)\n    address public router;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes the contract by setting address of native asset.\n     **/\n    constructor(IERC20 _nativeAsset) ERC721(\"Vader-V1-POS\", \"VLP\") {\n        require(\n            _nativeAsset != IERC20(_ZERO_ADDRESS),\n            \"BasePoolV2::constructor: Incorrect Arguments\"\n        );\n        nativeAsset = IERC20(_nativeAsset);\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Accepts address of foreign asset {foreignAsset} to determine the pair (pool)\n     * and returns reserves amounts of native and foreign assets, and the last timestamp\n     * when cumulative prices for these assets were updated.\n     **/\n    function getReserves(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        PairInfo storage pair = pairInfo[foreignAsset];\n        (reserveNative, reserveForeign, blockTimestampLast) = (\n            pair.reserveNative,\n            pair.reserveForeign,\n            pair.blockTimestampLast\n        );\n    }\n\n    /*\n     * @dev Accepts {id} of a liquidity position and returns foreign asset's\n     * address for that particular liquidity position.\n     **/\n    function positionForeignAsset(uint256 id)\n        external\n        view\n        override\n        returns (IERC20)\n    {\n        return positions[id].foreignAsset;\n    }\n\n    function pairSupply(IERC20 foreignAsset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return pairInfo[foreignAsset].totalSupply;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to a pool/pair by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records in {positions} mapping, the amounts\n     * of the native and foreign assets deposited and the liquidity units minted against.\n     *\n     * The pool/pair to accept the native and foreign assets against is determined by {foreignAsset}.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {pair.totalSupply} of pair/pool.\n     *\n     * Updates the cumulative prices of native and foreign assets in pool/pair after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be approved to the pool prior to calling the `mint` function.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function mint(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAsset)\n        returns (uint256 liquidity)\n    {\n        return _mint(foreignAsset, nativeDeposit, foreignDeposit, from, to);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT with {id} associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets from pool/pair against which the NFT with Id {id}\n     * was minted. The computed assets' amounts depends upon current reserves of assets and\n     * the liquidity associated with the position, and is transferred to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {pair.totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets in pool/pair after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the contract prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePoolV2::burn: Incorrect Ownership\"\n        );\n\n        IERC20 foreignAsset = positions[id].foreignAsset;\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 liquidity = positions[id].liquidity;\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePoolV2::burn: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n        _burn(id);\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev Allows swapping between two foreign assets from two different pools/pairs.\n     *\n     * It receives amount {foreignAmountIn} in {foreignAssetA} and returns the swapped amount in {foreignAssetB}.\n     *\n     * The amount {foreignAmountIn} is swapped to the native asset from the pair against {foreignAssetA} and the\n     * received native asset is swapped to foreign asset from the pair against {foreignAssetB}.\n     *\n     * Updates the cumulative prices for native and foreign assets across pools against assets {foreignAssetA} and\n     * {foreignAssetB}.\n     *\n     * Requirements:\n     * - The amount {foreignAmountIn} in {foreignAssetA} must be transferred to the contract prior to calling\n     *   the function `doubleSwap`.\n     * - The intermediary native asset retrieved from first swap must be greater than 0 and the reserve for native asset.\n     * - The foreign amount received from second swap must be greater than 0 and the reserve for foreign asset in the pair/pool\n     *   against that particular foreign asset.\n     * - The params {foreignAssetA} and {foreignAssetB} must be the supported tokens.\n     * - Can only be called by Router.\n     **/\n    function doubleSwap(\n        IERC20 foreignAssetA,\n        IERC20 foreignAssetB,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAssetA)\n        supportedToken(foreignAssetB)\n        nonReentrant\n        validateGas\n        returns (uint256 foreignAmountOut)\n    {\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAssetA\n        ); // gas savings\n\n        require(\n            foreignReserve + foreignAmountIn <=\n                foreignAssetA.balanceOf(address(this)),\n            \"BasePoolV2::doubleSwap: Insufficient Tokens Provided\"\n        );\n\n        uint256 nativeAmountOut = VaderMath.calculateSwap(\n            foreignAmountIn,\n            foreignReserve,\n            nativeReserve\n        );\n\n        require(\n            nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetA,\n            nativeReserve - nativeAmountOut,\n            foreignReserve + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetA,\n            msg.sender,\n            0,\n            foreignAmountIn,\n            nativeAmountOut,\n            0,\n            address(this)\n        );\n\n        (nativeReserve, foreignReserve, ) = getReserves(foreignAssetB); // gas savings\n\n        foreignAmountOut = VaderMath.calculateSwap(\n            nativeAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        require(\n            foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetB,\n            nativeReserve + nativeAmountOut,\n            foreignReserve - foreignAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetB,\n            msg.sender,\n            nativeAmountOut,\n            0,\n            0,\n            foreignAmountOut,\n            to\n        );\n\n        foreignAssetB.safeTransfer(to, foreignAmountOut);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets from within a single pair/pool determined\n     * by {foreignAsset}.\n     *\n     * It receives the source asset and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets for the pair involved after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function swap(\n        IERC20 foreignAsset,\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAsset)\n        nonReentrant\n        validateGas\n        returns (uint256)\n    {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePoolV2::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            require(\n                to != address(_nativeAsset) && to != address(foreignAsset),\n                \"BasePoolV2::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n        }\n\n        _update(\n            foreignAsset,\n            nativeReserve - nativeAmountOut + nativeAmountIn,\n            foreignReserve - foreignAmountOut + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAsset,\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /*\n     * @dev Allows withdrawing of unaccounted/unrealised foreign asset from the contract.\n     *\n     * Determines the realised amount of foreign asset from the pair against {foreignAsset}.\n     **/\n    function rescue(IERC20 foreignAsset) external {\n        uint256 foreignBalance = foreignAsset.balanceOf(address(this));\n        uint256 reserveForeign = pairInfo[foreignAsset].reserveForeign;\n\n        uint256 unaccounted = foreignBalance - reserveForeign;\n\n        foreignAsset.safeTransfer(msg.sender, unaccounted);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev See `mint`.\n     **/\n    function _mint(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) internal nonReentrant returns (uint256 liquidity) {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePoolV2::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            foreignAsset,\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(from, to, id, liquidity);\n    }\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets for\n     * the pair against {foreignAsset}. The updated prices depend upon the last reserves and\n     * updates the reserves for both of the assets corresponding to their\n     * current balances along with the timestamp.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        IERC20 foreignAsset,\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePoolV2::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        PairInfo storage pair = pairInfo[foreignAsset];\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - pair.blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                pair.priceCumulative.nativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                pair.priceCumulative.foreignLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        pair.reserveNative = uint112(balanceNative);\n        pair.reserveForeign = uint112(balanceForeign);\n        pair.blockTimestampLast = blockTimestamp;\n        emit Sync(foreignAsset, balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Private function that returns if the param {token} is a supported token\n     * or not.\n     **/\n    function _supportedToken(IERC20 token) private view {\n        require(\n            supported[token],\n            \"BasePoolV2::_supportedToken: Unsupported Token\"\n        );\n    }\n\n    /*\n     * @dev Private function that returns if {msg.sender} is a Router or not.\n     **/\n    function _onlyRouter() private view {\n        require(\n            msg.sender == router,\n            \"BasePoolV2::_onlyRouter: Only Router is allowed to call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /*\n     * @dev Modifier that only allows continuation of execution\n     * if {msg.sender} is Router.\n     **/\n    modifier onlyRouter() {\n        _onlyRouter();\n        _;\n    }\n\n    /*\n     * @dev Modifier that only allows continuation of exectuion if the param\n     * {token} is a supported token.\n     **/\n    modifier supportedToken(IERC20 token) {\n        _supportedToken(token);\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPoolV2.sol",
            "BasePool.sol",
            "BasePoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "from",
                    "nativeAsset.safeTransferFrom(from, address(this), nativeDeposit)",
                    "mintSynth",
                    "mintSynth(IERC",
                    "mintFungible"
                ],
                "Type": "  VaderPoolV2  minting synths & fungibles can be frontrun",
                "Description": "\nThe VaderPoolV2 mintFungible and mintSynth functions perform an unsafe nativeAsset.safeTransferFrom(from, address(this), nativeDeposit) with a parameter-specified from address.\n\nNote that these functions are not called by the Router, they are directly called on the pool.\nTherefore, users will usually be required to send two transactions, a first one approving the pool, and then a second one for the actual mintSynth.\n\nAn attacker can frontrun the mintSynth(IERC20 foreignAsset, uint256 nativeDeposit, address from, address to) function, use the same from=victim parameter but change the to parameter to the attacker.\n\n\nIt's possible to frontrun victims stealing their native token deposits and receiving synths / fungible tokens.\n\n",
                "Repair": "\nRemove the from parameter and always perform the safeTransferFrom call with from=msg.sender.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/147)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n\n        if (blockTimestampLast < block.timestamp) {\n            uint256 timeElapsed = block.timestamp - blockTimestampLast;\n            unchecked {\n                price0CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveForeign,\n                                pairInfo[foreignAsset].reserveNative\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n                price1CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveNative,\n                                pairInfo[foreignAsset].reserveForeign\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    // NOTE: Loss is in terms of USDV\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setQueue(bool _queueActive) external override onlyOwner {\n        require(\n            _queueActive != queueActive,\n            \"VaderPoolV2::setQueue: Already At Desired State\"\n        );\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(\n        IERC20 foreignAsset,\n        bool support,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override onlyOwner returns (uint256 liquidity) {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n        if (!support) {\n            PairInfo storage pair = pairInfo[foreignAsset];\n            require(\n                pair.reserveNative == 0 && pair.reserveForeign == 0,\n                \"VaderPoolV2::supportToken: Cannot Unsupport Token w/ Liquidity\"\n            );\n        } else {\n            require(\n                nativeDeposit != 0 && foreignDeposit != 0,\n                \"VaderPoolV2::supportToken: Improper First-Time Liquidity Provision\"\n            );\n            liquidity = _mint(\n                foreignAsset,\n                nativeDeposit,\n                foreignDeposit,\n                from,\n                to\n            );\n        }\n    }\n\n    /*\n     * @dev Allows the gas throttle to be toggled on/off in case of emergency\n     **/\n    function setGasThrottle(bool _gasThrottleEnabled)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            gasThrottleEnabled != _gasThrottleEnabled,\n            \"VaderPoolV2::setGasThrottle: Already At Desired State\"\n        );\n        gasThrottleEnabled = _gasThrottleEnabled;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n",
        "CodeNames": [
            "VaderPoolV2.sol",
            "BasePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "foreignAsset",
                    "setTokenSupport"
                ],
                "Type": "  VaderPoolV2  owner can steal all user assets which are approved  VaderPoolV2 ",
                "Description": "\nPossible theft of all user assets with an ERC20 approval on VaderPoolV2.\n\n\nThe owner of VaderPoolV2 can call the setTokenSupport function which allows the caller to supply any address from which to take the assets to provide the initial liquidity, the owner can also specify who shall receive the resulting LP NFT and so can take ownership over these assets. This call will succeed for any address which has an ERC20 approval on VaderPoolV2 for USDV and foreignAsset.\n\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L442-L474\n\nThis in effect gives custody over all assets in user wallets which are approved on VaderPoolV2 to Vader Protocol governance. This is especially problematic in the case of Vader Protocol as there's a single entity (i.e. the Council) which can force through a proposal to steal these assets for themselves with only the timelock giving protection to users, for this reason I give this high severity.\n\n",
                "Repair": "\nEnforce that the initial liquidity is provided by the VaderPoolV2 owner.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-14",
                "Location": [
                    "foreignDeposit",
                    "nativeDeposit",
                    "totalLiquidityUnits",
                    "setFungibleTokenSupport",
                    "mintFungible"
                ],
                "Type": " Denial of service",
                "Description": "\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L334\non the first deposit, the total liquidity is set to nativeDeposit.\nthis might be a very low number compared to foreignDeposit.\nIt can cause a denial of service of the pair.\n\n\nA pair can enter a denial of service state.\n\n\nconsider the following scenario:\nthe owner of the pool calls setFungibleTokenSupport for a new token, for example weth.\na malicious actor calls mintFungible,  with nativeDeposit == 1 and foreignDeposit == 10 ether.\ntotalLiquidityUnits will be 1.\nthe pool can be arbitraged, even by the attacker, but totalLiquidityUnits will still be 1.\nthis means that 1 liquidity token is equal to all of the pool reserves, which is a lot of money.\nIt will cause a very high rounding error for anyone trying to mint liquidity.\nthen, anyone who will try to mint liquidity will either:\n\n1.  fail, because they can't mint 0 liquidity if their amount is too small.\n2.  get less liquidity tokens than they should, because there is a very high rounding error, and its against new liquidity providers.\n\nThe rounding error losses will increase the pool reserves, which will increase value of liquidity tokens, so the hacker can even profit from this.\n\nafter this is realised, no one will want to provide liquidity, and since the pair cannot be removed or replaced, it will cause denial of service for that token forever.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/98)\n\n\n\n*\n\n \n\n",
                "Repair": ""
            },
            {
                "Name": "M-01",
                "Location": [
                    "foreignAsset",
                    "VaderPoolV",
                    "mintFungible",
                    "nativeAsset"
                ],
                "Type": "  VaderPoolV2.mintFungible  exposes users to unlimited slippage",
                "Description": "\nFrontrunners can extract up to 100% of the value provided by LPs to VaderPoolV2 as fungible liquidity.\n\n\nUsers can provide liquidity to VaderPoolV2 through the mintFungible function.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/pool/VaderPoolV2.sol#L311-L317\n\nThis allows users to provide tokens in any ratio and the pool will calculate what fraction of the value in the pool this makes up and mint the corresponding amount of liquidity units as an ERC20.\n\nHowever there's no way for users to specify the minimum number of liquidity units they will accept. As the number of liquidity units minted is calculated from the current reserves, this allows frontrunners to manipulate the pool's reserves in such a way that the LP receives fewer liquidity units than they should. e.g. LP provides a lot of nativeAsset but very little foreignAsset, the frontrunner can then sell a lot of nativeAsset to the pool to devalue it.\n\nOnce this is done the attacker returns the pool's reserves back to normal and pockets a fraction of the value which the LP meant to provide as liquidity.\n\n",
                "Repair": "\nAdd a user-specified minimum amount of LP tokens to mint.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/2)\n\nJack the Pug (judge) decreased severity to medium and commented(https://github.com/code-423n4/2021-12-vader-findings/issues/2#issuecomment-1066036603):\n  I'm downgrading this from high] to med and merging all the issues related to slippage control into this one.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityBasedTWAP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "totalUSD",
                    "totalUSDV"
                ],
                "Type": " Oracle doesn't calculate USDV/VADER price correctly",
                "Description": "\nInvalid values returned from oracle for USDV and VADER prices in situations where the oracle uses more than one foreign asset.\n\n\nThe USDV price is calculated as so (for simplicity we'll consider a two pairs):\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409\n\n    totalUSD =  (PriceForeign0InUSD * liquidityWeights[0] + PriceForeign1InUSD * liquidityWeights[1]) / totalUSDVLiquidityWeight;\n\ntotalUSD is then the average price of the foreign assets paired against USDV in terms of USD, weighted by the TVL of the relevant liquidity pool\n\n    totalUSDV =\n      (pairData0\n          .nativeTokenPriceAverage\n          .mul(pairData0.foreignUnit)\n          .decode144() * liquidityWeights[0] +\n       pairData1\n          .nativeTokenPriceAverage\n          .mul(pairData1.foreignUnit)\n          .decode144() * liquidityWeights[1]) /\n      totalUSDVLiquidityWeight;\n\n    // in pseudocode for readability\n    totalUSDV = (USDVPriceInForeign0 * liquidityWeights[0] + USDVPriceInForeign1 * liquidityWeights[1]) /  totalUSDVLiquidityWeight\n\ntotalUSDV is then the average price of USDV in terms of each of the foreign assets, weighted by the TVL of the relevant liquidity pool.\n\nIt should be fairly clear that this is the incorrect calculation as all the terms in totalUSDV are in different units you can't average the price of USDV in ETH with the price of USDV in BTC and get a meaningful result.\n\nIt appears that the VADER team intended to calculate the price of USDV in terms of USD through a number of different paired assets and then average them at the end based on the liquidity in each pair but have started averaging too early.\n\nHigh severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV an incorrect value will result in the protocol losing significant funds.\n\n",
                "Repair": "\nReview the algorithm used for calculating the prices of assets and ensure that it's calculating what you expect.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/42)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "totalUSDVLiquidityWeight",
                    "liquidityWeights[i]",
                    "_calculateUSDVPrice",
                    "totalUSD",
                    "totalUSDV"
                ],
                "Type": " Oracle returns an improperly scaled USDV/VADER price",
                "Description": "\nInvalid values returned from oracle in vast majority of situations.\n\n\nThe LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.\n\nConsider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:\n\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409\n\nFor L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy.\n\n    foreignPrice = getChainlinkPrice(address(foreignAsset));\n    foreignPrice = 1e8\n\nWe can set liquidityWeights[i] and totalUSDVLiquidityWeight both to 1 as we only consider a single pair so L399-401 becomes\n\n    totalUSD = foreignPrice;\n    totalUSD = 1e8;\n\nL403-408 is slightly more complex but from looking at the links below we can calculate totalUSDV as shown\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160\n\n    totalUSDV = pairData\n        .nativeTokenPriceAverage\n        .mul(pairData.foreignUnit)\n        .decode144()\n    // pairData.nativeTokenPriceAverage == 2112\n    // pairData.foreignUnit = 1018\n    // decode144(x) = x  112\n    totalUSDV = (2112).mul(1018).decode144()\n    totalUSDV = 1018\n\nUsing totalUSD and totalUSDV we can then calculate the return value of _calculateUSDVPrice\n\n    returnValue = (totalUSD * 1 ether) / totalUSDV;\n\n    returnValue = 1e8 * 1e18 / 1e18\n\n    returnValue = 1e8\n\nFor the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.\n\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76\n<https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109\n\nHigh severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV an incorrect value will result in the protocol losing significant funds.\n\n",
                "Repair": "\nGo over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.\n\nBuild a test suite to ensure that the oracle returns the expected values for simple situations.\n\nSamSteinGG (Vader) confirmed(https://github.com/code-423n4/2021-12-vader-findings/issues/70)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "currentLiquidityEvaluation"
                ],
                "Type": " Oracle can be manipulted to consider only a single pair for pricing",
                "Description": "\nLoss of resilience of oracle to a faulty pricing for a single pair.\n\n\nIn the oracle we calculate the TVL of each pool by pulling the reserves and multiplying both assets by the result of a supposedly manipulation resistant oracle (the oracle queries its previous value for USDV and pulls the foreign asset from chainlink).\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/lbt/LiquidityBasedTWAP.sol#L353-L383\n\nThis value can be manipulated by skewing the reserves of the underlying pair with a flashloan attack. An attacker can then make a pool appear with an arbitrarily large currentLiquidityEvaluation which will result in all other pairs contributing negligibly to the final result of the oracle.\n\nThis doesn't result in loss of funds by itself afaict but should there be an issue for the chainlink price feed for the asset in any pool then an attacker can force the oracle to only use that pool for pricing USDV/VADER\n\nMedium risk as \"Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\" External requirements being a malfunctioning or deprecated chainlink pricefeed for any used asset.\n\nCalculating TVL of the pool is equivalent to value of all LP tokens so for more information see this post: <https://blog.alphafinance.io/fair-lp-token-pricing/\n\n",
                "Repair": "\nCalculate fair reserves using the pool invariant and the fair prices of the two assets.\n\nThe above link contains a mitigates for Uniswap, a similar calculation would have to be performed which is specific for the Vader invariant.\n\nSamSteinGG (Vader) disputed and commented(https://github.com/code-423n4/2021-12-vader-findings/issues/40#issuecomment-1001506397):\n  The evaluation of liquidity for a particular pair is performed based on the reserves of the previous block rendering a flash loan attack impossible. Can the  warden clarify how he is expecting this to be exploited?\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/shared/IERC20Extended.sol\";\nimport \"../interfaces/tokens/IUSDV.sol\";\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\n// TBD\ncontract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20Extended;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The VADER token used for burns and mints\n    IERC20Extended public immutable vader;\n\n    // The LBT pricing mechanism for the conversion\n    ILiquidityBasedTWAP public lbt;\n\n    // The exchange fee if any applied to burns and mints\n    uint256 public exchangeFee;\n\n    // The 24 hour limit on USDV mints\n    uint256 public dailyLimit = type(uint256).max;\n\n    // The current cycle end timestamp\n    uint256 public cycleTimestamp;\n\n    // The current cycle cumulative mints\n    uint256 public cycleMints;\n\n    // All mint/burn locks\n    mapping(address => Lock[]) public locks;\n\n    // Guardian Account\n    address public guardian;\n\n    // Lock system\n    bool private isLocked;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _vader) ERC20(\"Vader USD\", \"USDV\") {\n        require(\n            _vader != IERC20Extended(_ZERO_ADDRESS),\n            \"USDV::constructor: Improper Configuration\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount - fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n    function claim(uint256 i) external onlyWhenNotLocked returns (uint256) {\n        Lock[] storage userLocks = locks[msg.sender];\n        Lock memory lock = userLocks[i];\n\n        require(lock.release <= block.timestamp, \"USDV::claim: Vesting\");\n\n        uint256 last = userLocks.length - 1;\n        if (i != last) {\n            userLocks[i] = userLocks[last];\n        }\n\n        userLocks.pop();\n\n        if (lock.token == LockTypes.USDV)\n            _transfer(address(this), msg.sender, lock.amount);\n        else vader.transfer(msg.sender, lock.amount);\n\n        emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n\n        return lock.amount;\n    }\n\n    function claimAll()\n        external\n        onlyWhenNotLocked\n        returns (uint256 usdvAmount, uint256 vaderAmount)\n    {\n        Lock[] memory userLocks = locks[msg.sender];\n        delete locks[msg.sender];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock memory lock = userLocks[i];\n\n            require(lock.release <= block.timestamp, \"USDV::claimAll: Vesting\");\n\n            if (lock.token == LockTypes.USDV) {\n                _transfer(address(this), msg.sender, lock.amount);\n                usdvAmount += lock.amount;\n            } else {\n                vader.transfer(msg.sender, lock.amount);\n                vaderAmount += lock.amount;\n            }\n\n            emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setLBTwap(ILiquidityBasedTWAP _lbt) external onlyOwner {\n        require(\n            _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"USDV::initialize: Improper Configuration\"\n        );\n        lbt = _lbt;\n    }\n\n    function setFee(uint256 _exchangeFee) external onlyOwner {\n        require(\n            _exchangeFee <= _MAX_BASIS_POINTS,\n            \"USDV::setFee: Fee Out of Bounds\"\n        );\n        emit ExchangeFeeChanged(exchangeFee, _exchangeFee);\n        exchangeFee = _exchangeFee;\n    }\n\n    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {\n        emit DailyLimitChanged(dailyLimit, _dailyLimit);\n        dailyLimit = _dailyLimit;\n    }\n\n    function setGuardian(address _guardian) external onlyOwner {\n        require(_guardian != address(0), \"USDV::setGuardian: Zero address\");\n        guardian = _guardian;\n    }\n\n    function setLock(bool _lock) external {\n        require(\n            msg.sender == owner() || msg.sender == guardian,\n            \"USDV::setLock: Insufficient Privileges\"\n        );\n        isLocked = _lock;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _createLock(LockTypes lockType, uint256 amount) private {\n        uint256 release = block.timestamp + lbt.maxUpdateWindow();\n\n        locks[msg.sender].push(Lock(lockType, amount, release));\n\n        emit LockCreated(msg.sender, lockType, amount, release);\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyWhenNotLocked() {\n        require(!isLocked);\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\ninterface ILiquidityBasedTWAP {\n    /* ========== STRUCTS ========== */\n\n    struct ExchangePair {\n        uint256 nativeTokenPriceCumulative;\n        FixedPoint.uq112x112 nativeTokenPriceAverage;\n        uint256 lastMeasurement;\n        uint256 updatePeriod;\n        uint256 pastLiquidityEvaluation;\n        address foreignAsset;\n        uint96 foreignUnit;\n    }\n\n    enum Paths {\n        VADER,\n        USDV\n    }\n\n    /* ========== FUNCTIONS ========== */\n\n    function previousPrices(uint256 i) external returns (uint256);\n\n    function maxUpdateWindow() external returns (uint256);\n\n    function getVaderPrice() external returns (uint256);\n\n    function syncVaderPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    function getUSDVPrice() external returns (uint256);\n\n    function syncUSDVPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    /* ========== EVENTS ========== */\n}\n\n\n",
        "CodeNames": [
            "VaderReserve.sol",
            "LiquidityBasedTWAP.sol",
            "USDV.sol",
            "ILiquidityBasedTWAP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction syncVaderPrice()\n    public\n    override\n    returns (\n        uint256[] memory pastLiquidityWeights,\n        uint256 pastTotalLiquidityWeight\n    )\n{\n    uint256 _totalLiquidityWeight;\n    uint256 totalPairs = vaderPairs.length;\n    pastLiquidityWeights = new uint256[(totalPairs);\n    pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n    for (uint256 i; i < totalPairs; ++i) {\n        IUniswapV2Pair pair = vaderPairs[i];\n        ExchangePair storage pairData = twapData[address(pair)];\n        // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp\n        uint256 timeElapsed = block.timestamp pairData.lastMeasurement;\n        // @audit-info update period depends on pair\n        // @audit-issue if update period not reached = does not initialize pastLiquidityWeights[i]\n        if (timeElapsed < pairData.updatePeriod) continue;\n\n        uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n        uint256 currentLiquidityEvaluation = _updateVaderPrice(\n            pair,\n            pairData,\n            timeElapsed\n        );\n\n        pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n        pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n        _totalLiquidityWeight += currentLiquidityEvaluation;\n    }\n\n    totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n}\n"
                ],
                "Type": " Vader TWAP averages wrong",
                "Description": "\nThe vader price in LiquidityBasedTWAP.getVaderPrice is computed using the pastLiquidityWeights and pastTotalLiquidityWeight return values of the syncVaderPrice.\n\nThe syncVaderPrice function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:\n\nsolidity\nfunction syncVaderPrice()\n    public\n    override\n    returns (\n        uint256[] memory pastLiquidityWeights,\n        uint256 pastTotalLiquidityWeight\n    )\n{\n    uint256 _totalLiquidityWeight;\n    uint256 totalPairs = vaderPairs.length;\n    pastLiquidityWeights = new uint256[(totalPairs);\n    pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n    for (uint256 i; i < totalPairs; ++i) {\n        IUniswapV2Pair pair = vaderPairs[i];\n        ExchangePair storage pairData = twapData[address(pair)];\n        // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp\n        uint256 timeElapsed = block.timestamp pairData.lastMeasurement;\n        // @audit-info update period depends on pair\n        // @audit-issue if update period not reached = does not initialize pastLiquidityWeights[i]\n        if (timeElapsed < pairData.updatePeriod) continue;\n\n        uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n        uint256 currentLiquidityEvaluation = _updateVaderPrice(\n            pair,\n            pairData,\n            timeElapsed\n        );\n\n        pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n        pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n        _totalLiquidityWeight += currentLiquidityEvaluation;\n    }\n\n    totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n}\n\n\n\nThis bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert.\nObserve what happens if an attacker calls syncVaderPrice twice in the same block:\n\n*   The first time any pairs that need to be updated are updated\n*   On the second call _totalLiquidityWeight is initialized to zero and all pairs have already been updated and thus skipped. _totalLiquidityWeight never increases and the storage variable totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0; is set to zero.\n*   DoS because calls to getStaleVaderPrice / getVaderPrice will revert in _calculateVaderPrice which divides by totalLiquidityWeight = 0.\n\nAttacker keeps double-calling syncVaderPrice every time an update window of one of the pairs becomes eligible to be updated.\n\n\nThis bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met.\nThis in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.\n\nIt's also possible to always set the totalLiquidityWeight to zero by calling syncVaderPrice twice which in turn reverts all transactions making use of the price because of a division by zero in _caluclateVaderPrice.\nAn attacker can break the USDV.mint minting forever and any router calls to VaderReserve.reimburseImpermanentLoss also fail as they perform a call to the reverting price function.\n\n",
                "Repair": "\nEven if timeElapsed < pairData.updatePeriod, the old pair weight should still contribute to the total liquidity weight and be set in pastLiquidityWeights.\nMove the _totalLiquidityWeight += currentLiquidityEvaluation and the pastLiquidityWeights[i] = pastLiquidityEvaluation assignments before the continue.\n\nSamSteinGG (Vader) confirmed(https://github.com/code-423n4/2021-12-vader-findings/issues/148)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n\n        if (blockTimestampLast < block.timestamp) {\n            uint256 timeElapsed = block.timestamp - blockTimestampLast;\n            unchecked {\n                price0CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveForeign,\n                                pairInfo[foreignAsset].reserveNative\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n                price1CumulativeLast +=\n                    uint256(\n                        FixedPoint\n                            .fraction(\n                                pairInfo[foreignAsset].reserveNative,\n                                pairInfo[foreignAsset].reserveForeign\n                            )\n                            ._x\n                    ) *\n                    timeElapsed;\n            }\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    // NOTE: Loss is in terms of USDV\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setQueue(bool _queueActive) external override onlyOwner {\n        require(\n            _queueActive != queueActive,\n            \"VaderPoolV2::setQueue: Already At Desired State\"\n        );\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(\n        IERC20 foreignAsset,\n        bool support,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override onlyOwner returns (uint256 liquidity) {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n        if (!support) {\n            PairInfo storage pair = pairInfo[foreignAsset];\n            require(\n                pair.reserveNative == 0 && pair.reserveForeign == 0,\n                \"VaderPoolV2::supportToken: Cannot Unsupport Token w/ Liquidity\"\n            );\n        } else {\n            require(\n                nativeDeposit != 0 && foreignDeposit != 0,\n                \"VaderPoolV2::supportToken: Improper First-Time Liquidity Provision\"\n            );\n            liquidity = _mint(\n                foreignAsset,\n                nativeDeposit,\n                foreignDeposit,\n                from,\n                to\n            );\n        }\n    }\n\n    /*\n     * @dev Allows the gas throttle to be toggled on/off in case of emergency\n     **/\n    function setGasThrottle(bool _gasThrottleEnabled)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            gasThrottleEnabled != _gasThrottleEnabled,\n            \"VaderPoolV2::setGasThrottle: Already At Desired State\"\n        );\n        gasThrottleEnabled = _gasThrottleEnabled;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "VaderPoolV"
                ],
                "Type": " LPs of  VaderPoolV2  can manipulate pool reserves to extract funds from the reserve.",
                "Description": "\nImpermanent loss protection can be exploited to drain the reserve.\n\n\nIn VaderPoolV2.burn we calculate the current losses that the LP has made to impermanent loss.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/pool/VaderPoolV2.sol#L265-L296\n\nThese losses are then refunded to the LP in VADER tokens from the reserve.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/router/VaderRouterV2.sol#L220\n\nThis loss is calculated by the current reserves of the pool so if an LP can manipulate the pool's reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex/math/VaderMath.sol#L72-L92\n\nThe attack is then as follows.\n\n1.  Be an LP for a reasonable period of time (IL protection scales linearly up to 100% after a year)\n2.  Flashloan a huge amount of one of the pool's assets.\n3.  Trade against the pool with the flashloaned funds to unbalance it such that your LP position has huge IL.\n4.  Remove your liquidity and receive compensation from the reserve for the IL you have engineered.\n5.  Re-add your liquidity back to the pool.\n6.  Trade against the pool to bring it back into balance.\n\nThe attacker now holds the majority of their flashloaned funds (minus slippage/swap fees) along with a large fraction of the value of their LP position in VADER paid out from the reserve. The value of their LP position is unchanged. Given a large enough LP position, the IL protection funds extracted from the reserve will exceed the funds lost to swap fees and the attacker will be able to repay their flashloan with a profit.\n\nThis is a high risk issue as after a year any large LP is incentivised and able to perform this attack and drain reserve funds.\n\n",
                "Repair": "\nUse a manipulation resistant oracle for the relative prices of the pool's assets (TWAP, etc.)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-12",
                "Location": [],
                "Type": " Using single total native reserve variable for synth and non-synth reserves of  VaderPoolV2  can lead to losses for synth holders",
                "Description": "\nUsers that mint synths do provide native assets, increasing native reserve pool, but do not get any liquidity shares issued.\nIn the same time, an exit of non-synth liquidity provider yields releasing a proportion of all current reserves to him.\n\nWhenever an exit of non-synth LP is substantial enough, the system will have much less native asset regarding the cumulative deposit of synth holders. That is, when a LP entered he provided a share of current reserves, both native and foreign, and got the corresponding liquidity shares in return. Suppose then big enough amounts of synths were minted, providing correspondingly big enough amount of native assets. If the LP now wants to exit, he will obtain a part of total native assets, including a part of the amount that was provided by synth minter. If the exit is big enough there will be substantially less native assets left to reimburse the synth minter than he initially provided. This is not reversible: the synth minters lost their native assets to LP that exited.\n\n\nThere are three types of mint/burn: NFT, fungible and synths. First two get LP shares, the latter gets synths. Whenever NFT or fungible LP exits, it gets a proportion of combined reserves. That is, some of native reserves were deposited by synth minters, but it is not accounted anyhow, only one total reserve number per asset is used.\n\nSuppose the following scenario, Alice wants to provide liquidity, while Bob wants to mint synths:\n\n1.  Alice deposits both sides to a pool, 100 USDV and 100 foreign.\n2.  Bob deposit 100 USDV and mints some foreign Synth.\n3.  LP withdraws 95% of her liquidity shares. As she owns the pool liquidity, she gets 95% of USDV and foreign total reserves, 190 USDV and 95 foreign. Alice received almost all of her and Bob's USDV.\n4.  If Bob burn his synth and withdraw, he will get a tiny fraction of USDV he deposited (calculated by VaderMath.calculateSwap, we use its terms):\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex/math/VaderMath.sol#L98\nx = 100, X = 0.05 * 200 = 10, Y = 0.05 * 100 = 5.\nSwap outcome, how much USDV will Bob get, is x * Y * X / (x + X) ^ 2 = 100 * 5 * 10 / (110^2) = 0.4 (rounded).\n\nThe issue is that synth provided and LP provided USDV aren't accounted separately, total reserves number if used everywhere instead:\n\nSynth minters provide native asset, say USDV, to the system:\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L187\n\nSynth minters get synths and no LP shares, while to account for their deposit, the total USDV balance is increased:\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L187\n\nWhen LP enters, it gets liquidity shares proportionally to current reserves (NFT mint, notice the reserveNative, which is BasePoolV2's pair.reserveNative, total amount of native asset in the Pool):\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L497\n\nWhen LP exits, it gets a proportion of current reserves back (NFT burn):\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L223\n\nThe same happens when fungible LP mints (same reserveNative):\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L336\nAnd burns:\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L401\n\n",
                "Repair": "\nAccount for LP provided liquidity separately from total amount variables, i.e. use only LP provided native reserves variables in LP shares mint and burn calculations.\nThat should suffice as total amount of native assets is still to be used elsewhere, whenever the whole pool is concerned, for example, in rescue function, swap calculations and so forth.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/179)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"./BasePool.sol\";\n\nimport \"../../interfaces/dex/pool/IVaderPool.sol\";\n\n/*\n * @dev Implementation of {VaderPool} contract.\n *\n * The contract VaderPool inherits from {BasePool} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePool` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPool is IVaderPool, BasePool {\n    /* ========== STATE VARIABLES ========== */\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by passing addresses of\n     * native and foreign assets to {BasePool} contract and setting\n     * active status of queue.\n     **/\n    constructor(\n        bool _queueActive,\n        IERC20Extended _nativeAsset,\n        IERC20Extended _foreignAsset\n    ) BasePool(_nativeAsset, _foreignAsset) {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePool} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Ensures only the DAO is able to invoke a particular function by validating that\n     * the owner is the msg.sender, equivalent to the DAO address\n     */\n    function _onlyDAO() private view {\n        require(\n            owner() == _msgSender(),\n            \"BasePool::_onlyDAO: Insufficient Privileges\"\n        );\n    }\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the DAO\n     */\n    modifier onlyDAO() {\n        _onlyDAO();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "BasePool.sol",
            "VaderPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "mintSynth",
                    "foreignAsset",
                    "nativeAsset"
                ],
                "Type": " Redemption value of synths can be manipulated to drain  VaderPoolV2  of all native assets in the associated pair",
                "Description": "\nDraining of funds from VaderPoolV2.\n\n\nSee the VaderPool.mintSynth function:\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex-v2/pool/VaderPoolV2.sol#L153-L194\n\nAs the pool's reserves can be manipulated through flashloans similar to on UniswapV2 (the slip mechanism can be mitigated by splitting the manipulation over a number of trades), an attacker may set the exchange rate between nativeAsset and synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.\n\n1.  The attacker first flashloans and sells a huge amount of foreignAsset to the pool. The pool now thinks nativeAsset is extremely valuable.\n2.  The attacker now uses a relatively small amount of nativeAsset to mint synths using VaderPool.mintSynth. As the pool thinks nativeAsset is very valuable the attacker will receive a huge amount of synths.\n3.  The attacker can now manipulate the pool in the opposite direction by buying up the foreignAsset they sold to the pool. nativeAsset is now back at its normal price, or perhaps artificially low if the attacker wishes.\n4.  The attacker now burns all of their synths. As nativeAsset is considered much less valuable than at the point the synths were minted it takes a lot more of nativeAsset in order to pay out for the burned synths.\n\nFor the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount of nativeAsset from the pool. This process can be repeated as long as it is profitable.\n\n",
                "Repair": "\nTie the exchange rate use for minting/burning synths to a manipulation resistant oracle.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/5)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/shared/IERC20Extended.sol\";\nimport \"../interfaces/tokens/IUSDV.sol\";\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\n// TBD\ncontract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20Extended;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The VADER token used for burns and mints\n    IERC20Extended public immutable vader;\n\n    // The LBT pricing mechanism for the conversion\n    ILiquidityBasedTWAP public lbt;\n\n    // The exchange fee if any applied to burns and mints\n    uint256 public exchangeFee;\n\n    // The 24 hour limit on USDV mints\n    uint256 public dailyLimit = type(uint256).max;\n\n    // The current cycle end timestamp\n    uint256 public cycleTimestamp;\n\n    // The current cycle cumulative mints\n    uint256 public cycleMints;\n\n    // All mint/burn locks\n    mapping(address => Lock[]) public locks;\n\n    // Guardian Account\n    address public guardian;\n\n    // Lock system\n    bool private isLocked;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _vader) ERC20(\"Vader USD\", \"USDV\") {\n        require(\n            _vader != IERC20Extended(_ZERO_ADDRESS),\n            \"USDV::constructor: Improper Configuration\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount - fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n    function claim(uint256 i) external onlyWhenNotLocked returns (uint256) {\n        Lock[] storage userLocks = locks[msg.sender];\n        Lock memory lock = userLocks[i];\n\n        require(lock.release <= block.timestamp, \"USDV::claim: Vesting\");\n\n        uint256 last = userLocks.length - 1;\n        if (i != last) {\n            userLocks[i] = userLocks[last];\n        }\n\n        userLocks.pop();\n\n        if (lock.token == LockTypes.USDV)\n            _transfer(address(this), msg.sender, lock.amount);\n        else vader.transfer(msg.sender, lock.amount);\n\n        emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n\n        return lock.amount;\n    }\n\n    function claimAll()\n        external\n        onlyWhenNotLocked\n        returns (uint256 usdvAmount, uint256 vaderAmount)\n    {\n        Lock[] memory userLocks = locks[msg.sender];\n        delete locks[msg.sender];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock memory lock = userLocks[i];\n\n            require(lock.release <= block.timestamp, \"USDV::claimAll: Vesting\");\n\n            if (lock.token == LockTypes.USDV) {\n                _transfer(address(this), msg.sender, lock.amount);\n                usdvAmount += lock.amount;\n            } else {\n                vader.transfer(msg.sender, lock.amount);\n                vaderAmount += lock.amount;\n            }\n\n            emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setLBTwap(ILiquidityBasedTWAP _lbt) external onlyOwner {\n        require(\n            _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"USDV::initialize: Improper Configuration\"\n        );\n        lbt = _lbt;\n    }\n\n    function setFee(uint256 _exchangeFee) external onlyOwner {\n        require(\n            _exchangeFee <= _MAX_BASIS_POINTS,\n            \"USDV::setFee: Fee Out of Bounds\"\n        );\n        emit ExchangeFeeChanged(exchangeFee, _exchangeFee);\n        exchangeFee = _exchangeFee;\n    }\n\n    function setDailyLimit(uint256 _dailyLimit) external onlyOwner {\n        emit DailyLimitChanged(dailyLimit, _dailyLimit);\n        dailyLimit = _dailyLimit;\n    }\n\n    function setGuardian(address _guardian) external onlyOwner {\n        require(_guardian != address(0), \"USDV::setGuardian: Zero address\");\n        guardian = _guardian;\n    }\n\n    function setLock(bool _lock) external {\n        require(\n            msg.sender == owner() || msg.sender == guardian,\n            \"USDV::setLock: Insufficient Privileges\"\n        );\n        isLocked = _lock;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _createLock(LockTypes lockType, uint256 amount) private {\n        uint256 release = block.timestamp + lbt.maxUpdateWindow();\n\n        locks[msg.sender].push(Lock(lockType, amount, release));\n\n        emit LockCreated(msg.sender, lockType, amount, release);\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyWhenNotLocked() {\n        require(!isLocked);\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "BasePool.sol",
            "LiquidityBasedTWAP.sol",
            "USDV.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "uAmount",
                    "vAmount = (uPrice * uAmount) /",
                    "uAmount = (vPrice * vAmount) /",
                    "vPrice",
                    "USD",
                    "burn",
                    "mint"
                ],
                "Type": "  USDV.sol  Mint and Burn Amounts Are Incorrect",
                "Description": "\nThe USDV.mint function queries the price of Vader from the LiquidityBasedTwap contract. The calculation to determine uAmount in mint is actually performed incorrectly. uAmount = (vPrice * vAmount) / 1e18; will return the USD amount for the provided Vader as vPrice is denominated in USD/Vader. This uAmount is subsequently used when minting tokens for the user (locked for a period of time) and fee to the contract owner.\n\nThis same issue also applies to how vAmount = (uPrice * uAmount) / 1e18; is calculated in USDV.burn.\n\nThis is a severe issue, as the mint and burn functions will always use an incorrect amount of tokens, leading to certain loss by either the protocol (if the user profits) or the user (if the user does not profit).\n\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/tokens/USDV.sol#L66-L98\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/tokens/USDV.sol#L100-L120\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n",
                "Repair": "\nConsider utilising both getVaderPrice and getUSDVPrice when calculating the expected uAmount and vAmount to mint or burn. To calculate uAmount in mint, vPrice should be denominated in USDV/Vader. To calculate vAmount in burn, uPrice should be denominated in Vader/USDV. It would be useful to add unit tests to test this explicitly as it is expected that users will interact with the USDV.sol contract frequently.\n\n0xstormtrooper (Vader) disputed and commented(https://github.com/code-423n4/2021-12-vader-findings/issues/164#issuecomment-1001314244):\n  Mint / burn calculation with USD is intentional, modeled after LUNA / UST.\n \n Mint USDV<br\n 1 USD worth of Vader should mint 1 USDV\n \n Burn USDV<br\n 1 USDV should mint 1 USD worth of Vader\n \n https://docs.terra.money/Concepts/Protocol.html#expansion-and-contraction\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPToken.sol\";\n\ncontract LPToken is ILPToken, ProtocolConstants, ERC20, Ownable {\n    IERC20Extended public immutable foreignAsset;\n    IVaderPoolV2 public immutable pool;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _foreignAsset, IVaderPoolV2 _pool)\n        ERC20(\"VADER-V1\", _calculateSymbol(_foreignAsset))\n    {\n        foreignAsset = _foreignAsset;\n        pool = _pool;\n        transferOwnership(address(_pool));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() public view override returns (uint256) {\n        return pool.pairSupply(foreignAsset);\n    }\n\n    function balanceOf(address user) public view override returns (uint256) {\n        if (user == address(pool)) return totalSupply() - ERC20.totalSupply();\n        else return ERC20.balanceOf(user);\n    }\n\n    function _calculateSymbol(IERC20Extended token)\n        internal\n        view\n        returns (string memory)\n    {\n        return _combine(\"V(\", token.symbol(), \"|USDV)\");\n    }\n\n    function _combine(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return _combine(a, b, \"\");\n    }\n\n    function _combine(\n        string memory a,\n        string memory b,\n        string memory c\n    ) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c));\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(uint256 amount) external onlyOwner {\n        _burn(msg.sender, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\ninterface ILiquidityBasedTWAP {\n    /* ========== STRUCTS ========== */\n\n    struct ExchangePair {\n        uint256 nativeTokenPriceCumulative;\n        FixedPoint.uq112x112 nativeTokenPriceAverage;\n        uint256 lastMeasurement;\n        uint256 updatePeriod;\n        uint256 pastLiquidityEvaluation;\n        address foreignAsset;\n        uint96 foreignUnit;\n    }\n\n    enum Paths {\n        VADER,\n        USDV\n    }\n\n    /* ========== FUNCTIONS ========== */\n\n    function previousPrices(uint256 i) external returns (uint256);\n\n    function maxUpdateWindow() external returns (uint256);\n\n    function getVaderPrice() external returns (uint256);\n\n    function syncVaderPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    function getUSDVPrice() external returns (uint256);\n\n    function syncUSDVPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    /* ========== EVENTS ========== */\n}\n\n\n",
        "CodeNames": [
            "LPToken.sol",
            "LiquidityBasedTWAP.sol",
            "ILiquidityBasedTWAP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "previousPrices",
                    "currentLiquidityEvaluation",
                    "VADER",
                    "syncVaderPrice",
                    "setupVader"
                ],
                "Type": "  previousPrices  Is Never Updated Upon Syncing Token Price",
                "Description": "\nThe LiquidityBasedTWAP contract attempts to accurately track the price of VADER and USDV while still being resistant to flash loan manipulation and short-term volatility. The previousPrices array is meant to track the last queried price for the two available paths, namely VADER and USDV.\n\nThe setupVader function configures the VADER token by setting previousPrices and adding a token pair. However, syncVaderPrice does not update previousPrices after syncing, causing currentLiquidityEvaluation to be dependent on the initial price for VADER. As a result, liquidity weightings do not accurately reflect the current and most up to date price for VADER.\n\nThis same issue also affects how USDV calculates currentLiquidityEvaluation.\n\nThis issue is of high risk and heavily impacts the accuracy of the TWAP implementation as the set price for VADER/USDV diverges from current market prices. For example, as the Chainlink oracle price and initial price for VADER diverge, currentLiquidityEvaluation will begin to favour either on-chain or off-chain price data depending on which price result is greater. The following calculation for currentLiquidityEvaluation outlines this behaviour.\n\n    currentLiquidityEvaluation =\n        (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n        (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L150-L189\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221-L235\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n",
                "Repair": "\nConsider updating previousPrices[uint256(Paths.VADER)] and previousPrices[uint256(Paths.USDV)] after syncing the respective prices for the two tokens. This will ensure the most up to date price is used when evaluating liquidity for all available token pairs.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/103)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPToken.sol\";\n\ncontract LPToken is ILPToken, ProtocolConstants, ERC20, Ownable {\n    IERC20Extended public immutable foreignAsset;\n    IVaderPoolV2 public immutable pool;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20Extended _foreignAsset, IVaderPoolV2 _pool)\n        ERC20(\"VADER-V1\", _calculateSymbol(_foreignAsset))\n    {\n        foreignAsset = _foreignAsset;\n        pool = _pool;\n        transferOwnership(address(_pool));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() public view override returns (uint256) {\n        return pool.pairSupply(foreignAsset);\n    }\n\n    function balanceOf(address user) public view override returns (uint256) {\n        if (user == address(pool)) return totalSupply() - ERC20.totalSupply();\n        else return ERC20.balanceOf(user);\n    }\n\n    function _calculateSymbol(IERC20Extended token)\n        internal\n        view\n        returns (string memory)\n    {\n        return _combine(\"V(\", token.symbol(), \"|USDV)\");\n    }\n\n    function _combine(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return _combine(a, b, \"\");\n    }\n\n    function _combine(\n        string memory a,\n        string memory b,\n        string memory c\n    ) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b, c));\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(uint256 amount) external onlyOwner {\n        _burn(msg.sender, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"../../external/libraries/FixedPoint.sol\";\n\ninterface ILiquidityBasedTWAP {\n    /* ========== STRUCTS ========== */\n\n    struct ExchangePair {\n        uint256 nativeTokenPriceCumulative;\n        FixedPoint.uq112x112 nativeTokenPriceAverage;\n        uint256 lastMeasurement;\n        uint256 updatePeriod;\n        uint256 pastLiquidityEvaluation;\n        address foreignAsset;\n        uint96 foreignUnit;\n    }\n\n    enum Paths {\n        VADER,\n        USDV\n    }\n\n    /* ========== FUNCTIONS ========== */\n\n    function previousPrices(uint256 i) external returns (uint256);\n\n    function maxUpdateWindow() external returns (uint256);\n\n    function getVaderPrice() external returns (uint256);\n\n    function syncVaderPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    function getUSDVPrice() external returns (uint256);\n\n    function syncUSDVPrice()\n        external\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        );\n\n    /* ========== EVENTS ========== */\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"./BasePool.sol\";\n\nimport \"../../interfaces/dex/pool/IVaderPool.sol\";\n\n/*\n * @dev Implementation of {VaderPool} contract.\n *\n * The contract VaderPool inherits from {BasePool} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePool` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPool is IVaderPool, BasePool {\n    /* ========== STATE VARIABLES ========== */\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by passing addresses of\n     * native and foreign assets to {BasePool} contract and setting\n     * active status of queue.\n     **/\n    constructor(\n        bool _queueActive,\n        IERC20Extended _nativeAsset,\n        IERC20Extended _foreignAsset\n    ) BasePool(_nativeAsset, _foreignAsset) {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePool} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Ensures only the DAO is able to invoke a particular function by validating that\n     * the owner is the msg.sender, equivalent to the DAO address\n     */\n    function _onlyDAO() private view {\n        require(\n            owner() == _msgSender(),\n            \"BasePool::_onlyDAO: Insufficient Privileges\"\n        );\n    }\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the DAO\n     */\n    modifier onlyDAO() {\n        _onlyDAO();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "LPToken.sol",
            "LiquidityBasedTWAP.sol",
            "ILiquidityBasedTWAP.sol",
            "VaderPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "_addVaderPair",
                    "pastLiquidityWeights",
                    "onlyOwner",
                    "getVaderPrice",
                    "VADER",
                    "pastTotalLiquidityWeight = totalLiquidityWeight[uint",
                    "pastTotalLiquidityWeight",
                    "totalLiquidityWeight",
                    "pairLiquidityEvaluation",
                    "syncVaderPrice",
                    "twapData",
                    "getUSDVPrice"
                ],
                "Type": "  totalLiquidityWeight  Is Updated When Adding New Token Pairs Which Skews Price Data For  getVaderPrice  and  getUSDVPrice ",
                "Description": "\nThe _addVaderPair function is called by the onlyOwner role. The relevant data in the twapData mapping is set by querying the respective liquidity pool and Chainlink oracle. totalLiquidityWeight for the VADER path is also incremented by the pairLiquidityEvaluation amount (calculated within _addVaderPair). If a user then calls syncVaderPrice, the recently updated totalLiquidityWeight will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in pastTotalLiquidityWeight and pastLiquidityWeights respectively.\n\nAs a result, newly added token pairs will increase pastTotalLiquidityWeight while leaving pastLiquidityWeights underrepresented. This only occurs if syncVaderPrice is called before the update period for the new token has not been passed.\n\nThis issue also affects how the price for USDV is synced.\n\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n<https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[(totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\nAs shown above, pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)] loads in the total liquidity weight which is updated when _addVaderPair is called. However, pastLiquidityWeights is calculated by iterating through each token pair that is eligible to be updated.\n\n",
                "Repair": "\nConsider removing the line totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation; in _addVaderPair so that newly added tokens do not impact upcoming queries for VADER/USDV price data. This should ensure syncVaderPrice and syncUSDVPrice cannot be manipulated when adding new tokens.\n\nSamSteinGG (Vader) confirmed(https://github.com/code-423n4/2021-12-vader-findings/issues/105)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/governance/ITimelock.sol\";\nimport \"../interfaces/x-vader/IXVader.sol\";\n\n/**\n * @dev Implementation of {GovernorAlpha} contract.\n *\n * The GovernorAlpha contract allows creation of proposals by anyone\n * by depositing xVader (1000 xVader initially).\n *\n * Anyone can vote on the created proposals utilizing their xVader weight in\n * xVader contract.\n *\n * Only 1 proposal can be active at a time by a particular proposer.\n *\n * A proposal is queued when it succeeds and can be executed after a cool-off\n * time period specified by {delay} in the Timelock contract.\n *\n * A proposal can be cancelled by a {guardian} if it has not been already\n * executed.\n *\n * A proposal can be vetoed by {council} while its state is active/pending\n * and a proposal vetoed with success is also queued at the same time.\n */\ncontract GovernorAlpha {\n    // The name of this contract\n    string public constant NAME = \"Vader Governor Alpha\";\n\n    // The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n    // The delay before voting on a proposal may take place, once proposed\n    uint256 public constant VOTING_DELAY = 1;\n\n    // The duration of voting on a proposal, in blocks\n    uint256 public immutable VOTING_PERIOD;\n\n    // The address of the Vader Protocol Timelock\n    ITimelock public timelock;\n\n    // The address of the Governor Guardian\n    address public guardian;\n\n    // The total number of proposals\n    uint256 public proposalCount;\n\n    // address of xVader token\n    IXVader public immutable xVader;\n\n    // address of fee receiver\n    address public feeReceiver;\n\n    // amount of fee deducted when proposing proposal\n    uint256 public feeAmount;\n\n    // address of council that is allowed to veto on proposals\n    address public council;\n\n    /**\n     * @dev {Proposal} struct contains parameters for a single proposal.\n     * id: Unique id for looking up a proposal.\n     * canceled: Flag marking whether the proposal has been canceled.\n     * executed: Flag marking whether the proposal has been executed.\n     * proposer: Creator of the proposal\n     * eta: The timestamp that the proposal will be available for execution, set once the vote succeeds\n     * targets: the ordered list of target addresses for calls to be made\n     * values: The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n     * signatures: The ordered list of function signatures to be called\n     * calldatas: The ordered list of calldata to be passed to each call\n     * startBlock: startBlock: The block at which voting begins: holders must delegate their votes prior to this block\n     * endBlock: The block at which voting ends: votes must be cast prior to this block\n     * forVotes: Current number of votes in favor of this proposal\n     * againstVotes: Current number of votes in opposition to this proposal\n     * vetoStatus: Veto status if the proposal has been vetoed by council in favor or against\n     // C4-Audit Fix for Issue # 141\n     * receipts: Receipts of ballots for the entire set of voters\n     */\n    struct Proposal {\n        uint256 id;\n        bool canceled;\n        bool executed;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint224 forVotes;\n        uint224 againstVotes;\n        VetoStatus vetoStatus;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev {Receipt} struct contains parameters for a voter against a particular proposal\n     * and is a ballot receipt record for a voter.\n     *\n     * hasVoted: Whether or not a vote has been casted\n     * support: Whether or not the voter supports the proposal\n     * votes: The number of votes the voter had, which were cast\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint224 votes;\n    }\n\n    /**\n     * @dev {VetoStatus} contains parameters representing if a proposal has been vetoed by council\n     *\n     * hasBeenVetoed: Whether proposal has been vetoed or not\n     // C4-Audit Fix for Issue # 142\n     * support: Whether veto is in favor of or against proposal\n     */\n    struct VetoStatus {\n        bool hasBeenVetoed;\n        bool support;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    // The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    // The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    // The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    // An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    // An event emitted when a vote has been cast on a proposal\n    event VoteCast(\n        address voter,\n        uint256 proposalId,\n        bool support,\n        uint256 votes\n    );\n\n    // An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    // An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // An event emitted when fee receiver is changed\n    event FeeReceiverChanged(address oldFeeReceiver, address newFeeReceiver);\n\n    // An event emitted when fee amount is changed\n    event FeeAmountChanged(uint256 oldFeeAmount, uint256 newFeeAmount);\n\n    // An event emitted when a proposal has been vetoed by the council\n    event ProposalVetoed(uint256 proposalId, bool support);\n\n    // An event emitted when council is changed\n    event CouncilChanged(address oldCouncil, address newCouncil);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Initializes the contract's state setting xVader, fee receiver,\n     * council and guardian addresses along with the fee amount.\n     *\n     * It performs sanity checks for the address type parameters against zero\n     * address values.\n     */\n    constructor(\n        address guardian_,\n        address xVader_,\n        address feeReceiver_,\n        uint256 feeAmount_,\n        address council_,\n        uint256 votingPeriod_\n    ) {\n        require(\n            xVader_ != address(0),\n            \"GovernorAlpha::constructor: xVader address is zero\"\n        );\n\n        require(\n            guardian_ != address(0) &&\n                feeReceiver_ != address(0) &&\n                council_ != address(0),\n            \"GovernorAlpha::constructor: guardian, feeReceiver or council cannot be zero\"\n        );\n\n        guardian = guardian_;\n        xVader = IXVader(xVader_);\n        feeReceiver = feeReceiver_;\n        feeAmount = feeAmount_;\n        council = council_;\n\n        VOTING_PERIOD = votingPeriod_ == 0\n            ? 17280 // ~3 days in blocks (assuming 15s blocks)\n            : votingPeriod_;\n\n        emit FeeReceiverChanged(address(0), feeReceiver_);\n        emit FeeAmountChanged(0, feeAmount_);\n    }\n\n    /* ========== VIEWS ========== */\n\n    // The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes(uint256 blockNumber) public view returns (uint256) {\n        return (xVader.getPastTotalSupply(blockNumber) * 4) / 100; // 4% of xVader's supply at the time of proposal creation.\n    }\n\n    /**\n     * @dev Returns the actions contained in a proposal with id {proposalId}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @dev Returns receipt of the {voter} against the proposal with id {proposalId}.\n     */\n    function getReceipt(uint256 proposalId, address voter)\n        public\n        view\n        returns (Receipt memory)\n    {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev Returns the current state of the proposal with id {proposalId}.\n     *\n     * Requirements:\n     * - The {proposalId} should be greater than 0\n     * - The {proposalId} should be less than or equal to {proposalCount}\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) return ProposalState.Canceled;\n\n        if (proposal.vetoStatus.hasBeenVetoed) {\n            // proposal has been vetoed\n            uint256 _eta = proposal.eta;\n\n            // proposal has been vetoed in favor, so considered succeeded\n            if (proposal.vetoStatus.support && _eta == 0)\n                return ProposalState.Succeeded;\n\n            // proposal has been vetoed against, so considered defeated\n            if (_eta == 0) return ProposalState.Defeated;\n        } else {\n            // proposal has not been vetoed, normal flow ensues\n            if (block.number <= proposal.startBlock)\n                return ProposalState.Pending;\n\n            if (block.number <= proposal.endBlock) return ProposalState.Active;\n\n            if (\n                proposal.forVotes <= proposal.againstVotes ||\n                proposal.forVotes < quorumVotes(proposal.startBlock)\n            ) return ProposalState.Defeated;\n\n            if (proposal.eta == 0) return ProposalState.Succeeded;\n        }\n\n        if (proposal.executed) return ProposalState.Executed;\n\n        // C4-Audit Fix for Issue # 177\n        unchecked {\n            if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD())\n                return ProposalState.Expired;\n        }\n\n        return ProposalState.Queued;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Sets timelock state variable. Contracts {GovernorAlpha} and\n     * {Timelock} have circular dependencies upon each other and constructors\n     * cannot be used to set them, hence this function is introduced to set\n     * {Timelock} in {GovernorAlpha} after it has been deployed.\n     *\n     * Requirements:\n     * - only guardian can call this function\n     */\n    function setTimelock(address _timelock) external onlyGuardian {\n        require(\n            _timelock != address(0),\n            \"GovernorAlpha::initTimelock: _timelock cannot be zero address\"\n        );\n        timelock = ITimelock(_timelock);\n    }\n\n    /**\n     * @dev Allows any to make a proposal by depositing {feeAmount} xVader.\n     * It accepts targets along with the values, signature and calldatas\n     * for the actions to perform if the proposal succeeds.\n     *\n     * Requirements:\n     * - targets, values, signatures and calldatas arrays' lengths must be greater\n     // C4-Audit Fix for Issue # 141\n     *   than zero, less than or equal to {proposalMaxOperations} and are the same lengths.\n     * - the caller must approve {feeAmount} xVader to this contract prior to call.\n     * - the caller must not have an active/pending proposal.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256 proposalId) {\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(\n            targets.length != 0,\n            \"GovernorAlpha::propose: must provide actions\"\n        );\n        require(\n            targets.length <= PROPOSAL_MAX_OPERATIONS,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        xVader.transferFrom(msg.sender, feeReceiver, feeAmount);\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(\n                latestProposalId\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        // C4-Audit Fix for Issue # 177\n        uint256 startBlock;\n        uint256 endBlock;\n        unchecked {\n            startBlock = block.number + VOTING_DELAY;\n            endBlock = startBlock + VOTING_PERIOD;\n        }\n\n        proposalId = ++proposalCount;\n        Proposal storage newProposal = proposals[proposalId];\n        newProposal.id = proposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n\n        latestProposalIds[msg.sender] = proposalId;\n\n        emit ProposalCreated(\n            proposalId,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n    }\n\n    /**\n     * @dev Queues a proposal by setting the hashes of its actions in {Timelock} contract.\n     * It also determines 'eta' for the proposal by adding timestamp to {delay} in {Timelock}\n     * and sets it against the proposal in question.\n     *\n     * Requirements:\n     * - the proposal in question must have succeeded either through majority for-votes\n     *   or has been vetoed in its favour.\n     */\n    function queue(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        // C4-Audit Fix for Issue # 177\n        uint256 eta;\n        unchecked{\n            eta = block.timestamp + timelock.delay();\n        }\n\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    /**\n     * @dev Executes a proposal after it has been queued and cool-off time has elapsed.\n     * It sets the {executed} status of the proposal to 'true'.\n     *\n     * Requirements:\n     // C4-Audit Fix for Issue # 142\n     * - the proposal in question must have been queued and cool-off time has elapsed\n     * - none of the actions of the proposal revert upon execution\n     */\n    function execute(uint256 proposalId) public payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @dev Casts vote by {msg.sender}.\n     * It calls the internal function `_castVote` to perform vote casting.\n     */\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /**\n     * @dev Called by a relayer to cast vote by a message signer.\n     *\n     * Requirements:\n     * - {signatory} retrieved must not be a zero address\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(NAME)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(BALLOT_TYPEHASH, proposalId, support)\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(\n            signatory != address(0),\n            \"GovernorAlpha::castVoteBySig: invalid signature\"\n        );\n\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @dev Changes the {feeReceiver}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeReceiver(address feeReceiver_) external onlyGuardian {\n        emit FeeReceiverChanged(feeReceiver, feeReceiver_);\n        feeReceiver = feeReceiver_;\n    }\n\n    /**\n     * @dev Changes the {feeAmount}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeAmount(uint256 feeAmount_) external onlyGuardian {\n        emit FeeAmountChanged(feeAmount, feeAmount_);\n        feeAmount = feeAmount_;\n    }\n\n    // C4-Audit Fix for Issue # 142\n    /**\n     * @dev Allows vetoing of a proposal in favor or against it.\n     * It also queues a proposal if it has been vetoed in favor of it and.\n     * sets the veto status of the proposal.\n     *\n     * Requirements:\n     * - can only be called by {council}\n     * - proposal being vetoed must be active or pending\n     * - none of the actions in proposal being vetoed point to the contract\n     *   itself. This to restrict council from vetoing a proposal intended\n     *   to change council.\n     */\n    function veto(uint256 proposalId, bool support) external onlyCouncil {\n        ProposalState _state = state(proposalId);\n        require(\n            _state == ProposalState.Active || _state == ProposalState.Pending,\n            \"GovernorAlpha::veto: Proposal can only be vetoed when active\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        address[] memory _targets = proposal.targets;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < _targets.length; ++i) {\n            if (_targets[i] == address(this)) {\n                // C4-Audit Fix for Issue # 167\n                bytes memory callData = proposal.calldatas[i];\n                bytes4 sig;\n                assembly {\n                    sig := mload(add(callData, 0x20))\n                }\n                require(\n                    sig != this.changeCouncil.selector,\n                    \"GovernorAlpha::veto: council cannot veto a council changing proposal\"\n                );\n            }\n        }\n\n        VetoStatus storage _vetoStatus = proposal.vetoStatus;\n        _vetoStatus.hasBeenVetoed = true;\n        _vetoStatus.support = support;\n\n        if (support) {\n            queue(proposalId);\n        }\n\n        emit ProposalVetoed(proposalId, support);\n    }\n\n    /**\n     * @dev Changes the {council}.\n     *\n     * Requirements:\n     // C4-Audit Fix for Issue # 142\n     * - can only be called by {Timelock} contract through a non-vetoable proposal\n     */\n    function changeCouncil(address council_) external onlyTimelock {\n        emit CouncilChanged(council, council_);\n        council = council_;\n    }\n\n    /**\n     * @dev Cancels the proposal with id {proposalId}.\n     * It also sets the {canceled} property of {Proposal} to `true` and\n     * removes the proposal's corresponding actions from {Timelock} contract.\n     *\n     * Requirements:\n     * - proposal must not be already executed\n     */\n    function cancel(uint256 proposalId) public onlyGuardian {\n        ProposalState _state = state(proposalId);\n        require(\n            _state != ProposalState.Executed,\n            \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        proposal.canceled = true;\n        uint256 length = proposal.targets.length;\n        // C4-Audit Fix for Issue # 81\n        for (uint256 i = 0; i < length; ++i) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @dev Calls {acceptAdmin} on {Timelock} contract and makes the current contract\n     * the admin of {Timelock} contract.\n     *\n     * Requirements:\n     * - only guardian can call it\n     * - current contract must be the `pendingAdmin` in {Timelock} contract\n     */\n    function __acceptAdmin() public onlyGuardian {\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * @dev Gives up the guardian role associated with the contract.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __abdicate() public onlyGuardian {\n        guardian = address(0);\n    }\n\n    /**\n     * @dev Queues the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __queueSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.queueTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /**\n     * @dev Executes the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __executeSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.executeTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev Queues a transaction in {Timelock}.\n     *\n     * Requirements:\n     * - transaction is not already queued in {Timelock}\n     */\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(target, value, signature, data, eta))\n            ),\n            \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @dev Casts vote against proposal with id {proposalId}.\n     * It gets the voting weight of voter from {xVader} token contract corresponding to\n     * the blocknumber when proposal started and adds those votes to either\n     * {forVotes} or {againstVotes} property of {Proposal} depending upon if\n     * the voter is voting in favor of or against the proposal.\n     *\n     * Requirements:\n     * - proposal being voted must be active\n     * - voter has not already voted against the proposal\n     */\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(\n            !receipt.hasVoted,\n            \"GovernorAlpha::_castVote: voter already voted\"\n        );\n\n        // optimistically casting to uint224 as xVader contract performs the checks for\n        // votes to not overflow uint224.\n        uint224 votes = uint224(\n            xVader.getPastVotes(voter, proposal.startBlock)\n        );\n\n        // C4-Audit Fix for Issue # 177\n        unchecked {\n            if (support) {\n                proposal.forVotes = proposal.forVotes + votes;\n            } else {\n                proposal.againstVotes = proposal.againstVotes + votes;\n            }\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    // gets the chainid from current network\n    function getChainId() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n    // C4-Audit Fix for Issue # 142\n    // ensures only {guardian} is able to call a particular function.\n    function _onlyGuardian() private view {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::_onlyGuardian: only guardian can call\"\n        );\n    }\n\n    // C4-Audit Fix for Issue # 142\n    // ensures only {timelock} is able to call a particular function.\n    function _onlyTimelock() private view {\n        require(\n            msg.sender == address(timelock),\n            \"GovernorAlpha::_onlyTimelock: only timelock can call\"\n        );\n    }\n\n    // C4-Audit Fix for Issue # 142\n    // ensures only {council} is able to call a particular function.\n    function _onlyCouncil() private view {\n        require(\n            msg.sender == council,\n            \"GovernorAlpha::_onlyCouncil: only council can call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {guardian}\n     */\n    modifier onlyGuardian() {\n        _onlyGuardian();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {timelock}\n     */\n    modifier onlyTimelock() {\n        _onlyTimelock();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {council}\n     */\n    modifier onlyCouncil() {\n        _onlyCouncil();\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol",
            "BasePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-13",
                "Location": [
                    "calldata",
                    "signatures",
                    "veto",
                    "changeCouncil"
                ],
                "Type": " Council veto protection does not work",
                "Description": "\nCouncil can veto proposals to remove them to remain in power.\n\n\nThe Vader governance contract has the concept of a \"council\" which can unilaterally accept or reject a proposal. To prevent a malicious council preventing itself from being replaced by the token holders, the veto function checks the calldata for any proposal action directed at GovernorAlpha to see if it matches the changeCouncil function selector.\n\nNote this is done by reading from the proposal.calldatas array.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/governance/GovernorAlpha.sol#L568-L603\n\nIf we look at the structure of a proposal however we can see that the function selector is held (in the form of the signature) in the signatures array rather than being included in the calldata. The calldata array then holds just the function arguments for the call rather than specifying which function to call.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/governance/GovernorAlpha.sol#L71-L72\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/governance/GovernorAlpha.sol#L356-L362\n\nIndeed if we look at the TimeLock contract we see that the signature is hashed to calculate the function selector and is prepended onto the calldata.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/governance/Timelock.sol#L292-L299\n\nLooking at the function signature of the changeCouncil we can see that the value that the veto function will check against this.changeCouncil.signature will be the first 4 bytes of an abi encoded address and so will always be zero no matter what function is being called.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/governance/GovernorAlpha.sol#L623\n\nHigh risk as this issue gives the council absolute control over the DAO such that they cannot be removed.\n\n",
                "Repair": "\nHash the function signatures to calculate function selectors and then check those rather than the calldata.\n\nThis is something that should be picked up by a test suite however, I'd recommend writing tests to ensure that protections you add to the code have any affect and more broadly check that the code behaves as expected.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/44)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n",
        "CodeNames": [
            "BasePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "foreignAsset"
                ],
                "Type": " Adding pair of the same  foreignAsset  would replace oracle of earlier entry",
                "Description": "\nOracles are mapped to the foreignAsset but not to the specific pair. Pairs with the same foreignAsset (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.\n\n\n<https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271\n\n            oracles[foreignAsset] = oracle;\n\n",
                "Repair": "\nBind the oracle to pair instead\n\nSamSteinGG (Vader) confirmed(https://github.com/code-423n4/2021-12-vader-findings/issues/160)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/external/chainlink/IAggregator.sol\";\n\ncontract GasThrottle is ProtocolConstants {\n    bool public gasThrottleEnabled = true;\n\n    modifier validateGas() {\n        // TODO: Uncomment prior to launch\n        // require(\n        //     gasThrottleEnabled &&\n        //         (block.basefee <= tx.gasprice &&\n        //             tx.gasprice <=\n        //             uint256(IAggregator(_FAST_GAS_ORACLE).latestAnswer())),\n        //     \"GasThrottle::validateGas: Gas Exceeds Thresholds\"\n        // );\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n",
        "CodeNames": [
            "GasThrottle.sol",
            "BasePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "validateGas",
                    "_FAST_GAS_ORACLE"
                ],
                "Type": " No way to remove  GasThrottle  from  VaderPool  after deployment",
                "Description": "\nPotential DOS on swaps on VaderPool.\n\n\nBasePool makes use of a validateGas modifier on swaps which checks that the user's gas price is below the value returned by _FAST_GAS_ORACLE.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex/pool/BasePool.sol#L292\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/dex/utils/GasThrottle.sol#L8-L22\n\nShould  _FAST_GAS_ORACLE be compromised to always return zero then all swaps will fail. There is no way to recover from this scenario.\n\n",
                "Repair": "\nEither remove GasThrottle.sol entirely or allow governance to turn it off as is done in VaderPoolV2.sol\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getStaleVaderPrice() external view returns (uint256) {\n        uint256 totalPairs = vaderPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.VADER)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(vaderPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function getStaleUSDVPrice() external view returns (uint256) {\n        uint256 totalPairs = usdvPairs.length;\n        uint256[] memory pastLiquidityWeights = new uint256[](totalPairs);\n        uint256 pastTotalLiquidityWeight = totalLiquidityWeight[\n            uint256(Paths.USDV)\n        ];\n\n        for (uint256 i; i < totalPairs; ++i)\n            pastLiquidityWeights[i] = twapData[address(usdvPairs[i])]\n                .pastLiquidityEvaluation;\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function getChainlinkPrice(address asset) public view returns (uint256) {\n        IAggregatorV3 oracle = oracles[asset];\n\n        (uint80 roundID, int256 price, , , uint80 answeredInRound) = oracle\n            .latestRoundData();\n\n        require(\n            answeredInRound >= roundID,\n            \"LBTWAP::getChainlinkPrice: Stale Chainlink Price\"\n        );\n\n        require(price > 0, \"LBTWAP::getChainlinkPrice: Chainlink Malfunction\");\n\n        return uint256(price);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function getVaderPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncVaderPrice();\n\n        return\n            _calculateVaderPrice(\n                pastLiquidityWeights,\n                pastTotalLiquidityWeight\n            );\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n\n    function _calculateVaderPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalVaderLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalVader;\n        uint256 totalPairs = vaderPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n\n            uint256 foreignPrice = getChainlinkPrice(pairData.foreignAsset);\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n\n            totalVader +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalVaderLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalVader;\n    }\n\n    function setupVader(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 vaderPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] == 0,\n            \"LBTWAP::setupVader: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.VADER)] = vaderPrice;\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.VADER)] != 0,\n            \"LBTWAP::addVaderPair: Vader Uninitialized\"\n        );\n\n        _addVaderPair(pair, oracle, updatePeriod);\n    }\n\n    function _addVaderPair(\n        IUniswapV2Pair pair,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addVaderPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");\n\n        ExchangePair storage pairData = twapData[address(pair)];\n\n        bool isFirst = pair.token0() == vader;\n\n        (address nativeAsset, address foreignAsset) = isFirst\n            ? (pair.token0(), pair.token1())\n            : (pair.token1(), pair.token0());\n\n        oracles[foreignAsset] = oracle;\n\n        require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");\n\n        pairData.foreignAsset = foreignAsset;\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(foreignAsset).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        pairData.nativeTokenPriceCumulative = isFirst\n            ? pair.price0CumulativeLast()\n            : pair.price1CumulativeLast();\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(foreignAsset));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;\n\n        vaderPairs.push(pair);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n\n    function getUSDVPrice() external returns (uint256) {\n        (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        ) = syncUSDVPrice();\n\n        return\n            _calculateUSDVPrice(pastLiquidityWeights, pastTotalLiquidityWeight);\n    }\n\n    function syncUSDVPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = usdvPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.USDV)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateUSDVPrice(\n                foreignAsset,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.USDV)] = _totalLiquidityWeight;\n    }\n\n    function _updateUSDVPrice(\n        IERC20 foreignAsset,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        (\n            uint256 nativeTokenPriceCumulative,\n            ,\n            uint256 currentMeasurement\n        ) = vaderPool.cumulativePrices(foreignAsset);\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n    }\n\n    function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }\n\n    function setupUSDV(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod,\n        uint256 usdvPrice\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] == 0,\n            \"LBTWAP::setupUSDV: Already Initialized\"\n        );\n\n        previousPrices[uint256(Paths.USDV)] = usdvPrice;\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    // NOTE: Discuss whether minimum paired liquidity value should be enforced at code level\n    function addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) external onlyOwner {\n        require(\n            previousPrices[uint256(Paths.USDV)] != 0,\n            \"LBTWAP::addUSDVPair: USDV Uninitialized\"\n        );\n\n        _addUSDVPair(foreignAsset, oracle, updatePeriod);\n    }\n\n    function _addUSDVPair(\n        IERC20 foreignAsset,\n        IAggregatorV3 oracle,\n        uint256 updatePeriod\n    ) internal {\n        require(\n            updatePeriod != 0,\n            \"LBTWAP::addUSDVPair: Incorrect Update Period\"\n        );\n\n        require(oracle.decimals() == 8, \"LBTWAP::addUSDVPair: Non-USD Oracle\");\n\n        oracles[address(foreignAsset)] = oracle;\n\n        ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n        // NOTE: Redundant\n        // pairData.foreignAsset = foreignAsset;\n\n        pairData.foreignUnit = uint96(\n            10**uint256(IERC20Metadata(address(foreignAsset)).decimals())\n        );\n\n        pairData.updatePeriod = updatePeriod;\n        pairData.lastMeasurement = block.timestamp;\n\n        (uint256 nativeTokenPriceCumulative, , ) = vaderPool.cumulativePrices(\n            foreignAsset\n        );\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        (uint256 reserveNative, uint256 reserveForeign, ) = vaderPool\n            .getReserves(foreignAsset);\n\n        uint256 pairLiquidityEvaluation = (reserveNative *\n            previousPrices[uint256(Paths.USDV)]) +\n            (reserveForeign * getChainlinkPrice(address(foreignAsset)));\n\n        pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;\n\n        totalLiquidityWeight[uint256(Paths.USDV)] += pairLiquidityEvaluation;\n\n        usdvPairs.push(foreignAsset);\n\n        if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nlibrary VaderMath {\n    /* ========== CONSTANTS ========== */\n\n    uint256 public constant ONE = 1 ether;\n\n    /* ========== LIBRARY FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the amount of liquidity units for the {vaderDeposited}\n     * and {assetDeposited} amounts across {totalPoolUnits}.\n     *\n     * The {vaderBalance} and {assetBalance} are taken into account in order to\n     * calculate any necessary slippage adjustment.\n     */\n    function calculateLiquidityUnits(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance,\n        uint256 totalPoolUnits\n    ) internal pure returns (uint256) {\n        // slipAdjustment\n        uint256 slip = calculateSlipAdjustment(\n            vaderDeposited,\n            vaderBalance,\n            assetDeposited,\n            assetBalance\n        );\n\n        // (Va + vA)\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\n            (vaderDeposited * assetBalance);\n\n        // 2VA\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\n\n        // P * [(Va + vA) / (2 * V * A)] * slipAdjustment\n        return ((totalPoolUnits * poolUnitFactor) / denominator) * slip;\n    }\n\n    /**\n     * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}\n     * amounts across the total {vaderBalance} and {assetBalance} amounts.\n     */\n    function calculateSlipAdjustment(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance\n    ) internal pure returns (uint256) {\n        // Va\n        uint256 vaderAsset = vaderBalance * assetDeposited;\n\n        // aV\n        uint256 assetVader = assetBalance * vaderDeposited;\n\n        // (v + V) * (a + A)\n        uint256 denominator = (vaderDeposited + vaderBalance) *\n            (assetDeposited + assetBalance);\n\n        // 1 - [|Va - aV| / (v + V) * (a + A)]\n        return ONE - (delta(vaderAsset, assetVader) / denominator);\n    }\n\n    /**\n     * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}\n     * compared to the supplied {originalVader} and {originalAsset}.\n     */\n    function calculateLoss(\n        uint256 originalVader,\n        uint256 originalAsset,\n        uint256 releasedVader,\n        uint256 releasedAsset\n    ) internal pure returns (uint256 loss) {\n        //\n        // TODO: Vader Formula Differs https://github.com/vetherasset/vaderprotocol-contracts/blob/main/contracts/Utils.sol#L347-L356\n        //\n\n        // [(A0 * P1) + V0]\n        uint256 originalValue = ((originalAsset * releasedVader) /\n            releasedAsset) + originalVader;\n\n        // [(A1 * P1) + V1]\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\n            releasedAsset) + releasedVader;\n\n        // [(A0 * P1) + V0] - [(A1 * P1) + V1]\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\n    }\n\n    /**\n     * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}\n     * across the supplied {reserveIn} and {reserveOut} amounts.\n     */\n    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}\n     * across the supplied {reserveIn} and {reserveOut} amounts.\n     */\n    function calculateSwapReverse(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        // X * Y\n        uint256 XY = reserveIn * reserveOut;\n\n        // 2y\n        uint256 y2 = amountOut * 2;\n\n        // 4y\n        uint256 y4 = y2 * 2;\n\n        require(\n            y4 < reserveOut,\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1/4 of Liquidity Pool)\"\n        );\n\n        // root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\n\n        // X * (2y - Y)    =>    2yX - XY\n        uint256 numeratorB = y2 * reserveIn;\n        uint256 numeratorC = XY;\n\n        // -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\n\n        // 2y\n        uint256 denominator = y2;\n\n        amountIn = numerator / denominator;\n    }\n\n    /**\n     * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.\n     */\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n     * @dev Calculates the power of 2 of the supplied {a} value.\n     */\n    function pow(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n\n    /**\n     * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:\n     * https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n     */\n    function root(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 x = a / 2 + 1;\n            while (x < c) {\n                c = x;\n                x = (a / x + x) / 2;\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\ninterface IVaderReserve {\n    /* ========== STRUCTS ========== */\n    /* ========== FUNCTIONS ========== */\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external;\n\n    function grant(address recipient, uint256 amount) external;\n\n    function reserve() external view returns (uint256);\n\n    /* ========== EVENTS ========== */\n\n    event GrantDistributed(address recipient, uint256 amount);\n    event LossCovered(address recipient, uint256 amount, uint256 actualAmount);\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityBasedTWAP.sol",
            "VaderMath.sol",
            "IVaderReserve.sol",
            "VaderReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "reimburseImpermanentLoss",
                    "recipient",
                    "amount / usdvPrice",
                    "amount",
                    "usdvPrice"
                ],
                "Type": "  VaderReserve.reimburseImpermanentLoss  improperly converts USDV to VADER",
                "Description": "\nIL isn't properly converted from being in terms of USDV to VADER, resulting in reserve paying out incorrect amount.\n\n\nVaderReserve.reimburseImpermanentLoss receives an amount in terms of USDV and converts this to an amount of VADER to send to recipient.\n\nHowever as shown in the link if there is a previous price stored for USDV, the amount of VADER tokens to be sent to the recipient is amount / usdvPrice.\n\n<https://github.com/code-423n4/2021-12-vader/blob/fd2787013608438beae361ce1bb6d9ffba466c45/contracts/reserve/VaderReserve.sol#L84-L110\n\nusdvPrice is the total USD value of foreign assets divided by the total amount of USDV in a number of pairs. It's then some measure of the inverse of the price of USDV in USD, nothing to do with converting into VADER.\n\nThe reserve will then improperly calculate the amount of VADER to pay out once there is a single reading of the USDV price.\n\n",
                "Repair": "\nIt looks like both branches of this if statement are supposed to be run, i.e. convert from USDV to USD and then to VADER but I can't be sure. Care should be taken so that the calculation being performed is the expected one.\n\nSamSteinGG (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/7)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\ninterface IConverter {\n    /* ========== FUNCTIONS ========== */\n\n    function convert(bytes32[] calldata proof, uint256 amount, uint256 minVader)\n        external\n        returns (uint256 vaderReceived);\n\n    /* ========== EVENTS ========== */\n\n    event Conversion(\n        address indexed user,\n        uint256 vetherAmount,\n        uint256 vaderAmount\n    );\n}\n\n\n// SPDX-License-Identifier: MIT AND AGPL-3.0-or-later\npragma solidity =0.8.9;\n\nlibrary VaderMath {\n    /* ========== CONSTANTS ========== */\n\n    uint256 public constant ONE = 1 ether;\n\n    /* ========== LIBRARY FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the amount of liquidity units for the {vaderDeposited}\n     * and {assetDeposited} amounts across {totalPoolUnits}.\n     *\n     * The {vaderBalance} and {assetBalance} are taken into account in order to\n     * calculate any necessary slippage adjustment.\n     */\n    function calculateLiquidityUnits(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance,\n        uint256 totalPoolUnits\n    ) internal pure returns (uint256) {\n        // slipAdjustment\n        uint256 slip = calculateSlipAdjustment(\n            vaderDeposited,\n            vaderBalance,\n            assetDeposited,\n            assetBalance\n        );\n\n        // (Va + vA)\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\n            (vaderDeposited * assetBalance);\n\n        // 2VA\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\n\n        // P * [(Va + vA) / (2 * V * A)] * slipAdjustment\n        return ((totalPoolUnits * poolUnitFactor) / denominator) * slip;\n    }\n\n    /**\n     * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}\n     * amounts across the total {vaderBalance} and {assetBalance} amounts.\n     */\n    function calculateSlipAdjustment(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance\n    ) internal pure returns (uint256) {\n        // Va\n        uint256 vaderAsset = vaderBalance * assetDeposited;\n\n        // aV\n        uint256 assetVader = assetBalance * vaderDeposited;\n\n        // (v + V) * (a + A)\n        uint256 denominator = (vaderDeposited + vaderBalance) *\n            (assetDeposited + assetBalance);\n\n        // 1 - [|Va - aV| / (v + V) * (a + A)]\n        return ONE - (delta(vaderAsset, assetVader) / denominator);\n    }\n\n    /**\n     * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}\n     * compared to the supplied {originalVader} and {originalAsset}.\n     */\n    function calculateLoss(\n        uint256 originalVader,\n        uint256 originalAsset,\n        uint256 releasedVader,\n        uint256 releasedAsset\n    ) internal pure returns (uint256 loss) {\n        //\n        // TODO: Vader Formula Differs https://github.com/vetherasset/vaderprotocol-contracts/blob/main/contracts/Utils.sol#L347-L356\n        //\n\n        // [(A0 * P1) + V0]\n        uint256 originalValue = ((originalAsset * releasedVader) /\n            releasedAsset) + originalVader;\n\n        // [(A1 * P1) + V1]\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\n            releasedAsset) + releasedVader;\n\n        // [(A0 * P1) + V0] - [(A1 * P1) + V1]\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\n    }\n\n    /**\n     * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}\n     * across the supplied {reserveIn} and {reserveOut} amounts.\n     */\n    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}\n     * across the supplied {reserveIn} and {reserveOut} amounts.\n     */\n    function calculateSwapReverse(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        // X * Y\n        uint256 XY = reserveIn * reserveOut;\n\n        // 2y\n        uint256 y2 = amountOut * 2;\n\n        // 4y\n        uint256 y4 = y2 * 2;\n\n        require(\n            y4 < reserveOut,\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1/4 of Liquidity Pool)\"\n        );\n\n        // root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\n\n        // X * (2y - Y)    =>    2yX - XY\n        uint256 numeratorB = y2 * reserveIn;\n        uint256 numeratorC = XY;\n\n        // -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\n\n        // 2y\n        uint256 denominator = y2;\n\n        amountIn = numerator / denominator;\n    }\n\n    /**\n     * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.\n     */\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n     * @dev Calculates the power of 2 of the supplied {a} value.\n     */\n    function pow(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n\n    /**\n     * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:\n     * https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n     */\n    function root(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 x = a / 2 + 1;\n            while (x < c) {\n                c = x;\n                x = (a / x + x) / 2;\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "IConverter.sol",
            "VaderMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "amount",
                    "minVader"
                ],
                "Type": " Users can lock themselves out of being able to convert VETH, becoming stuck with the deprecated asset",
                "Description": "\nI've put this as a medium issue as we're leaking value as users are stuck with assets which are likely to be worth much less as they are deprecated. It could also be low as it's not exploitable by outside parties and the loss isn't taken by the protocol but the user.\n\n\nPotential for users to lose the right to convert VETH to VADER, being stuck with a deprecated token.\n\n\nShould a user have a zero allowance of VETH on the converter, no VETH will be taken and no VADER will be paid out as L147 will set the amount to zero.\n\n<https://github.com/code-423n4/2021-12-vader/blob/28d3405447f0c3353964ca755a42562840d151c5/contracts/tokens/converter/Converter.sol#L145-L150\n\nThere is a minVader check on L153 to enforce a minimum output of VADER but should this be improperly set the transaction would succeed with the user receiving much less VADER than they expect.\n\nCrucially, the merkle proof that was used in this transaction will be marked as invalid so the user will not be able to try again once they have set the proper allowance. Someone can then lose the opportunity to convert their VETH and are left with a worthless deprecated token if they are inattentive.\n\nIt seems like this is trying to handle the case where a user doesn't have the full amount of VETH as they are entitled to convert (by setting their allowance equal to their balance?). This is a pretty suboptimal way to go about this as it's extremely implicit so users are liable to make mistakes.\n\nI'd recommend decoupling the merkle proof from conversion of VETH to VADER:\n\n1.  Change the merkle proof to set an amountEligibleToConvert value in storage for each user (which would be initially set to amount).\n2.  Allow a user to then convert VETH to VADER up to their amountEligibleToConvert value, subtracting the amount converted from this each time.\n\nFor gas efficiency we can use a sentinel value here to mark a user which has claimed their full quota already distinctly from someone who hasn't provided a merkle proof yet (to avoid having to track this separately in another storage slot)\n\nThese two steps could be chained in a single transaction to give a similar UX as currently but would also allow users to recover in the case of partial conversions.\n\n",
                "Repair": "\nAs above. I'd caution against just stating \"The frontend will handle this correctly so this isn't an issue\", there will be users who interact with the contract manually so it's important to make the interface safe where possible.\n\n0xstormtrooper (Vader) acknowledged(https://github.com/code-423n4/2021-12-vader-findings/issues/97)\n\n\n\n*\n\n\n"
            }
        ]
    }
]