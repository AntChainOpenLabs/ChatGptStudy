[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal \u2014 i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}\n\n\n",
        "CodeNames": [
            "Governance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "GRACE_PERIOD",
                    "activateProposal()"
                ],
                "Type": " In  Governance.sol , it might be impossible to activate a new proposal forever after failed to execute the previous active proposal.",
                "Description": "\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221<br\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L302-L304\n\nCurrently, if users vote for the active proposal, the VOTES are transferred to the contract so that users can't vote or endorse other proposals while the voted proposal is active.\n\nAnd the active proposal can be replaced only when the proposal is executed successfully or another proposal is activated after GRACE_PERIOD.\n\nBut activateProposal() requires at least 20% endorsements here(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221), so it might be impossible to activate a new proposal forever if the current active proposal involves more than 80% of total votes.\n\n\nThe below scenario would be possible.\n\n1.  Proposal 1 was submitted and activated successfully.\n2.  Let's assume 81% of the total votes voted for this proposal. Yes = 47%, No = 34%\n3.  This proposal can't be executed for this requirement(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268-L270) because 47% 34% = 13% < 33%.\n4.  Currently the contract contains more than 81% of total votes and users have at most 19% in total.\n5.  Also users can't reclaim their votes among 81% while Proposal 1 is active.\n6.  So even if a user who has 1% votes submits a new proposal, it's impossible to activate because of this require()(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L216-L221).\n7.  So it's impossible to delete Proposal 1 from an active proposal and there won't be other active proposal forever.\n\n\nSolidity Visual Developer of VSCode\n\n",
                "Repair": "\nI think we should add one more constant like EXECUTION_EXPIRE = 2 weeks so that voters can reclaim their votes after this period even if the proposal is active.\n\nI am not sure we can use the current GRACE_PERIOD for that purpose.\n\nSo reclaimVotes() should be modified like below.\n\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_EXPIRE) //+++++++++++++++++++++++++++++++++\n            {\n                revert CannotReclaimTokensForActiveVote();\n            }\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n\nfullyallocated (Olympus) confirmed(https://github.com/code-423n4/2022-08-olympus-findings/issues/376)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal \u2014 i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {UserFactory} from \"test/lib/UserFactory.sol\";\n\nimport \"./mocks/KernelTestMocks.sol\";\nimport \"src/Kernel.sol\";\n\ncontract KernelTest is Test {\n    Kernel internal kernel;\n    MockPolicy internal policy;\n    MockModule internal MOCKY;\n\n    address public deployer;\n    address public multisig;\n    address public user;\n    UserFactory public userFactory;\n\n    bytes public err;\n    MockPolicy internal policyTest;\n\n    function setUp() public {\n        userFactory = new UserFactory();\n        address[] memory users = userFactory.create(3);\n        deployer = users[0];\n        multisig = users[1];\n        user = users[2];\n\n        vm.startPrank(deployer);\n        kernel = new Kernel();\n        MOCKY = new MockModule(kernel);\n        policy = new MockPolicy(kernel);\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_InitializeKernel() public {\n        Keycode keycode = Keycode.wrap(0);\n\n        assertEq(kernel.admin(), deployer);\n        assertEq(kernel.executor(), deployer);\n        assertEq(kernel.modulePermissions(keycode, policy, bytes4(0)), false);\n        assertEq(address(kernel.getModuleForKeycode(keycode)), address(0));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), bytes5(0));\n\n        // Ensure actions cannot be performed by unauthorized addresses\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"executor\"), address(deployer));\n        //kernel.revokeRole(deployer);\n    }\n\n    function testCorrectness_EnsureContract() public {\n        ensureContract(address(kernel));\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(deployer));\n        vm.expectRevert(err);\n        ensureContract(deployer);\n\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", address(0));\n        vm.expectRevert(err);\n        ensureContract(address(0));\n    }\n\n    function testCorrectness_EnsureValidKeycode() public {\n        ensureValidKeycode(Keycode.wrap(\"VALID\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"inval\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(\"inval\"));\n\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"\"));\n        vm.expectRevert(err);\n        ensureValidKeycode(Keycode.wrap(bytes5(\"\")));\n    }\n\n    function testCorrectness_EnsureValidRole() public {\n        ensureValidRole(Role.wrap(\"valid\"));\n\n        err = abi.encodeWithSignature(\"InvalidRole(bytes32)\", Role.wrap(\"INVALID_ID\"));\n        vm.expectRevert(err);\n        ensureValidRole(Role.wrap(bytes32(\"INVALID_ID\")));\n    }\n\n    function testCorrectness_GrantRole() public {\n        // Ensure role doesn't exist yet\n        assertFalse(kernel.isRole(Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.prank(deployer);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        assertTrue(kernel.isRole(Role.wrap(\"tester\")));\n        assertTrue(kernel.hasRole(multisig, Role.wrap(\"tester\")));\n    }\n\n    function testCorrectness_RevokeRole() public {\n        Role testerRole = toRole(\"tester\");\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, deployer);\n\n        // TODO test role not existing\n\n        vm.startPrank(deployer);\n        kernel.grantRole(testerRole, multisig);\n        assertTrue(kernel.hasRole(multisig, testerRole));\n\n        kernel.revokeRole(testerRole, multisig);\n        assertFalse(kernel.hasRole(multisig, testerRole));\n\n        err = abi.encodeWithSelector(Kernel_AddressDoesNotHaveRole.selector, multisig, testerRole);\n        vm.expectRevert(err);\n        kernel.revokeRole(testerRole, multisig);\n    }\n\n    function testCorrectness_InitializeModule() public {\n        assertEq(Keycode.unwrap(MOCKY.KEYCODE()), \"MOCKY\");\n        assertEq(MOCKY.publicState(), 0);\n        assertEq(MOCKY.permissionedState(), 0);\n    }\n\n    function testCorrectness_InstallModule() public {\n        vm.startPrank(deployer);\n\n        // Ensure module is installed properly\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        assertEq(address(kernel.getModuleForKeycode(Keycode.wrap(\"MOCKY\"))), address(MOCKY));\n        assertEq(Keycode.unwrap(kernel.getKeycodeForModule(MOCKY)), \"MOCKY\");\n\n        // Try installing an EOA as a module\n        err = abi.encodeWithSignature(\"TargetNotAContract(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, deployer);\n\n        // Try installing module with a bad keycode\n        Module invalidModule = new InvalidMockModule(kernel);\n        err = abi.encodeWithSignature(\"InvalidKeycode(bytes5)\", Keycode.wrap(\"badkc\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(invalidModule));\n\n        // Try installing MOCKY again\n        err = abi.encodeWithSignature(\n            \"Kernel_ModuleAlreadyInstalled(bytes5)\",\n            Keycode.wrap(\"MOCKY\")\n        );\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        vm.stopPrank();\n    }\n\n    function testCorrectness_ActivatePolicy() public {\n        Keycode testKeycode = Keycode.wrap(\"MOCKY\");\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Policy_ModuleDoesNotExist(bytes5)\", testKeycode);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        _initModuleAndPolicy();\n\n        assertEq(\n            kernel.modulePermissions(testKeycode, policy, MOCKY.permissionedCall.selector),\n            true\n        );\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        uint256 depIndex = kernel.getDependentIndex(testKeycode, policy);\n        Policy[] memory dependencies = new Policy[](1);\n        dependencies[0] = policy;\n        assertEq(address(kernel.moduleDependents(testKeycode, depIndex)), address(dependencies[0]));\n\n        vm.prank(deployer);\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n    }\n\n    function testCorrectness_PolicyPermissions() public {\n        _initModuleAndPolicy();\n        Permissions[] memory permissions = policy.requestPermissions();\n\n        assertEq(Keycode.unwrap(permissions[0].keycode), \"MOCKY\");\n        assertEq(permissions[0].funcSelector, MOCKY.permissionedCall.selector);\n    }\n\n    function testCorrectness_CallPublicPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        vm.prank(deployer);\n        policy.callPublicFunction();\n\n        assertEq(MOCKY.publicState(), 1);\n    }\n\n    function testCorrectness_CallPermissionedPolicyFunction() public {\n        _initModuleAndPolicy();\n\n        // Test role-based auth for policy calls\n        Role testerRole = Role.wrap(\"tester\");\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        kernel.grantRole(testerRole, multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n        assertEq(MOCKY.permissionedState(), 1);\n\n        vm.prank(deployer);\n        kernel.revokeRole(testerRole, multisig);\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", testerRole);\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_DeactivatePolicy() public {\n        vm.startPrank(deployer);\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        err = abi.encodeWithSignature(\"Kernel_PolicyAlreadyActivated(address)\", address(policy));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        kernel.executeAction(Actions.DeactivatePolicy, address(policy));\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        err = abi.encodeWithSignature(\"Module_PolicyNotPermitted(address)\", address(policy));\n        vm.expectRevert(err);\n        policy.callPermissionedFunction();\n\n        assertEq(\n            kernel.modulePermissions(\n                Keycode.wrap(\"MOCKY\"),\n                policy,\n                MOCKY.permissionedCall.selector\n            ),\n            false\n        );\n        vm.expectRevert();\n        assertEq(address(kernel.activePolicies(0)), address(0));\n    }\n\n    function testCorrectness_UpgradeModule() public {\n        UpgradedMockModule upgradedModule = new UpgradedMockModule(kernel, MOCKY);\n\n        vm.startPrank(deployer);\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n\n        err = abi.encodeWithSignature(\"Kernel_InvalidModuleUpgrade(bytes5)\", Keycode.wrap(\"MOCKY\"));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.UpgradeModule, address(MOCKY));\n\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(MOCKY.permissionedState(), 1);\n\n        // Upgrade MOCKY\n        vm.prank(deployer);\n        kernel.executeAction(Actions.UpgradeModule, address(upgradedModule));\n\n        // check state is reset\n        assertEq(upgradedModule.permissionedState(), 1);\n\n        // check if permissions persist\n        vm.prank(multisig);\n        policy.callPermissionedFunction();\n\n        assertEq(upgradedModule.permissionedState(), 2);\n    }\n\n    function testCorrectness_ChangeExecutor() public {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", deployer);\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.stopPrank();\n\n        vm.prank(multisig);\n        kernel.executeAction(Actions.ChangeExecutor, address(deployer));\n\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.ChangeExecutor, address(multisig));\n    }\n\n    function testCorrectness_ChangeAdmin() public {\n        err = abi.encodeWithSignature(\"Kernel_OnlyExecutor(address)\", address(this));\n        vm.expectRevert(err);\n        kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n\n        vm.startPrank(deployer);\n\n        {\n            kernel.executeAction(Actions.InstallModule, address(MOCKY));\n            kernel.executeAction(Actions.ActivatePolicy, address(policy));\n            kernel.executeAction(Actions.ChangeAdmin, address(multisig));\n            vm.stopPrank();\n        }\n\n        vm.prank(multisig);\n\n        kernel.grantRole(Role.wrap(\"tester\"), user);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n\n        vm.prank(deployer);\n        kernel.executeAction(Actions.ChangeAdmin, address(user));\n\n        vm.startPrank(multisig);\n        err = abi.encodeWithSignature(\"Kernel_OnlyAdmin(address)\", multisig);\n        vm.expectRevert(err);\n        kernel.grantRole(Role.wrap(\"tester\"), multisig);\n        vm.stopPrank();\n\n        vm.prank(user);\n        kernel.revokeRole(Role.wrap(\"tester\"), user);\n        assertFalse(kernel.hasRole(user, Role.wrap(\"tester\")));\n\n        err = abi.encodeWithSignature(\"Policy_OnlyRole(bytes32)\", Role.wrap(\"tester\"));\n        vm.expectRevert(err);\n        vm.prank(user);\n        policy.callPermissionedFunction();\n    }\n\n    function testCorrectness_MigrateKernel() public {\n        _initModuleAndPolicy();\n\n        assertEq(address(kernel.getModuleForKeycode(kernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(kernel.activePolicies(0)), address(policy));\n\n        vm.startPrank(deployer);\n\n        // Create new kernel and migrate to it\n        Kernel newKernel = new Kernel();\n\n        kernel.executeAction(Actions.MigrateKernel, address(newKernel));\n\n        assertEq(address(MOCKY.kernel()), address(newKernel));\n        assertEq(address(policy.kernel()), address(newKernel));\n\n        // Install module and approve policy\n        newKernel.executeAction(Actions.InstallModule, address(MOCKY));\n        newKernel.executeAction(Actions.ActivatePolicy, address(policy));\n\n        assertEq(address(newKernel.getModuleForKeycode(newKernel.allKeycodes(0))), address(MOCKY));\n        assertEq(address(newKernel.activePolicies(0)), address(policy));\n    }\n\n    function _initModuleAndPolicy() internal {\n        vm.startPrank(deployer);\n        kernel.executeAction(Actions.InstallModule, address(MOCKY));\n        kernel.executeAction(Actions.ActivatePolicy, address(policy));\n        vm.stopPrank();\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}\n\n\n",
        "CodeNames": [
            "Governance.sol",
            "Kernel.t.sol",
            "Kernel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n    function test_AttackerPassesProposalBeforeMinting() public {\n\n        address[] memory users = userCreator.create(1);\n        address attacker = users[0];\n        vm.prank(attacker);\n        MockMalicious attackerControlledContract = new MockMalicious();\n\n        Instruction[] memory instructions_ = new Instruction[(2);\n        instructions_[0] = Instruction(Actions.ChangeAdmin, address(attackerControlledContract));\n        instructions_[1] = Instruction(Actions.ChangeExecutor, address(attackerControlledContract));\n\n        vm.prank(attacker);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n        \n        governance.endorseProposal(1);\n        \n        vm.prank(attacker);\n        governance.activateProposal(1);\n        \n        vm.warp(block.timestamp + 3 days + 1);\n        \n        governance.executeProposal();\n\n        assert(kernel.executor()==address(attackerControlledContract));\n        assert(kernel.admin()==address(attackerControlledContract));\n\n\n    }\n",
                    "//solidity\ncontract MockMalicious {}\n\n"
                ],
                "Type": " Anyone can pass any proposal alone before first  VOTES  are minted",
                "Description": "\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164<br\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-L218<br\n<https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268\n\nBefore any VOTES are minted anyone can activate and execute an arbitrary proposal even with 0 votes cast. So an attacker can pass any proposal (i.e. change the executor + admin of the Kernel, gaining access to all permissioned functions and to funds held).\n\n\nChecks on vote numbers made in Governance.sol at lines L164(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164), 217-218(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L217-218), 268(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L268) pass if VOTES.totalSupply() == 0. So, until no VOTES are minted, anyone can submit, activate and execute a proposal. There is no need to own or cast votes. This happens if OlympusGovernance is granted the executor role before any VOTES are minted (as in Governance.t.sol(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol)). The attacker can anticipate/frontrun the minting and pass a proposal to change both the Kernel admin and executor. Then he/she can upgrade malicious modules, steal funds from treasury...\n\nA PoC was obtained modifying the setUp() of Governance.t.sol(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol) by keeping only what is before the minting of VOTES (up to L83(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/test/policies/Governance.t.sol#L83) included). The test is as follows:\n\nsolidity\n    function test_AttackerPassesProposalBeforeMinting() public {\n\n        address[] memory users = userCreator.create(1);\n        address attacker = users[0];\n        vm.prank(attacker);\n        MockMalicious attackerControlledContract = new MockMalicious();\n\n        Instruction[] memory instructions_ = new Instruction[(2);\n        instructions_[0] = Instruction(Actions.ChangeAdmin, address(attackerControlledContract));\n        instructions_[1] = Instruction(Actions.ChangeExecutor, address(attackerControlledContract));\n\n        vm.prank(attacker);\n        governance.submitProposal(instructions_, \"proposalName\", \"This is the proposal URI\");\n        \n        governance.endorseProposal(1);\n        \n        vm.prank(attacker);\n        governance.activateProposal(1);\n        \n        vm.warp(block.timestamp + 3 days + 1);\n        \n        governance.executeProposal();\n\n        assert(kernel.executor()==address(attackerControlledContract));\n        assert(kernel.admin()==address(attackerControlledContract));\n\n\n    }\n\n\nwith\n\nsolidity\ncontract MockMalicious {}\n\n\n\n",
                "Repair": "\nIn Governance.sol check for a minimum VOTES totalSupply, similiar to the expected initial supply of VOTES when they have been fairly distributed, for example at line L164(https://github.com/code-423n4/2022-08-olympus/blob/2a0b515012b4a40076f6eac487f7816aafb8724a/src/policies/Governance.sol#L164).\n\nfullyallocated (Olympus) acknowledged(https://github.com/code-423n4/2022-08-olympus-findings/issues/392)\n\n0xean (judge) commented(https://github.com/code-423n4/2022-08-olympus-findings/issues/392#issuecomment-1249926401):\n  Leaving as High severity as this shows a clear path to loss of funds.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror TRSRY_NotApproved();\nerror TRSRY_NoDebtOutstanding();\n\n/// @notice Treasury holds reserves, LP tokens and all other assets under the control\n///         of the protocol.\ncontract OlympusTreasury is Module, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    event ApprovedForWithdrawal(address indexed policy_, ERC20 indexed token_, uint256 amount_);\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"TRSRY\");\n    }\n\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getReserveBalance(ERC20 token_) external view returns (uint256) {\n        return token_.balanceOf(address(this)) + totalDebt[token_];\n    }\n\n    /// @notice Sets approval for specific withdrawer addresses\n    function setApprovalFor(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external permissioned {\n        withdrawApproval[withdrawer_][token_] = amount_;\n\n        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n    }\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) public {\n        _checkApproval(msg.sender, token_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n\n        emit Withdrawal(msg.sender, to_, token_, amount_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             DEBT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pre-approved policies can get a loan to perform operations on treasury assets.\n    function getLoan(ERC20 token_, uint256 amount_) external permissioned {\n        _checkApproval(msg.sender, token_, amount_);\n\n        // Add debt to caller\n        reserveDebt[token_][msg.sender] += amount_;\n        totalDebt[token_] += amount_;\n\n        token_.safeTransfer(msg.sender, amount_);\n\n        emit DebtIncurred(token_, msg.sender, amount_);\n    }\n\n    /// @notice Lets an address with debt repay their loan.\n    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n\n        // Deposit from caller first (to handle nonstandard token transfers)\n        uint256 prevBalance = token_.balanceOf(address(this));\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 received = token_.balanceOf(address(this)) - prevBalance;\n\n        // Subtract debt from caller\n        reserveDebt[token_][msg.sender] -= received;\n        totalDebt[token_] -= received;\n\n        emit DebtRepaid(token_, msg.sender, received);\n    }\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external permissioned {\n        uint256 oldDebt = reserveDebt[token_][debtor_];\n\n        reserveDebt[token_][debtor_] = amount_;\n\n        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\n        else totalDebt[token_] -= oldDebt - amount_;\n\n        emit DebtSet(token_, debtor_, amount_);\n    }\n\n    function _checkApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) internal {\n        // Must be approved\n        uint256 approval = withdrawApproval[withdrawer_][token_];\n        if (approval < amount_) revert TRSRY_NotApproved();\n\n        // Check for infinite approval\n        if (approval != type(uint256).max) {\n            unchecked {\n                withdrawApproval[withdrawer_][token_] = approval - amount_;\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "TRSRY.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n// modules/TRSRY.sol\n\n 63     /// @notice Sets approval for specific withdrawer addresses\n 64     function setApprovalFor(\n 65         address withdrawer_,\n 66         ERC20 token_,\n 67         uint256 amount_\n 68     ) external permissioned {\n 69         withdrawApproval[withdrawer_][token_] = amount_;\n 70\n 71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n 72     }\n",
                    "//solidity\n 41\n 42     function grantApproval(\n 43         address for_,\n 44         ERC20 token_,\n 45         uint256 amount_\n 46     ) external onlyRole(\"custodian\") {\n 47         TRSRY.setApprovalFor(for_, token_, amount_);\n 48     }\n"
                ],
                "Type": " TRSRY: front-runnable  setApprovalFor ",
                "Description": "\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L64-L72<br\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L42-L48\n\nAn attacker may be able to withdraw more than intended\n\n\nLet's say Alice had approval of 100. Now the treasury custodian reduced the approval to 50. Alice could frontrun the setApprovalFor of 50, and withdraw 100 as it was before. Then withdraw 50 with the newly set approval. So the alice could withdraw 150.\n\nsolidity\n// modules/TRSRY.sol\n\n 63     /// @notice Sets approval for specific withdrawer addresses\n 64     function setApprovalFor(\n 65         address withdrawer_,\n 66         ERC20 token_,\n 67         uint256 amount_\n 68     ) external permissioned {\n 69         withdrawApproval[withdrawer_][token_] = amount_;\n 70\n 71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n 72     }\n\n\nThe TreasuryCustodian simply calls the setApprovalFor to grant Approval.\n\nsolidity\n 41\n 42     function grantApproval(\n 43         address for_,\n 44         ERC20 token_,\n 45         uint256 amount_\n 46     ) external onlyRole(\"custodian\") {\n 47         TRSRY.setApprovalFor(for_, token_, amount_);\n 48     }\n\n\n",
                "Repair": "\nInstead of setting the given amount, one can reduce from the current approval. By doing so, it checks whether the previous approval is spend.\n\nind-igo (Olympus) confirmed and commented(https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1238901986):\n  Understood. Will change the logic to increase/decrease allowances.\n\n0xean (judge) increased severity to High and commented(https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1249816020):\n  I think this vulnerability should be a high severity as it opens up the possibility of a direct loss of funds in the amount of up to the previous approval amount. Upgrading to High. \n\n0xean (judge) commented(https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1250385243):\n  @ind-igo Not sure if you deleted your comment, but that context is useful.  Happy to take another look here. \n\nind-igo (Olympus) commented(https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1251369022):\n  I did, I just thought it was unnecessary to evaluate the issue. I was just saying that the context of the code is that it is not intended to be used to approve an EOA/multisig, but instead used to approve governance-voted contracts to access treasury funds, in order to deposit into yield contracts or whatever. But I don't think it's very relevant to this, as the code is still faulty and exploitable in an extreme case. I already have made this remediation as well, so all good.\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]