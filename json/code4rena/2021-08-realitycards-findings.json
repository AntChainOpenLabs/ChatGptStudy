[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\n\n/// @title Reality Cards Orderbook\n/// @author Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCOrderbook is NativeMetaTransaction, IRCOrderbook {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev a record of a users single bid.\n    /// @dev now declared in the interface, left here for reference\n    // struct Bid {\n    //     address market;\n    //     address next;\n    //     address prev;\n    //     uint64 card;\n    //     uint128 price;\n    //     uint64 timeHeldLimit;\n    // }\n\n    /// @dev maps a user address to an array of their bids\n    mapping(address => Bid[]) public user;\n    /// @dev index of a bid record in the user array, User|Market|Token->Index\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public\n        override index;\n\n    /// @dev record of market specific variables\n    struct Market {\n        uint64 mode;\n        uint64 cardCount;\n        uint64 minimumPriceIncreasePercent;\n        uint64 minimumRentalDuration;\n    }\n    /// @dev map a market address to a market record\n    mapping(address => Market) public market;\n    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner\n    mapping(address => mapping(uint256 => address)) public override ownerOf;\n    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner\n    mapping(address => mapping(uint256 => address)) public oldOwner;\n    mapping(address => mapping(uint256 => uint256)) public oldPrice;\n    /// @dev an array of closed markets, used to reduce user bid rates\n    address[] public override closedMarkets;\n    /// @dev how far through the array a given user is, saves iterating the whole array every time.\n    mapping(address => uint256) public override userClosedMarketIndex;\n\n    ///// GOVERNANCE VARIABLES /////\n    /// @dev the current treasury\n    IRCTreasury public override treasury;\n    /// @dev max number of searches to place an order in the book\n    /// @dev current estimates place limit around 2000 but 1000 is sufficient\n    uint256 public override maxSearchIterations = 1000;\n    /// @dev max number of records to delete in one transaction\n    uint256 public override maxDeletions = 70;\n    /// @dev number of bids a user should clean when placing a new bid\n    uint256 public override cleaningLoops = 2;\n    /// @dev max number of market records to put into the waste pile in one go\n    uint256 public override marketCloseLimit = 70;\n    /// @dev nonce emitted with orderbook insertions, for frontend sorting\n    uint256 public override nonce;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          MODIFIERS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice only allow markets to call certain functions\n    modifier onlyMarkets() {\n        require(\n            treasury.checkPermission(MARKET, msgSender()),\n            \"Not authorised\"\n        );\n        _;\n    }\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    modifier onlyFactory() {\n        require(\n            treasury.checkPermission(FACTORY, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToOrderbook(\n        address indexed newOwner,\n        uint256 indexed newPrice,\n        uint256 timeHeldLimit,\n        uint256 nonce,\n        uint256 indexed tokenId,\n        address market\n    );\n    /// @dev emitted when an order is removed from the orderbook\n    event LogRemoveFromOrderbook(\n        address indexed owner,\n        address indexed market,\n        uint256 indexed tokenId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(IRCTreasury _treasury) {\n        treasury = _treasury;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         GOVERNANCE              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function setTreasuryAddress(address _newTreasury)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newTreasury != address(0));\n        treasury = IRCTreasury(_newTreasury);\n    }\n\n    function setDeletionLimit(uint256 _deletionLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxDeletions = _deletionLimit;\n    }\n\n    function setCleaningLimit(uint256 _cleaningLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        cleaningLoops = _cleaningLimit;\n    }\n\n    function setSearchLimit(uint256 _searchLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxSearchIterations = _searchLimit;\n    }\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        marketCloseLimit = _marketCloseLimit;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             INSERTIONS              \u2551\n      \u2551 functions that add to the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the orderbook\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _minIncrease\n    ) internal {\n        market[_market].cardCount = SafeCast.toUint64(_cardCount);\n        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(\n            _minIncrease\n        );\n        market[_market].minimumRentalDuration = SafeCast.toUint64(\n            1 days / IRCMarket(_market).minRentalDayDivisor()\n        );\n        for (uint64 i = 0; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.card = i;\n            _newBid.prev = _market;\n            _newBid.next = _market;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = type(uint64).max;\n            index[_market][_market][i] = user[_market].length;\n            user[_market].push(_newBid);\n        }\n    }\n\n    /// @notice adds or updates a bid in the orderbook\n    /// @param _user the user placing the bid\n    /// @param _card the card to place the bid on\n    /// @param _price the price of the new bid\n    /// @param _timeHeldLimit an optional time limit for the bid\n    /// @param _prevUserAddress to help find where to insert the bid\n    function addBidToOrderbook(\n        address _user,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        if (!bidExists(_market, _market, _card)) {\n            uint256 _cardCount = IRCMarket(_market).numberOfCards();\n            uint256 _minIncrease = IRCMarket(_market)\n                .minimumPriceIncreasePercent();\n            addMarket(_market, _cardCount, _minIncrease);\n        }\n        // each new bid can help clean up some junk\n        cleanWastePile();\n\n        if (user[_user].length == 0) {\n            //users first bid, skip already closed markets\n            userClosedMarketIndex[_user] = closedMarkets.length;\n        }\n\n        if (_prevUserAddress == address(0)) {\n            _prevUserAddress = _market;\n        } else {\n            require(\n                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]\n                    .price >= _price,\n                \"Location too low\"\n            );\n        }\n        require(\n            bidExists(_prevUserAddress, _market, _card),\n            \"Invalid starting location\"\n        );\n        Bid storage _prevUser = user[_prevUserAddress][\n            index[_prevUserAddress][_market][_card]\n        ];\n\n        if (bidExists(_user, _market, _card)) {\n            // old bid exists, update it\n            _updateBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        } else {\n            // new bid, add it\n            _newBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        }\n    }\n\n    /// @dev finds the correct location in the orderbook for a given bid\n    /// @dev returns an adjusted (lowered) bid price if necessary.\n    function _searchOrderbook(\n        Bid storage _prevUser,\n        address _market,\n        uint256 _card,\n        uint256 _price\n    ) internal view returns (Bid storage, uint256) {\n        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /\n            (100);\n\n        uint256 i = 0;\n        while (\n            // break loop if match price above AND above price below (so if either is false, continue, hence OR )\n            // if match previous then must be greater than next to continue\n            (_price != _prevUser.price || _price <= _nextUser.price) &&\n            // break loop if price x% above below\n            _price < _requiredPrice &&\n            // break loop if hits max iterations\n            i < maxSearchIterations\n        ) {\n            _prevUser = _nextUser;\n            _nextUser = user[_prevUser.next][\n                index[_prevUser.next][_market][_card]\n            ];\n            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);\n            i++;\n        }\n        require(i < maxSearchIterations, \"Position not found\");\n\n        // if previous price is zero it must be the market and this is a new owner\n        // .. then don't reduce their price, we already checked they are 10% higher\n        // .. than the previous owner.\n        if (_prevUser.price != 0 && _prevUser.price < _price) {\n            _price = _prevUser.price;\n        }\n        return (_prevUser, _price);\n    }\n\n    /// @dev add a new bid to the orderbook\n    function _newBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        if (ownerOf[_market][_card] != _market) {\n            (_prevUser, _price) = _searchOrderbook(\n                _prevUser,\n                _market,\n                _card,\n                _price\n            );\n        }\n\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // create new record\n        Bid memory _newBid;\n        _newBid.market = _market;\n        _newBid.card = SafeCast.toUint64(_card);\n        _newBid.prev = _nextUser.prev;\n        _newBid.next = _prevUser.next;\n        _newBid.price = SafeCast.toUint128(_price);\n        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // insert in linked list\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n        user[_user].push(_newBid);\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = user[_user].length - (1);\n\n        emit LogAddToOrderbook(\n            _user,\n            _price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _price);\n        if (user[_user][index[_user][_market][_card]].prev == _market) {\n            address _oldOwner = user[_user][index[_user][_market][_card]].next;\n            transferCard(_market, _card, _oldOwner, _user, _price);\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                user[_oldOwner][index[_oldOwner][_market][_card]].price,\n                _price,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev updates a bid that is already in the orderbook\n    function _updateBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        // TODO no need to unlink and relink if bid doesn't change position in orderbook\n        // unlink current bid\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        user[_currUser.next][index[_currUser.next][_market][_card]]\n            .prev = _currUser.prev;\n        user[_currUser.prev][index[_currUser.prev][_market][_card]]\n            .next = _currUser.next;\n        bool _wasOwner = _currUser.prev == _market;\n\n        // find new position\n        (_prevUser, _price) = _searchOrderbook(\n            _prevUser,\n            _market,\n            _card,\n            _price\n        );\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // update price, save old price for rental rate adjustment later\n        (_currUser.price, _price) = (\n            SafeCast.toUint128(_price),\n            uint256(_currUser.price)\n        );\n        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // relink bid\n        _currUser.next = _prevUser.next;\n        _currUser.prev = _nextUser.prev;\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n\n        emit LogAddToOrderbook(\n            _user,\n            _currUser.price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _currUser.price);\n        treasury.decreaseBidRate(_user, _price);\n        if (_wasOwner && _currUser.prev == _market) {\n            // if owner before and after, update the price difference\n            transferCard(_market, _card, _user, _user, _currUser.price);\n            treasury.updateRentalRate(\n                _user,\n                _user,\n                _price,\n                _currUser.price,\n                block.timestamp\n            );\n        } else if (_wasOwner && _currUser.prev != _market) {\n            // if owner before and not after, remove the old price\n            address _newOwner = user[_market][index[_market][_market][_card]]\n                .next;\n            uint256 _newPrice = user[_newOwner][\n                index[_newOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _user,\n                _newOwner,\n                _price,\n                _newPrice,\n                block.timestamp\n            );\n            transferCard(_market, _card, _user, _newOwner, _newPrice);\n        } else if (!_wasOwner && _currUser.prev == _market) {\n            // if not owner before but is owner after, add new price\n            address _oldOwner = _currUser.next;\n            uint256 _oldPrice = user[_oldOwner][\n                index[_oldOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                _oldPrice,\n                _currUser.price,\n                block.timestamp\n            );\n            transferCard(_market, _card, _oldOwner, _user, _currUser.price);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551                DELETIONS                 \u2551      \n      \u2551 functions that remove from the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice removes a single bid from the orderbook - onlyMarkets\n    function removeBidFromOrderbook(address _user, uint256 _card)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        assert(_user != ownerOf[_market][_card]);\n        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n    }\n\n    /// @dev removes a single bid from the orderbook, doesn't update ownership\n    function _removeBidFromOrderbookIgnoreOwner(\n        address _user,\n        address _market,\n        uint256 _card\n    ) internal returns (uint256 _newPrice) {\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // return next users price to check they're eligible later\n        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;\n\n        // update rate\n        treasury.decreaseBidRate(_user, _currUser.price);\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].card\n            ] = _index;\n        }\n\n        assert(!bidExists(_user, _market, _card));\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @notice find the next valid owner of a given card - onlyMarkets\n    /// @param _card the card to remove\n    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes\n    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n        external\n        override\n        onlyMarkets\n    {\n        address _newOwner = address(0);\n        address _market = msgSender();\n        // the market is the head of the list, the next bid is therefore the owner\n        Bid storage _head = user[_market][index[_market][_market][_card]];\n        address _oldOwner = address(0);\n        uint256 _oldPrice = 0;\n        if (oldOwner[_market][_card] != address(0)) {\n            _oldOwner = oldOwner[_market][_card];\n            _oldPrice = oldPrice[_market][_card];\n            oldOwner[_market][_card] = address(0);\n            oldPrice[_market][_card] = 0;\n        } else {\n            _oldOwner = ownerOf[_market][_card];\n            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;\n        }\n        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +\n            market[_market].minimumRentalDuration;\n        uint256 _newPrice;\n        uint256 _loopCounter = 0;\n\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner(\n                _head.next,\n                _market,\n                _card\n            );\n            _loopCounter++;\n            // delete next bid if foreclosed\n        } while (\n            treasury.foreclosureTimeUser(\n                _head.next,\n                _newPrice,\n                _timeOwnershipChanged\n            ) <\n                minimumTimeToOwnTo &&\n                _loopCounter < maxDeletions\n        );\n\n        if (_loopCounter != maxDeletions) {\n            // the old owner is dead, long live the new owner\n            _newOwner = user[_market][index[_market][_market][_card]].next;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _newOwner,\n                _oldPrice,\n                _newPrice,\n                _timeOwnershipChanged\n            );\n            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);\n        } else {\n            // we hit the limit, save the old owner, we'll try again next time\n            oldOwner[_market][_card] = _oldOwner;\n            oldPrice[_market][_card] = _oldPrice;\n        }\n    }\n\n    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards\n    /// @notice .. as the markets will need to finish the accounting for them first.\n    /// @param _user the user whose bids to start deleting\n    function removeUserFromOrderbook(address _user) external override {\n        require(treasury.isForeclosed(_user), \"User must be foreclosed\");\n        uint256 i = user[_user].length;\n        if (i != 0) {\n            uint256 _limit = 0;\n            if (i > maxDeletions) {\n                _limit = i - maxDeletions;\n            }\n\n            do {\n                i--;\n\n                // If the prev record isn't the market, this is only a bid (not owned) so we can delete\n                if (user[_user][i].prev != user[_user][i].market) {\n                    address _market = user[_user][i].market;\n                    uint256 _card = user[_user][i].card;\n                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n                }\n            } while (user[_user].length > _limit && i > 0);\n        }\n        treasury.assessForeclosure(_user);\n    }\n\n    /// @notice reduces the rentalRates of the card owners when a market closes\n    /// @dev too many bidders to reduce all bid rates also\n    function closeMarket() external override onlyMarkets returns (bool) {\n        address _market = msgSender();\n        // check if the market was ever added to the orderbook\n        if (bidExists(_market, _market, 0)) {\n            closedMarkets.push(_market);\n            uint256 i = user[_market].length; // start on the last record so we can easily pop()\n            uint256 _limit = 0;\n            if (marketCloseLimit < user[_market].length) {\n                _limit = user[_market].length - marketCloseLimit;\n            } else {\n                _limit = 0;\n            }\n            do {\n                i--;\n                address _lastOwner = user[_market][index[_market][_market][i]]\n                    .next;\n                if (_lastOwner != _market) {\n                    uint256 _price = user[_lastOwner][\n                        index[_lastOwner][_market][i]\n                    ].price;\n\n                    // store last bid for later\n                    address _lastBid = user[_market][index[_market][_market][i]]\n                        .prev;\n\n                    // detach market from rest of list\n                    user[_market][index[_market][_market][i]].prev = _market;\n                    user[_market][index[_market][_market][i]].next = _market;\n                    user[_lastOwner][index[_lastOwner][_market][i]]\n                        .prev = address(this);\n                    user[_lastBid][index[_lastBid][_market][i]].next = address(\n                        this\n                    );\n\n                    index[address(this)][_market][i] = user[address(this)]\n                        .length;\n\n                    // insert bids in the waste pile\n                    Bid memory _newBid;\n                    _newBid.market = _market;\n                    _newBid.card = SafeCast.toUint64(i);\n                    _newBid.prev = _lastBid;\n                    _newBid.next = _lastOwner;\n                    _newBid.price = 0;\n                    _newBid.timeHeldLimit = 0;\n                    user[address(this)].push(_newBid);\n\n                    // reduce owners rental rate\n                    treasury.updateRentalRate(\n                        _lastOwner,\n                        _market,\n                        _price,\n                        0,\n                        block.timestamp\n                    );\n                }\n                // remove the market record\n                user[_market].pop();\n            } while (i > _limit);\n        }\n        if (user[_market].length == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Remove bids in closed markets for a given user\n    /// @notice this can reduce the users bidRate and chance to foreclose\n    /// @param _user the address of the users bids to remove\n    function removeOldBids(address _user) external override {\n        if (user[_user].length != 0) {\n            address _market = address(0);\n            uint256 _cardCount = 0;\n            uint256 _loopCounter = 0;\n            uint256 _subLoopCounter = 0;\n            while (\n                userClosedMarketIndex[_user] < closedMarkets.length &&\n                _loopCounter + _cardCount < maxDeletions\n            ) {\n                _market = closedMarkets[userClosedMarketIndex[_user]];\n                // Just do the whole market at once\n                _cardCount = market[_market].cardCount;\n                uint256 i = _cardCount;\n                do {\n                    i--;\n                    if (bidExists(_user, _market, i)) {\n                        uint256 _index = index[_user][_market][i];\n                        // reduce bidRate\n                        uint256 _price = user[_user][_index].price;\n\n                        // preserve linked list\n                        address _tempPrev = user[_user][_index].prev;\n                        address _tempNext = user[_user][_index].next;\n\n                        user[_tempNext][index[_tempNext][_market][i]]\n                            .prev = _tempPrev;\n                        user[_tempPrev][index[_tempPrev][_market][i]]\n                            .next = _tempNext;\n\n                        uint256 _lastRecord = user[_user].length - 1;\n                        // no point overwriting itself\n                        if (_index != _lastRecord) {\n                            // overwrite array element\n                            user[_user][_index] = user[_user][_lastRecord];\n                        }\n                        user[_user].pop();\n\n                        // update the index to help find the record later\n                        index[_user][_market][i] = 0;\n                        if (user[_user].length != 0 && _index != _lastRecord) {\n                            index[_user][user[_user][_index].market][\n                                user[_user][_index].card\n                            ] = _index;\n                        }\n\n                        treasury.decreaseBidRate(_user, _price);\n                        // count deletions\n                        _loopCounter++;\n                    } else {\n                        // iterations cost gas also\n                        // after enough increment the loopCounter\n                        _subLoopCounter++;\n                        if (_subLoopCounter > 100) {\n                            _subLoopCounter = 0;\n                            _loopCounter++;\n                        }\n                    }\n                } while (i > 0);\n                userClosedMarketIndex[_user]++;\n            }\n        }\n    }\n\n    /// @dev remove bids in closed markets, not user specific\n    function cleanWastePile() public override {\n        uint256 i = 0;\n        while (i < cleaningLoops && user[address(this)].length > 0) {\n            uint256 _pileHeight = user[address(this)].length - 1;\n            address _market = user[address(this)][_pileHeight].market;\n            uint256 _card = user[address(this)][_pileHeight].card;\n            address _user = user[address(this)][_pileHeight].next;\n\n            if (user[address(this)][_pileHeight].next == address(this)) {\n                index[address(this)][_market][_card] = 0;\n                user[address(this)].pop();\n            } else {\n                uint256 _index = index[_user][_market][_card];\n                address _tempNext = user[_user][_index].next;\n\n                treasury.decreaseBidRate(_user, user[_user][_index].price);\n\n                // extract from linked list\n                user[address(this)][_pileHeight].next = _tempNext;\n                user[_tempNext][index[_tempNext][_market][_card]]\n                    .prev = address(this);\n\n                // overwrite array element\n                uint256 _lastRecord = user[_user].length - 1;\n                // no point overwriting itself\n                if (_index != _lastRecord) {\n                    user[_user][_index] = user[_user][_lastRecord];\n                }\n                user[_user].pop();\n\n                // update the index to help find the record later\n                index[_user][_market][_card] = 0;\n                if (user[_user].length != 0 && _index != _lastRecord) {\n                    index[_user][user[_user][_index].market][\n                        user[_user][_index].card\n                    ] = _index;\n                }\n            }\n            i++;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        HELPER FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check if a bid exists\n    /// @param _user the address of the user\n    /// @param _market the address of the market\n    /// @param _card the card index\n    /// @return if the bid exists or not\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view override returns (bool) {\n        if (user[_user].length != 0) {\n            //some bids exist\n            if (index[_user][_market][_card] != 0) {\n                // this bid exists\n                return true;\n            } else {\n                // check bid isn't index 0\n                if (\n                    user[_user][0].market == _market &&\n                    user[_user][0].card == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function getBidValue(address _user, uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address _market = msgSender();\n        if (bidExists(_user, _market, _card)) {\n            return user[_user][index[_user][_market][_card]].price;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev just to pass old tests, not needed otherwise\n    /// @dev but also useful to have so probably will stay\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view override returns (Bid memory) {\n        if (bidExists(_user, _market, _card)) {\n            Bid memory _bid = user[_user][index[_user][_market][_card]];\n            return _bid;\n        } else {\n            Bid memory _newBid;\n            _newBid.market = address(0);\n            _newBid.card = SafeCast.toUint64(_card);\n            _newBid.prev = address(0);\n            _newBid.next = address(0);\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            return _newBid;\n        }\n    }\n\n    function getTimeHeldlimit(address _user, uint256 _card)\n        external\n        view\n        override\n        onlyMarkets\n        returns (uint256)\n    {\n        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;\n    }\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeldLimit\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        require(bidExists(_user, _market, _card), \"Bid doesn't exist\");\n        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast\n            .toUint64(_timeHeldLimit);\n    }\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeToReduce\n    ) external override onlyMarkets {\n        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast\n            .toUint64(_timeToReduce);\n    }\n\n    function transferCard(\n        address _market,\n        uint256 _card,\n        address _oldOwner,\n        address _newOwner,\n        uint256 _price\n    ) internal {\n        ownerOf[_market][_card] = _newOwner;\n        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]\n            .timeHeldLimit;\n        IRCMarket _rcmarket = IRCMarket(_market);\n        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n",
        "CodeNames": [
            "RCOrderbook.sol",
            "RCFull.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n"
                ],
                "Type": "  findNewOwner  edgecase",
                "Description": "\nIn the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions\nAfterwards, a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished.\nIf _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.\n\nHowever, there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.\n\nYou can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished.\nOf course having maxDeletions==1 is very unlikely in practice.\n\nsolidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n\n\n",
                "Repair": "Recommend using a different way to determine that the processing is done. This could save some gas.\nNote: the additional check also costs gas, so you have to verify the end result.\n\nPerhaps in setDeletionLimit, doublecheck that _deletionLimit  1.\n\nSplidge (Reality Cards) confirmed and disagreed with severity(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905499584):\n  oh wow, this is actually a really big problem. It's easier to see it if maxDeletions is 1 but it exists with any size of maxDeletions.\n Whenever we find a valid owner on the final iteration of the loop the if statement will simply check if it was the final loop. That valid owner is then assumed to be invalid and saved for the next transaction to try and find a new owner. When that next transaction happens the valid owner is immediately deleted and not given any ownership of the card at all.\n I think this just falls short of 3 (High risk) because I don't think it'd be possible for an attacker to engineer the situation to have a particular user deleted without ownership. But I believe this would count as 2 (Med risk) because the protocol \"availability could be impacted\"(https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr) for the user that is deleted.\n\nSplidge (Reality Cards) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905523120):\n  I have since thought of an attack that could have used this and might raise it to 3 (High risk).\n\n Due to the difficultly of monitoring which cards you own all the time a valid strategy which some users employ is to bid high enough to scare off other users (usually bidding significantly beyond the 10% minimum increase). Suppose Alice employs this strategy by bidding $100 on a card that was previously only $10.\n Mal (our attacker) wishes to rent the card but wants to pay less than $100. Mal could use Sybil accounts to place maxDeletions 1 bids all for the minimum rental duration (only funding the accounts for the minimum duration). Mal would then need to wait for the minimum duration of all these bids to expire, (maxDeletions 1 ) * minimumRentalDuration\n Once this has completed Mal can place a bid at $11, this will trigger a rent collection which will attempt to findNewOwner, Alice being the user that was found on the last iteration of the loop would be considered as invalid. There will not be a change of ownership or any events emitted about this until the next rent collection is triggered.\n This means that the UI would still consider Alice to be the owner of card (Mals' Sybil bids having had LogRemoveFromOrderbook and LogUserForeclosed events emitted) and other users might not consider trying to outbid this, whereas actually Mal is accruing time at a significantly cheaper rate.\n\n Thinking about it, this doesn't really even need Alice at all, Mal could have placed all the higher bids to simultaneously scare off other users while renting at a lower price.\n\n I think the fix is relatively simple, by checking if we found a valid user OR hit the deletion limit we can make it so that we don't skip any bids. This would then leave Alice (or Mal in the other version) correctly having to pay for the time at the higher price.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-911673904):\n  upgrading based on sponsors analysis\n\nSplidge (Reality Cards) patched(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-914180653):\n  Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/9f81f683ea0d2ab41ab91ba9188baf594012c295)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n",
        "CodeNames": [
            "RCFull.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "UberOwner"
                ],
                "Type": "  UberOwner  has too much power",
                "Description": "\nThe Uber Owner has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code\n\nThe above functions can be used by the Uber Owner to completely change the functionality of the system.\nThis goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.\n\n",
                "Repair": "Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.\n\nmcplums (Reality Cards) disputed(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906225388):\n  This is a subjective opinionthere is always going to be a compromise between decentralisation and the ability to respond to potential problems. The latter is especially important with a protocol that is so new.\n\n There is no correct answer here, but the current abilities of uberOwner were decided after a lot of thought and are in line with other DeFi protocols.\n\nSplidge (Reality Cards) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906236023):\n  I'd just like to add that we did recognize the power of the UberOwner which is why it is separated from the Owner specifically so that we can add additional security to it (in the form of a multisig) and so that we can relinquish this control at the appropriate time.\n This was covered in the readme(https://github.com/code-423n4/2021-08-realitycards#mortar_board-governance-mortar_board).\n And also commented (https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L288-L291)in the code.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-911717998):\n  I think the warden(s) have a valid point here. This is an incredible amount of power for a single address to yield over the protocol, even if backed by a multi-sig.\n\n Is it no an option to 1) pause all activity, and unlock all funds allowing users to withdraw their own funds or 2) pause all activity besides withdraws and implement a time delay between that and the \"rug pull\" function being called.\n\n The readme also states\n\n Alternatively we may wish for this to be a multisig but the normal owner to not be, for convenience.\n\n Without a multisig, I believe this absolutely qualifies as a high severity issue as a compromise of a single end user address compromises the entire system, with a multisig it potentially lowers the severity down to a medium, but its still a risk that is worth highlighting in the system and for the sponsor to scrutinize if there are indeed other mitigation paths that could be taken.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L586\nfunction setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {\n    require(address(_newAddress) != address(0), \"Must set Address\");\n    nfthub = _newAddress;\n}\n\nfunction setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\" );\n    orderbook = _newOrderbook;\n}\n\nfunction setLeaderboardAddress(IRCLeaderboard _newLeaderboard) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\");\n    leaderboard = _newLeaderboard;\n}\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L188\nfunction setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n    minRentalDayDivisor = _newDivisor;\n}\n"
                ],
                "Type": " Parameter updates not propagated",
                "Description": "\nThere are several functions to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results.\nExamples are:\nsetNftHubAddress of RCFactory\nsetOrderbookAddress of RCFactory\nsetLeaderboardAddress of RCFactory\nsetMinRental of RCTreasury\n\nsolidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L586\nfunction setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {\n    require(address(_newAddress) != address(0), \"Must set Address\");\n    nfthub = _newAddress;\n}\n\nfunction setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\" );\n    orderbook = _newOrderbook;\n}\n\nfunction setLeaderboardAddress(IRCLeaderboard _newLeaderboard) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\");\n    leaderboard = _newLeaderboard;\n}\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L188\nfunction setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n    minRentalDayDivisor = _newDivisor;\n}\n\n\n",
                "Repair": "Recommend implementing a way to notify the underlying contracts of the updates.\n\nSplidge (Reality Cards) acknowledged(https://github.com/code-423n4/2021-08-realitycards-findings/issues/30#issuecomment-904726786):\n  We have come to realise that it is very unlikely we will be able to change certain contracts once they are in-use, the exception being the market where a new reference could be deployed.\n In practice we do use setNftHubAddress shortly after deploying new contracts, this is so that we can continue to use an existing NFT hub that has already been put through Matic Mintable Asset mapping, but changing this while a market is active would cause problems.\n While we accept that changing these parameters on active contracts may be troublesome we will not be making changes at this time, partly because it's useful to be able to change these before the contracts are in use but also due to the potential risk of introducing new problems at this stage in the project.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /////// CONTRACT VARIABLES ///////\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n    /// @dev reference contract\n    address public override referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public override referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(IRCMarket.Mode => address[]) public marketAddresses;\n\n    ////// BACKUP MODE //////\n    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data\n    /// @dev the IPFS hash for each market\n    mapping(address => string) public override ipfsHash;\n    /// @dev the slug each market is hosted at\n    mapping(string => address) public override slugToAddress;\n    mapping(address => string) public override addressToSlug;\n    /// @dev the number of results to return in the backup view function\n    uint256 public override marketInfoResults;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms initial pot\n    uint256 public override sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev The number of users that are allowed to mint an NFT\n    uint256 public override nftsToAward;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public override advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public override maximumDuration;\n    /// @dev market closing time must be at least this many seconds after opening\n    uint32 public override minimumDuration;\n    /// @dev if false, anyone can create markets\n    bool public override marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public override approvedAffiliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public override approvedArtistsOnly = true;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the maximum number of rent collections to have performed before locking the market\n    uint256 public override maxRentIterationsToLockMarket;\n    /// @dev the address of the arbitrator\n    address public override arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public override timeout;\n    /// @dev if true markets default to the paused state\n    bool public override marketPausedDefaultState;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public override cardLimit;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n\n    ///// OTHER /////\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev store the tokenURIs for when we need to mint them\n    /// @dev we may want the original and the copies to have slightly different metadata\n    /// @dev so we append the metadata for the copies to the end of this array\n    mapping(address => mapping(uint256 => string)) tokenURIs;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        IRCMarket.Mode mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool approved);\n    event LogMarketTimeRestrictions(\n        uint256 _newAdvancedWarning,\n        uint256 _newMinimumDuration,\n        uint256 _newMaximumDuration\n    );\n    event LogMintNFTCopy(\n        uint256 _originalTokenId,\n        address _newOwner,\n        uint256 _newTokenId\n    );\n    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(\n        IRCTreasury _treasury,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasury) != address(0), \"Must set Address\");\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // store contract instances\n        treasury = _treasury;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncreasePercent(10); // 10%\n        setNumberOfNFTsToAward(3);\n        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes\n        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /// @notice fetch the current oracle, arbitrator and timeout settings\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    /// @return Oracle Address\n    /// @return Arbitrator Address\n    /// @return Question timeout in seconds\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n\n    /// @notice Returns market addresses and ipfs hashes\n    /// @dev used for the UI backup mode\n    /// @param _mode return markets only in the given mode\n    /// @param _state return markets only in the given state\n    /// @param _skipResults the number of results to skip\n    function getMarketInfo(\n        IRCMarket.Mode _mode,\n        uint256 _state,\n        uint256 _skipResults\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            string[] memory,\n            string[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 _marketIndex = marketAddresses[_mode].length;\n        uint256 _resultNumber = 0;\n        address[] memory _marketAddresses = new address[](marketInfoResults);\n        string[] memory _ipfsHashes = new string[](marketInfoResults);\n        uint256[] memory _potSizes = new uint256[](marketInfoResults);\n        string[] memory _slugs = new string[](marketInfoResults);\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;\n                    _ipfsHashes[_resultNumber] = ipfsHash[_market];\n                    _slugs[_resultNumber] = addressToSlug[_market];\n                    _potSizes[_resultNumber] = IRCMarket(_market)\n                        .totalRentCollected();\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyOwner() {\n        require(treasury.checkPermission(OWNER, msgSender()), \"Not approved\");\n        _;\n    }\n    modifier onlyGovernors() {\n        require(\n            treasury.checkPermission(GOVERNOR, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyMarkets() {\n        require(treasury.checkPermission(MARKET, msgSender()), \"Not approved\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in MegaBip (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public override onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                PER_MILLE,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice how many NFTs will be awarded to the leaderboard\n    /// @param _nftsToAward the number of NFTs to award\n    function setNumberOfNFTsToAward(uint256 _nftsToAward)\n        public\n        override\n        onlyOwner\n    {\n        nftsToAward = _nftsToAward;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _cardLimit the limit to set\n    function setCardLimit(uint256 _cardLimit) public override onlyOwner {\n        cardLimit = _cardLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n        maxRentIterationsToLockMarket = _rentLimitLocking;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public override onlyOwner {\n        // event is emitted from the Oracle when the question is asked\n        timeout = _newTimeout;\n    }\n\n    function setMarketPausedDefaultState(bool _state)\n        external\n        override\n        onlyOwner\n    {\n        marketPausedDefaultState = _state;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external override onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external override onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external override onlyOwner {\n        approvedAffiliatesOnly = !approvedAffiliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount)\n        external\n        override\n        onlyOwner\n    {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external override onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        minimumDuration = _newMinimumDuration;\n        maximumDuration = _newMaximumDuration;\n        emit LogMarketTimeRestrictions(\n            _newAdvancedWarning,\n            _newMinimumDuration,\n            _newMaximumDuration\n        );\n    }\n\n    /// @notice Allow the owner to update a token URI.\n    /// @param _market the market address the token belongs to\n    /// @param _cardId the index 0 card id of the token to change\n    /// @param _newTokenURI the new URI to set\n    /// @param _newCopyTokenURI the new URI to set for the copy\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external override onlyOwner {\n        IRCMarket.Mode _mode = IRCMarket(_market).mode();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        tokenURIs[_market][_cardId] = _newTokenURI;\n        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;\n        string[] memory _tokenURIs = new string[](_numberOfCards);\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            _tokenURIs[i] = tokenURIs[_market][i];\n        }\n        uint32[] memory _timestamps = new uint32[](3);\n        _timestamps[0] = IRCMarket(_market).marketOpeningTime();\n        _timestamps[1] = IRCMarket(_market).marketLockingTime();\n        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();\n\n        // reuse this event so the frontend can pickup the change\n        emit LogMarketCreated2(\n            _market,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            ipfsHash[_market],\n            _timestamps,\n            nfthub.totalSupply()\n        );\n    }\n\n    /// @notice change how many results are returned from getMarketInfo\n    /// @dev would be better to pass this as a parameter in getMarketInfo\n    /// @dev .. however we are limited because of stack too deep errors\n    function setMarketInfoResults(uint256 _results)\n        external\n        override\n        onlyOwner\n    {\n        // no event needed, only used for the backup view mode\n        marketInfoResults = _results;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market)\n        external\n        override\n        onlyGovernors\n    {\n        require(_market != address(0), \"Must set Address\");\n        // check it's an RC contract\n        require(treasury.checkPermission(MARKET, _market), \"Not Market\");\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        // governors shouldn't have the ability to pause a market, only un-pause.\n        // .. if a governor accidentally approves a market they should seek\n        // .. assistance from the owner to decide if it should be paused.\n        treasury.unPauseMarket(_market);\n        // the market will however be hidden from the UI in the meantime\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551   GOVERNANCE - Role management  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev the following functions could all be performed directly on the treasury\n    /// @dev .. they are here as an interim solution to give governors an easy way\n    /// @dev .. to change all their parameters via the block explorer.\n\n    /// @notice Grant the artist role to an address\n    /// @param _newArtist the address to grant the role of artist\n    function addArtist(address _newArtist) external override onlyGovernors {\n        treasury.grantRole(ARTIST, _newArtist);\n    }\n\n    /// @notice Remove the artist role from an address\n    /// @param _oldArtist the address to revoke the role of artist\n    function removeArtist(address _oldArtist) external override onlyGovernors {\n        treasury.revokeRole(ARTIST, _oldArtist);\n    }\n\n    /// @notice Grant the affiliate role to an address\n    /// @param _newAffiliate the address to grant the role of affiliate\n    function addAffiliate(address _newAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.grantRole(AFFILIATE, _newAffiliate);\n    }\n\n    /// @notice Remove the affiliate role from an address\n    /// @param _oldAffiliate the address to revoke the role of affiliate\n    function removeAffiliate(address _oldAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.revokeRole(AFFILIATE, _oldAffiliate);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades, this is separated so owner can be\n    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    /// @notice change the reference contract for the contract logic\n    /// @param _newAddress the address of the new reference contract to set\n    function setReferenceContractAddress(address _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        require(newContractVariable.isMarket(), \"Not Market\");\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice where the NFTs live\n    /// @param _newAddress the address to set\n    function setNftHubAddress(IRCNftHubL2 _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(address(_newAddress) != address(0), \"Must set Address\");\n        nfthub = _newAddress;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newOrderbook the address to set\n    /// @dev set by the treasury to ensure all contracts use the same orderbook\n    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        orderbook = _newOrderbook;\n    }\n\n    /// @notice set the address of the leaderboard contract\n    /// @param _newLeaderboard the address to set\n    /// @dev set by the treasury to ensure all contracts use the same leaderboard\n    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)\n        external\n        override\n    {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        leaderboard = _newLeaderboard;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all\n    /// @param _ipfsHash the IPFS location of the market metadata\n    /// @param _slug the URL subdomain in the UI\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata, originals followed by copies\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliates cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion,\n        uint256 _sponsorship\n    ) external override returns (address) {\n        address _creator = msgSender();\n\n        // check nfthub has been set\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check the number of NFTs to mint is within limits\n        /// @dev we want different tokenURIs for originals and copies\n        /// @dev ..the copies are appended to the end of the array\n        /// @dev ..so half the array length if the number of tokens.\n        require(\n            (_tokenURIs.length / 2) <= cardLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                _artistAddress == address(0) ||\n                    treasury.checkPermission(ARTIST, _artistAddress),\n                \"Artist not approved\"\n            );\n        }\n\n        // affiliate\n        require(\n            _cardAffiliateAddresses.length == 0 ||\n                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n            \"Card Affiliate Length Error\"\n        );\n        if (approvedAffiliatesOnly) {\n            require(\n                _affiliateAddress == address(0) ||\n                    treasury.checkPermission(AFFILIATE, _affiliateAddress),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    _cardAffiliateAddresses[i] == address(0) ||\n                        treasury.checkPermission(\n                            CARD_AFFILIATE,\n                            _cardAffiliateAddresses[i]\n                        ),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(\n                treasury.checkPermission(GOVERNOR, _creator),\n                \"Not approved\"\n            );\n        }\n\n        _checkTimestamps(_timestamps);\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            nfthub.totalSupply()\n        );\n\n        // tell Treasury and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress, marketPausedDefaultState);\n        nfthub.addMarket(_newAddress);\n\n        // update internals\n        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);\n        ipfsHash[_newAddress] = _ipfsHash;\n        slugToAddress[_slug] = _newAddress;\n        addressToSlug[_newAddress] = _slug;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize(\n            IRCMarket.Mode(_mode),\n            _timestamps,\n            (_tokenURIs.length / 2),\n            _artistAddress,\n            _affiliateAddress,\n            _cardAffiliateAddresses,\n            _creator,\n            _realitioQuestion,\n            nftsToAward\n        );\n\n        // store token URIs\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            tokenURIs[_newAddress][i] = _tokenURIs[i];\n        }\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    function _checkTimestamps(uint32[] memory _timestamps) internal view {\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            // different statements to give clearer revert messages\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        require(\n            _timestamps[0] + minimumDuration < _timestamps[1] &&\n                block.timestamp + minimumDuration < _timestamps[1],\n            \"Market lock must be after opening\"\n        );\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n    }\n\n    /// @notice Called by the markets to mint the original NFTs\n    /// @param _card the card id to be minted\n    function mintMarketNFT(uint256 _card) external override onlyMarkets {\n        uint256 nftHubMintCount = nfthub.totalSupply();\n        address _market = msgSender();\n        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);\n        emit LogMintNFT(_card, _market, nftHubMintCount);\n    }\n\n    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard\n    /// @param _user the user to award the NFT to\n    /// @param _cardId the tokenId to copy\n    function mintCopyOfNFT(address _user, uint256 _cardId)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        uint256 _newTokenId = nfthub.totalSupply();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        nfthub.mint(\n            _user,\n            _newTokenId,\n            tokenURIs[_market][(_cardId + _numberOfCards)]\n        );\n        emit LogMintNFTCopy(_cardId, _user, _newTokenId);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCFull.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "marketWhitelist",
                    "true",
                    "marketWhitelistCheck()",
                    "newRental()"
                ],
                "Type": " Uninitialized Variable  marketWhitelist  in  RCTreasury.sol ",
                "Description": "\nThe variable, marketWhitelist, is never initialized in the contract RCTreasury.sol. As a result, the function marketWhitelistCheck()  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.\n\nThe initial state variable is defined in RCTreasury.sol L75(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75).\n\n\nThe state variable marketWhitelist is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281).\n\nThe function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761). The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.\n\n",
                "Repair": "Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.\n\nSplidge (Reality Cards) confirmed and disagreed with severity(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-905413207):\n  I think the severity could be double-checked on this one.\n It's a close one but I'd be tempted to put it under 1 (low risk) as a \"Function incorrect to spec\".\n Regardless, this will be fixed.\n\n Edit: I notice the duplicates were both marked as 1 (low risk).\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-910962066):\n  based on \" but the function of the protocol or its availability could be impacted\" in the code4 docs, I am going to agree with warden and leave this as a 2.  The function of the protocol is certainly impacted in a case where the whitelist if not working correctly.\n\n\nSplidge (Reality Cards) patched(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-914175471):\n  Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/1515f87e97be1ed09316340e19caea5c12242c17)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20Dai {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "RCFull.sol",
            "IERC20Dai.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n"
                ],
                "Type": " Deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).\n\nThe RCTreasury.deposit() function will credit more deposits than the contract actually received:\n\nsolidity\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n\n\n",
                "Repair": "Recommend ensuring that the erc20 token does not implement any customizations.\nAlternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines\n\nSplidge (Reality Cards) acknowledged(https://github.com/code-423n4/2021-08-realitycards-findings/issues/58#issuecomment-906322667):\n  The issue that keeps on giving..(https://github.com/code-423n4/2021-06-realitycards-findings/issues/152)\n\n ![takemymoney(https://user-images.githubusercontent.com/73956628/130954991-f6f29f54-926f-4e68-b4cb-f73ed1dc3c95.jpg)\n\n\n\n"
            }
        ]
    }
]