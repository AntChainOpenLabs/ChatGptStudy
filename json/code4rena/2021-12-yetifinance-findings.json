[
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./BoringCrypto/BoringMath.sol\";\nimport \"./BoringCrypto/BoringERC20.sol\";\nimport \"./BoringCrypto/Domain.sol\";\nimport \"./BoringCrypto/ERC20.sol\";\nimport \"./BoringCrypto/IERC20.sol\";\nimport \"./BoringCrypto/BoringOwnable.sol\";\nimport \"./IsYETIRouter.sol\";\n\n\ninterface IYETIToken is IERC20 {\n    function sendToSYETI(address _sender, uint256 _amount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n// modified by BoringCrypto for DictatorDAO\n\n\n// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 \n// Each rebase increases the effective yetibalance by a certain amount of the total value\n// of the contract, which is equal to the yusd balance + the last price which the buyback \n// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200\n// of the total value of the contract is added to the effective yetibalance. Also updated on \n// mint and withdraw, because that is actual value that is added to the contract. \n\ncontract sYETIToken is IERC20, Domain, BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sYETI\";\n    string public constant name = \"Staked YETI Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 69 hours;\n    uint256 public effectiveYetiTokenBalance;\n    uint256 public lastBuybackTime;\n    uint256 public lastBuybackPrice;\n    uint256 public lastRebaseTime;\n    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. \n    IYETIToken public yetiToken;\n    IERC20 public yusdToken;\n    bool private addressesSet;\n\n\n    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain\n    // and do that one. \n    mapping(address => bool) public validRouters;\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);\n    event Rebase(uint additionalYetiTokenBalance);\n\n    function balanceOf(address user) public view override returns (uint256) {\n        return users[user].balance;\n    }\n\n    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        yetiToken = _yeti;\n        yusdToken = _yusd;\n        addressesSet = true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                uint128 shares128 = shares.to128();\n                users[from].balance = fromUser.balance - shares128; // Underflow is checked\n                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            uint256 newAllowance = spenderAllowance - shares;\n            allowance[from][msg.sender] = newAllowance; // Underflow is checked\n            emit Approval(from, msg.sender, newAllowance);\n        }\n    }\n\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param shares of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param shares The token shares to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] += amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n            owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n    function mint(uint256 amount) public returns (bool) {\n        User memory user = users[msg.sender];\n\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        yetiToken.sendToSYETI(msg.sender, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        yetiToken.transfer(to, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n\n    /** \n     * Buyback function called by owner of function. Keeps track of the \n     */\n    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {\n        require(_YUSDToSell != 0, \"Zero amount\");\n        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, \"Not enough YUSD in contract\");\n        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);\n    }\n\n    /** \n     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.\n     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock \n     * in order to activate. \n     * No YUSDToSell param since this just does 5% of the YUSD in the contract.\n     */\n    function publicBuyBack(address _routerAddress) external {\n        uint256 YUSDBalance = yusdToken.balanceOf(address(this));\n        require(YUSDBalance != 0, \"No YUSD in contract\");\n        require(lastBuybackTime + 169 hours < block.timestamp, \"Can only publicly buy back every 169 hours\");\n        // Get 5% of the YUSD in the contract\n        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract\n        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);\n        _buyBack(_routerAddress, YUSDToSell, 0);\n    }\n\n    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. \n    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {\n        // Checks internal mapping to see if router is valid\n        require(validRouters[_routerAddress] == true, \"Invalid router passed in\");\n        require(yusdToken.approve(_routerAddress, 0));\n        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));\n        lastBuybackTime = block.timestamp;\n        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));\n        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);\n    }\n\n    // Rebase function for adding new value to the sYETI - YETI ratio. \n    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }\n\n    // Sums YUSD balance + old price. \n    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI \n    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.\n    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);\n    }\n\n    // Sets new transfer ratio for rebasing\n    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {\n        require(newTransferRatio != 0, \"Zero transfer ratio\");\n        require(newTransferRatio <= 1e18, \"Transfer ratio too high\");\n        transferRatio = newTransferRatio;\n    }\n    \n    // TODO - add time delay for setting new valid router. \n    function addValidRouter(address _routerAddress) external onlyOwner {\n        require(_routerAddress != address(0), \"Invalid router address\");\n        validRouters[_routerAddress] = true;\n    }\n\n    // TODO - add time delay for invalidating router. \n    function removeValidRouter(address _routerAddress) external onlyOwner {\n        validRouters[_routerAddress] = false;\n    }\n\n    // Safe divide\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b != 0, \"BoringMath: Div By 0\");\n        return a / b;\n    }\n}\n\n\n",
        "CodeNames": [
            "sYETIToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "effectiveYetiTokenBalance"
                ],
                "Type": " Yeti token rebase checks the additional token amount incorrectly",
                "Description": "\n\nThe condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market.\nAs it's not checked, the amount added to effectiveYetiTokenBalance during rebase can exceed the actual amount of the Yeti tokens owned by the contract.\nAs the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.\n\nThe deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one.\nIn this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users\u2019 claims.\nIn other words, the contract will be in default if enough users claim after that.\n\n\nNow the whole balance amount is used instead of the amount bought back from market.\n\nRebasing amount is added to effectiveYetiTokenBalance, so it should be limited by extra Yeti tokens, not the whole balance:\n<https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247\n\n",
                "Repair": "\nIt looks like only extra tokens should be used for the check, i.e. yetiToken.balance effectiveYetiTokenBalance.\n\nNow:\nsolidity\nfunction rebase() external {\n        ...\n    uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));\n    uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);\n    uint256 additionalYetiTokenBalance = ...\n    if (yetiTokenBalance < additionalYetiTokenBalance) {\n            additionalYetiTokenBalance = yetiTokenBalance;\n    }\n    effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance);\n...\nfunction _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {\n    uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);\n    uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n    return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance);\n}\n\nAs the _getValueOfContract function isn't used elsewhere, the logic can be simplified.\nTo be:\nsolidity\nfunction rebase() external {\n    ...\n    uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);\n    uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);\n    uint256 additionalYetiTokenBalance = ...\n    if (additionalYetiTokenBalance  adjustedYetiTokenBalance) {\n            additionalYetiTokenBalance = adjustedYetiTokenBalance;\n    }\n    effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance);\n...\nfunction _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n    uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n    return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance);\n}\n\n\nkingyetifinance (Yeti finance) disagreed with severity and confirmed(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/121):\n  @LilYeti: \n \n This is the logic for the fix which we have already done: \n \n if (yetiTokenBalance effectiveYetiTokenBalance < additionalYetiTokenBalance) \n \n Will look into this again before confirming as fixed to see if it is the same as the suggested error. \n \n\n0xtruco (Yeti finance) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/121#issuecomment-1009823126):\n  https://github.com/code-423n4/2021-12-yetifinance/pull/12\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/IWhitelist.sol\";\nimport './Interfaces/IERC20.sol';\nimport \"./Interfaces/IWAsset.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/YetiCustomBase.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\n/*\n * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.\n *\n * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 constant public NAME = \"ActivePool\";\n\n    address internal borrowerOperationsAddress;\n    address internal troveManagerAddress;\n    address internal stabilityPoolAddress;\n    address internal defaultPoolAddress;\n    address internal troveManagerLiquidationsAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal collSurplusPoolAddress;\n\n    \n    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts \n    newColls internal poolColl;\n\n    // YUSD Debt tracker. Tracker of all debt in the system. \n    uint256 internal YUSDDebt;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);\n    event ActivePoolBalanceUpdated(address _collateral, uint _amount);\n    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);\n    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress,\n        address _troveManagerRedemptionsAddress,\n        address _collSurplusPoolAddress\n    )\n        external\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_collSurplusPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        whitelist = IWhitelist(_whitelistAddress);\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit WhitelistAddressChanged(_whitelistAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Internal Functions ---\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collateralBalance for a given collateral\n    *\n    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.\n    */\n    function getCollateral(address _collateral) public view override returns (uint) {\n        return poolColl.amounts[whitelist.getIndex(_collateral)];\n    }\n\n    /*\n    * Returns all collateral balances in state. Not necessarily the contract's actual balances.\n    */\n    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {\n        return (poolColl.tokens, poolColl.amounts);\n    }\n\n    // returns the VC value of a given collateralAddress in this contract\n    function getCollateralVC(address _collateral) external view override returns (uint) {\n        return whitelist.getValueVC(_collateral, getCollateral(_collateral));\n    }\n\n\n    /*\n    * Returns the VC of the contract\n    *\n    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.\n    *\n    * Computed when called by taking the collateral balances and\n    * multiplying them by the corresponding price and ratio and then summing that\n    */\n    function getVC() external view override returns (uint totalVC) {\n        uint len = poolColl.tokens.length;\n        for (uint256 i; i < len; ++i) {\n            address collateral = poolColl.tokens[i];\n            uint amount = poolColl.amounts[i];\n\n            uint collateralVC = whitelist.getValueVC(collateral, amount);\n\n            totalVC = totalVC.add(collateralVC);\n        }\n    }\n\n\n    // Debt that this pool holds. \n    function getYUSDDebt() external view override returns (uint) {\n        return YUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    // Internal function to send collateral to a different pool. \n    function _sendCollateral(address _to, address _collateral, uint _amount) internal {\n        uint index = whitelist.getIndex(_collateral);\n        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n        IERC20(_collateral).safeTransfer(_to, _amount);\n\n        emit ActivePoolBalanceUpdated(_collateral, _amount);\n        emit CollateralSent(_collateral, _to, _amount);\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. \n    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 len = _tokens.length;\n        require(len == _amounts.length, \"AP:Lengths\");\n        uint256 thisAmount;\n        for (uint256 i; i < len; ++i) {\n            thisAmount = _amounts[i];\n            if (thisAmount != 0) {\n                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails\n            }\n        }\n\n        if (_needsUpdateCollateral(_to)) {\n            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);\n        }\n\n        emit CollateralsSent(_tokens, _amounts, _to);\n        \n        return true;\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.\n    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,\n    // It also harvests rewards on the user's behalf. \n    // _from is where the reward balance is, _to is where to send the tokens. \n    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, \"AP:Lengths\");\n        for (uint256 i; i < tokensLen; ++i) {\n            if (whitelist.isWrapped(_tokens[i])) {\n                // Collects rewards automatically for that amount and unwraps for the original borrower. \n                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);\n            } else {\n                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails\n            }\n        }\n        return true;\n    }\n\n    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        _sendCollateral(_to, _token, _amount); // reverts if send fails\n        return true;\n    }\n\n    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        if (whitelist.isWrapped(_token)) {\n            // Collects rewards automatically for that amount and unwraps for the original borrower. \n            IWAsset(_token).unwrapFor(_from, _to, _amount);\n        } else {\n            _sendCollateral(_to, _token, _amount); // reverts if send fails\n        }\n        return true;\n    }\n\n    // View function that returns if the contract transferring to needs to have its balances updated. \n    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {\n        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));\n    }\n\n    // Increases the YUSD Debt of this pool. \n    function increaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveM();\n        YUSDDebt  = YUSDDebt.add(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // Decreases the YUSD Debt of this pool. \n    function decreaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        YUSDDebt = YUSDDebt.sub(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBOorTroveMorTMLorSP() internal view {\n        if (\n            msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerLiquidationsAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != defaultPoolAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != address(whitelist)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert(\"AP: External caller not allowed\");\n    }\n\n    // should be called by BorrowerOperations or DefaultPool\n    // __after__ collateral is transferred to this contract.\n    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);\n        emit ActivePoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // Adds collateral type from whitelist. \n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        poolColl.tokens.push(_collateral);\n        poolColl.amounts.push(0);\n    }\n\n}\n\n\n//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./BoringCrypto/BoringMath.sol\";\nimport \"./BoringCrypto/BoringERC20.sol\";\nimport \"./BoringCrypto/Domain.sol\";\nimport \"./BoringCrypto/ERC20.sol\";\nimport \"./BoringCrypto/IERC20.sol\";\nimport \"./BoringCrypto/BoringOwnable.sol\";\nimport \"./IsYETIRouter.sol\";\n\n\ninterface IYETIToken is IERC20 {\n    function sendToSYETI(address _sender, uint256 _amount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n// modified by BoringCrypto for DictatorDAO\n\n\n// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 \n// Each rebase increases the effective yetibalance by a certain amount of the total value\n// of the contract, which is equal to the yusd balance + the last price which the buyback \n// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200\n// of the total value of the contract is added to the effective yetibalance. Also updated on \n// mint and withdraw, because that is actual value that is added to the contract. \n\ncontract sYETIToken is IERC20, Domain, BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sYETI\";\n    string public constant name = \"Staked YETI Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 69 hours;\n    uint256 public effectiveYetiTokenBalance;\n    uint256 public lastBuybackTime;\n    uint256 public lastBuybackPrice;\n    uint256 public lastRebaseTime;\n    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. \n    IYETIToken public yetiToken;\n    IERC20 public yusdToken;\n    bool private addressesSet;\n\n\n    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain\n    // and do that one. \n    mapping(address => bool) public validRouters;\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);\n    event Rebase(uint additionalYetiTokenBalance);\n\n    function balanceOf(address user) public view override returns (uint256) {\n        return users[user].balance;\n    }\n\n    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        yetiToken = _yeti;\n        yusdToken = _yusd;\n        addressesSet = true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                uint128 shares128 = shares.to128();\n                users[from].balance = fromUser.balance - shares128; // Underflow is checked\n                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            uint256 newAllowance = spenderAllowance - shares;\n            allowance[from][msg.sender] = newAllowance; // Underflow is checked\n            emit Approval(from, msg.sender, newAllowance);\n        }\n    }\n\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param shares of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param shares The token shares to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] += amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n    \n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n            owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n    function mint(uint256 amount) public returns (bool) {\n        User memory user = users[msg.sender];\n\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        yetiToken.sendToSYETI(msg.sender, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        yetiToken.transfer(to, amount);\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n\n    /** \n     * Buyback function called by owner of function. Keeps track of the \n     */\n    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {\n        require(_YUSDToSell != 0, \"Zero amount\");\n        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, \"Not enough YUSD in contract\");\n        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);\n    }\n\n    /** \n     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.\n     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock \n     * in order to activate. \n     * No YUSDToSell param since this just does 5% of the YUSD in the contract.\n     */\n    function publicBuyBack(address _routerAddress) external {\n        uint256 YUSDBalance = yusdToken.balanceOf(address(this));\n        require(YUSDBalance != 0, \"No YUSD in contract\");\n        require(lastBuybackTime + 169 hours < block.timestamp, \"Can only publicly buy back every 169 hours\");\n        // Get 5% of the YUSD in the contract\n        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract\n        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);\n        _buyBack(_routerAddress, YUSDToSell, 0);\n    }\n\n    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. \n    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {\n        // Checks internal mapping to see if router is valid\n        require(validRouters[_routerAddress] == true, \"Invalid router passed in\");\n        require(yusdToken.approve(_routerAddress, 0));\n        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));\n        lastBuybackTime = block.timestamp;\n        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));\n        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);\n    }\n\n    // Rebase function for adding new value to the sYETI - YETI ratio. \n    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }\n\n    // Sums YUSD balance + old price. \n    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI \n    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.\n    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);\n    }\n\n    // Sets new transfer ratio for rebasing\n    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {\n        require(newTransferRatio != 0, \"Zero transfer ratio\");\n        require(newTransferRatio <= 1e18, \"Transfer ratio too high\");\n        transferRatio = newTransferRatio;\n    }\n    \n    // TODO - add time delay for setting new valid router. \n    function addValidRouter(address _routerAddress) external onlyOwner {\n        require(_routerAddress != address(0), \"Invalid router address\");\n        validRouters[_routerAddress] = true;\n    }\n\n    // TODO - add time delay for invalidating router. \n    function removeValidRouter(address _routerAddress) external onlyOwner {\n        validRouters[_routerAddress] = false;\n    }\n\n    // Safe divide\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b != 0, \"BoringMath: Div By 0\");\n        return a / b;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/IYetiRouter.sol\";\nimport \"../Interfaces/IERC20.sol\";\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../YUSDToken.sol\";\n\n// ERC20 router contract to be used for routing YUSD -> ERC20 and then wrapping.\n// simple router using TJ router. \ncontract ERC20Router is IYetiRouter {\n    using SafeMath for uint256;\n\n    address internal activePoolAddress;\n    address internal traderJoeRouter;\n    address internal yusdTokenAddress;\n    string public name;\n\n    constructor(\n        string memory _name,\n        address _activePoolAddress,\n        address _traderJoeRouter, \n        address _yusdTokenAddress\n    ) public {\n        name = _name;\n        activePoolAddress = _activePoolAddress;\n        traderJoeRouter = _traderJoeRouter;\n        yusdTokenAddress = _yusdTokenAddress;\n    }\n\n    // Takes the address of the token in, and gives a certain amount of token out.\n    // Auto transfers to active pool.\n    function route(\n        address _fromUser,\n        address _startingTokenAddress,\n        address _endingTokenAddress,\n        uint256 _amount,\n        uint256 _minSwapAmount\n    ) public override returns (uint256) {\n        require(\n            _startingTokenAddress == yusdTokenAddress,\n            \"Cannot route from a token other than YUSD\"\n        );\n        address[] memory path = new address[](2);\n        path[0] = yusdTokenAddress;\n        path[1] = _endingTokenAddress;\n        IERC20(yusdTokenAddress).transferFrom(_fromUser, address(this), _amount);\n        IERC20(yusdTokenAddress).approve(traderJoeRouter, _amount);\n        uint256[] memory amounts = IRouter(traderJoeRouter).swapExactTokensForTokens(\n            _amount,\n            1,\n            path,\n            activePoolAddress,\n            block.timestamp\n        );\n        require(\n            amounts[1] >= _minSwapAmount,\n            \"Did not receive enough tokens to account for slippage\"\n        );\n\n        return amounts[1];\n    }\n\n    function unRoute(\n        address _fromUser,\n        address _startingTokenAddress,\n        address _endingTokenAddress,\n        uint256 _amount,\n        uint256 _minSwapAmount\n    ) external override returns (uint256) {\n        require(\n            _endingTokenAddress == yusdTokenAddress,\n            \"Cannot unroute from a token other than YUSD\"\n        );\n        address[] memory path = new address[](2);\n        path[0] = _startingTokenAddress;\n        path[1] = yusdTokenAddress;\n        IERC20(_startingTokenAddress).transferFrom(_fromUser, address(this), _amount);\n        IERC20(_startingTokenAddress).approve(traderJoeRouter, _amount);\n        uint256[] memory amounts = IRouter(traderJoeRouter).swapExactTokensForTokens(\n            _amount,\n            1,\n            path,\n            _fromUser,\n            block.timestamp\n        );\n        require(\n            amounts[1] >= _minSwapAmount,\n            \"Did not receive enough tokens to account for slippage\"\n        );\n\n        return amounts[1];\n\n    }\n}\n\n// Router for Uniswap V2, performs YUSD -> YETI swaps\ninterface IRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\n\n",
        "CodeNames": [
            "ActivePool.sol",
            "sYETIToken.sol",
            "ERC20Router.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {\n    require(YUSDToSell  0, \"Zero amount\");\n    require(lastBuybackTime + 69 hours < block.timestamp, \"Must have 69 hours pass before another buyBack\");\n    yusdToken.approve(routerAddress, YUSDToSell);\n    uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);\n    lastBuybackTime = block.timestamp;\n    // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n    // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)\n    lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n    emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]);\n}\n"
                ],
                "Type": " Wrong  lastBuyBackPrice ",
                "Description": "\nThe sYETIToken.lastBuyBackPrice is set in buyBack and hardcoded as:\n\nsolidity\nfunction buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {\n    require(YUSDToSell  0, \"Zero amount\");\n    require(lastBuybackTime + 69 hours < block.timestamp, \"Must have 69 hours pass before another buyBack\");\n    yusdToken.approve(routerAddress, YUSDToSell);\n    uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);\n    lastBuybackTime = block.timestamp;\n    // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]\n    // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)\n    lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);\n    emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]);\n}\n\n\nIt divides the first and second return amounts of the swap, however, these amounts depend on the swap path parameter that is used by the caller.\nIf a swap path of length 3 is used, then this is obviously wrong.\nIt also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).\n\n\nThe lastBuyBackPrice will be wrong when using a different path.\nThis will lead rebases using a different yeti amount and the effectiveYetiTokenBalance being updated wrong.\n\n",
                "Repair": "\nVerify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.\n\nkingyetifinance (Yeti finance) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/206)\n  @LilYeti: The idea was that on launch we will likely use a curve pool to route through so this contract would change slightly. However it is valid and some more checks would be good to add. Moving to level 1 issue.\n\nalcueca (Judge) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/206#issuecomment-1013714211):\n  A medium severity rating is warranted.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "js\n    if (!_response.success) {return true;}\n    // Check for an invalid roundId that is 0\n    if (_response.roundId == 0) {return true;}\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (_response.timestamp == 0 || _response.timestamp  block.timestamp) {return true;}\n    // Check for non-positive price\n    if (_response.answer <= 0) {return true;}\n"
                ],
                "Type": " Should check return data from Chainlink aggregators",
                "Description": "\n\nThe latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.\n\nStale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.\n\nExample Medium Issue : <https://github.com/code-423n4/2021-08-notional-findings/issues/18\n\n\n1.  Navigate to the following contract.\n\n<https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578\n\n2.  Only the following checks are implemented.\n\njs\n    if (!_response.success) {return true;}\n    // Check for an invalid roundId that is 0\n    if (_response.roundId == 0) {return true;}\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (_response.timestamp == 0 || _response.timestamp  block.timestamp) {return true;}\n    // Check for non-positive price\n    if (_response.answer <= 0) {return true;}\n\n\n",
                "Repair": "\nConsider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:\nsolidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData();\nrequire(price  0, \"Chainlink price <= 0\"); \nrequire(answeredInRound = roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n\n\nkingyetifinance (Yeti finance) confirmed(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/91#issuecomment-1005398691):\n  @LilYeti: \n \n https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round\n \n https://github.com/code-423n4/2021-08-notional-findings/issues/92\n\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction sendCollaterals(address _to, address[] memory _tokens, uint[] memory _amounts) external override returns (bool) {\n    _requireCallerIsBOorTroveMorTMLorSP();\n    require(_tokens.length == _amounts.length);\n    for (uint i = 0; i < _tokens.length; i++) {\n        _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails\n    }\n\n    if (_needsUpdateCollateral(_to)) {\n        ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);\n    }\n    \n    return true;\n}\n",
                    "//solidity\nfunction _sendCollateral(address _to, address _collateral, uint _amount) internal returns (bool) {\n    uint index = whitelist.getIndex(_collateral);\n    poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n    bool sent = IERC20(_collateral).transfer(_to, _amount);\n    require(sent);\n\n    emit ActivePoolBalanceUpdated(_collateral, _amount);\n    emit CollateralSent(_collateral, _to, _amount);\n}\n",
                    "//solidity\npoolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n"
                ],
                "Type": " Unwhitelisted token can cause disaster",
                "Description": "\n\nContract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)\n\n\n1.  Navigate to contract at <https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol\n\n2.  Assume sendCollaterals function is called by one of allowed contract with a non whitelisted token and amount as 1\n\nsolidity\nfunction sendCollaterals(address _to, address[] memory _tokens, uint[] memory _amounts) external override returns (bool) {\n    _requireCallerIsBOorTroveMorTMLorSP();\n    require(_tokens.length == _amounts.length);\n    for (uint i = 0; i < _tokens.length; i++) {\n        _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails\n    }\n\n    if (_needsUpdateCollateral(_to)) {\n        ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);\n    }\n    \n    return true;\n}\n\n\n3.  This calls _sendCollateral with our non whitelisted token and amount as 1\n\nsolidity\nfunction _sendCollateral(address _to, address _collateral, uint _amount) internal returns (bool) {\n    uint index = whitelist.getIndex(_collateral);\n    poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n    bool sent = IERC20(_collateral).transfer(_to, _amount);\n    require(sent);\n\n    emit ActivePoolBalanceUpdated(_collateral, _amount);\n    emit CollateralSent(_collateral, _to, _amount);\n}\n\n4.  whitelist.getIndex(_collateral); will return 0 as our collateral is not whitelisted and will not be present in whitelist.getIndex(_collateral);. This means index will point to whitelisted collateral at index 0\n\n5.  poolColl.amounts[index] will get updated for whitelisted collateral at index 0 even though this collateral was never meant to be updated\n\nsolidity\npoolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n\n\n6.  Finally our non supported token gets transferred to recipient and since _needsUpdateCollateral is true so recipient poolColl.amounts gets increased even though recipient never received the whitelisted collateral\n\n7.  Finally sender pool amount will be reduced even though it has the whitelisted collateral and recipient pool amount will be increased even though it does not have whitelisted collateral\n\n",
                "Repair": "\nAdd a check to see if collateral to be transferred is whitelisted\n\nkingyetifinance (Yeti finance) disputed(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/146#issuecomment-1005436938):\n  @LilYeti: Thanks for the thorough run through. It is true, but this is abstracted away, all calls of sendCollateral are internal / between contracts in our codebase, and there are checks for valid collateral in whitelist before this. \n\nalcueca (Judge) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/146#issuecomment-1013823086):\n  Validating data integrity outside a function inside the same contract would be a low severity. Validating data integrity in an external contract is medium severity. Many things can go wrong.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/IWhitelist.sol\";\nimport './Interfaces/IERC20.sol';\nimport \"./Interfaces/IWAsset.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/YetiCustomBase.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\n/*\n * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.\n *\n * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 constant public NAME = \"ActivePool\";\n\n    address internal borrowerOperationsAddress;\n    address internal troveManagerAddress;\n    address internal stabilityPoolAddress;\n    address internal defaultPoolAddress;\n    address internal troveManagerLiquidationsAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal collSurplusPoolAddress;\n\n    \n    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts \n    newColls internal poolColl;\n\n    // YUSD Debt tracker. Tracker of all debt in the system. \n    uint256 internal YUSDDebt;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);\n    event ActivePoolBalanceUpdated(address _collateral, uint _amount);\n    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);\n    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress,\n        address _troveManagerRedemptionsAddress,\n        address _collSurplusPoolAddress\n    )\n        external\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_collSurplusPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        whitelist = IWhitelist(_whitelistAddress);\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit WhitelistAddressChanged(_whitelistAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Internal Functions ---\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collateralBalance for a given collateral\n    *\n    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.\n    */\n    function getCollateral(address _collateral) public view override returns (uint) {\n        return poolColl.amounts[whitelist.getIndex(_collateral)];\n    }\n\n    /*\n    * Returns all collateral balances in state. Not necessarily the contract's actual balances.\n    */\n    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {\n        return (poolColl.tokens, poolColl.amounts);\n    }\n\n    // returns the VC value of a given collateralAddress in this contract\n    function getCollateralVC(address _collateral) external view override returns (uint) {\n        return whitelist.getValueVC(_collateral, getCollateral(_collateral));\n    }\n\n\n    /*\n    * Returns the VC of the contract\n    *\n    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.\n    *\n    * Computed when called by taking the collateral balances and\n    * multiplying them by the corresponding price and ratio and then summing that\n    */\n    function getVC() external view override returns (uint totalVC) {\n        uint len = poolColl.tokens.length;\n        for (uint256 i; i < len; ++i) {\n            address collateral = poolColl.tokens[i];\n            uint amount = poolColl.amounts[i];\n\n            uint collateralVC = whitelist.getValueVC(collateral, amount);\n\n            totalVC = totalVC.add(collateralVC);\n        }\n    }\n\n\n    // Debt that this pool holds. \n    function getYUSDDebt() external view override returns (uint) {\n        return YUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    // Internal function to send collateral to a different pool. \n    function _sendCollateral(address _to, address _collateral, uint _amount) internal {\n        uint index = whitelist.getIndex(_collateral);\n        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n        IERC20(_collateral).safeTransfer(_to, _amount);\n\n        emit ActivePoolBalanceUpdated(_collateral, _amount);\n        emit CollateralSent(_collateral, _to, _amount);\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. \n    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 len = _tokens.length;\n        require(len == _amounts.length, \"AP:Lengths\");\n        uint256 thisAmount;\n        for (uint256 i; i < len; ++i) {\n            thisAmount = _amounts[i];\n            if (thisAmount != 0) {\n                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails\n            }\n        }\n\n        if (_needsUpdateCollateral(_to)) {\n            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);\n        }\n\n        emit CollateralsSent(_tokens, _amounts, _to);\n        \n        return true;\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.\n    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,\n    // It also harvests rewards on the user's behalf. \n    // _from is where the reward balance is, _to is where to send the tokens. \n    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, \"AP:Lengths\");\n        for (uint256 i; i < tokensLen; ++i) {\n            if (whitelist.isWrapped(_tokens[i])) {\n                // Collects rewards automatically for that amount and unwraps for the original borrower. \n                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);\n            } else {\n                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails\n            }\n        }\n        return true;\n    }\n\n    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        _sendCollateral(_to, _token, _amount); // reverts if send fails\n        return true;\n    }\n\n    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        if (whitelist.isWrapped(_token)) {\n            // Collects rewards automatically for that amount and unwraps for the original borrower. \n            IWAsset(_token).unwrapFor(_from, _to, _amount);\n        } else {\n            _sendCollateral(_to, _token, _amount); // reverts if send fails\n        }\n        return true;\n    }\n\n    // View function that returns if the contract transferring to needs to have its balances updated. \n    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {\n        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));\n    }\n\n    // Increases the YUSD Debt of this pool. \n    function increaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveM();\n        YUSDDebt  = YUSDDebt.add(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // Decreases the YUSD Debt of this pool. \n    function decreaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        YUSDDebt = YUSDDebt.sub(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBOorTroveMorTMLorSP() internal view {\n        if (\n            msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerLiquidationsAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != defaultPoolAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != address(whitelist)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert(\"AP: External caller not allowed\");\n    }\n\n    // should be called by BorrowerOperations or DefaultPool\n    // __after__ collateral is transferred to this contract.\n    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);\n        emit ActivePoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // Adds collateral type from whitelist. \n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        poolColl.tokens.push(_collateral);\n        poolColl.amounts.push(0);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "ActivePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "getVC()"
                ],
                "Type": " Out of gas.",
                "Description": "\nThere is no upper limit on poolColl.tokens[], it increments each time  when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise  and that there is no implemented function to reduce the array size.\n\n\nFor every call  getVC() function which computed  contain the VC value of a given collateralAddress is listed in poolColl.tokens[] array, the gas consumption can be more expensive each time that a new collateral address is appended to the  array, until reaching an \"Out of Gas\" error or a \"Block Gas Limit\" in the worst scenario.\n\n\n<https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/ActivePool.sol#L268\n\n<https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/DefaultPool.sol#L184\n\n\nRemix\n\n",
                "Repair": "\nArray's length should be checked.\n\nkingyetifinance (Yeti finance) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/151#issuecomment-1005461661):\n  @LilYeti: This is a known problem, and we are yet to test the upper limits of the contracts as is. Not sure how more theoretical issues like these are scored, but I would agree with that it is a medium to high risk based on how likely it is to happen * the potential effects. The worst possible outcome is that funds are locked in the protocol because it costs too much gas to do a withdrawal. We are still doing analysis on this, judges do what you want with this information. \n  We would actually recommend it be a severity level 2, but it does have high potential risk. \n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IYUSDToken.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ICommunityIssuance.sol\";\nimport \"./Interfaces/IWhitelist.sol\";\nimport \"./Interfaces/IERC20.sol\";\nimport \"./Interfaces/IWAsset.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/LiquitySafeMath128.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\n\n/*\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n *\n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n *\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositor\u2019s snapshots of P and S, and the latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).\n *\n *\n *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n *\n * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n *\n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n *\n * Each deposit is tagged with the address of the front end through which it was made.\n *\n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\n *\n */\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"StabilityPool\";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address => uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\n\n    /* depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor's snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     */\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\n\n    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct\n    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\n    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\n\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     *\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     */\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.\n     *\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n     *\n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale => sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings\n     */\n    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;\n\n    /*\n     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\n     *\n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     */\n    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /*\n     * Returns all collateral balances in state. Not necessarily the contract's actual balances.\n     */\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /*  provideToSP():\n     *\n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end's accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /*  withdrawFromSP():\n     *\n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end's accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /*\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         *\n         */\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /*\n         * Calculate the YETI-per-unit staked.  Division uses a \"feedback\" error correction, to keep the\n         * cumulative error low in the running total G:\n         *\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n         */\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /*\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /*\n    * Compute the YUSD and Collateral amount rewards. Uses a \"feedback\" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    *\n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate \"per-unit-staked\" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this \"division before multiplication\", however, it is intended.\n    */\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256[](amountsLen);\n        uint256 currentP = P;\n\n        for (uint256 i; i < amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset <= _totalYUSDDeposits, \"SP:This debt less than totalYUSD\");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /*\n             * Add 1 to make error in quotient positive. We want \"slightly too much\" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             */\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);\n        for (uint256 i; i < amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i < amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, \"SP: YUSDLoss < 1\");\n        /*\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         */\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /*\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         *\n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         */\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i < assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, \"SP: P = 0\");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    /* Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     */\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address[](0);\n            uint256[] memory emptyUint = new uint256[](0);\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256[](assetsLen);\n        for (uint256 i; i < assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /*\n         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /*\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     */\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /*\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         */\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /*\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     *\n     * D0 is the last recorded value of the front end's total tagged deposits.\n     */\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /*\n         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         */\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /*\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\n     */\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /*\n     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor's snapshot of the product P, taken at the last time\n     * when one of the front end's tagged deposits updated their deposit.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot < currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         */\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff >= 2\n            compoundedStake = 0;\n        }\n\n        /*\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         *\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded deposit should slightly less\n         * than it's theoretical value.\n         *\n         * Thus it's unclear whether this line is still really needed.\n         */\n        if (compoundedStake < initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, \"SP:Length mismatch\");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i < assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i < collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i < allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end's YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor's YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR >= MCR, \"SP:No Withdraw when troveICR<MCR\");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, \"SP: require nonzero deposit\");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, \"SP: User must have no deposit\");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, \"SP: Amount must be non-zero\");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            \"SP: Frontend already registered\"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            \"SP: Frontend not registered\"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate <= DECIMAL_PRECISION,\n            \"SP:Invalid Kickback rate\"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert(\"SP: External caller not allowed\");\n    }\n\n    // Should be called by ActivePool\n    // __after__ collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/IWhitelist.sol\";\nimport './Interfaces/IERC20.sol';\nimport \"./Interfaces/IWAsset.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/YetiCustomBase.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\n\n/*\n * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.\n *\n * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 constant public NAME = \"ActivePool\";\n\n    address internal borrowerOperationsAddress;\n    address internal troveManagerAddress;\n    address internal stabilityPoolAddress;\n    address internal defaultPoolAddress;\n    address internal troveManagerLiquidationsAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal collSurplusPoolAddress;\n\n    \n    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts \n    newColls internal poolColl;\n\n    // YUSD Debt tracker. Tracker of all debt in the system. \n    uint256 internal YUSDDebt;\n\n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);\n    event ActivePoolBalanceUpdated(address _collateral, uint _amount);\n    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);\n    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress,\n        address _troveManagerRedemptionsAddress,\n        address _collSurplusPoolAddress\n    )\n        external\n        onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_collSurplusPoolAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        whitelist = IWhitelist(_whitelistAddress);\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit WhitelistAddressChanged(_whitelistAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Internal Functions ---\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collateralBalance for a given collateral\n    *\n    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.\n    */\n    function getCollateral(address _collateral) public view override returns (uint) {\n        return poolColl.amounts[whitelist.getIndex(_collateral)];\n    }\n\n    /*\n    * Returns all collateral balances in state. Not necessarily the contract's actual balances.\n    */\n    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {\n        return (poolColl.tokens, poolColl.amounts);\n    }\n\n    // returns the VC value of a given collateralAddress in this contract\n    function getCollateralVC(address _collateral) external view override returns (uint) {\n        return whitelist.getValueVC(_collateral, getCollateral(_collateral));\n    }\n\n\n    /*\n    * Returns the VC of the contract\n    *\n    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.\n    *\n    * Computed when called by taking the collateral balances and\n    * multiplying them by the corresponding price and ratio and then summing that\n    */\n    function getVC() external view override returns (uint totalVC) {\n        uint len = poolColl.tokens.length;\n        for (uint256 i; i < len; ++i) {\n            address collateral = poolColl.tokens[i];\n            uint amount = poolColl.amounts[i];\n\n            uint collateralVC = whitelist.getValueVC(collateral, amount);\n\n            totalVC = totalVC.add(collateralVC);\n        }\n    }\n\n\n    // Debt that this pool holds. \n    function getYUSDDebt() external view override returns (uint) {\n        return YUSDDebt;\n    }\n\n    // --- Pool functionality ---\n\n    // Internal function to send collateral to a different pool. \n    function _sendCollateral(address _to, address _collateral, uint _amount) internal {\n        uint index = whitelist.getIndex(_collateral);\n        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);\n        IERC20(_collateral).safeTransfer(_to, _amount);\n\n        emit ActivePoolBalanceUpdated(_collateral, _amount);\n        emit CollateralSent(_collateral, _to, _amount);\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. \n    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 len = _tokens.length;\n        require(len == _amounts.length, \"AP:Lengths\");\n        uint256 thisAmount;\n        for (uint256 i; i < len; ++i) {\n            thisAmount = _amounts[i];\n            if (thisAmount != 0) {\n                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails\n            }\n        }\n\n        if (_needsUpdateCollateral(_to)) {\n            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);\n        }\n\n        emit CollateralsSent(_tokens, _amounts, _to);\n        \n        return true;\n    }\n\n    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.\n    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,\n    // It also harvests rewards on the user's behalf. \n    // _from is where the reward balance is, _to is where to send the tokens. \n    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {\n        _requireCallerIsBOorTroveMorTMLorSP();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, \"AP:Lengths\");\n        for (uint256 i; i < tokensLen; ++i) {\n            if (whitelist.isWrapped(_tokens[i])) {\n                // Collects rewards automatically for that amount and unwraps for the original borrower. \n                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);\n            } else {\n                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails\n            }\n        }\n        return true;\n    }\n\n    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        _sendCollateral(_to, _token, _amount); // reverts if send fails\n        return true;\n    }\n\n    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality\n    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {\n        _requireCallerIsBorrowerOperations();\n        if (whitelist.isWrapped(_token)) {\n            // Collects rewards automatically for that amount and unwraps for the original borrower. \n            IWAsset(_token).unwrapFor(_from, _to, _amount);\n        } else {\n            _sendCollateral(_to, _token, _amount); // reverts if send fails\n        }\n        return true;\n    }\n\n    // View function that returns if the contract transferring to needs to have its balances updated. \n    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {\n        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));\n    }\n\n    // Increases the YUSD Debt of this pool. \n    function increaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveM();\n        YUSDDebt  = YUSDDebt.add(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // Decreases the YUSD Debt of this pool. \n    function decreaseYUSDDebt(uint _amount) external override {\n        _requireCallerIsBOorTroveMorSP();\n        YUSDDebt = YUSDDebt.sub(_amount);\n        emit ActivePoolYUSDDebtUpdated(YUSDDebt);\n    }\n\n    // --- 'require' functions ---\n\n    function _requireCallerIsBOorTroveMorTMLorSP() internal view {\n        if (\n            msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerLiquidationsAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != defaultPoolAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress &&\n            msg.sender != stabilityPoolAddress &&\n            msg.sender != troveManagerRedemptionsAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        if (msg.sender != borrowerOperationsAddress &&\n            msg.sender != troveManagerAddress) {\n                _revertWrongFuncCaller();\n            }\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != address(whitelist)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert(\"AP: External caller not allowed\");\n    }\n\n    // should be called by BorrowerOperations or DefaultPool\n    // __after__ collateral is transferred to this contract.\n    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);\n        emit ActivePoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // Adds collateral type from whitelist. \n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        poolColl.tokens.push(_collateral);\n        poolColl.amounts.push(0);\n    }\n\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"./Ownable.sol\";\nimport \"../Interfaces/IBaseOracle.sol\";\nimport \"../Interfaces/IWhitelist.sol\";\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Interfaces/IPriceCurve.sol\";\nimport \"../Interfaces/IActivePool.sol\";\nimport \"../Interfaces/IDefaultPool.sol\";\nimport \"../Interfaces/IStabilityPool.sol\";\nimport \"../Interfaces/ICollSurplusPool.sol\";\nimport \"../Interfaces/IERC20.sol\";\nimport \"./LiquityMath.sol\";\nimport \"./CheckContract.sol\";\n\n\n/**\n * Whitelist is the contract that keeps track of all the assets that the system takes as collateral.\n * It has onlyOwner functions to add or deprecate collaterals from the whitelist, change the price\n * curve, price feed, safety ratio, etc.\n */\n\ncontract Whitelist is Ownable, IWhitelist, IBaseOracle, CheckContract {\n    using SafeMath for uint256;\n\n    struct CollateralParams {\n        // Safety ratio\n        uint256 ratio; // 10**18 * the ratio. i.e. ratio = .95 * 10**18 for 95%. More risky collateral has a lower ratio\n        address oracle;\n        uint256 decimals;\n        address priceCurve;\n        uint256 index;\n        bool active;\n        bool isWrapped;\n        address defaultRouter;\n    }\n\n    IActivePool activePool;\n    IDefaultPool defaultPool;\n    IStabilityPool stabilityPool;\n    ICollSurplusPool collSurplusPool;\n    address borrowerOperationsAddress;\n    bool private addressesSet;\n\n    mapping(address => CollateralParams) public collateralParams;\n\n    mapping(address => bool) public validRouter;\n\n    // list of all collateral types in collateralParams (active and deprecated)\n    // Addresses for easy access\n    address[] public validCollateral; // index maps to token address.\n\n    event CollateralAdded(address _collateral);\n    event CollateralDeprecated(address _collateral);\n    event CollateralUndeprecated(address _collateral);\n    event CollateralRemoved(address _collateral);\n    event OracleChanged(address _collateral);\n    event PriceCurveChanged(address _collateral);\n    event RatioChanged(address _collateral);\n\n    // Require that the collateral exists in the whitelist. If it is not the 0th index, and the\n    // index is still 0 then it does not exist in the mapping.\n    // no require here for valid collateral 0 index because that means it exists. \n    modifier exists(address _collateral) {\n        _exists(_collateral);\n        _;\n    }\n\n    // Calling from here makes it not inline, reducing contract size and gas. \n    function _exists(address _collateral) internal view {\n        if (validCollateral[0] != _collateral) {\n            require(collateralParams[_collateral].index != 0, \"collateral does not exist\");\n        }\n    }\n\n    // ----------Only Owner Setter Functions----------\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _borrowerOperationsAddress\n    ) external override onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        addressesSet = true;\n    }\n\n    function addCollateral(\n        address _collateral,\n        uint256 _minRatio,\n        address _oracle,\n        uint256 _decimals,\n        address _priceCurve, \n        bool _isWrapped, \n        address _routerAddress\n    ) external onlyOwner {\n        checkContract(_collateral);\n        checkContract(_oracle);\n        checkContract(_priceCurve);\n        checkContract(_routerAddress);\n        // If collateral list is not 0, and if the 0th index is not equal to this collateral,\n        // then if index is 0 that means it is not set yet.\n        require(_minRatio < 11e17, \"ratio must be less than 1.10\"); //=> greater than 1.1 would mean taking out more YUSD than collateral VC\n\n        if (validCollateral.length != 0) {\n            require(validCollateral[0] != _collateral && collateralParams[_collateral].index == 0, \"collateral already exists\");\n        }\n\n        validCollateral.push(_collateral);\n        collateralParams[_collateral] = CollateralParams(\n            _minRatio,\n            _oracle,\n            _decimals,\n            _priceCurve,\n            validCollateral.length - 1, \n            true,\n            _isWrapped,\n            _routerAddress\n        );\n\n        activePool.addCollateralType(_collateral);\n        defaultPool.addCollateralType(_collateral);\n        stabilityPool.addCollateralType(_collateral);\n        collSurplusPool.addCollateralType(_collateral);\n\n        // throw event\n        emit CollateralAdded(_collateral);\n    }\n\n    /**\n     * Deprecate collateral by not allowing any more collateral to be added of this type.\n     * Still can interact with it via validCollateral and CollateralParams\n     */\n    function deprecateCollateral(address _collateral) external exists(_collateral) onlyOwner {\n        checkContract(_collateral);\n\n        require(collateralParams[_collateral].active, \"collateral already deprecated\");\n\n        collateralParams[_collateral].active = false;\n\n        // throw event\n        emit CollateralDeprecated(_collateral);\n    }\n\n    /**\n     * Undeprecate collateral by allowing more collateral to be added of this type.\n     * Still can interact with it via validCollateral and CollateralParams\n     */\n    function undeprecateCollateral(address _collateral) external exists(_collateral) onlyOwner {\n        checkContract(_collateral);\n\n        require(!collateralParams[_collateral].active, \"collateral is already active\");\n\n        collateralParams[_collateral].active = true;\n\n        // throw event\n        emit CollateralUndeprecated(_collateral);\n    }\n\n    /**\n     * Function to change oracles\n     */\n    function changeOracle(address _collateral, address _oracle)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        checkContract(_oracle);\n        collateralParams[_collateral].oracle = _oracle;\n\n        // throw event\n        emit OracleChanged(_collateral);\n    }\n\n    /**\n     * Function to change price curve\n     */\n    function changePriceCurve(address _collateral, address _priceCurve)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        checkContract(_priceCurve);\n        uint lastFeePercent;\n        uint lastFeeTime; \n        (lastFeePercent, lastFeeTime) = IPriceCurve(collateralParams[_collateral].priceCurve).getFeeCapAndTime();\n        IPriceCurve(_priceCurve).setFeeCapAndTime(lastFeePercent, lastFeeTime);\n        collateralParams[_collateral].priceCurve = _priceCurve;\n\n        // throw event\n        emit PriceCurveChanged(_collateral);\n    }\n\n    /**\n     * Function to change Safety ratio.\n     */\n    function changeRatio(address _collateral, uint256 _ratio)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        require(_ratio < 11e17, \"ratio must be less than 1.10\"); //=> greater than 1.1 would mean taking out more YUSD than collateral VC\n        require(collateralParams[_collateral].ratio < _ratio, \"New SR must be greater than previous SR\");\n        collateralParams[_collateral].ratio = _ratio;\n\n        // throw event\n        emit RatioChanged(_collateral);\n    }\n\n    // -----------Routers--------------\n\n    function setDefaultRouter(address _collateral, address _router) external override onlyOwner exists(_collateral) {\n        checkContract(_router);\n        collateralParams[_collateral].defaultRouter = _router;\n    }\n\n    function getDefaultRouterAddress(address _collateral) external view override exists(_collateral) returns (address) {\n        return collateralParams[_collateral].defaultRouter;\n    }\n\n\n    // ---------- View Functions -----------\n\n\n    function isValidRouter(address _router) external override view returns (bool) {\n        return validRouter[_router];\n    }\n\n    function isWrapped(address _collateral) external view override returns (bool) {\n        return collateralParams[_collateral].isWrapped;\n    }\n\n    function getValidCollateral() external view override returns (address[] memory) {\n        return validCollateral;\n    }\n\n    function getRatio(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return collateralParams[_collateral].ratio;\n    }\n\n    function getOracle(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (address)\n    {\n        return collateralParams[_collateral].oracle;\n    }\n\n    function getPriceCurve(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (address)\n    {\n        return collateralParams[_collateral].priceCurve;\n    }\n\n    function getIsActive(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (bool)\n    {\n        return collateralParams[_collateral].active;\n    }\n\n    function getDecimals(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return collateralParams[_collateral].decimals;\n    }\n\n    function getIndex(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return (collateralParams[_collateral].index);\n    }\n\n    // Returned as fee percentage * 10**18. View function for external callers.\n    function getFee(\n        address _collateral,\n        uint256 _collateralVCInput,\n        uint256 _collateralVCBalancePost,\n        uint256 _totalVCBalancePre,\n        uint256 _totalVCBalancePost\n    ) external view override exists(_collateral) returns (uint256 fee) {\n        IPriceCurve priceCurve = IPriceCurve(collateralParams[_collateral].priceCurve);\n        return priceCurve.getFee(_collateralVCInput, _collateralVCBalancePost, _totalVCBalancePre, _totalVCBalancePost);\n    }\n\n    // Returned as fee percentage * 10**18. Non view function for just borrower operations to call.\n    function getFeeAndUpdate(\n        address _collateral,\n        uint256 _collateralVCInput,\n        uint256 _collateralVCBalancePost,\n        uint256 _totalVCBalancePre,\n        uint256 _totalVCBalancePost\n    ) external override exists(_collateral) returns (uint256 fee) {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"caller must be BO\"\n        );\n        IPriceCurve priceCurve = IPriceCurve(collateralParams[_collateral].priceCurve);\n        return\n            priceCurve.getFeeAndUpdate(\n                _collateralVCInput,\n                _collateralVCBalancePost,\n                _totalVCBalancePre,\n                _totalVCBalancePost\n            );\n    }\n\n    // should return 10**18 times the price in USD of 1 of the given _collateral\n    function getPrice(address _collateral)\n        public\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        IPriceFeed collateral_priceFeed = IPriceFeed(collateralParams[_collateral].oracle);\n        return collateral_priceFeed.fetchPrice_v();\n    }\n\n    // Gets the value of that collateral type, of that amount, in USD terms.\n    function getValueUSD(address _collateral, uint256 _amount)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        uint256 decimals = collateralParams[_collateral].decimals;\n        uint256 price = getPrice(_collateral);\n        return price.mul(_amount).div(10**decimals);\n    }\n\n    // Gets the value of that collateral type, of that amount, in VC terms.\n    function getValueVC(address _collateral, uint256 _amount)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        // uint256 price = getPrice(_collateral);\n        // uint256 decimals = collateralParams[_collateral].decimals;\n        // uint256 ratio = collateralParams[_collateral].ratio;\n        // return (price.mul(_amount).mul(ratio).div(10**(18 + decimals)));\n\n        // div by 10**18 for price adjustment\n        // and divide by 10 ** decimals for decimal adjustment\n        // do inline since this function is called often\n        return ((getPrice(_collateral)).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals)));\n    }\n\n\n}\n\n\n",
        "CodeNames": [
            "StabilityPool.sol",
            "ActivePool.sol",
            "Whitelist.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction addCollateral(\n    address _collateral,\n    uint256 _minRatio,\n    address _oracle,\n    uint256 _decimals,\n    address _priceCurve, \n    bool _isWrapped\n) external onlyOwner {\n    checkContract(_collateral);\n    checkContract(_oracle);\n    checkContract(_priceCurve);\n    // If collateral list is not 0, and if the 0th index is not equal to this collateral,\n    // then if index is 0 that means it is not set yet.\n    // @audit evaluates validCollateral[0] != validCollateral[0] which is obv. false = skips require check\n    if (validCollateral.length != 0 && validCollateral[0] != _collateral) {\n        require(collateralParams[_collateral].index == 0, \"collateral already exists\");\n    }\n\n    validCollateral.push(_collateral);\n    // overwrites parameters\n    collateralParams[_collateral] = CollateralParams(\n        _minRatio,\n        _oracle,\n        _decimals,\n        true,\n        _priceCurve,\n        validCollateral.length 1, \n        _isWrapped\n    );\n}\n"
                ],
                "Type": " Collateral parameters can be overwritten",
                "Description": "\nIt's possible to repeatedly add the first collateral token in validCollateral through the Whitelist.addCollateral function.\nThe validCollateral[0] != _collateral check will return false and skip further checks.\n\n\nOwner calls addCollateral(collateral=validCollateral[0]):\n\nsolidity\nfunction addCollateral(\n    address _collateral,\n    uint256 _minRatio,\n    address _oracle,\n    uint256 _decimals,\n    address _priceCurve, \n    bool _isWrapped\n) external onlyOwner {\n    checkContract(_collateral);\n    checkContract(_oracle);\n    checkContract(_priceCurve);\n    // If collateral list is not 0, and if the 0th index is not equal to this collateral,\n    // then if index is 0 that means it is not set yet.\n    // @audit evaluates validCollateral[0] != validCollateral[0] which is obv. false = skips require check\n    if (validCollateral.length != 0 && validCollateral[0] != _collateral) {\n        require(collateralParams[_collateral].index == 0, \"collateral already exists\");\n    }\n\n    validCollateral.push(_collateral);\n    // overwrites parameters\n    collateralParams[_collateral] = CollateralParams(\n        _minRatio,\n        _oracle,\n        _decimals,\n        true,\n        _priceCurve,\n        validCollateral.length 1, \n        _isWrapped\n    );\n}\n\n\n\nThe collateral parameters collateralParams are re-initialized which can break the existing accounting.\nThe collateral token also exists multiple times in validCollateral.\n\n",
                "Repair": "\nFix the check. It should be something like:\n\nsolidity\nif (validCollateral.length  0) {\n    require(collateralParams[_collateral].index == 0 && validCollateral[0] != _collateral, \"collateral already exists\");\n}\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/IPriceCurve.sol\";\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\n\n/** \n * This contract is used to calculate the variable fee for an input of tokens. \n * Uses three linear piecewise functions to calculate the fee, and the average \n * of the system collateralization by that asset before and after the tx. \n */\ncontract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {\n    using SafeMath for uint256;\n\n    string name;\n    uint256 m1;\n    uint256 b1;\n    uint256 cutoff1;\n    uint256 m2;\n    uint256 b2;\n    bool b2Negative;\n    uint256 cutoff2;\n    uint256 m3;\n    uint256 b3;\n    bool b3Negative;\n    uint256 decayTime;\n\n    uint lastFeeTime;\n    uint lastFeePercent;\n    uint dollarCap;\n    address whitelistAddress;\n    bool private addressesSet;\n\n    /** \n     * f1 = m1 * x + b1\n     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2\n     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3\n     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages\n     * Decimal precision = 1e18\n     */\n\n    /** \n     * Function for setting slopes and intercepts of linear functions used for fee calculations. \n     */\n    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {\n        require(_cutoff1 <= _cutoff2, \"Cutoffs must be increasing\");\n        name = _name;\n        m1 = _m1;\n        b1 = _b1;\n        m2 = _m2;\n        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);\n        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);\n        if (m2Val > m1Val) {\n            b2Negative = true;\n            b2 = m2Val.sub(m1Val);\n        } else {\n            b2 = m1Val.sub(m2Val);\n        }\n        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));\n        cutoff1 = _cutoff1;\n        m3 = _m3;\n        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);\n        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);\n        if (m3Val > m2Val) {\n            b3Negative = true;\n            b3 = m3Val.sub(m2Val);\n        } else {\n            b3 = m2Val.sub(m3Val);\n        }\n        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));\n        cutoff2 = _cutoff2;\n        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.\n        decayTime = 5 days;\n    }\n\n    // Set the whitelist address so that the fee can only be updated by whitelistAddress\n    function setAddresses(address _whitelistAddress) external override onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        whitelistAddress = _whitelistAddress;\n        addressesSet = true;\n    }\n\n    // Set the decay time in seconds\n    function setDecayTime(uint _decayTime) external override onlyOwner {\n        decayTime = _decayTime;\n    }\n\n    // Gets the fee cap and time currently. Used for setting new values for next price curve. \n    function getFeeCapAndTime() external override view returns (uint256, uint256) {\n        return (lastFeePercent, lastFeeTime);\n    }\n\n    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. \n    // Called only by whitelist. \n    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {\n        require(msg.sender == whitelistAddress, \"caller must be whitelist\");\n        lastFeePercent = _lastFeePercent;\n        lastFeeTime = _lastFeeTime;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     * @param _collateralVCInput is how much collateral is being input by the user into the system\n     * @param _totalCollateralVCBalance is how much collateral is in the system\n     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)\n     */\n    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        return feeCalculated;\n    }\n\n    // Called only by whitelist. Updates the last fee time and last fee percent\n    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {\n        require(msg.sender == whitelistAddress, \"Only whitelist can update fee\");\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        lastFeeTime = block.timestamp;\n        lastFeePercent = feeCalculated;\n        return feeCalculated;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     */\n    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {\n        if (_totalVCBalance == 0) {\n            return 0;\n        }\n        // percent of all VC backed by this collateral * 1e18\n        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);\n        require(percentBacked <= 1e18, \"percent backed out of bounds\");\n\n        if (percentBacked <= cutoff1) { // use function 1\n            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);\n        } else if (percentBacked <= cutoff2) { // use function 2\n            if (b2Negative) {\n                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);\n            } else {\n                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n            }\n            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n        } else { // use function 3\n            if (b3Negative) {\n                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);\n            } else {\n                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n            }\n            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n        }\n    }\n\n    function calculateDecayedFee() public override view returns (uint256 fee) {\n        uint256 decay = block.timestamp.sub(lastFeeTime);\n        // Decay within bounds of decay time, then decay the fee. \n        uint256 cachedDecayTime = decayTime;\n        if (decay <= cachedDecayTime) {\n            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));\n        } else {\n            // If it has been longer than decay time, then reset fee to 0.\n            fee = 0;\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? b : a;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? b : a;\n    }\n}\n\n\n",
        "CodeNames": [
            "ThreePieceWiseLinearPriceCurve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "adjustParams"
                ],
                "Type": " Cannot use most piecewise linear functions with current implementation",
                "Description": "\nThe ThreePieceWiseLinearPriceCurve.adjustParams function uses three functions f1, f2, f3 where y_i = f_i(x_i).\nIt computes the y-axis intersect (b2 = f_2(0), b3 = f_3(0)) for each of these but uses unsigned integers for this, which means these values cannot become negative.\nThis rules out a whole class of functions, usually the ones that are desirable.\n\n\nCheck out this two-piece linear interest curve of Aave:\n\n![Aave(https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894)\nThe intersection of the second steep straight line with the y-axis b_2 = f_2(0) would be negative.\n\nExample:\nImagine a curve that is flat at 10% on the first 50% utilization but shoots up to 110% at 100% utilization.\n\n*   m1 = 0, b1 = 10%, cutoff1 = 50%\n*   m2 = 200% = b2 = m1 * cutoff1 + b1 m2 * cutoff1 = f1(cutoff1) m2 * cutoff1 = 10% 200% * 50% = 10% 100% = -90%. (f2(100%) = 200% * 100% 90% = 110% \u2705)\n\nThis function would revert in the b2 computation as it underflows due to being a negative value.\n\n\nMost curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.\n\n",
                "Repair": "\nEvaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value.\nFor example, for cutoff2 = x  cutoff1, use f(x) = f_1(cutoff) + f_2(x cutoff).\nSee Compound(https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).\n\nkingyetifinance (Yeti finance) confirmed(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/200#issuecomment-1005522334):\n  @LilYeti: Great find. \n\n0xtruco (Yeti finance) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/200#issuecomment-1010542293):\n  Resolved in https://github.com/code-423n4/2021-12-yetifinance/pull/23 \n by adding negative possibility\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IYUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ISYETI.sol\";\nimport \"./Interfaces/IWhitelist.sol\";\nimport \"./Interfaces/IYetiRouter.sol\";\nimport \"./Interfaces/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/ReentrancyGuard.sol\";\nimport \"./Interfaces/IWAsset.sol\";\n\n/** \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /**\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  */\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, \"BO:MIN_NET_DEBT==0\");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol's\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist's approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage > 1e18, \"WrongLeverage\");\n        require(_maxSlippage <= 1e18, \"WrongSlippage\");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), \"BO:RouteLeverUpNotSent\");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called *after* collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256[](0);\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /*\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     *\n     * Should be called after the collsIn has been sent to ActivePool\n     */\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease && !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC > vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don't send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist's approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage <= 1e18, \"WrongSlippage\");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), \"BO:YUSDNotSentUnLever\");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and *only* pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    /** \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     */\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    /** \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     */\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i < tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i < amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), \"BO:TransferCollsFailed\");\n        }\n    }\n\n    /**\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     */\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i < collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), \"BO:BadColl\");\n            require(_amounts[i] != 0, \"BO:NoAmounts\");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            \"BO:0Adjust\"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i < arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), \"BO:TroveInactive\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), \"BO:TroveActive\");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, \"BO:NoDebtChange\");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i < colls1Len; ++i) {\n            for (uint256 j; j < colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], \"BO:OverlapColls\");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i < collsLen; ++i) {\n            for (uint256 j = i.add(1); j < collsLen; j++) {\n                require(_colls[i] != _colls[j], \"BO:OverlapColls\");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), \"BO:InRecMode\");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            \"BO:InRecMode\"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, \"BOps:Len0\");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, \"BO:LenMismatch\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= MCR,\n            \"BO:ReqICR>MCR\"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR >= CCR, \"BO:ReqICR>CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR >= _oldICR,\n            \"BO:RecMode:ICR<oldICR\"\n        );\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(\n            _newTCR >= CCR,\n            \"BO:ReqTCR>CCR\"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt >= MIN_NET_DEBT,\n            \"BO:netDebt<2000\"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            \"BO:InvalidYUSDRepay\"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) >= _debtRepayment,\n            \"BO:InsuffYUSDBal\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {\n            revert(\"BO:InvalidMaxFee\");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  \"_requireValidRouterParams: _finalRoutedColls length mismatch\");\n    //     require(_amounts.length == _routers.length, \"_requireValidRouterParams: _routers length mismatch\");\n    //     require(_amounts.length == _minSwapAmounts.length, \"_minSwapAmounts: finalRoutedColls length mismatch\");\n    //     for (uint256 i; i < _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), \"_requireValidRouterParams: not a valid router\");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i < _indices.length - 1; ++i) {\n    //         require(_indices[i] < _indices[i.add(1)], \"_requireRouterAVAXIndicesInOrder: indices out of order\");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/IPriceCurve.sol\";\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\n\n/** \n * This contract is used to calculate the variable fee for an input of tokens. \n * Uses three linear piecewise functions to calculate the fee, and the average \n * of the system collateralization by that asset before and after the tx. \n */\ncontract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {\n    using SafeMath for uint256;\n\n    string name;\n    uint256 m1;\n    uint256 b1;\n    uint256 cutoff1;\n    uint256 m2;\n    uint256 b2;\n    bool b2Negative;\n    uint256 cutoff2;\n    uint256 m3;\n    uint256 b3;\n    bool b3Negative;\n    uint256 decayTime;\n\n    uint lastFeeTime;\n    uint lastFeePercent;\n    uint dollarCap;\n    address whitelistAddress;\n    bool private addressesSet;\n\n    /** \n     * f1 = m1 * x + b1\n     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2\n     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3\n     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages\n     * Decimal precision = 1e18\n     */\n\n    /** \n     * Function for setting slopes and intercepts of linear functions used for fee calculations. \n     */\n    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {\n        require(_cutoff1 <= _cutoff2, \"Cutoffs must be increasing\");\n        name = _name;\n        m1 = _m1;\n        b1 = _b1;\n        m2 = _m2;\n        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);\n        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);\n        if (m2Val > m1Val) {\n            b2Negative = true;\n            b2 = m2Val.sub(m1Val);\n        } else {\n            b2 = m1Val.sub(m2Val);\n        }\n        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));\n        cutoff1 = _cutoff1;\n        m3 = _m3;\n        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);\n        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);\n        if (m3Val > m2Val) {\n            b3Negative = true;\n            b3 = m3Val.sub(m2Val);\n        } else {\n            b3 = m2Val.sub(m3Val);\n        }\n        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));\n        cutoff2 = _cutoff2;\n        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.\n        decayTime = 5 days;\n    }\n\n    // Set the whitelist address so that the fee can only be updated by whitelistAddress\n    function setAddresses(address _whitelistAddress) external override onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        whitelistAddress = _whitelistAddress;\n        addressesSet = true;\n    }\n\n    // Set the decay time in seconds\n    function setDecayTime(uint _decayTime) external override onlyOwner {\n        decayTime = _decayTime;\n    }\n\n    // Gets the fee cap and time currently. Used for setting new values for next price curve. \n    function getFeeCapAndTime() external override view returns (uint256, uint256) {\n        return (lastFeePercent, lastFeeTime);\n    }\n\n    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. \n    // Called only by whitelist. \n    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {\n        require(msg.sender == whitelistAddress, \"caller must be whitelist\");\n        lastFeePercent = _lastFeePercent;\n        lastFeeTime = _lastFeeTime;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     * @param _collateralVCInput is how much collateral is being input by the user into the system\n     * @param _totalCollateralVCBalance is how much collateral is in the system\n     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)\n     */\n    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        return feeCalculated;\n    }\n\n    // Called only by whitelist. Updates the last fee time and last fee percent\n    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {\n        require(msg.sender == whitelistAddress, \"Only whitelist can update fee\");\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        lastFeeTime = block.timestamp;\n        lastFeePercent = feeCalculated;\n        return feeCalculated;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     */\n    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {\n        if (_totalVCBalance == 0) {\n            return 0;\n        }\n        // percent of all VC backed by this collateral * 1e18\n        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);\n        require(percentBacked <= 1e18, \"percent backed out of bounds\");\n\n        if (percentBacked <= cutoff1) { // use function 1\n            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);\n        } else if (percentBacked <= cutoff2) { // use function 2\n            if (b2Negative) {\n                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);\n            } else {\n                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n            }\n            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n        } else { // use function 3\n            if (b3Negative) {\n                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);\n            } else {\n                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n            }\n            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n        }\n    }\n\n    function calculateDecayedFee() public override view returns (uint256 fee) {\n        uint256 decay = block.timestamp.sub(lastFeeTime);\n        // Decay within bounds of decay time, then decay the fee. \n        uint256 cachedDecayTime = decayTime;\n        if (decay <= cachedDecayTime) {\n            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));\n        } else {\n            // If it has been longer than decay time, then reset fee to 0.\n            fee = 0;\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? b : a;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? b : a;\n    }\n}\n\n\n",
        "CodeNames": [
            "BorrowerOperations.sol",
            "ThreePieceWiseLinearPriceCurve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "//solidity\n// @param _collateralVCInput is how much collateral is being input by the user into the system\nif (dollarCap != 0) {\n    require(_collateralVCInput <= dollarCap, \"Collateral input exceeds cap\");\n}\n"
                ],
                "Type": " Wrong comment in  getFee ",
                "Description": "\nThe ThreePieceWiseLinearPriceCurve.getFee comment states that the total + the input must be less than the cap:\n\n If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n\nThe code only checks if the input is less than the cap:\n\nsolidity\n// @param _collateralVCInput is how much collateral is being input by the user into the system\nif (dollarCap != 0) {\n    require(_collateralVCInput <= dollarCap, \"Collateral input exceeds cap\");\n}\n\n\n",
                "Repair": "\nClarify the desired behavior and reconcile the code with the comments.\n\nkingyetifinance (Yeti finance) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/203#issuecomment-1005532067):\n  @LilYeti: This was an issue also found by one of our independent economic auditors. Good find. Is actually more like a medium (severity 2) issue.\n\n0xtruco (Yeti finance) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/203#issuecomment-1009868188):\n  Fixed in line 92\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\ninterface IPriceCurve {\n    function setAddresses(address _whitelistAddress) external;\n\n    function setDecayTime(uint _decayTime) external;\n\n    /** \n     * Returns fee based on inputted collateral VC balance and total VC balance of system. \n     * fee is in terms of percentage * 1e18. \n     * If the fee were 1%, this would be 0.01 * 1e18 = 1e16\n     */\n    function getFee(uint256 _collateralVCInput, uint256 _collateralVCBalancePost, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external view returns (uint256 fee);\n\n    // Same function, updates the fee as well. Called only by whitelist. \n    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external returns (uint256 fee);\n\n    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. \n    // Called only by whitelist. \n    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external;\n\n    // Gets the fee cap and time currently. Used for setting new values for next price curve. \n    // returns lastFeePercent, lastFeeTime\n    function getFeeCapAndTime() external view returns (uint256 _lastFeePercent, uint256 _lastFeeTime);\n\n    /** \n     * Returns fee based on decay since last fee calculation, which we take to be \n     * a reasonable fee amount. If it has decayed a certain amount since then, we let\n     * the new fee amount slide. \n     */\n    function calculateDecayedFee() external view returns (uint256 fee);\n}\n\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"./Ownable.sol\";\nimport \"../Interfaces/IBaseOracle.sol\";\nimport \"../Interfaces/IWhitelist.sol\";\nimport \"../Interfaces/IPriceFeed.sol\";\nimport \"../Interfaces/IPriceCurve.sol\";\nimport \"../Interfaces/IActivePool.sol\";\nimport \"../Interfaces/IDefaultPool.sol\";\nimport \"../Interfaces/IStabilityPool.sol\";\nimport \"../Interfaces/ICollSurplusPool.sol\";\nimport \"../Interfaces/IERC20.sol\";\nimport \"./LiquityMath.sol\";\nimport \"./CheckContract.sol\";\n\n\n/**\n * Whitelist is the contract that keeps track of all the assets that the system takes as collateral.\n * It has onlyOwner functions to add or deprecate collaterals from the whitelist, change the price\n * curve, price feed, safety ratio, etc.\n */\n\ncontract Whitelist is Ownable, IWhitelist, IBaseOracle, CheckContract {\n    using SafeMath for uint256;\n\n    struct CollateralParams {\n        // Safety ratio\n        uint256 ratio; // 10**18 * the ratio. i.e. ratio = .95 * 10**18 for 95%. More risky collateral has a lower ratio\n        address oracle;\n        uint256 decimals;\n        address priceCurve;\n        uint256 index;\n        bool active;\n        bool isWrapped;\n        address defaultRouter;\n    }\n\n    IActivePool activePool;\n    IDefaultPool defaultPool;\n    IStabilityPool stabilityPool;\n    ICollSurplusPool collSurplusPool;\n    address borrowerOperationsAddress;\n    bool private addressesSet;\n\n    mapping(address => CollateralParams) public collateralParams;\n\n    mapping(address => bool) public validRouter;\n\n    // list of all collateral types in collateralParams (active and deprecated)\n    // Addresses for easy access\n    address[] public validCollateral; // index maps to token address.\n\n    event CollateralAdded(address _collateral);\n    event CollateralDeprecated(address _collateral);\n    event CollateralUndeprecated(address _collateral);\n    event CollateralRemoved(address _collateral);\n    event OracleChanged(address _collateral);\n    event PriceCurveChanged(address _collateral);\n    event RatioChanged(address _collateral);\n\n    // Require that the collateral exists in the whitelist. If it is not the 0th index, and the\n    // index is still 0 then it does not exist in the mapping.\n    // no require here for valid collateral 0 index because that means it exists. \n    modifier exists(address _collateral) {\n        _exists(_collateral);\n        _;\n    }\n\n    // Calling from here makes it not inline, reducing contract size and gas. \n    function _exists(address _collateral) internal view {\n        if (validCollateral[0] != _collateral) {\n            require(collateralParams[_collateral].index != 0, \"collateral does not exist\");\n        }\n    }\n\n    // ----------Only Owner Setter Functions----------\n\n    function setAddresses(\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _collSurplusPoolAddress,\n        address _borrowerOperationsAddress\n    ) external override onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_borrowerOperationsAddress);\n\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPool = IStabilityPool(_stabilityPoolAddress);\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        addressesSet = true;\n    }\n\n    function addCollateral(\n        address _collateral,\n        uint256 _minRatio,\n        address _oracle,\n        uint256 _decimals,\n        address _priceCurve, \n        bool _isWrapped, \n        address _routerAddress\n    ) external onlyOwner {\n        checkContract(_collateral);\n        checkContract(_oracle);\n        checkContract(_priceCurve);\n        checkContract(_routerAddress);\n        // If collateral list is not 0, and if the 0th index is not equal to this collateral,\n        // then if index is 0 that means it is not set yet.\n        require(_minRatio < 11e17, \"ratio must be less than 1.10\"); //=> greater than 1.1 would mean taking out more YUSD than collateral VC\n\n        if (validCollateral.length != 0) {\n            require(validCollateral[0] != _collateral && collateralParams[_collateral].index == 0, \"collateral already exists\");\n        }\n\n        validCollateral.push(_collateral);\n        collateralParams[_collateral] = CollateralParams(\n            _minRatio,\n            _oracle,\n            _decimals,\n            _priceCurve,\n            validCollateral.length - 1, \n            true,\n            _isWrapped,\n            _routerAddress\n        );\n\n        activePool.addCollateralType(_collateral);\n        defaultPool.addCollateralType(_collateral);\n        stabilityPool.addCollateralType(_collateral);\n        collSurplusPool.addCollateralType(_collateral);\n\n        // throw event\n        emit CollateralAdded(_collateral);\n    }\n\n    /**\n     * Deprecate collateral by not allowing any more collateral to be added of this type.\n     * Still can interact with it via validCollateral and CollateralParams\n     */\n    function deprecateCollateral(address _collateral) external exists(_collateral) onlyOwner {\n        checkContract(_collateral);\n\n        require(collateralParams[_collateral].active, \"collateral already deprecated\");\n\n        collateralParams[_collateral].active = false;\n\n        // throw event\n        emit CollateralDeprecated(_collateral);\n    }\n\n    /**\n     * Undeprecate collateral by allowing more collateral to be added of this type.\n     * Still can interact with it via validCollateral and CollateralParams\n     */\n    function undeprecateCollateral(address _collateral) external exists(_collateral) onlyOwner {\n        checkContract(_collateral);\n\n        require(!collateralParams[_collateral].active, \"collateral is already active\");\n\n        collateralParams[_collateral].active = true;\n\n        // throw event\n        emit CollateralUndeprecated(_collateral);\n    }\n\n    /**\n     * Function to change oracles\n     */\n    function changeOracle(address _collateral, address _oracle)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        checkContract(_oracle);\n        collateralParams[_collateral].oracle = _oracle;\n\n        // throw event\n        emit OracleChanged(_collateral);\n    }\n\n    /**\n     * Function to change price curve\n     */\n    function changePriceCurve(address _collateral, address _priceCurve)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        checkContract(_priceCurve);\n        uint lastFeePercent;\n        uint lastFeeTime; \n        (lastFeePercent, lastFeeTime) = IPriceCurve(collateralParams[_collateral].priceCurve).getFeeCapAndTime();\n        IPriceCurve(_priceCurve).setFeeCapAndTime(lastFeePercent, lastFeeTime);\n        collateralParams[_collateral].priceCurve = _priceCurve;\n\n        // throw event\n        emit PriceCurveChanged(_collateral);\n    }\n\n    /**\n     * Function to change Safety ratio.\n     */\n    function changeRatio(address _collateral, uint256 _ratio)\n        external\n        exists(_collateral)\n        onlyOwner\n    {\n        checkContract(_collateral);\n        require(_ratio < 11e17, \"ratio must be less than 1.10\"); //=> greater than 1.1 would mean taking out more YUSD than collateral VC\n        require(collateralParams[_collateral].ratio < _ratio, \"New SR must be greater than previous SR\");\n        collateralParams[_collateral].ratio = _ratio;\n\n        // throw event\n        emit RatioChanged(_collateral);\n    }\n\n    // -----------Routers--------------\n\n    function setDefaultRouter(address _collateral, address _router) external override onlyOwner exists(_collateral) {\n        checkContract(_router);\n        collateralParams[_collateral].defaultRouter = _router;\n    }\n\n    function getDefaultRouterAddress(address _collateral) external view override exists(_collateral) returns (address) {\n        return collateralParams[_collateral].defaultRouter;\n    }\n\n\n    // ---------- View Functions -----------\n\n\n    function isValidRouter(address _router) external override view returns (bool) {\n        return validRouter[_router];\n    }\n\n    function isWrapped(address _collateral) external view override returns (bool) {\n        return collateralParams[_collateral].isWrapped;\n    }\n\n    function getValidCollateral() external view override returns (address[] memory) {\n        return validCollateral;\n    }\n\n    function getRatio(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return collateralParams[_collateral].ratio;\n    }\n\n    function getOracle(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (address)\n    {\n        return collateralParams[_collateral].oracle;\n    }\n\n    function getPriceCurve(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (address)\n    {\n        return collateralParams[_collateral].priceCurve;\n    }\n\n    function getIsActive(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (bool)\n    {\n        return collateralParams[_collateral].active;\n    }\n\n    function getDecimals(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return collateralParams[_collateral].decimals;\n    }\n\n    function getIndex(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return (collateralParams[_collateral].index);\n    }\n\n    // Returned as fee percentage * 10**18. View function for external callers.\n    function getFee(\n        address _collateral,\n        uint256 _collateralVCInput,\n        uint256 _collateralVCBalancePost,\n        uint256 _totalVCBalancePre,\n        uint256 _totalVCBalancePost\n    ) external view override exists(_collateral) returns (uint256 fee) {\n        IPriceCurve priceCurve = IPriceCurve(collateralParams[_collateral].priceCurve);\n        return priceCurve.getFee(_collateralVCInput, _collateralVCBalancePost, _totalVCBalancePre, _totalVCBalancePost);\n    }\n\n    // Returned as fee percentage * 10**18. Non view function for just borrower operations to call.\n    function getFeeAndUpdate(\n        address _collateral,\n        uint256 _collateralVCInput,\n        uint256 _collateralVCBalancePost,\n        uint256 _totalVCBalancePre,\n        uint256 _totalVCBalancePost\n    ) external override exists(_collateral) returns (uint256 fee) {\n        require(\n            msg.sender == borrowerOperationsAddress,\n            \"caller must be BO\"\n        );\n        IPriceCurve priceCurve = IPriceCurve(collateralParams[_collateral].priceCurve);\n        return\n            priceCurve.getFeeAndUpdate(\n                _collateralVCInput,\n                _collateralVCBalancePost,\n                _totalVCBalancePre,\n                _totalVCBalancePost\n            );\n    }\n\n    // should return 10**18 times the price in USD of 1 of the given _collateral\n    function getPrice(address _collateral)\n        public\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        IPriceFeed collateral_priceFeed = IPriceFeed(collateralParams[_collateral].oracle);\n        return collateral_priceFeed.fetchPrice_v();\n    }\n\n    // Gets the value of that collateral type, of that amount, in USD terms.\n    function getValueUSD(address _collateral, uint256 _amount)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        uint256 decimals = collateralParams[_collateral].decimals;\n        uint256 price = getPrice(_collateral);\n        return price.mul(_amount).div(10**decimals);\n    }\n\n    // Gets the value of that collateral type, of that amount, in VC terms.\n    function getValueVC(address _collateral, uint256 _amount)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        // uint256 price = getPrice(_collateral);\n        // uint256 decimals = collateralParams[_collateral].decimals;\n        // uint256 ratio = collateralParams[_collateral].ratio;\n        // return (price.mul(_amount).mul(ratio).div(10**(18 + decimals)));\n\n        // div by 10**18 for price adjustment\n        // and divide by 10 ** decimals for decimal adjustment\n        // do inline since this function is called often\n        return ((getPrice(_collateral)).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals)));\n    }\n\n\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/IPriceCurve.sol\";\nimport \"../Dependencies/SafeMath.sol\";\nimport \"../Dependencies/Ownable.sol\";\n\n/** \n * This contract is used to calculate the variable fee for an input of tokens. \n * Uses three linear piecewise functions to calculate the fee, and the average \n * of the system collateralization by that asset before and after the tx. \n */\ncontract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {\n    using SafeMath for uint256;\n\n    string name;\n    uint256 m1;\n    uint256 b1;\n    uint256 cutoff1;\n    uint256 m2;\n    uint256 b2;\n    bool b2Negative;\n    uint256 cutoff2;\n    uint256 m3;\n    uint256 b3;\n    bool b3Negative;\n    uint256 decayTime;\n\n    uint lastFeeTime;\n    uint lastFeePercent;\n    uint dollarCap;\n    address whitelistAddress;\n    bool private addressesSet;\n\n    /** \n     * f1 = m1 * x + b1\n     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2\n     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3\n     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages\n     * Decimal precision = 1e18\n     */\n\n    /** \n     * Function for setting slopes and intercepts of linear functions used for fee calculations. \n     */\n    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {\n        require(_cutoff1 <= _cutoff2, \"Cutoffs must be increasing\");\n        name = _name;\n        m1 = _m1;\n        b1 = _b1;\n        m2 = _m2;\n        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);\n        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);\n        if (m2Val > m1Val) {\n            b2Negative = true;\n            b2 = m2Val.sub(m1Val);\n        } else {\n            b2 = m1Val.sub(m2Val);\n        }\n        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));\n        cutoff1 = _cutoff1;\n        m3 = _m3;\n        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);\n        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);\n        if (m3Val > m2Val) {\n            b3Negative = true;\n            b3 = m3Val.sub(m2Val);\n        } else {\n            b3 = m2Val.sub(m3Val);\n        }\n        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));\n        cutoff2 = _cutoff2;\n        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.\n        decayTime = 5 days;\n    }\n\n    // Set the whitelist address so that the fee can only be updated by whitelistAddress\n    function setAddresses(address _whitelistAddress) external override onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        whitelistAddress = _whitelistAddress;\n        addressesSet = true;\n    }\n\n    // Set the decay time in seconds\n    function setDecayTime(uint _decayTime) external override onlyOwner {\n        decayTime = _decayTime;\n    }\n\n    // Gets the fee cap and time currently. Used for setting new values for next price curve. \n    function getFeeCapAndTime() external override view returns (uint256, uint256) {\n        return (lastFeePercent, lastFeeTime);\n    }\n\n    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. \n    // Called only by whitelist. \n    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {\n        require(msg.sender == whitelistAddress, \"caller must be whitelist\");\n        lastFeePercent = _lastFeePercent;\n        lastFeeTime = _lastFeeTime;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     * @param _collateralVCInput is how much collateral is being input by the user into the system\n     * @param _totalCollateralVCBalance is how much collateral is in the system\n     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)\n     */\n    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        return feeCalculated;\n    }\n\n    // Called only by whitelist. Updates the last fee time and last fee percent\n    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {\n        require(msg.sender == whitelistAddress, \"Only whitelist can update fee\");\n        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.\n        uint256 cachedDollarCap = dollarCap;\n        if (cachedDollarCap != 0) {\n            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \"Collateral input exceeds cap\");\n        }\n        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);\n        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);\n\n        uint decayedLastFee = calculateDecayedFee();\n        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);\n\n        lastFeeTime = block.timestamp;\n        lastFeePercent = feeCalculated;\n        return feeCalculated;\n    }\n\n    /** \n     * Function for getting the fee for a particular collateral type based on percent of YUSD backed\n     * by this asset. \n     */\n    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {\n        if (_totalVCBalance == 0) {\n            return 0;\n        }\n        // percent of all VC backed by this collateral * 1e18\n        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);\n        require(percentBacked <= 1e18, \"percent backed out of bounds\");\n\n        if (percentBacked <= cutoff1) { // use function 1\n            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);\n        } else if (percentBacked <= cutoff2) { // use function 2\n            if (b2Negative) {\n                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);\n            } else {\n                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n            }\n            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);\n        } else { // use function 3\n            if (b3Negative) {\n                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);\n            } else {\n                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n            }\n            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);\n        }\n    }\n\n    function calculateDecayedFee() public override view returns (uint256 fee) {\n        uint256 decay = block.timestamp.sub(lastFeeTime);\n        // Decay within bounds of decay time, then decay the fee. \n        uint256 cachedDecayTime = decayTime;\n        if (decay <= cachedDecayTime) {\n            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));\n        } else {\n            // If it has been longer than decay time, then reset fee to 0.\n            fee = 0;\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? b : a;\n    }\n\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? b : a;\n    }\n}\n\n\n",
        "CodeNames": [
            "IPriceCurve.sol",
            "Whitelist.sol",
            "ThreePieceWiseLinearPriceCurve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\nif (decay  0 && decay < decayTime) {\n    // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay  decayTime should return 0.\n    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));\n} else {\n    fee = lastFeePercent;\n}\n"
                ],
                "Type": " Fee not decayed if past  decayTime ",
                "Description": "\nThe ThreePieceWiseLinearPriceCurve.calculateDecayedFee function is supposed to decay the lastFeePercent over time.\nThis is correctly done in the decay  0 && decay < decayTime case, but for the decay  decayTime case it does not decay at all but should set it to 0 instead..\n\nsolidity\nif (decay  0 && decay < decayTime) {\n    // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay  decayTime should return 0.\n    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));\n} else {\n    fee = lastFeePercent;\n}\n\n\n",
                "Repair": "\nIt seems wrong to handle the decay == 0 case (decay happened in same block) the same way as the decay = decayTime case (decay happened long time ago) as is done in the else branch.\nI believe it should be like this instead:\n\nsolidity\n// decay == 0 case should be full lastFeePercent\nif(decay < decayTime) {\n    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));\n} else {\n    // reset to zero if decay = decayTime\n    fee = 0;\n}\n\n\nkingyetifinance (Yeti finance) confirmed(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/204#issuecomment-1005534724):\n  @LilYeti: Good find. The fee would be reset to not 0 in this case. \n\n0xtruco (Yeti finance) commented(https://github.com/code-423n4/2021-12-yetifinance-findings/issues/204#issuecomment-1009875009):\n  Resolved in https://github.com/code-423n4/2021-12-yetifinance/pull/14.\n\n\n"
            }
        ]
    }
]