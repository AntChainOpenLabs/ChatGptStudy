[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\nimport \"./Withdrawer.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /// @dev Helper to withdraw native tokens from wrapper\n    Withdrawer private immutable withdrawer;\n\n    /// @dev Fees when funds stay in portfolios\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public entryFees;\n\n    /// @dev Fees when funds are withdrawed\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public exitFees;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver,\n        Withdrawer _withdrawer\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0) &&\n                address(_withdrawer) != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n        withdrawer = _withdrawer;\n    }\n\n    /// @dev Receive function that will wrap the ether if\n    ///      an address other than the withdrawer sends ether to\n    ///      to the contract. The factory cannot handle ether but\n    ///      has functions to withdraw ERC20 tokens if needed.\n    receive() external payable {\n        if (msg.sender != address(withdrawer)) {\n            weth.deposit{ value: msg.value }();\n        }\n    }\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        rebuildCache();\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        bytes32[] storage operatorsCache = operators;\n        uint256 operatorsLength = operatorsCache.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operatorsCache[i] == operator) {\n                operatorsCache[i] = operators[operatorsLength - 1];\n                operatorsCache.pop();\n                if (operatorCache[operator].implementation != address(0)) {\n                    delete operatorCache[operator]; // remove from cache\n                }\n                rebuildCache();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setEntryFees(uint256 _entryFees) external override onlyOwner {\n        require(_entryFees != 0, \"NF: ZERO_FEES\");\n        require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\");\n        entryFees = _entryFees;\n        emit EntryFeesUpdated(_entryFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function setExitFees(uint256 _exitFees) external override onlyOwner {\n        require(_exitFees != 0, \"NF: ZERO_FEES\");\n        require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\");\n        exitFees = _exitFees;\n        emit ExitFeesUpdated(_exitFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            address token = tokens[i];\n            uint256 amount = _safeWithdraw(token, _nftId);\n            _safeSubmitOrder(token, address(_buyToken), amount, _nftId, _orders[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees\n        unchecked {\n            amountBought -= amountFees;\n\n            _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n            _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n        }\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = _safeWithdraw(token, _nftId);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n        unchecked {\n            uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n            }\n\n            // If input is from the reserve, update the records\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < batchLength; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            unchecked {\n                uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n                if (underSpentAmount != 0) {\n                    SafeERC20.safeTransfer(_inputToken, address(reserve), underSpentAmount);\n                }\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n            }\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n\n        unchecked {\n            // Entry or Exit Fees\n            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\n\n            if (_toReserve) {\n                _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n            }\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    /// @return amountSpent The _inputToken amount spent (with the order)\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        // We raise the following error in case the call to the operator failed\n        // We do not check the calldata to raise the specific error for now\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NF: OVERSPENT\");\n            unchecked {\n                uint256 underSpentAmount = _amountToSpend - amounts[1];\n                if (underSpentAmount != 0) {\n                    _safeTransferWithFees(IERC20(_inputToken), underSpentAmount, _msgSender(), _nftId);\n                }\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        SafeERC20.safeTransfer(_token, reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    /// @return The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(!_fromReserve, \"NF: NO_ETH_FROM_RESERVE\");\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(_inputToken, _inputTokenAmount);\n        } else {\n            SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n            withdrawer.withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            SafeERC20.safeTransfer(_token, _dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    /// @param _nftId The nft Id (for royalty fees)\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee\n        unchecked {\n            _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n            SafeERC20.safeTransfer(_token, _dest, _amount - feeAmount);\n        }\n    }\n\n    /// @dev Withdraw from reserve with care of deflationary tokens.\n    /// @param _token The token to withdraw\n    /// @param _nftId The NFT id to withdraw from\n    /// @return The withdrawed amount from the reserve\n    function _safeWithdraw(address _token, uint256 _nftId) private returns (uint256) {\n        uint256 holdingAmount = nestedRecords.getAssetHolding(_nftId, _token);\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        reserve.withdraw(IERC20(_token), holdingAmount);\n        return IERC20(_token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weight The new weight\n    event RoyaltiesWeightUpdated(uint256 weight);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weight\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0, \"FS: EMPTY_ARRAY\");\n        require(accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_weight != 0, \"FS: INVALID_WEIGHT\");\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        Shareholder storage _shareholder = shareholders[_accountIndex];\n        totalWeights = totalWeights + _weight - _shareholder.weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        _shareholder.weight = _weight;\n        emit ShareholderUpdated(_shareholder.account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 _totalWeights = totalWeights;\n        uint256 royaltiesAmount = (amountReceived * royaltiesWeight) / _totalWeights;\n\n        _sendFees(_token, amountReceived, _totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 _totalShares = _tokenRecords.totalShares;\n        if (_totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return (totalReceived * _tokenRecords.shares[_account]) / _totalShares - _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                (_amount * shareholdersCache[i].weight) / _totalWeights,\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "entryFee",
                    "create()",
                    "calldata"
                ],
                "Type": " User can bypass  entryFee  by sending arbitrary  calldata  to ParaSwap operator",
                "Description": "\nNestedFactory.sol#L466(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L466)<br\nParaswapOperator.sol#L34(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L34)<br\n\nAny user is able to bypass the entryFee collection when using NestedFactory.create() by passing in arbitrary calldata when using the ParaSwap router. High level, a user can pass in calldata to swap from a miniscule amount of input token to an ERC777 with themselves as the recipient and will gain control of execution, at which time they can send a large amount of output token back to the Nested Factory.\n\nIf the user sends 1 wei of input token, the Nested Factory will return an entryFee of 0 due to precision loss. The amount of output token returned to the contract via the direct transfer from the user will then be deposited in the vault.\n\n\nSteps\n\n*   User calls NestedFactory.create() with a single input order. This input order will define the parameters of the call to Paraswap.\n*   The single order defines the following in pseudocode:\n    1.  inputToken: Any token, but we'll use address(0) ETH\n    2.  amount: 1 wei\n    3.  Order(operator=Paraswap, token=USDC, calldata=calldata)\n\n*The calldata used in the call to paraswap would swap from ETH to any ERC777 (NOT USDC), with an attack contract address set as the beneficiary. Upon transferring the swapped ERC777 to the user's attack contract, the contract would immediately send e.g. 1,000,000 USDC directly back to the Nested Factory contract.*\n\n*   The Paraswap operator checks the balances of the buy and sell tokens. Note that the buy token is defined in the Order token parameter, not the calldata passed to Paraswap. Since the operator will check the balance of USDC, it looks like we've swapped 1 wei ETH for 1,000,000 USDC.\n*   The Paraswap operator returns the swap amounts back to Nested Factory.\n*   Nested Factory deposits the 1,000,000 USDC to the vault for the user without charging any entryFee.\n\nNOTE: I use 1 wei as an extreme example. You would have to ensure that you're swapping at least enough to receive 1 wei of the ERC777 to transfer to the attack contract.\n\n",
                "Repair": "\nAllowing a user to pass arbitrary call data to a router is risky because routers allow several paths for an attacker to gain control of execution. Originally, I believed this exploit to be possible simply by swapping to ETH, which would perform an external call to the beneficiary, but Paraswap actually only forwards 10,000 gas when performing ETH transfers. If Nested plans to include a vanilla Uniswap router operator, this would be an issue. Here is the Paraswap transfer logic:\n\n    function transferTokens(\n            address token,\n            address payable destination,\n            uint256 amount\n        )\n        internal\n        {\n            if (amount  0) {\n                if (token == ETH_ADDRESS) {\n                    (bool result, ) = destination.call{value: amount, gas: 10000}(\"\");\n                    require(result, \"Failed to transfer Ether\");\n                }\n                else {\n                    IERC20(token).safeTransfer(destination, amount);\n                }\n            }\n\n        }\n\nTherefore, it might be worth exploring the option of allowing the user to only choose from a list of predefined function signatures when making calls to Paraswap. The final Order param that is passed to the operator would be built within the contract by concatenating the function, input, and output tokens. Even then, if the output token truly is an ERC777, the user would be able to intercept control and directly transfer more of the ERC777.\n\nA large-scale fix would be to charge the entry fee on the amount of output tokens after performing the swap. I'm not sure if this falls in line with Nested's plans though.\n\nmaximebrugel (Nested) acknowledged(https://github.com/code-423n4/2022-06-nested-findings/issues/69)\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-06-nested-findings/issues/69#issuecomment-1183919165):\n  I find this to be a valid Medium issue. I have a few things to add:\n \n 1. It applies not only to the ParaSwap operator but also the other operators, ie, 0x;\n 2. Not just the entryFee, the exitFees can also be bypassed in a similar way;\n 3. Not necessarily using a ERC777, the attacker can also use a malicious ERC20 they deployed on their own;\n \n The root cause is that:\n \n entryFee and exitFees should be charged on the token that gets in and out the Reserve, not the inputToken/outputToken of the swap.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 22 reports were submitted by wardens detailing low risk and non-critical issues. The report(https://github.com/code-423n4/2022-06-nested-findings/issues/11) submitted by 0xNazgul received the top score from the judge.\n\n*The low risk and non-critical findings below include reports submitted by 0xNazgul, as well as: Meera(https://github.com/code-423n4/2022-06-nested-findings/issues/61), Chom(https://github.com/code-423n4/2022-06-nested-findings/issues/73), IllIllI(https://github.com/code-423n4/2022-06-nested-findings/issues/76), codexploder(https://github.com/code-423n4/2022-06-nested-findings/issues/34), joestakey(https://github.com/code-423n4/2022-06-nested-findings/issues/84), simon135(https://github.com/code-423n4/2022-06-nested-findings/issues/40), 0xf15ers(https://github.com/code-423n4/2022-06-nested-findings/issues/72), BowTiedWardens(https://github.com/code-423n4/2022-06-nested-findings/issues/94), Dravee(https://github.com/code-423n4/2022-06-nested-findings/issues/67), cccz(https://github.com/code-423n4/2022-06-nested-findings/issues/26), &#95;Adam(https://github.com/code-423n4/2022-06-nested-findings/issues/43), 0xDjango(https://github.com/code-423n4/2022-06-nested-findings/issues/70), 0xFar5eer(https://github.com/code-423n4/2022-06-nested-findings/issues/53), delfin454000(https://github.com/code-423n4/2022-06-nested-findings/issues/45), fatherOfBlocks(https://github.com/code-423n4/2022-06-nested-findings/issues/98), hansfriese(https://github.com/code-423n4/2022-06-nested-findings/issues/18), MiloTruck(https://github.com/code-423n4/2022-06-nested-findings/issues/33), oyc&#95;109(https://github.com/code-423n4/2022-06-nested-findings/issues/3), PierrickGT(https://github.com/code-423n4/2022-06-nested-findings/issues/50), TerrierLover(https://github.com/code-423n4/2022-06-nested-findings/issues/96), and cryptphi(https://github.com/code-423n4/2022-06-nested-findings/issues/8).*\n\n## Low Risk Issue Summary\n\nL-01] Known vulnerabilities exist in currently used @openzeppelin/contracts version<br\nL-02] Impractical Entry/Exit fees are allowed<br\nL-03] poolCoinAmount validation<br\nL-04] Low level calls with solidity version 0.8.14 can result in optimiser bug.<br\nL-05] Unchecked return value of transferFrom can allow a user to withdraw native token for free.<br\n\n\n"
            },
            {
                "Name": "-16",
                "Location": [
                    "calldata",
                    "memory",
                    "private",
                    "public",
                    "require",
                    "_submitOutOrders()",
                    "storage",
                    "require()"
                ],
                "Type": " Inequality",
                "Description": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L286\n\nNon strict inequality are cheaper than strict one. I suggest to use = or <= instead of  and < if possible.\n\nmaximebrugel (Nested) responded:\n  OK:\n * G-1] Using calldata instead of memory for read-only arguments in external functions saves gas\n * G-2] Using storage instead of memory for structs/arrays saves gas\n * G-3] Multiple accesses of a mapping/array should use a local variable cache\n * G-5] Splitting require() statements that use && saves gas\n * G-7] Division by two should use bit shifting\n * G-10] The require statements could be put at the beginning part of a block of statements if it doesn\u2019t affect the logic to save gas.\n * G-12] Mathematical optimizations\n * G-13] Constructor parameters should be avoided when possible\n * G-14] Can save gas when call _submitOutOrders() with _toReserve = false\n * G-15] transferToReserveAndStore: balanceReserveAfter can be inlined\n * G-16] Inequality\n\n  Acknowledged:\n * G-6] Using private rather than public for constants, saves gas\n * G-11] Unnecessary computation\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n\"@openzeppelin/contracts\": \"^4.3.2\",\n"
                ],
                "Type": " Known vulnerabilities exist in currently used @openzeppelin/contracts version",
                "Description": "\nAs some known vulnerabilities(https://snyk.io/test/npm/@openzeppelin/contracts/4.3.2) exist in the current @openzeppelin/contracts version, consider updating package.json with at least @openzeppelin/contracts@4.4.2 here:\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/package.json#L65\n\nsolidity\n\"@openzeppelin/contracts\": \"^4.3.2\",\n\n\nWhile vulnerabilities are known, the current scope isn't affected (this might not hold true for the whole solution).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nif (poolCoinAmount < 2 || poolCoinAmount  4) revert\nChange code to\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma //solidity 0.8.14;\n\nimport \"./../Withdrawer.sol\";\nimport \"./../libraries/ExchangeHelpers.sol\";\nimport \"./../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePool.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./../interfaces/external/IStakingVault/IStakingVault.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\nerror InvalidPoolCoinAmount(uint256 poolCoinAmount);\n\n/// @notice Library for LP Staking Vaults deposit/withdraw\nlibrary StakingLPVaultHelpers {\n    using SafeERC20 for IERC20;\n\n    /// @dev  Add liquidity in a Curve pool with ETH and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param eth ETH address\n    /// @param amount ETH amount to add in the Curve pool\n    function _addLiquidityAndDepositETH(\n        address vault,\n        ICurvePoolETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address eth,\n        uint256 amount\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);\n        } else {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev  Add liquidity in a Curve pool and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool lpToken\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param token Token to add in the Curve pool liquidity\n    /// @param amount Token amount to add in the Curve pool\n    function _addLiquidityAndDeposit(\n        address vault,\n        ICurvePoolNonETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address token,\n        uint256 amount\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);\n        } else {\n            pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity128(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity256(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n}\n"
                ],
                "Type": " poolCoinAmount validation",
                "Description": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol\n\npoolCoinAmount must be 2, 3, 4. so, if it not fall in this range it should be reverted but now it doesn't. On every functions in this file add:\n\nsolidity\nif (poolCoinAmount < 2 || poolCoinAmount  4) revert\nChange code to\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../Withdrawer.sol\";\nimport \"./../libraries/ExchangeHelpers.sol\";\nimport \"./../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePool.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./../interfaces/external/IStakingVault/IStakingVault.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\nerror InvalidPoolCoinAmount(uint256 poolCoinAmount);\n\n/// @notice Library for LP Staking Vaults deposit/withdraw\nlibrary StakingLPVaultHelpers {\n    using SafeERC20 for IERC20;\n\n    /// @dev  Add liquidity in a Curve pool with ETH and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param eth ETH address\n    /// @param amount ETH amount to add in the Curve pool\n    function _addLiquidityAndDepositETH(\n        address vault,\n        ICurvePoolETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address eth,\n        uint256 amount\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);\n        } else {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev  Add liquidity in a Curve pool and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool lpToken\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param token Token to add in the Curve pool liquidity\n    /// @param amount Token amount to add in the Curve pool\n    function _addLiquidityAndDeposit(\n        address vault,\n        ICurvePoolNonETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address token,\n        uint256 amount\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);\n        } else {\n            pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity128(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity256(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        if (poolCoinAmount < 2 || poolCoinAmount  4) revert InvalidPoolCoinAmount(poolCoinAmount);\n\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n}\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #1\n\n25:                   return amounts;\n",
                    "//solidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #2\n\n45:                   return amounts;\n",
                    "//solidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #3\n\n65:                   return amounts;\n",
                    "//solidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #4\n\n89:                   return success;\n"
                ],
                "Type": " Adding a return statement when the function defines a named return variable, is redundant",
                "Description": " \nThere are 4 instances of this issue:\n\nsolidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #1\n\n25:                   return amounts;\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L25\n\nsolidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #2\n\n45:                   return amounts;\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L45\n\nsolidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #3\n\n65:                   return amounts;\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L65\n\nsolidity\nFile: contracts/libraries/CurveHelpers/CurveHelpers.sol   #4\n\n89:                   return success;\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L89\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: contracts/governance/OwnerProxy.sol   #1\n\n16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #2\n\n295       function executeEmergency(\n296           address target,\n297           uint256 value,\n298           bytes calldata data\n299:      ) public payable onlyRole(EMERGENCY_ROLE) {\n"
                ],
                "Type": " Public functions not called by the contract should be declared external instead",
                "Description": "\nContracts are allowed(https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from external to public.\n\nThere are 2 instances of this issue:\n\nsolidity\nFile: contracts/governance/OwnerProxy.sol   #1\n\n16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #2\n\n295       function executeEmergency(\n296           address target,\n297           uint256 value,\n298           bytes calldata data\n299:      ) public payable onlyRole(EMERGENCY_ROLE) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L295-L299\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\n/// @audit Missing: '@return'\n230       /// @param path An array of the two paired token addresses\n231       /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n232       function _swapAndAddLiquidity(\n233           uint256 amount,\n234           uint256 swapAmountIn,\n235           address[] memory path,\n236           IBiswapRouter02 biswapRouter\n237:      ) private returns (uint256 mintedLpAmount) {\n\n/// @audit Missing: '@param reserveA'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param reserveB'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param router'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@return'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n",
                    "//solidity\n/// @audit Missing: '@return'\n230       /// @param path An array of the two paired token addresses\n231       /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition\n232       function _swapAndAddLiquidity(\n233           uint256 amount,\n234           uint256 swapAmountIn,\n235           address[] memory path,\n236           IUniswapV2Router02 uniswapRouter\n237:      ) private returns (uint256 mintedLpAmount) {\n\n/// @audit Missing: '@param reserveA'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param reserveB'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param router'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@return'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n"
                ],
                "Type": " NatSpec is incomplete",
                "Description": "\nThere are 10 instances of this issue:\n\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol\n\nsolidity\n/// @audit Missing: '@return'\n230       /// @param path An array of the two paired token addresses\n231       /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n232       function _swapAndAddLiquidity(\n233           uint256 amount,\n234           uint256 swapAmountIn,\n235           address[] memory path,\n236           IBiswapRouter02 biswapRouter\n237:      ) private returns (uint256 mintedLpAmount) {\n\n/// @audit Missing: '@param reserveA'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param reserveB'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param router'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n/// @audit Missing: '@return'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       /// @param pair The IBiswapPair to be used\n264       function _getOptimalSwapAmount(\n265           uint256 investmentA,\n266           uint256 reserveA,\n267           uint256 reserveB,\n268           IBiswapRouter02 router,\n269           IBiswapPair pair\n270:      ) private view returns (uint256 swapAmount) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L230-L237\n\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol\n\nsolidity\n/// @audit Missing: '@return'\n230       /// @param path An array of the two paired token addresses\n231       /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition\n232       function _swapAndAddLiquidity(\n233           uint256 amount,\n234           uint256 swapAmountIn,\n235           address[] memory path,\n236           IUniswapV2Router02 uniswapRouter\n237:      ) private returns (uint256 mintedLpAmount) {\n\n/// @audit Missing: '@param reserveA'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param reserveB'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@param router'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n/// @audit Missing: '@return'\n258       /// @dev Calculate the optimal amount of tokenA to swap to obtain\n259       ///         the same market value of tokenB after the trade.\n260       ///         This allows to add as many tokensA and tokensB as possible\n261       ///         to the liquidity to minimize the remaining amount.\n262       /// @param investmentA The total amount of tokenA to invest\n263       function _getOptimalSwapAmount(\n264           uint256 investmentA,\n265           uint256 reserveA,\n266           uint256 reserveB,\n267           IUniswapV2Router02 router\n268:      ) private pure returns (uint256 swapAmount) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L230-L237\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nabstracts/MixinOperatorResolver.sol:81:    /// @dev Build the calldata (with safe datas) and call the Operator\n",
                    "diff\n \nabstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is setted\n+ abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is set\n",
                    "//solidity\nlibraries/StakingLPVaultHelpers.sol:21:    /// @param pool The Curve pool to add liquitiy in\nlibraries/StakingLPVaultHelpers.sol:52:    /// @param pool The Curve pool to add liquitiy in\nlibraries/StakingLPVaultHelpers.sol:85:    /// @param pool The Curve pool to remove liquitiy from\nlibraries/StakingLPVaultHelpers.sol:115:    /// @param pool The Curve pool to remove liquitiy from\n",
                    "//solidity\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\noperators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, \"BVO: INVALID_AMOUNT_WITHDRAWED\");\nNestedFactory.sol:51:    /// @dev Fees when funds are withdrawed\nNestedFactory.sol:639:    /// @return The withdrawed amount from the reserve\n",
                    "//solidity\nNestedFactory.sol:477:    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\ntransfered vs transferred\nNestedFactory.sol:534:    /// @return Token transfered (in case of ETH)\n"
                ],
                "Type": " Typos",
                "Description": "\ndatas vs data\n\nsolidity\nabstracts/MixinOperatorResolver.sol:81:    /// @dev Build the calldata (with safe datas) and call the Operator\n\n\nsetted vs set\n\ndiff\n \nabstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is setted\n+ abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is set\n\nliquitiy vs liquidity\n\nsolidity\nlibraries/StakingLPVaultHelpers.sol:21:    /// @param pool The Curve pool to add liquitiy in\nlibraries/StakingLPVaultHelpers.sol:52:    /// @param pool The Curve pool to add liquitiy in\nlibraries/StakingLPVaultHelpers.sol:85:    /// @param pool The Curve pool to remove liquitiy from\nlibraries/StakingLPVaultHelpers.sol:115:    /// @param pool The Curve pool to remove liquitiy from\n\n\nWITHDRAWED vs WITHDREW or WITHDRAWN\n\nsolidity\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\noperators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, \"BVO: INVALID_AMOUNT_WITHDRAWED\");\nNestedFactory.sol:51:    /// @dev Fees when funds are withdrawed\nNestedFactory.sol:639:    /// @return The withdrawed amount from the reserve\n\n\ndont vs don't\n\nsolidity\nNestedFactory.sol:477:    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\ntransfered vs transferred\nNestedFactory.sol:534:    /// @return Token transfered (in case of ETH)\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-21",
                "Location": [],
                "Type": " Lack of solhint To Ignore Warnings",
                "Description": "\nContext: OwnerProxy.sol#L21-L36(https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/OwnerProxy.sol#L21-L36), OperatorScripts.sol#L58-L60(https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L58-L60)\n\nsolhint is useful to help ignore warnings that aren't really issues. For example the code base has some assembly blocks which promts the warning Linter: Avoid to use inline assembly. It is acceptable only in rare cases. Adding in /* solhint-disable no-inline-assembly */ above it will ignore this warning.\n\n",
                "Repair": "Use solhint to ignore warnings that aren't really issues.\n\nmaximebrugel (Nested) responded:\n  OK:\n * L-01] Known vulnerabilities exist in currently used @openzeppelin/contracts version\n * L-02] Impractical Entry/Exit fees are allowed\n * L-03] poolCoinAmount validation\n * L-04] Low level calls with solidity version 0.8.14 can result in optimiser bug.\n * L-05] Unchecked return value of transferFrom can allow a user to withdraw native token for free.\n * N-01] Missing checks for address(0x0) when assigning values to address state variables\n * N-02] Adding a return statement when the function defines a named return variable, is redundant\n * N-03] Public functions not called by the contract should be declared external instead\n * N-04] NatSpec is incomplete\n * N-06] Typos\n * N-07] Lack of Event Emission For Critical Functions\n * N-09] Missing selector check on operator\n * N-10] Unused imports\n * N-12] Add namesLength  0 check in areOperatorsImported() method\n * N-13] Libraries, interfaces, and external imports can be ordered nicely\n * N-15] Consider using IERC20 type instead of address.\n * N-17] Naming inconsistency some arguments have _ at their prefixes but others do not at NestedFactory.sol\n * N-18] Use either _msgSender() or msg.sender\n * N-19] OwnerProxy can call selfdestruct()\n * N-20] A magic number should be documented and explained. Use a constant instead\n\n Acknowledged:\n * N-05] Event is missing indexed fields\n * N-08] Too Recent of a Pragma\n * N-11] Change your imports\n * N-14] Consider checking the recipient address for existence before making the call\n * N-16] setMaxAllowance should be called in the constructor\n\n Not an Issue for Us:\n * N-21] Lack of solhint To Ignore Warnings\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 27 reports were submitted by wardens detailing gas optimizations. The report(https://github.com/code-423n4/2022-06-nested-findings/issues/75) submitted by IllIllI received the top score from the judge.\n\n*The gas optimizations below include reports submitted by IllIllI, as well as: Meera(https://github.com/code-423n4/2022-06-nested-findings/issues/62), 0xkatana(https://github.com/code-423n4/2022-06-nested-findings/issues/29), ElKu(https://github.com/code-423n4/2022-06-nested-findings/issues/68), joestakey(https://github.com/code-423n4/2022-06-nested-findings/issues/82), minhquanym(https://github.com/code-423n4/2022-06-nested-findings/issues/71), PierrickGT(https://github.com/code-423n4/2022-06-nested-findings/issues/49), Waze(https://github.com/code-423n4/2022-06-nested-findings/issues/58), MiloTruck(https://github.com/code-423n4/2022-06-nested-findings/issues/32), c3phas(https://github.com/code-423n4/2022-06-nested-findings/issues/89), &#95;Adam(https://github.com/code-423n4/2022-06-nested-findings/issues/42), 0xKitsune(https://github.com/code-423n4/2022-06-nested-findings/issues/91), Chom(https://github.com/code-423n4/2022-06-nested-findings/issues/81), UnusualTurtle(https://github.com/code-423n4/2022-06-nested-findings/issues/85), 0xNazgul(https://github.com/code-423n4/2022-06-nested-findings/issues/9), delfin454000(https://github.com/code-423n4/2022-06-nested-findings/issues/44), fatherOfBlocks(https://github.com/code-423n4/2022-06-nested-findings/issues/97), robee(https://github.com/code-423n4/2022-06-nested-findings/issues/63), sach1r0(https://github.com/code-423n4/2022-06-nested-findings/issues/25), simon135(https://github.com/code-423n4/2022-06-nested-findings/issues/39), 0x1f8b(https://github.com/code-423n4/2022-06-nested-findings/issues/6), asutorufos(https://github.com/code-423n4/2022-06-nested-findings/issues/57), JC(https://github.com/code-423n4/2022-06-nested-findings/issues/93), oyc&#95;109(https://github.com/code-423n4/2022-06-nested-findings/issues/2), Picodes(https://github.com/code-423n4/2022-06-nested-findings/issues/87), SooYa(https://github.com/code-423n4/2022-06-nested-findings/issues/77), and TerrierLover(https://github.com/code-423n4/2022-06-nested-findings/issues/99).*\n\n## Summary\n\nG-1] Using calldata instead of memory for read-only arguments in external functions saves gas<br\nG-2] Using storage instead of memory for structs/arrays saves gas<br\nG-3] Multiple accesses of a mapping/array should use a local variable cache<br\nG-4] It costs more gas to initialize non-constant/non-immutable variables to zero than to let the default of zero be applied<br\nG-5] Splitting require() statements that use && saves gas<br\nG-6] Using private rather than public for constants, saves gas<br\nG-7] Division by two should use bit shifting<br\nG-8] require() or revert() statements that check input arguments should be at the top of the function<br\nG-9] Functions guaranteed to revert when called by normal users can be marked payable<br\nG-10] The require statements could be put at the beginning part of a block of statements if it doesn\u2019t affect the logic to save gas.<br\nG-11] Unnecessary computation<br\nG-12] Mathematical optimizations<br\nG-13] Constructor parameters should be avoided when possible<br\nG-14] Can save gas when call _submitOutOrders() with _toReserve = false<br\nG-15] transferToReserveAndStore: balanceReserveAfter can be inlined<br\nG-16] Inequality<br\n\n\n"
            },
            {
                "Name": "-03",
                "Location": [
                    "//solidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol   #1\n\n/// @audit vaults[vault] on line 33\n34:           require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n",
                    "//solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n/// @audit operators[i] on line 68\n69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n",
                    "//solidity\nFile: contracts/OperatorResolver.sol   #3\n\n/// @audit operators[<etc] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n",
                    "//solidity\nFile: contracts/OperatorResolver.sol   #4\n\n/// @audit destinations[i] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n"
                ],
                "Type": " Multiple accesses of a mapping/array should use a local variable cache",
                "Description": "\nThe instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local storage variable when the value is accessed multiple times(https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory.\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol   #1\n\n/// @audit vaults[vault] on line 33\n34:           require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L34\n\nsolidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n/// @audit operators[i] on line 68\n69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector);\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L69\n\nsolidity\nFile: contracts/OperatorResolver.sol   #3\n\n/// @audit operators[<etc] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43\n\nsolidity\nFile: contracts/OperatorResolver.sol   #4\n\n/// @audit destinations[i] on line 42\n43:                   operators[names[i]].selector != destinations[i].selector\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n84:           for (uint256 i = 0; i < proposers.length; ++i) {\n\n89:           for (uint256 i = 0; i < executors.length; ++i) {\n\n234:          for (uint256 i = 0; i < targets.length; ++i) {\n\n324:          for (uint256 i = 0; i < targets.length; ++i) {\n",
                    "//solidity\nFile: contracts/abstracts/MixinOperatorResolver.sol\n\n37:           for (uint256 i = 0; i < requiredOperators.length; i++) {\n\n56:           for (uint256 i = 0; i < requiredOperators.length; i++) {\n",
                    "//solidity\nFile: contracts/OperatorResolver.sol\n\n40:           for (uint256 i = 0; i < namesLength; i++) {\n\n60:           for (uint256 i = 0; i < names.length; i++) {\n\n75:           for (uint256 i = 0; i < destinations.length; i++) {\n",
                    "//solidity\nFile: contracts/NestedFactory.sol\n\n124:          for (uint256 i = 0; i < operatorsCache.length; i++) {\n\n136:          for (uint256 i = 0; i < operatorsLength; i++) {\n\n196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n256:          for (uint256 i = 0; i < tokensLength; i++) {\n\n315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n369:          for (uint256 i = 0; i < batchLength; i++) {\n\n412:          for (uint256 i = 0; i < batchLength; i++) {\n\n651:          for (uint256 i = 0; i < _batchedOrders.length; i++) {\n"
                ],
                "Type": " It costs more gas to initialize non-constant/non-immutable variables to zero than to let the default of zero be applied",
                "Description": "\nNot overwriting the default for stack variables(https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves 8 gas. Storage and memory variables have larger savings\n\n*There are 18 instances of this issue:*\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n84:           for (uint256 i = 0; i < proposers.length; ++i) {\n\n89:           for (uint256 i = 0; i < executors.length; ++i) {\n\n234:          for (uint256 i = 0; i < targets.length; ++i) {\n\n324:          for (uint256 i = 0; i < targets.length; ++i) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84\n\nsolidity\nFile: contracts/abstracts/MixinOperatorResolver.sol\n\n37:           for (uint256 i = 0; i < requiredOperators.length; i++) {\n\n56:           for (uint256 i = 0; i < requiredOperators.length; i++) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37\n\nsolidity\nFile: contracts/OperatorResolver.sol\n\n40:           for (uint256 i = 0; i < namesLength; i++) {\n\n60:           for (uint256 i = 0; i < names.length; i++) {\n\n75:           for (uint256 i = 0; i < destinations.length; i++) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40\n\nsolidity\nFile: contracts/NestedFactory.sol\n\n124:          for (uint256 i = 0; i < operatorsCache.length; i++) {\n\n136:          for (uint256 i = 0; i < operatorsLength; i++) {\n\n196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n256:          for (uint256 i = 0; i < tokensLength; i++) {\n\n315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {\n\n369:          for (uint256 i = 0; i < batchLength; i++) {\n\n412:          for (uint256 i = 0; i < batchLength; i++) {\n\n651:          for (uint256 i = 0; i < _batchedOrders.length; i++) {\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-07",
                "Location": [
                    "//solidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol   #1\n\n275:          uint256 halfInvestment = investmentA / 2;\n",
                    "//solidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol   #2\n\n273:          uint256 halfInvestment = investmentA / 2;\n"
                ],
                "Type": " Division by two should use bit shifting",
                "Description": "\n<x / 2 is the same as <x  1. The DIV opcode costs 5 gas, whereas SHR only costs 3 gas.\n\n*There are 2 instances of this issue:*\n\nsolidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol   #1\n\n275:          uint256 halfInvestment = investmentA / 2;\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275\n\nsolidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol   #2\n\n273:          uint256 halfInvestment = investmentA / 2;\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-11",
                "Location": [
                    "//solidity\nOwnableProxyDelegation.sol\nfunction _setOwner\n",
                    "//solidity\naddress oldOwner = _owner;\n_owner = newOwner;\nemit OwnershipTransferred(oldOwner, newOwner)\n",
                    "//solidity\nemit OwnershipTransferred(_owner_, newOwner)\n_owner = newOwner;\n"
                ],
                "Type": " Unnecessary computation",
                "Description": "\nWhen emitting an event that includes a new and an old value, it is cheaper in gas to avoid caching the old value in memory. Instead, emit the event, then save the new value in storage.\n\n\nInstances include:\n\nsolidity\nOwnableProxyDelegation.sol\nfunction _setOwner\n\n\n\nReplace\n\nsolidity\naddress oldOwner = _owner;\n_owner = newOwner;\nemit OwnershipTransferred(oldOwner, newOwner)\n\n\nwith\n\nsolidity\nemit OwnershipTransferred(_owner_, newOwner)\n_owner = newOwner;\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-12",
                "Location": [],
                "Type": " Mathematical optimizations",
                "Description": "\nX += Y costs 22 more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated n times (loops)\n\n\nInstances include:\n\n* NestedFactory.sol\n* amountBought -= amountFees(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L266)\n* amountSpent += _submitOrder(address(tokenSold),_batchedOrders.orders[i].token,_nftId,_batchedOrders.orders[i],true // always to the reserve)(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L370-L376)\n* ethNeeded += _batchedOrders[i].amount(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L653)\n\n\nuse X = X + Y instead of X += Y (same with -).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-13",
                "Location": [],
                "Type": " Constructor parameters should be avoided when possible",
                "Description": "\nConstructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters. With the compilers parameters in hardhat.config.ts, deployment costs approximately 400 more gas per variable written via a constructor parameter.\n\n\nInstances include:\n\nYearnCurveVaultOperator.sol\n\neth = _eth(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\n\nwithdrawer = _withdrawer(https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)\n\n\nHardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\nimport \"./Withdrawer.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /// @dev Helper to withdraw native tokens from wrapper\n    Withdrawer private immutable withdrawer;\n\n    /// @dev Fees when funds stay in portfolios\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public entryFees;\n\n    /// @dev Fees when funds are withdrawed\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public exitFees;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver,\n        Withdrawer _withdrawer\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0) &&\n                address(_withdrawer) != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n        withdrawer = _withdrawer;\n    }\n\n    /// @dev Receive function that will wrap the ether if\n    ///      an address other than the withdrawer sends ether to\n    ///      to the contract. The factory cannot handle ether but\n    ///      has functions to withdraw ERC20 tokens if needed.\n    receive() external payable {\n        if (msg.sender != address(withdrawer)) {\n            weth.deposit{ value: msg.value }();\n        }\n    }\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        rebuildCache();\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        bytes32[] storage operatorsCache = operators;\n        uint256 operatorsLength = operatorsCache.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operatorsCache[i] == operator) {\n                operatorsCache[i] = operators[operatorsLength - 1];\n                operatorsCache.pop();\n                if (operatorCache[operator].implementation != address(0)) {\n                    delete operatorCache[operator]; // remove from cache\n                }\n                rebuildCache();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setEntryFees(uint256 _entryFees) external override onlyOwner {\n        require(_entryFees != 0, \"NF: ZERO_FEES\");\n        require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\");\n        entryFees = _entryFees;\n        emit EntryFeesUpdated(_entryFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function setExitFees(uint256 _exitFees) external override onlyOwner {\n        require(_exitFees != 0, \"NF: ZERO_FEES\");\n        require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\");\n        exitFees = _exitFees;\n        emit ExitFeesUpdated(_exitFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            address token = tokens[i];\n            uint256 amount = _safeWithdraw(token, _nftId);\n            _safeSubmitOrder(token, address(_buyToken), amount, _nftId, _orders[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees\n        unchecked {\n            amountBought -= amountFees;\n\n            _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n            _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n        }\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = _safeWithdraw(token, _nftId);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n        unchecked {\n            uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n            }\n\n            // If input is from the reserve, update the records\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < batchLength; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            unchecked {\n                uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n                if (underSpentAmount != 0) {\n                    SafeERC20.safeTransfer(_inputToken, address(reserve), underSpentAmount);\n                }\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n            }\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n\n        unchecked {\n            // Entry or Exit Fees\n            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\n\n            if (_toReserve) {\n                _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n            }\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    /// @return amountSpent The _inputToken amount spent (with the order)\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        // We raise the following error in case the call to the operator failed\n        // We do not check the calldata to raise the specific error for now\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NF: OVERSPENT\");\n            unchecked {\n                uint256 underSpentAmount = _amountToSpend - amounts[1];\n                if (underSpentAmount != 0) {\n                    _safeTransferWithFees(IERC20(_inputToken), underSpentAmount, _msgSender(), _nftId);\n                }\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        SafeERC20.safeTransfer(_token, reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    /// @return The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(!_fromReserve, \"NF: NO_ETH_FROM_RESERVE\");\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(_inputToken, _inputTokenAmount);\n        } else {\n            SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n            withdrawer.withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            SafeERC20.safeTransfer(_token, _dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    /// @param _nftId The nft Id (for royalty fees)\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee\n        unchecked {\n            _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n            SafeERC20.safeTransfer(_token, _dest, _amount - feeAmount);\n        }\n    }\n\n    /// @dev Withdraw from reserve with care of deflationary tokens.\n    /// @param _token The token to withdraw\n    /// @param _nftId The NFT id to withdraw from\n    /// @return The withdrawed amount from the reserve\n    function _safeWithdraw(address _token, uint256 _nftId) private returns (uint256) {\n        uint256 holdingAmount = nestedRecords.getAssetHolding(_nftId, _token);\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        reserve.withdraw(IERC20(_token), holdingAmount);\n        return IERC20(_token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "sol#L"
                ],
                "Type": " Impractical Entry/Exit fees are allowed",
                "Description": "\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L159\n\nIt seems that Owner is allowed to set entry/exit fees to be 100% of amount. An entry fees of 100% will be impractical and will lead to all order amount to be gone in fees at NestedFactory.sol#L378\n\n\n1. Admin call setEntryFees function and set _entryFees as 10000.\n2. entryFees becomes 100%.\n3. Now assume an order is submitted via _submitInOrders.\n4. Entry fees will be deducted from amount spent.\n5. Since fees is 100% so feesDeducted=amountSpent which means amountSpent effectively becomes 0 as all of it went for fees.\n\n",
                "Repair": "\nDecide a max percentage of fees say 10% which can be charged and then change the require condition accordingly. Same logic need to be applied for exit fees\n\nrequire(_entryFees <= MAX_PERCENTAGE, \"NF: FEES_OVERFLOW\");\n\n\n"
            },
            {
                "Name": "-20",
                "Location": [
                    "//solidity\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:240:            1,\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:251:            1,\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:252:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:240:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:251:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:252:            1,\n",
                    "//solidity\nNestedFactory.sol:378:        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\nNestedFactory.sol:443:            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\n"
                ],
                "Type": " A magic number should be documented and explained. Use a constant instead.",
                "Description": "\n*Similar issue in the past: here(https://github.com/code-423n4/2021-04-marginswap-findings/issues/71)*\n\n1:\nsolidity\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:240:            1,\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:251:            1,\noperators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:252:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:240:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:251:            1,\noperators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:252:            1,\n\n10000:\nsolidity\nNestedFactory.sol:378:        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\nNestedFactory.sol:443:            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\n\n\nI suggest using constant variables as this would make the code more maintainable and readable while costing nothing gas-wise (constants are replaced by their value at compile-time).\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-14",
                "Location": [
                    "_submitOutOrders()",
                    "feesAmount",
                    "entryFees"
                ],
                "Type": " Can save gas when call  _submitOutOrders()  with  _toReserve = false ",
                "Description": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443\n\nIn case _toReserve = false, it still calculates feesAmount using entryFees but do not use the result anywhere. We can save gas by calculating feesAmount only when _toReserve = true\n\n",
                "Repair": "\nOnly calculate feesAmount only when _toReserve = true\n\nsolidity\nif (_toReserve) {\n\tfeesAmount = (amountBought * entryFees) / 10000;\n_transferToReserveAndStore(_batchedOrders.outputToken, amountBought feesAmount, _nftId);\n}\n\n\n\n"
            },
            {
                "Name": "-15",
                "Location": [
                    "_transferToReserveAndStore"
                ],
                "Type": " transferToReserveAndStore: balanceReserveAfter can be inlined",
                "Description": "\nIn the _transferToReserveAndStore function, we store the reserve balance after the transfer in the balanceReserveAfter variable, on line 523(https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L523).\n\nThis variable being only used once, we can inline it and save one mstore.\n\n",
                "Repair": "\nsolidity\nnestedRecords.store(_nftId, address(_token), _token.balanceOf(reserveAddr) balanceReserveBefore, reserveAddr);\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weight The new weight\n    event RoyaltiesWeightUpdated(uint256 weight);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weight\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0, \"FS: EMPTY_ARRAY\");\n        require(accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_weight != 0, \"FS: INVALID_WEIGHT\");\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        Shareholder storage _shareholder = shareholders[_accountIndex];\n        totalWeights = totalWeights + _weight - _shareholder.weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        _shareholder.weight = _weight;\n        emit ShareholderUpdated(_shareholder.account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 _totalWeights = totalWeights;\n        uint256 royaltiesAmount = (amountReceived * royaltiesWeight) / _totalWeights;\n\n        _sendFees(_token, amountReceived, _totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 _totalShares = _tokenRecords.totalShares;\n        if (_totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return (totalReceived * _tokenRecords.shares[_account]) / _totalShares - _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                (_amount * shareholdersCache[i].weight) / _totalWeights,\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1\n\n48:           eth = _eth;\n",
                    "//solidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol   #2\n\n65:           _owner = newOwner;\n"
                ],
                "Type": " Missing checks for  address(0x0)  when assigning values to address state variables",
                "Description": "\nThere are 2 instances of this issue:\n\nsolidity\nFile: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1\n\n48:           eth = _eth;\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48\n\nsolidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol   #2\n\n65:           _owner = newOwner;\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L65\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-15",
                "Location": [
                    "address[]",
                    "IERC"
                ],
                "Type": " Consider using IERC20 type instead of address",
                "Description": "\nConsider using IERC20 type instead of address or IERC20[] type instead of address[].\n\nAffected code:\n\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L291\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L371\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L422\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L423\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L460\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L461\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L487\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L488\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L587\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L640\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L91\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L92\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L19\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L39\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L59\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L82\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L62\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L95\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L125\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L133\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L140\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L141\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L153\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L181\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L191\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L192\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L133\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L140\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L141\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L153\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L181\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L191\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L192\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L11\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L117\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L226\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L274\n1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L9\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-18",
                "Location": [
                    "_msgSender()"
                ],
                "Type": " Use either  _msgSender()  or  msg.sender ",
                "Description": "\nThroughout the file NestedFactory.sol, _msgSender() is used to get the sender. However, following 2 places use msg.sender which seem not consistent.\n\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L89\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-02",
                "Location": [
                    "//solidity\nFile: contracts/NestedFactory.sol   #1\n\n123:          bytes32[] memory operatorsCache = operators;\n"
                ],
                "Type": " Using  storage  instead of  memory  for structs/arrays saves gas",
                "Description": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/NestedFactory.sol   #1\n\n123:          bytes32[] memory operatorsCache = operators;\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: contracts/operators/Beefy/BeefyVaultOperator.sol\n\n54:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\");\n",
                    "//solidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit = depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n",
                    "//solidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit = depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n",
                    "//solidity\nFile: contracts/operators/Paraswap/ParaswapOperator.sol\n\n16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\");\n",
                    "//solidity\nFile: contracts/NestedFactory.sol\n\n66            require(\n67                address(_nestedAsset) != address(0) &&\n68                    address(_nestedRecords) != address(0) &&\n69                    address(_reserve) != address(0) &&\n70                    address(_feeSplitter) != address(0) &&\n71                    address(_weth) != address(0) &&\n72                    _operatorResolver != address(0) &&\n73                    address(_withdrawer) != address(0),\n74                \"NF: INVALID_ADDRESS\"\n75:           );\n"
                ],
                "Type": " Splitting  require()  statements that use  &&  saves gas",
                "Description": "\nSee this issue(https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper.\n\n*There are 7 instances of this issue:*\n\nsolidity\nFile: contracts/operators/Beefy/BeefyVaultOperator.sol\n\n54:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54\n\nsolidity\nFile: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit = depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64\n\nsolidity\nFile: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol\n\n64:           require(vaultAmount != 0 && vaultAmount = minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n\n65:           require(depositedAmount != 0 && amountToDeposit = depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64\n\nsolidity\nFile: contracts/operators/Paraswap/ParaswapOperator.sol\n\n16:           require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16\n\nsolidity\nFile: contracts/NestedFactory.sol\n\n66            require(\n67                address(_nestedAsset) != address(0) &&\n68                    address(_nestedRecords) != address(0) &&\n69                    address(_reserve) != address(0) &&\n70                    address(_feeSplitter) != address(0) &&\n71                    address(_weth) != address(0) &&\n72                    _operatorResolver != address(0) &&\n73                    address(_withdrawer) != address(0),\n74                \"NF: INVALID_ADDRESS\"\n75:           );\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L75\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-06",
                "Location": [
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #1\n\n25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #2\n\n26:       bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #3\n\n27:       bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #4\n\n28:       bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n"
                ],
                "Type": " Using  private  rather than  public  for  constants , saves gas",
                "Description": "\nIf needed, the value can be read from the verified contract source code. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 4 instances of this issue:*\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #1\n\n25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #2\n\n26:       bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #3\n\n27:       bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #4\n\n28:       bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-08",
                "Location": [
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #1\n\n244:          require(delay = getMinDelay(), \"TimelockController: insufficient delay\");\n"
                ],
                "Type": "  require()  or  revert()  statements that check input arguments should be at the top of the function",
                "Description": "\nChecks that involve constants should come before checks that involve state variables.\n\n*There is 1 instance of this issue:*\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol   #1\n\n244:          require(delay = getMinDelay(), \"TimelockController: insufficient delay\");\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-09",
                "Location": [
                    "//solidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n24:       function addVault(address vault, address tokenOrZapper) external onlyOwner {\n\n34:       function removeVault(address vault) external onlyOwner {\n",
                    "//solidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n29:       function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n\n41:       function removeVault(address vault) external onlyOwner {\n",
                    "//solidity\nFile: contracts/governance/OwnerProxy.sol\n\n16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n199       function schedule(\n200           address target,\n201           uint256 value,\n202           bytes calldata data,\n203           bytes32 predecessor,\n204           bytes32 salt,\n205           uint256 delay\n206:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n221       function scheduleBatch(\n222           address[] calldata targets,\n223           uint256[] calldata values,\n224           bytes[] calldata datas,\n225           bytes32 predecessor,\n226           bytes32 salt,\n227           uint256 delay\n228:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n255:      function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n\n274       function execute(\n275           address target,\n276           uint256 value,\n277           bytes calldata data,\n278           bytes32 predecessor,\n279           bytes32 salt\n280:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\n295       function executeEmergency(\n296           address target,\n297           uint256 value,\n298           bytes calldata data\n299:      ) public payable onlyRole(EMERGENCY_ROLE) {\n\n312       function executeBatch(\n313           address[] calldata targets,\n314           uint256[] calldata values,\n315           bytes[] calldata datas,\n316           bytes32 predecessor,\n317           bytes32 salt\n318:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n",
                    "//solidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol\n\n50:       function renounceOwnership() public virtual onlyOwner {\n\n56:       function transferOwnership(address newOwner) public virtual onlyOwner {\n",
                    "//solidity\nFile: contracts/OperatorResolver.sol\n\n52        function importOperators(\n53            bytes32[] calldata names,\n54            Operator[] calldata operatorsToImport,\n55            MixinOperatorResolver[] calldata destinations\n56:       ) external override onlyOwner {\n\n74:       function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n",
                    "//solidity\n\nFile: contracts/NestedFactory.sol\n\n121:      function addOperator(bytes32 operator) external override onlyOwner {\n\n133:      function removeOperator(bytes32 operator) external override onlyOwner {\n\n152:      function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n\n159:      function setEntryFees(uint256 _entryFees) external override onlyOwner {\n\n167:      function setExitFees(uint256 _exitFees) external override onlyOwner {\n\n175:      function unlockTokens(IERC20 _token) external override onlyOwner {\n\n205       function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n206           external\n207           payable\n208           override\n209           nonReentrant\n210           onlyTokenOwner(_nftId)\n211:          isUnlocked(_nftId)\n\n219       function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n220           external\n221           override\n222           nonReentrant\n223           onlyTokenOwner(_nftId)\n224:          isUnlocked(_nftId)\n\n231       function processInputAndOutputOrders(\n232           uint256 _nftId,\n233           BatchedInputOrders[] calldata _batchedInputOrders,\n234           BatchedOutputOrders[] calldata _batchedOutputOrders\n235:      ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n243       function destroy(\n244           uint256 _nftId,\n245           IERC20 _buyToken,\n246           Order[] calldata _orders\n247:      ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n278       function withdraw(uint256 _nftId, uint256 _tokenIndex)\n279           external\n280           override\n281           nonReentrant\n282           onlyTokenOwner(_nftId)\n283:          isUnlocked(_nftId)\n\n301:      function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n"
                ],
                "Type": " Functions guaranteed to revert when called by normal users can be marked  payable ",
                "Description": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\nCALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 27 instances of this issue:*\n\nsolidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n24:       function addVault(address vault, address tokenOrZapper) external onlyOwner {\n\n34:       function removeVault(address vault) external onlyOwner {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24\n\nsolidity\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n29:       function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n\n41:       function removeVault(address vault) external onlyOwner {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L29\n\nsolidity\nFile: contracts/governance/OwnerProxy.sol\n\n16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n199       function schedule(\n200           address target,\n201           uint256 value,\n202           bytes calldata data,\n203           bytes32 predecessor,\n204           bytes32 salt,\n205           uint256 delay\n206:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n221       function scheduleBatch(\n222           address[] calldata targets,\n223           uint256[] calldata values,\n224           bytes[] calldata datas,\n225           bytes32 predecessor,\n226           bytes32 salt,\n227           uint256 delay\n228:      ) public virtual onlyRole(PROPOSER_ROLE) {\n\n255:      function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n\n274       function execute(\n275           address target,\n276           uint256 value,\n277           bytes calldata data,\n278           bytes32 predecessor,\n279           bytes32 salt\n280:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\n295       function executeEmergency(\n296           address target,\n297           uint256 value,\n298           bytes calldata data\n299:      ) public payable onlyRole(EMERGENCY_ROLE) {\n\n312       function executeBatch(\n313           address[] calldata targets,\n314           uint256[] calldata values,\n315           bytes[] calldata datas,\n316           bytes32 predecessor,\n317           bytes32 salt\n318:      ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L199-L206\n\nsolidity\nFile: contracts/abstracts/OwnableProxyDelegation.sol\n\n50:       function renounceOwnership() public virtual onlyOwner {\n\n56:       function transferOwnership(address newOwner) public virtual onlyOwner {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L50\n\nsolidity\nFile: contracts/OperatorResolver.sol\n\n52        function importOperators(\n53            bytes32[] calldata names,\n54            Operator[] calldata operatorsToImport,\n55            MixinOperatorResolver[] calldata destinations\n56:       ) external override onlyOwner {\n\n74:       function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L52-L56\n\nsolidity\n\nFile: contracts/NestedFactory.sol\n\n121:      function addOperator(bytes32 operator) external override onlyOwner {\n\n133:      function removeOperator(bytes32 operator) external override onlyOwner {\n\n152:      function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n\n159:      function setEntryFees(uint256 _entryFees) external override onlyOwner {\n\n167:      function setExitFees(uint256 _exitFees) external override onlyOwner {\n\n175:      function unlockTokens(IERC20 _token) external override onlyOwner {\n\n205       function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n206           external\n207           payable\n208           override\n209           nonReentrant\n210           onlyTokenOwner(_nftId)\n211:          isUnlocked(_nftId)\n\n219       function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n220           external\n221           override\n222           nonReentrant\n223           onlyTokenOwner(_nftId)\n224:          isUnlocked(_nftId)\n\n231       function processInputAndOutputOrders(\n232           uint256 _nftId,\n233           BatchedInputOrders[] calldata _batchedInputOrders,\n234           BatchedOutputOrders[] calldata _batchedOutputOrders\n235:      ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n243       function destroy(\n244           uint256 _nftId,\n245           IERC20 _buyToken,\n246           Order[] calldata _orders\n247:      ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n\n278       function withdraw(uint256 _nftId, uint256 _tokenIndex)\n279           external\n280           override\n281           nonReentrant\n282           onlyTokenOwner(_nftId)\n283:          isUnlocked(_nftId)\n\n301:      function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L121\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-10",
                "Location": [
                    "\nuint256 halfInvestment = investmentA / 2;\n\nuint256 halfInvestment = investmentA / 2;\n",
                    "\nbytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\nb. bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))\n"
                ],
                "Type": " The  require  statements could be put at the beginning part of a block of statements if it doesn\u2019t affect the logic to save gas.",
                "Description": "\n require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n\nThese arithmetic operations can be unchecked.\n\n\nuint256 halfInvestment = investmentA / 2;\n\nuint256 halfInvestment = investmentA / 2;\n\n\nThis line could be pre-computed and defined as a constant to save gas.\n \n\nbytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\nb. bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weight The new weight\n    event RoyaltiesWeightUpdated(uint256 weight);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weight\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0, \"FS: EMPTY_ARRAY\");\n        require(accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_weight != 0, \"FS: INVALID_WEIGHT\");\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        Shareholder storage _shareholder = shareholders[_accountIndex];\n        totalWeights = totalWeights + _weight - _shareholder.weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        _shareholder.weight = _weight;\n        emit ShareholderUpdated(_shareholder.account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 _totalWeights = totalWeights;\n        uint256 royaltiesAmount = (amountReceived * royaltiesWeight) / _totalWeights;\n\n        _sendFees(_token, amountReceived, _totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 _totalShares = _tokenRecords.totalShares;\n        if (_totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return (totalReceived * _tokenRecords.shares[_account]) / _totalShares - _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                (_amount * shareholdersCache[i].weight) / _totalWeights,\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/// @notice Ownable re-implementation to initialize the owner in the\n///         proxy storage after an \"upgradeToAndCall()\" (delegatecall).\n/// @dev The implementation contract owner will be address zero (by removing the constructor)\nabstract contract OwnableProxyDelegation is Context {\n    /// @dev The contract owner\n    address private _owner;\n\n    /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ)\n    bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);\n\n    /// @dev True if the owner is setted\n    bool public initialized;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Initialize the owner (by the proxy admin)\n    /// @param ownerAddr The owner address\n    function initialize(address ownerAddr) external {\n        require(ownerAddr != address(0), \"OPD: INVALID_ADDRESS\");\n        require(!initialized, \"OPD: INITIALIZED\");\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OPD: FORBIDDEN\");\n\n        _setOwner(ownerAddr);\n\n        initialized = true;\n    }\n\n    /// @dev Returns the address of the current owner.\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"OPD: NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Leaves the contract without owner. It will not be possible to call\n    /// `onlyOwner` functions anymore. Can only be called by the current owner.\n    ///\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\n    /// thereby removing any functionality that is only available to the owner.\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"OPD: INVALID_ADDRESS\");\n        _setOwner(newOwner);\n    }\n\n    /// @dev Update the owner address\n    /// @param newOwner The new owner address\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n",
        "CodeNames": [
            "FeeSplitter.sol",
            "OwnableProxyDelegation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-05",
                "Location": [
                    "//solidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n12:       event VaultAdded(address vault, address tokenOrZapper);\n\n16:       event VaultRemoved(address vault);\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12\n\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n17:       event VaultAdded(address vault, CurvePool pool);\n\n21:       event VaultRemoved(address vault);\n",
                    "//solidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n37        event CallScheduled(\n38            bytes32 indexed id,\n39            uint256 indexed index,\n40            address target,\n41            uint256 value,\n42            bytes data,\n43            bytes32 predecessor,\n44            uint256 delay\n45:       );\n\n50:       event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n60:       event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n",
                    "//solidity\nFile: contracts/abstracts/MixinOperatorResolver.sol\n\n14:       event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n"
                ],
                "Type": " Event is missing  indexed  fields",
                "Description": "\nEach event should use three indexed fields if there are three or more fields.\n\nThere are 8 instances of this issue:\n\nsolidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n12:       event VaultAdded(address vault, address tokenOrZapper);\n\n16:       event VaultRemoved(address vault);\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12\n\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n17:       event VaultAdded(address vault, CurvePool pool);\n\n21:       event VaultRemoved(address vault);\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17\n\nsolidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n37        event CallScheduled(\n38            bytes32 indexed id,\n39            uint256 indexed index,\n40            address target,\n41            uint256 value,\n42            bytes data,\n43            bytes32 predecessor,\n44            uint256 delay\n45:       );\n\n50:       event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n60:       event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L37-L45\n\nsolidity\nFile: contracts/abstracts/MixinOperatorResolver.sol\n\n14:       event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation ||\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "OperatorResolver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-12",
                "Location": [
                    "//solidity\nfunction areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n    external\n    view\n    override\n    returns (bool)\n{\n    uint256 namesLength = names.length;\n    require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n    for (uint256 i = 0; i < namesLength; i++) {\n        if (\n            operators[names[i]].implementation != destinations[i].implementation ||\n            operators[names[i]].selector != destinations[i].selector\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                "Type": " Add  namesLength > 0  check in  areOperatorsImported()  method",
                "Description": "\nareOperatorsImported() in OperatorResolver.sol#L32-L49(https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L32-L49) returns true when input arrays are empty (ie. [], ]).\n\n\nsolidity\nfunction areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n    external\n    view\n    override\n    returns (bool)\n{\n    uint256 namesLength = names.length;\n    require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n    for (uint256 i = 0; i < namesLength; i++) {\n        if (\n            operators[names[i]].implementation != destinations[i].implementation ||\n            operators[names[i]].selector != destinations[i].selector\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n",
                "Repair": "\nrequire(namesLength  0 \"empty names/destinations\");\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\nimport \"./Withdrawer.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /// @dev Helper to withdraw native tokens from wrapper\n    Withdrawer private immutable withdrawer;\n\n    /// @dev Fees when funds stay in portfolios\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public entryFees;\n\n    /// @dev Fees when funds are withdrawed\n    ///      From 1 to 10,000 (0.01% to 100%)\n    uint256 public exitFees;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver,\n        Withdrawer _withdrawer\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0) &&\n                address(_withdrawer) != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n        withdrawer = _withdrawer;\n    }\n\n    /// @dev Receive function that will wrap the ether if\n    ///      an address other than the withdrawer sends ether to\n    ///      to the contract. The factory cannot handle ether but\n    ///      has functions to withdraw ERC20 tokens if needed.\n    receive() external payable {\n        if (msg.sender != address(withdrawer)) {\n            weth.deposit{ value: msg.value }();\n        }\n    }\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        rebuildCache();\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        bytes32[] storage operatorsCache = operators;\n        uint256 operatorsLength = operatorsCache.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operatorsCache[i] == operator) {\n                operatorsCache[i] = operators[operatorsLength - 1];\n                operatorsCache.pop();\n                if (operatorCache[operator].implementation != address(0)) {\n                    delete operatorCache[operator]; // remove from cache\n                }\n                rebuildCache();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setEntryFees(uint256 _entryFees) external override onlyOwner {\n        require(_entryFees != 0, \"NF: ZERO_FEES\");\n        require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\");\n        entryFees = _entryFees;\n        emit EntryFeesUpdated(_entryFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function setExitFees(uint256 _exitFees) external override onlyOwner {\n        require(_exitFees != 0, \"NF: ZERO_FEES\");\n        require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\");\n        exitFees = _exitFees;\n        emit ExitFeesUpdated(_exitFees);\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            address token = tokens[i];\n            uint256 amount = _safeWithdraw(token, _nftId);\n            _safeSubmitOrder(token, address(_buyToken), amount, _nftId, _orders[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees\n        unchecked {\n            amountBought -= amountFees;\n\n            _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n            _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n        }\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = _safeWithdraw(token, _nftId);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n        unchecked {\n            uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n            }\n\n            // If input is from the reserve, update the records\n            if (_fromReserve) {\n                _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < batchLength; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            unchecked {\n                uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n                if (underSpentAmount != 0) {\n                    SafeERC20.safeTransfer(_inputToken, address(reserve), underSpentAmount);\n                }\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n            }\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n\n        unchecked {\n            // Entry or Exit Fees\n            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\n\n            if (_toReserve) {\n                _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n            }\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    /// @return amountSpent The _inputToken amount spent (with the order)\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        // We raise the following error in case the call to the operator failed\n        // We do not check the calldata to raise the specific error for now\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NF: OVERSPENT\");\n            unchecked {\n                uint256 underSpentAmount = _amountToSpend - amounts[1];\n                if (underSpentAmount != 0) {\n                    _safeTransferWithFees(IERC20(_inputToken), underSpentAmount, _msgSender(), _nftId);\n                }\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        SafeERC20.safeTransfer(_token, reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    /// @return The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(!_fromReserve, \"NF: NO_ETH_FROM_RESERVE\");\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(_inputToken, _inputTokenAmount);\n        } else {\n            SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n            withdrawer.withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            SafeERC20.safeTransfer(_token, _dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    /// @param _nftId The nft Id (for royalty fees)\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee\n        unchecked {\n            _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n            SafeERC20.safeTransfer(_token, _dest, _amount - feeAmount);\n        }\n    }\n\n    /// @dev Withdraw from reserve with care of deflationary tokens.\n    /// @param _token The token to withdraw\n    /// @param _nftId The NFT id to withdraw from\n    /// @return The withdrawed amount from the reserve\n    function _safeWithdraw(address _token, uint256 _nftId) private returns (uint256) {\n        uint256 holdingAmount = nestedRecords.getAssetHolding(_nftId, _token);\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        reserve.withdraw(IERC20(_token), holdingAmount);\n        return IERC20(_token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"./../../../interfaces/external/IBiswapRouter02.sol\";\nimport \"./../../../interfaces/external/IBiswapPair.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy Biswap LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy Biswap LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapBiswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IBiswapRouter02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IBiswapRouter02 biswapRouter = IBiswapRouter02(router);\n        IBiswapPair pair = IBiswapPair(vault.want());\n\n        require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, biswapRouter, pair);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, biswapRouter, pair);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, biswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0]\u00a0= tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IBiswapRouter02 biswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = biswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = biswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    /// @param pair The IBiswapPair to be used\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IBiswapRouter02 router,\n        IBiswapPair pair\n    ) private view returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB, pair.swapFee());\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax\u00b2 + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../Withdrawer.sol\";\nimport \"./../libraries/ExchangeHelpers.sol\";\nimport \"./../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePool.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./../interfaces/external/IStakingVault/IStakingVault.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @notice Library for LP Staking Vaults deposit/withdraw\nlibrary StakingLPVaultHelpers {\n    using SafeERC20 for IERC20;\n\n    /// @dev  Add liquidity in a Curve pool with ETH and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param eth ETH address\n    /// @param amount ETH amount to add in the Curve pool\n    function _addLiquidityAndDepositETH(\n        address vault,\n        ICurvePoolETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address eth,\n        uint256 amount\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);\n        } else {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev  Add liquidity in a Curve pool and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool lpToken\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param token Token to add in the Curve pool liquidity\n    /// @param amount Token amount to add in the Curve pool\n    function _addLiquidityAndDeposit(\n        address vault,\n        ICurvePoolNonETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);\n        } else {\n            pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity128(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity256(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol",
            "YearnCurveVaultOperator.sol",
            "BeefyZapBiswapLPVaultOperator.sol",
            "StakingLPVaultHelpers.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-16",
                "Location": [
                    "//solidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], tokens[i]);\n    ExchangeHelpers.setMaxAllowance(tokens[i], vaults[i]);\n}\n",
                    "//solidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], routers[i]);\n\n    IBiswapPair pair = IBiswapPair(IBeefyVaultV6(vaults[i]).want());\n\n    ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vaults[i]));\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token0()), routers[i]);\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token1()), routers[i]);\n}\n",
                    "//solidity\nExchangeHelpers.setMaxAllowance(IERC20(_weth), address(_withdrawer));\n",
                    "//solidity\nExchangeHelpers.setMaxAllowance(curvePool.lpToken, vault);\n"
                ],
                "Type": " setMaxAllowance should be called in the constructor",
                "Description": "\n\ndeposit: setMaxAllowance should be called in the constructor\n\nIn the deposit function on line 48(https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/BeefyVaultOperator.sol#L48), we call ExchangeHelpers.setMaxAllowance(token, vault); to allow the vault to spend token.<br\n\nEach time assets are deposited in the vault, we shouldn't have to allow it to spend the token again.<br\n\nI recommend to call ExchangeHelpers.setMaxAllowance(token, vault) only once in the constructor for each vault and token. I also recommend to add a setMaxAllowance function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\nRecommendation\n\nsolidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], tokens[i]);\n    ExchangeHelpers.setMaxAllowance(tokens[i], vaults[i]);\n}\n\n\n\nzapAndStakeLp: setMaxAllowance should be called in the constructor\n\nIn the _zapAndStakeLp function on line 189(https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L189) and subsequently on line 194(https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L194) and 195(https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L195) we call ExchangeHelpers.setMaxAllowance(); to allow the vault to spend token.\n\nEach time assets are deposited in the vault, we shouldn't have to allow it to spend the token again.<br\nI recommend to call ExchangeHelpers.setMaxAllowance() only once in the constructor for each vault and token. I also recommend to add a setMaxAllowance function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\nThis will also avoid calling ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router); in the _withdrawAndSwap function on line 162.\n\nRecommendation\n\nsolidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], routers[i]);\n\n    IBiswapPair pair = IBiswapPair(IBeefyVaultV6(vaults[i]).want());\n\n    ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vaults[i]));\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token0()), routers[i]);\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token1()), routers[i]);\n}\n\n\n\ndepositETH: setMaxAllowance should be called in the constructor\n\nIn the depositETH function on line 78(https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L78), we call ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer)); to allow the withdrawer to spend weth.\n\nEach time assets are deposited in the vault, we shouldn't have to allow the withdrawer to spend weth again.<br\nI recommend to call ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer)) only once in the constructor. I also recommend to add a setMaxAllowance function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\nRecommendation\n\nsolidity\nExchangeHelpers.setMaxAllowance(IERC20(_weth), address(_withdrawer));\n\n\n\naddLiquidityAndDepositETH: setMaxAllowance should be called in addVault\n\nIn the addLiquidityAndDepositETH function on line 45(https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L45), we call ExchangeHelpers.setMaxAllowance(lpToken, vault); to allow the vault to spend lpToken.\n\nEach time assets are deposited in the vault, we shouldn't have to allow the vault to spend lpToken again.<br\nI recommend to call ExchangeHelpers.setMaxAllowance(lpToken, vault); only once in the addVault function of the YearnVaultStorage. I also recommend to add a setMaxAllowance function only callable by the owner that would allow to set the max allowance in case the allowance has decreased.\n\nThis will also avoid calling it in the _addLiquidityAndDeposit function on line 77(https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L77)\n\nRecommendation\n\nsolidity\nExchangeHelpers.setMaxAllowance(curvePool.lpToken, vault);\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/external/INestedToken.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\n\n/// @title Token sent to this contract are used to purchase NST.\n/// @dev Some of it is burned, the rest is sent to a pool that will redistribute\n///      to the NST ecosystem and community.\ncontract NestedBuybacker is Ownable {\n    /// @dev Emitted when the reserve address is updated\n    /// @param newReserve The new reserve address\n    event ReserveUpdated(address newReserve);\n\n    /// @dev Emitted when the fee splitter address is updated\n    /// @param newFeeSplitter The new FeeSplitter address\n    event FeeSplitterUpdated(FeeSplitter newFeeSplitter);\n\n    /// @dev Emitted when the burn percentage is updated\n    /// @param newBurnPart The new burn percentage amount\n    event BurnPartUpdated(uint256 newBurnPart);\n\n    /// @dev Emitted when the buy back is executed\n    /// @param forToken sellToken used for the buy back\n    event BuybackTriggered(IERC20 forToken);\n\n    /// @dev The Nested project token\n    INestedToken public immutable NST;\n\n    /// @dev Current address where user assets are stored\n    address public nstReserve;\n\n    /// @dev Current fee splitter address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Part of the bought tokens to be burned (100% = 1000)\n    uint256 public burnPercentage;\n\n    receive() external payable {}\n\n    constructor(\n        address _NST,\n        address _nstReserve,\n        address payable _feeSplitter,\n        uint256 _burnPercentage\n    ) {\n        require(_burnPercentage <= 1000, \"NB: INVALID_BURN_PART\");\n        require(_NST != address(0) && _nstReserve != address(0) && _feeSplitter != address(0), \"NB: INVALID_ADDRESS\");\n        burnPercentage = _burnPercentage;\n        NST = INestedToken(_NST);\n        feeSplitter = FeeSplitter(_feeSplitter);\n        nstReserve = _nstReserve;\n    }\n\n    /// @notice Update the nested reserve address\n    /// @param _nstReserve New reserve contract address\n    function setNestedReserve(address _nstReserve) external onlyOwner {\n        require(_nstReserve != address(0), \"NB: INVALID_ADDRESS\");\n        nstReserve = _nstReserve;\n        emit ReserveUpdated(nstReserve);\n    }\n\n    /// @notice Update the fee splitter address\n    /// @param _feeSplitter The new fee splitter contract address\n    function setFeeSplitter(FeeSplitter _feeSplitter) external onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NB: INVALID_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(feeSplitter);\n    }\n\n    /// @notice Update parts deciding what amount is sent to reserve or burned\n    /// @param _burnPercentage The new burn percentage\n    function setBurnPart(uint256 _burnPercentage) external onlyOwner {\n        require(_burnPercentage <= 1000, \"NB: INVALID_BURN_PART\");\n        burnPercentage = _burnPercentage;\n        emit BurnPartUpdated(burnPercentage);\n    }\n\n    /// @notice Triggers the purchase of NST sent to reserve and burn\n    /// @param _swapCallData Call data provided by 0x to fill quotes\n    /// @param _swapTarget Target contract for the swap (could be Uniswap router for example)\n    /// @param _sellToken Token to sell in order to buy NST\n    function triggerForToken(\n        bytes calldata _swapCallData,\n        address payable _swapTarget,\n        IERC20 _sellToken\n    ) external onlyOwner {\n        if (feeSplitter.getAmountDue(address(this), _sellToken) != 0) {\n            IERC20[] memory tokens = new IERC20[](1);\n            tokens[0] = _sellToken;\n            feeSplitter.releaseTokensNoETH(tokens);\n        }\n\n        require(ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData), \"NB : FAILED_SWAP\");\n        trigger();\n        emit BuybackTriggered(_sellToken);\n    }\n\n    /// @dev burns part of the bought NST and send the rest to the reserve\n    function trigger() internal {\n        uint256 balance = NST.balanceOf(address(this));\n        uint256 toBurn = (balance * burnPercentage) / 1000;\n        uint256 toSendToReserve = balance - toBurn;\n        NST.burn(toBurn);\n        SafeERC20.safeTransfer(NST, nstReserve, toSendToReserve);\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedBuybacker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-17",
                "Location": [
                    "setFeeSplitter(FeeSplitter _feeSplitter)"
                ],
                "Type": " Naming inconsistency - some arguments have  _  at their prefixes but others do not at NestedFactory.sol",
                "Description": "\nThroughout the file NestedFactory.sol, arguments of functions have _ at their prefixes like function setFeeSplitter(FeeSplitter _feeSplitter). However, following 2 arguments do not have _ at their prefixes which are not consistent.\n\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121\n\nhttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L133\n\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../OperatorResolver.sol\";\nimport \"../interfaces/IOperatorResolver.sol\";\nimport \"../interfaces/INestedFactory.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address/selector\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public immutable resolver;\n\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\n    mapping(bytes32 => IOperatorResolver.Operator) internal operatorCache;\n\n    constructor(address _resolver) {\n        require(_resolver != address(0), \"MOR: INVALID_ADDRESS\");\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    ///      invoked via super in subclasses\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\n\n    /// @notice Rebuild the operatorCache\n    function rebuildCache() public {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory destination;\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            destination = resolver.getOperator(name);\n            if (destination.implementation != address(0)) {\n                operatorCache[name] = destination;\n            } else {\n                delete operatorCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of operatorCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory cacheTmp;\n        IOperatorResolver.Operator memory actualValue;\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            cacheTmp = operatorCache[name];\n            actualValue = resolver.getOperator(name);\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                actualValue.implementation != cacheTmp.implementation ||\n                actualValue.selector != cacheTmp.selector ||\n                cacheTmp.implementation == address(0)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\"MOR: MISSING_OPERATOR: \", name)));\n        return _foundAddress;\n    }\n\n    /// @dev Build the calldata (with safe datas) and call the Operator\n    /// @param _order The order to execute\n    /// @param _inputToken The input token address\n    /// @param _outputToken The output token address\n    /// @return success If the operator call is successful\n    /// @return amounts The amounts from the execution (used and received)\n    ///         - amounts[0] : The amount of output token\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\n    function callOperator(\n        INestedFactory.Order calldata _order,\n        address _inputToken,\n        address _outputToken\n    ) internal returns (bool success, uint256[] memory amounts) {\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\n        // Parameters are concatenated and padded to 32 bytes.\n        // We are concatenating the selector + given params\n        bytes memory data;\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\n\n        if (success) {\n            address[] memory tokens;\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\n            require(tokens[0] == _outputToken, \"MOR: INVALID_OUTPUT_TOKEN\");\n            require(tokens[1] == _inputToken, \"MOR: INVALID_INPUT_TOKEN\");\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/external/INestedToken.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\n\n/// @title Token sent to this contract are used to purchase NST.\n/// @dev Some of it is burned, the rest is sent to a pool that will redistribute\n///      to the NST ecosystem and community.\ncontract NestedBuybacker is Ownable {\n    /// @dev Emitted when the reserve address is updated\n    /// @param newReserve The new reserve address\n    event ReserveUpdated(address newReserve);\n\n    /// @dev Emitted when the fee splitter address is updated\n    /// @param newFeeSplitter The new FeeSplitter address\n    event FeeSplitterUpdated(FeeSplitter newFeeSplitter);\n\n    /// @dev Emitted when the burn percentage is updated\n    /// @param newBurnPart The new burn percentage amount\n    event BurnPartUpdated(uint256 newBurnPart);\n\n    /// @dev Emitted when the buy back is executed\n    /// @param forToken sellToken used for the buy back\n    event BuybackTriggered(IERC20 forToken);\n\n    /// @dev The Nested project token\n    INestedToken public immutable NST;\n\n    /// @dev Current address where user assets are stored\n    address public nstReserve;\n\n    /// @dev Current fee splitter address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Part of the bought tokens to be burned (100% = 1000)\n    uint256 public burnPercentage;\n\n    receive() external payable {}\n\n    constructor(\n        address _NST,\n        address _nstReserve,\n        address payable _feeSplitter,\n        uint256 _burnPercentage\n    ) {\n        require(_burnPercentage <= 1000, \"NB: INVALID_BURN_PART\");\n        require(_NST != address(0) && _nstReserve != address(0) && _feeSplitter != address(0), \"NB: INVALID_ADDRESS\");\n        burnPercentage = _burnPercentage;\n        NST = INestedToken(_NST);\n        feeSplitter = FeeSplitter(_feeSplitter);\n        nstReserve = _nstReserve;\n    }\n\n    /// @notice Update the nested reserve address\n    /// @param _nstReserve New reserve contract address\n    function setNestedReserve(address _nstReserve) external onlyOwner {\n        require(_nstReserve != address(0), \"NB: INVALID_ADDRESS\");\n        nstReserve = _nstReserve;\n        emit ReserveUpdated(nstReserve);\n    }\n\n    /// @notice Update the fee splitter address\n    /// @param _feeSplitter The new fee splitter contract address\n    function setFeeSplitter(FeeSplitter _feeSplitter) external onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NB: INVALID_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(feeSplitter);\n    }\n\n    /// @notice Update parts deciding what amount is sent to reserve or burned\n    /// @param _burnPercentage The new burn percentage\n    function setBurnPart(uint256 _burnPercentage) external onlyOwner {\n        require(_burnPercentage <= 1000, \"NB: INVALID_BURN_PART\");\n        burnPercentage = _burnPercentage;\n        emit BurnPartUpdated(burnPercentage);\n    }\n\n    /// @notice Triggers the purchase of NST sent to reserve and burn\n    /// @param _swapCallData Call data provided by 0x to fill quotes\n    /// @param _swapTarget Target contract for the swap (could be Uniswap router for example)\n    /// @param _sellToken Token to sell in order to buy NST\n    function triggerForToken(\n        bytes calldata _swapCallData,\n        address payable _swapTarget,\n        IERC20 _sellToken\n    ) external onlyOwner {\n        if (feeSplitter.getAmountDue(address(this), _sellToken) != 0) {\n            IERC20[] memory tokens = new IERC20[](1);\n            tokens[0] = _sellToken;\n            feeSplitter.releaseTokensNoETH(tokens);\n        }\n\n        require(ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData), \"NB : FAILED_SWAP\");\n        trigger();\n        emit BuybackTriggered(_sellToken);\n    }\n\n    /// @dev burns part of the bought NST and send the rest to the reserve\n    function trigger() internal {\n        uint256 balance = NST.balanceOf(address(this));\n        uint256 toBurn = (balance * burnPercentage) / 1000;\n        uint256 toSendToReserve = balance - toBurn;\n        NST.burn(toBurn);\n        SafeERC20.safeTransfer(NST, nstReserve, toSendToReserve);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Owner proxy to run atomic actions.\n/// @notice DSProxy-like contract without a cache to simply run\n///         a sequence of atomic actions.\ncontract OwnerProxy is Ownable {\n    /// @notice Execute atomic actions. Only the owner can call this function (e.g. the timelock)\n    /// @param _target Address of the \"script\" to perform a delegatecall\n    /// @param _data The bytes calldata\n    /// @return response The delegatecall response\n    /// @dev Fork from https://github.com/dapphub/ds-proxy/blob/e17a2526ad5c9877ba925ff25c1119f519b7369b/src/proxy.sol#L53\n    /// @dev bytes4 selector must be included in the calldata (_data)\n    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) {\n        require(_target != address(0), \"OP: INVALID_TARGET\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n            let size := returndatasize()\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n                // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "MixinOperatorResolver.sol",
            "NestedBuybacker.sol",
            "OwnerProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-19",
                "Location": [
                    "_target",
                    "delegatecall()",
                    "execute()"
                ],
                "Type": "  OwnerProxy  can call  selfdestruct() ",
                "Description": "\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L9-L36\n\n\nOwnerProxy's selfdestruct\n\n\nWhile only the owner (the timelock) can call the execute function, this doesn't mean it can't be compromised or phished to call a malicious _target, which could contain a call to selfdestruct().\n\nAs selfdestruct() would be a simple OPCODE in the context of the OwnerProxy contract (which is the one using delegatecall() in execute()), this would destroy the contract.\n\nThis is a known bug in the community (see the Parity Multisig Hack): delegatecalls from contracts are dangerous.\n\n",
                "Repair": "\nConsider making OwnerProxy a library instead of a contract to protect it from being selfdestructed and to further protect its state (that can also be manipulated as a contract)\n\nAlternatively, consider deploying the OwnerProxy contract using CREATE2 so that the contract could be re-created at the same pre-computed address, if need be.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./abstracts/OwnableFactoryHandler.sol\";\n\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\ncontract NestedAsset is ERC721Enumerable, OwnableFactoryHandler {\n    using Counters for Counters.Counter;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    Counters.Counter private _tokenIds;\n\n    /// @dev Base URI (API)\n    string public baseUri;\n\n    /// @dev Token URI when not revealed\n    string public unrevealedTokenUri;\n\n    /// @dev NFT contract URI\n    string public contractUri;\n\n    /// @dev Stores the original asset of each asset\n    mapping(uint256 => uint256) public originalAsset;\n\n    /// @dev Stores owners of burnt assets\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\n\n    /// @dev True if revealed, false if not.\n    bool public isRevealed;\n\n    /* ---------------------------- CONSTRUCTORS --------------------------- */\n\n    constructor() ERC721(\"NestedNFT\", \"NESTED\") {}\n\n    /* ----------------------------- MODIFIERS ----------------------------- */\n\n    /// @dev Reverts the transaction if the address is not the token owner\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\n        require(_address == ownerOf(_tokenId), \"NA: FORBIDDEN_NOT_OWNER\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\n    /// @param _tokenId The id of the NestedAsset\n    /// @return The token Uniform Resource Identifier (URI)\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(_exists(_tokenId), \"URI query for nonexistent token\");\n        if (isRevealed) {\n            return super.tokenURI(_tokenId);\n        } else {\n            return unrevealedTokenUri;\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function _baseURI() internal view override returns (string memory) {\n        return baseUri;\n    }\n\n    /// @notice Returns the owner of the original token if the token was replicated\n    /// If the original asset was burnt, the last owner before burn is returned\n    /// @param _tokenId The asset for which we want to know the original owner\n    /// @return The owner of the original asset\n    function originalOwner(uint256 _tokenId) external view returns (address) {\n        uint256 originalAssetId = originalAsset[_tokenId];\n\n        if (originalAssetId != 0) {\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\n        }\n        return address(0);\n    }\n\n    /* ---------------------------- ONLY FACTORY --------------------------- */\n\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\n    /// @param _owner The account address that signed the transaction\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\n    /// @return The minted token's id\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 tokenId = _tokenIds.current();\n        _safeMint(_owner, tokenId);\n\n        // Stores the first asset of the replication chain as the original\n        if (_replicatedTokenId == 0) {\n            return tokenId;\n        }\n\n        require(_exists(_replicatedTokenId), \"NA: NON_EXISTENT_TOKEN_ID\");\n        require(tokenId != _replicatedTokenId, \"NA: SELF_DUPLICATION\");\n\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\n\n        return tokenId;\n    }\n\n    /// @notice Burns an ERC721 token\n    /// @param _owner The account address that signed the transaction\n    /// @param _tokenId The id of the NestedAsset\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\n        lastOwnerBeforeBurn[_tokenId] = _owner;\n        _burn(_tokenId);\n    }\n\n    /* ----------------------------- ONLY OWNER ---------------------------- */\n\n    /// @notice Update isRevealed to reveal or hide the token URI\n    function setIsRevealed(bool _isRevealed) external onlyOwner {\n        isRevealed = _isRevealed;\n    }\n\n    /// @notice Set the base URI (once revealed)\n    /// @param _baseUri The new baseURI\n    function setBaseURI(string memory _baseUri) external onlyOwner {\n        require(bytes(_baseUri).length != 0, \"NA: EMPTY_URI\");\n        baseUri = _baseUri;\n    }\n\n    /// @notice Set the unrevealed token URI (fixed)\n    /// @param _newUri The new unrevealed URI\n    function setUnrevealedTokenURI(string memory _newUri) external onlyOwner {\n        require(bytes(_newUri).length != 0, \"NA: EMPTY_URI\");\n        unrevealedTokenUri = _newUri;\n    }\n\n    /// @notice Set the contract URI\n    /// @param _newUri The new contract URI\n    function setContractURI(string memory _newUri) external onlyOwner {\n        contractUri = _newUri;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is received\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Emitted when the royalties weight is updated\n    /// @param weight The new weight\n    event RoyaltiesWeightUpdated(uint256 weight);\n\n    /// @dev Emitted when a new shareholder is added\n    /// @param account The new shareholder account\n    /// @param weight The shareholder weight\n    event ShareholdersAdded(address account, uint256 weight);\n\n    /// @dev Emitted when a shareholder weight is updated\n    /// @param account The shareholder address\n    /// @param weight The new weight\n    event ShareholderUpdated(address account, uint256 weight);\n\n    /// @dev Emitted when royalties are claim released\n    /// @param to The address claiming the royalties\n    /// @param token The token received\n    /// @param value The amount received\n    event RoyaltiesReceived(address to, address token, uint256 value);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint96 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        address[] memory _accounts,\n        uint96[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        require(_weth != address(0), \"FS: INVALID_ADDRESS\");\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(msg.sender == weth, \"FS: ETH_SENDER_NOT_WETH\");\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        require(_weight != 0, \"FS: WEIGHT_ZERO\");\n        totalWeights = totalWeights + _weight - royaltiesWeight;\n        royaltiesWeight = _weight;\n        emit RoyaltiesWeightUpdated(_weight);\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\n        delete shareholders;\n        uint256 accountsLength = _accounts.length;\n        require(accountsLength != 0, \"FS: EMPTY_ARRAY\");\n        require(accountsLength == _weights.length, \"FS: INPUTS_LENGTH_MUST_MATCH\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < accountsLength; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\n        require(_weight != 0, \"FS: INVALID_WEIGHT\");\n        require(_accountIndex < shareholders.length, \"FS: INVALID_ACCOUNT_INDEX\");\n        Shareholder storage _shareholder = shareholders[_accountIndex];\n        totalWeights = totalWeights + _weight - _shareholder.weight;\n        require(totalWeights != 0, \"FS: TOTAL_WEIGHTS_ZERO\");\n        _shareholder.weight = _weight;\n        emit ShareholderUpdated(_shareholder.account, _weight);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @notice Release multiple tokens and handle ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            if (address(_tokens[i]) == weth) {\n                IWETH(weth).withdraw(amount);\n                (bool success, ) = _msgSender().call{ value: amount }(\"\");\n                require(success, \"FS: ETH_TRANFER_ERROR\");\n            } else {\n                SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            }\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Release multiple tokens without ETH unwrapping\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\n        uint256 amount;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            amount = _releaseToken(_msgSender(), _tokens[i]);\n            SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\n        }\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights;\n        unchecked {\n            weights = totalWeights - royaltiesWeight;\n        }\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FS: INVALID_ROYALTIES_TARGET\");\n\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\n\n        uint256 _totalWeights = totalWeights;\n        uint256 royaltiesAmount = (amountReceived * royaltiesWeight) / _totalWeights;\n\n        _sendFees(_token, amountReceived, _totalWeights);\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\n\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 _totalShares = _tokenRecords.totalShares;\n        if (_totalShares == 0) return 0;\n\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\n        return (totalReceived * _tokenRecords.shares[_account]) / _totalShares - _tokenRecords.released[_account];\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FS: SHAREHOLDER_NOT_FOUND\");\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @notice Transfers a fee to this contract\n    /// @dev This method calculates the amount received, to support deflationary tokens\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token sent\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        Shareholder[] memory shareholdersCache = shareholders;\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\n            _addShares(\n                shareholdersCache[i].account,\n                (_amount * shareholdersCache[i].weight) / _totalWeights,\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares += _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FS: NO_PAYMENT_DUE\");\n\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        _tokenRecords.released[_account] += amountToRelease;\n        _tokenRecords.totalReleased += amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint96 _weight) private {\n        require(_weight != 0, \"FS: ZERO_WEIGHT\");\n        require(_account != address(0), \"FS: INVALID_ADDRESS\");\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            require(shareholders[i].account != _account, \"FS: ALREADY_SHAREHOLDER\");\n        }\n\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n        emit ShareholdersAdded(_account, _weight);\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedAsset.sol",
            "FeeSplitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "//solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #1\n\n28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28\n",
                    "//solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n",
                    "//solidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #3\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n"
                ],
                "Type": " Using  calldata  instead of  memory  for read-only arguments in external functions saves gas",
                "Description": "\nWhen a function with a memory array is called externally, the abi.decode() step has to use a for-loop to copy each index of the calldata to the memory index. Each iteration of this for-loop costs at least 60 gas (i.e. 60 * <mem_array.length). Using calldata directly, obliviates the need for such a loop in the contract code and runtime execution.\n\nIf the array is passed to an internal function which passes the array to another internal function where the array is modified and therefore memory is used in the external call, it's still more gas-efficient to use calldata when the external function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\n*There are 3 instances of this issue:*\n\nsolidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #1\n\n28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28\n\n\nsolidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #2\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n\n\nsolidity\nFile: contracts/governance/scripts/OperatorScripts.sol   #3\n\n52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external {\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52\n\n\n\n",
                "Repair": ""
            }
        ]
    }
]