[
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/external/yearn/IYearnVault.sol\";\nimport \"./interfaces/IYearnVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Yearn protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the\n/// last `deposit` / `withdraw`\n///\n/// ### yTokens\n/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there\n/// - in YearnVaultRegistry.\n/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,\n/// the YearnVault cannot be created.\n///\n/// ### Push / Pull\n/// There are some deposit limits imposed by Yearn vaults.\n/// The contract's vaultTokens are fully allowed to corresponding yTokens.\n\ncontract YearnVault is Vault {\n    address[] private _yTokens;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _yTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);\n            require(_yTokens[i] != address(0), \"YV\");\n        }\n    }\n\n    /// @notice Yearn protocol vaults used by this contract\n    function yTokens() external view returns (address[] memory) {\n        return _yTokens;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            address token = tokens[i];\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            _allowTokenIfNecessary(token, address(yToken));\n            yToken.deposit(tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        uint256 maxLoss = abi.decode(options, (uint256));\n        for (uint256 i = 0; i < _yTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n\n            IYearnVault yToken = IYearnVault(_yTokens[i]);\n            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());\n            uint256 balance = yToken.balanceOf(address(this));\n            if (yTokenAmount > balance) {\n                yTokenAmount = balance;\n            }\n            if (yTokenAmount == 0) {\n                continue;\n            }\n            yToken.withdraw(yTokenAmount, to, maxLoss);\n            (tokenAmounts[i], address(this));\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _allowTokenIfNecessary(address token, address yToken) internal {\n        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {\n            IERC20(token).approve(yToken, type(uint256).max);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/CommonLibrary.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ILpIssuer.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./LpIssuerGovernance.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}\n\n\n",
        "CodeNames": [
            "YearnVault.sol",
            "AaveVault.sol",
            "LpIssuer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n    for (uint256 i = 0; i < _yTokens.length; i++) {\n        if (tokenAmounts[i] == 0) {\n            continue;\n        }\n\n        IYearnVault yToken = IYearnVault(_yTokens[i]);\n        uint256 yTokenAmount = ((tokenAmounts[i] * (10yToken.decimals())) / yToken.pricePerShare());\n        uint256 balance = yToken.balanceOf(address(this));\n        if (yTokenAmount  balance) {\n            yTokenAmount = balance;\n        }\n        if (yTokenAmount == 0) {\n            continue;\n        }\n        yToken.withdraw(yTokenAmount, to, maxLoss);\n        (tokenAmounts[i], address(this));\n    }\n    actualTokenAmounts = tokenAmounts;\n"
                ],
                "Type": "  YearnVault.sol#pull()  will most certainly fail",
                "Description": "\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101\n\nsolidity\n    for (uint256 i = 0; i < _yTokens.length; i++) {\n        if (tokenAmounts[i] == 0) {\n            continue;\n        }\n\n        IYearnVault yToken = IYearnVault(_yTokens[i]);\n        uint256 yTokenAmount = ((tokenAmounts[i] * (10yToken.decimals())) / yToken.pricePerShare());\n        uint256 balance = yToken.balanceOf(address(this));\n        if (yTokenAmount  balance) {\n            yTokenAmount = balance;\n        }\n        if (yTokenAmount == 0) {\n            continue;\n        }\n        yToken.withdraw(yTokenAmount, to, maxLoss);\n        (tokenAmounts[i], address(this));\n    }\n    actualTokenAmounts = tokenAmounts;\n\n\nThe actual token withdrew from yToken.withdraw() will most certainly be less than the tokenAmounts[i], due to precision loss in the calculation of yTokenAmount.\n\nAs a result, IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]); in LpIssuer.sol#withdraw() will revert due to insufficant balance.\n\n",
                "Repair": "\nChange to:\n\nsolidity\ntokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss);\n\n\nMihanixA (Mellow Protocol) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1005637681):\n  Actually I don't see how this could lead to fund loss. I think this one is a bug.\n @0xleastwood what do you think? \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1007872447):\n  my understanding is that users won't be able to withdraw pushed funds @MihanixA \n  \n  so fund loss is related to not being able to withdraw rather than by extracting value from the protocol\n\nOxn1ck (Mellow Protocol) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1030698636):\n  While we agree that this will prevent full withdrawal of the funds, that wil be limited to only a couple of wei's which is the yearn precision loss. So in case you put 100eth you will be able to recover 100eth 1wei. So we'd rather name the issue \"some small amounts cannot be withdrawn from the pool\"\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1030720307):\n  If my understanding is correct, YearnVault._pull will withdraw yTokenAmount representing the yToken's shares and then withdraw on this amount but return tokenAmounts where the amount withdrawn is typically less than the amount intended to be withdrawn. LpIssuer.withdraw() will expect actualTokenAmounts to be available to be transferred which isn't exactly in the contract's balance.\n \n https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L90\n https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L152\n \n  Let's use an example:\n \n Alice calls LpIssuer.withdraw() with tokensAmount[0] equal to 100 tokens. Let's ignore the lpTokenAmount argument for the sake of this example.\n _subvault().pull is called on this tokensAmount[0].\n yTokenAmount is calculated according to ((tokenAmounts[i] * (10yToken.decimals())) / yToken.pricePerShare()); which potentially leads to a slightly truncated output.\n This truncated output represents the shares belonging to the user which is then parsed to yToken.withdraw().\n yToken.withdraw() is likely less than 100 tokens and is sent to the LpIssuer.sol contract but actualTokenAmounts[0] is equal to 100 tokens.\n LpIssuer.withdraw() attempts to send tokens to the withdrawer but is unable as the contract does not have sufficient balance. IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n If I'm not mistaken, it seems like this issue would be apparent on any withdrawal amount (assuming there is some amount truncated).\n There is also an important edge case where the amount to withdraw from the yearn vault is greater than the available contract balance, it will always revert.\n\nOxn1ck (Mellow Protocol) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/121#issuecomment-1032415580):\n  Agreed, thank you!\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/CommonLibrary.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ILpIssuer.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./LpIssuerGovernance.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}\n\n\n",
        "CodeNames": [
            "LpIssuer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n"
                ],
                "Type": " Wrong implementation of  performanceFee  can cause users to lose 50% to 100% of their funds",
                "Description": "\nA certain amount of lp tokens (shares of the vault) will be minted to the strategyPerformanceTreasury as performanceFee, the amount is calculated based on the minLpPriceFactor.\n\nHowever, the current formula for toMint is wrong, which issues more than 100% of the current totalSupply of the lp token to the strategyPerformanceTreasury each time. Causing users to lose 50% to 100% of their funds after a few times.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271\n\nsolidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n\n\n\nGiven:\n\n*   strategyParams.performanceFee: 10e7 (1%)\n\n1.  Alice deposited 1,000 USDC, received 1000 lpToken; the totalSupply of the lpToken is now: 1000;\n2.  3 days later, baseTvl increased to 1,001 USDC, Bob deposited 1 USDC and trigegred _chargeFees():\n\n*   Expected Result: strategyPerformanceTreasury to receive about 0.01 lpToken (1% of 1 USDC);\n*   Actual Result: minLpPriceFactor is about 1.001, and strategyPerformanceTreasury will received 1001 lpToken as performanceFee; Alice lose 50% of deposited funds.\n\n",
                "Repair": "\nChange to:\n\nsolidity\naddress treasury = strategyParams.strategyPerformanceTreasury;\nuint256 toMint = (baseSupply * (minLpPriceFactor CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR;\n_mint(treasury, toMint);\n\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/91)\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nif (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n    return;\n}\n"
                ],
                "Type": " Users can avoid paying vault fees",
                "Description": "\nThe LPIssuer.deposit/withdraw function charges protocol&management&performance fees through inflating the LP supply in the _chargeFees function.\nHowever, this LP fees minting is skipped if the elapsed time is less than the managementFeeChargeDelay:\n\nsolidity\nif (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n    return;\n}\n\n\nThis allows a user to avoid paying any fees if they deposit right after a charge fee interaction and withdraw within again managementFeeChargeDelay time period.\n\n\nThis can be abused heavily on networks where the gas fees are a lot cheaper than the three vault fees:\n\n*   deposit a tiny amount just to trigger the charge fees. This sets lastFeeCharge\n*   deposit a huge amount, tvl increases significantly\n*   let it earn interest. withdraw it before the managementFeeChargeDelay. No fees are paid, tvl reduces significantly\n*   repeat, fees are only paid on tiny tvl\n\n\nIn the worst case, nobody pays fees by repeating the above actions.\n\n",
                "Repair": "\nFees must always be charged on each deposit and withdrawal, even within the same block as it could be that a huge interest \"harvest\" comes in that an attacker sandwiches.\nRemove the if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) { return; } code.\n\nMihanixA (Mellow Protocol) disputed(https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-999373852):\n  Charging fees on every deposit costs a lot of gas. \n If we notice users avoid paying fees we would just switch managementFeeChargeDelay to zero. \n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005658252):\n  I don't think this is a valid reason. At the end of the day, users can still abuse this feature and it is best to think about worse case scenario. I'll keep this issue as high severity unless there is any reason not to? @MihanixA \n\nMihanixA (Mellow Protocol) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005665074):\n  @0xleastwood \n Notice that users funds are not at risk and we can not remove this behaviour because this would lead to high withdraw/deposit fees.\n Anyway feel free to mark this issue anything seems fair to you.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/47#issuecomment-1005668810):\n  While I understand funds aren't directly at risk. It does seem like this issue can be exploited to earn additional yield at a lower opportunity cost as the user does not pay fees.\n \n I think I'll mark this as medium then.\n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IGatewayVault.sol\";\nimport \"./interfaces/IGatewayVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that combines several integration layer Vaults into one Vault.\ncontract GatewayVault is IERC721Receiver, IGatewayVault, Vault {\n    using SafeERC20 for IERC20;\n    uint256[] internal _subvaultNfts;\n    mapping(uint256 => uint256) internal _subvaultNftsIndex;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc IGatewayVault\n    function subvaultNfts() external view returns (uint256[] memory) {\n        return _subvaultNfts;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                tokenAmounts[j] += vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));\n        return vault.tvl();\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 vaultTokensLength = _vaultTokens.length;\n        tokenAmounts = new uint256[][](_subvaultNfts.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            tokenAmounts[i] = new uint256[](vaultTokensLength);\n            for (uint256 j = 0; j < vaultTokensLength; j++) {\n                tokenAmounts[i][j] = vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function hasSubvault(address vault) external view override returns (bool) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 nft_ = registry.nftForVault(vault);\n        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);\n    }\n\n    /// @inheritdoc IGatewayVault\n    function addSubvaults(uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);\n        address[] memory selfTokens = _vaultTokens;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        for (uint256 i = 0; i < nfts.length; i++) {\n            uint256 nft_ = nfts[i];\n            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n            IVault vault = IVault(registry.vaultForNft(nft_));\n            address[] memory vTokens = vault.vaultTokens();\n            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);\n            for (uint256 j = 0; j < selfTokens.length; j++) {\n                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);\n            }\n            _subvaultNfts.push(nft_);\n            _subvaultNftsIndex[nft_] = i;\n        }\n    }\n\n    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);\n        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;\n        for (uint i = 0; i < nfts.length; ++i)\n            vaultRegistry.approve(strategy, nfts[i]);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        bool optimized;\n        bytes[] memory vaultsOptions;\n        (optimized, vaultsOptions) = _parseOptions(options);\n\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(\n            address(_vaultGovernance)\n        ).delayedStrategyParams(_nft);\n        if (optimized && strategyParams.redirects.length > 0) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (strategyParams.redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            if (optimized && (strategyParams.redirects[i] != 0)) {\n                continue;\n            }\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                if (amountsByVault[i][j] > 0) {\n                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));\n                }\n            }\n            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(\n                address(this),\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n                totalTvl[j] += tvls[i][j];\n            }\n        }\n        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);\n        }\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);\n\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))\n            .delayedStrategyParams(_nft)\n            .redirects;\n\n        if (optimized && (_redirects.length > 0)) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (_redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory actualVaultTokenAmounts = vault.pull(\n                to,\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n            }\n        }\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {\n        if (options.length == 0) {\n            return (false, new bytes[](_subvaultNfts.length));\n        }\n        return abi.decode(options, (bool, bytes[]));\n    }\n\n    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);\n    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/external/univ3/INonfungiblePositionManager.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Pool.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Factory.sol\";\nimport \"./interfaces/IUniV3VaultGovernance.sol\";\nimport \"./libraries/external/TickMath.sol\";\nimport \"./libraries/external/LiquidityAmounts.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.\ncontract UniV3Vault is IERC721Receiver, Vault {\n    struct Options {\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct Pair {\n        uint256 a0;\n        uint256 a1;\n    }\n\n    IUniswapV3Pool public immutable pool;\n\n    uint256 public uniV3Nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param fee Fee of the underlying UniV3 pool\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        uint24 fee\n    ) Vault(vaultGovernance_, vaultTokens_) {\n        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);\n        pool = IUniswapV3Pool(\n            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)\n        );\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {\n        require(msg.sender == address(_positionManager()), \"SNFT\");\n        require(_isStrategy(operator), \"STR\");\n        (\n            , ,\n            address token0,\n            address token1,\n            , , , , , , ,\n        ) = _positionManager().positions(tokenId);\n        // new position should have vault tokens\n        require(\n            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],\n            \"VT\"\n        );\n\n        if (uniV3Nft != 0) {\n            (\n                , , , , , , ,\n                uint128 liquidity,\n                , ,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            ) = _positionManager().positions(uniV3Nft);\n            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, \"TVL\");\n            // return previous uni v3 position nft\n            _positionManager().transferFrom(address(this), from, uniV3Nft);\n        }\n\n        uniV3Nft = tokenId;\n        return this.onERC721Received.selector;\n    }\n\n    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        collectedEarnings = new uint256[](2);\n        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n        collectedEarnings[0] = collectedEarnings0;\n        collectedEarnings[1] = collectedEarnings1;\n        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        if (uniV3Nft == 0)\n            return tokenAmounts;\n        (\n            , , , , , \n            int24 tickLower, \n            int24 tickUpper, \n            uint128 liquidity,\n            , , ,\n        ) = _positionManager().positions(uniV3Nft);\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            liquidity\n        );\n        tokenAmounts[0] = amount0;\n        tokenAmounts[1] = amount1;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < tokens.length; i++)\n            _allowTokenIfNecessary(tokens[i]);\n\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = Pair({\n            a0: tokenAmounts[0],\n            a1: tokenAmounts[1]\n        });\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                amount0Desired: amounts.a0,\n                amount1Desired: amounts.a1,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        actualTokenAmounts[0] = amount0;\n        actualTokenAmounts[1] = amount1;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);\n        actualTokenAmounts[0] = amounts.a0;\n        actualTokenAmounts[1] = amounts.a1;\n    }\n\n    function _pullUniV3Nft(\n        uint256[] memory tokenAmounts,\n        address to,\n        Options memory opts\n    ) internal returns (Pair memory) {\n        uint128 liquidityToPull;\n        // scope the code below to avoid stack-too-deep exception\n        {\n            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]\n            );\n            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;\n            if (liquidityToPull == 0) {\n                return Pair({a0: 0, a1: 0});\n            }\n        }\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                liquidity: liquidityToPull,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n        return Pair({a0: amount0Collected, a1: amount1Collected});\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {}\n\n    /// TODO: make a virtual function here? Or other better approach\n    function _positionManager() internal view returns (INonfungiblePositionManager) {\n        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(address(_positionManager()), type(uint256).max);\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (Options memory) {\n        if (options.length == 0)\n            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});\n\n        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);\n        return abi.decode(options, (Options));\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);\n}\n\n\n",
        "CodeNames": [
            "GatewayVault.sol",
            "AaveVault.sol",
            "UniV3Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "withdraw()",
                    "UniV",
                    "collectEarnings()",
                    "tvl()",
                    "strategy"
                ],
                "Type": "  UniV3Vault.sol#collectEarnings()  can be front run",
                "Description": "\nFor UniV3Vault, it seems that lp fees are collected through collectEarnings() callable by the strategy and reinvested (rebalanced).\n\nHowever, in the current implementation, unharvested yields are not included in tvl(), making it vulnerable to front-run attacks that steal pending yields.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97\n\n\nGiven:\n\n*   Current tvl() is 10 ETH and 40,000 USDC;\n*   Current unclaimed yields (trading fees) is 1 ETH and 4,000 USDC;\n\n1.  strategy calls collectEarnings() to collect fees and reinvest;\n2.  The attacker sends a deposit tx with a higher gas price to deposit 10 ETH and 40,000 USDC, take 50% share of the pool;\n3.  After the transaction in step 1 is packed, the attacker calls withdraw() and retrieves 10.5 ETH and 42,000 USDC.\n\nAs a result, the attacker has stolen half of the pending yields in about 1 block of time.\n\n",
                "Repair": "\nConsider including fees in tvl().\n\nFor the code to calculate fees earned, please reference _computeFeesEarned() in G-UNI project:\n\n<https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/98#issuecomment-995467521):\n  Thanks! \n Added tokensOwed to UniV3Vault's tvl \n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./libraries/CommonLibrary.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ILpIssuer.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./LpIssuerGovernance.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.\ncontract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    uint256 private _subvaultNft;\n    IVaultGovernance internal _vaultGovernance;\n    address[] internal _vaultTokens;\n    mapping(address => bool) internal _vaultTokensIndex;\n    uint256 private _nft;\n    uint256[] private _lpPriceHighWaterMarks;\n    uint256[] private _existentials;\n\n    uint256 public lastFeeCharge;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param name_ Name of the ERC-721 token\n    /// @param symbol_ Symbol of the ERC-721 token\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {\n        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);\n        _vaultGovernance = vaultGovernance_;\n        _vaultTokens = vaultTokens_;\n        for (uint256 i = 0; i < vaultTokens_.length; i++) {\n            address token = vaultTokens_[i];\n            _vaultTokensIndex[token] = true;\n            _lpPriceHighWaterMarks.push(0);\n            _existentials.push(10**(ERC20(token).decimals() / 2));\n        }\n        lastFeeCharge = block.timestamp;\n    }\n\n    function vaultGovernance() external view returns (IVaultGovernance) {\n        return _vaultGovernance;\n    }\n\n    function vaultTokens() external view returns (address[] memory) {\n        return _vaultTokens;\n    }\n\n    function existentials() external view returns (uint256[] memory) {\n        return _existentials;\n    }\n\n    /// @inheritdoc ILpIssuer\n    function subvaultNft() external view returns (uint256) {\n        return _subvaultNft;\n    }\n\n    function nft() external view returns (uint256) {\n        return _nft;\n    }\n\n    function initialize(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);\n        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);\n        _nft = nft_;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        registry.setApprovalForAll(address(registry), true);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 thisNft = _nft;\n        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);\n        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);\n        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);\n        IVault subvault = _subvault();\n        uint256[] memory existentials_ = _existentials;\n        uint256[] memory tvl = subvault.tvl(); //pre-money\n        uint256 supply = totalSupply();\n        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;\n        if (supply > 0) {\n            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR\n            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);\n        }\n\n        // If with that big supply we don't reveive any lps then it doesn't make sense to continue\n        require(balanceFactor > 0, \"BF\");\n        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);\n\n        // Making sure the proportion between tokenAmounts and tvl are the same\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);\n            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));\n            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);\n        }\n\n        uint256[] memory actualTokenAmounts = subvault.transferAndPush(\n            address(this),\n            _vaultTokens,\n            balancedAmounts,\n            options\n        );\n        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);\n\n        require(amountToMint > 0, \"ZLP\");\n\n        require(\n            amountToMint + balanceOf(msg.sender) <=\n                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,\n            ExceptionsLibrary.LIMIT_PER_ADDRESS\n        );\n\n        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);\n        _mint(msg.sender, amountToMint);\n\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (balancedAmounts[i] > actualTokenAmounts[i]) {\n                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);\n            }\n        }\n\n        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function withdraw(\n        address to,\n        uint256 lpTokenAmount,\n        bytes memory options\n    ) external nonReentrant {\n        uint256 supply = totalSupply();\n        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);\n        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);\n        uint256[] memory tvl = _subvault().tvl();\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;\n        }\n        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            if (actualTokenAmounts[i] == 0) {\n                continue;\n            }\n            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);\n        }\n        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);\n        _burn(msg.sender, lpTokenAmount);\n        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);\n    }\n\n    /// @inheritdoc ILpIssuer\n    function addSubvault(uint256 nft_) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n        _subvaultNft = nft_;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _subvault() internal view returns (IVault) {\n        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));\n    }\n\n    /// @dev We don't charge on any deposit / withdraw to save gas.\n    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)\n    /// So the error results in slightly lower management fees than in exact case\n    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n\n    function _getLpAmount(\n        uint256[] memory tvl,\n        uint256[] memory amounts,\n        uint256[] memory existentials_,\n        uint256 supply\n    ) internal pure returns (uint256 lpAmount) {\n        lpAmount = 0;\n        if (supply == 0) {\n            // On init lpToken = max(tokenAmounts)\n            for (uint256 i = 0; i < tvl.length; i++) {\n                if (amounts[i] > lpAmount) {\n                    lpAmount = amounts[i];\n                }\n            }\n            return lpAmount;\n        }\n        for (uint256 i = 0; i < tvl.length; i++) {\n            if (amounts[i] <= existentials_[i]) {\n                // skip existential deposits for lp share calculation\n                continue;\n            }\n            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];\n            // take min of meaningful tokenLp amounts\n            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\n                lpAmount = tokenLpAmount;\n            }\n        }\n    }\n\n    function _getBalancedAmount(\n        uint256 tvl,\n        uint256 amount,\n        uint256 existential,\n        uint256 balanceFactor,\n        uint256 supply\n    ) internal pure returns (uint256) {\n        if (supply == 0) {\n            // skip normalization on init\n            return amount;\n        }\n        if (amount < existential) {\n            // avoid putting small amounts as it can introduce unnecessary harsh errors\n            // one should provide amount > existential deposit each time tvl is not 0\n            require(tvl == 0, \"PN\");\n            return 0;\n        }\n        // normalize amount\n        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;\n        if (res > amount) {\n            res = amount;\n        }\n        return res;\n    }\n\n    /// @notice Emitted when management fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when protocol fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when performance fees are charged\n    /// @param treasury Treasury receiver of the fee\n    /// @param feeRate Fee percent applied denominated in 10 ** 9\n    /// @param amount Amount of lp token minted\n    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);\n\n    /// @notice Emitted when liquidity is deposited\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens deposited\n    /// @param actualTokenAmounts Token amounts deposited\n    /// @param lpTokenMinted LP tokens received by the liquidity provider\n    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);\n\n    /// @notice Emitted when liquidity is withdrawn\n    /// @param from The source address for the liquidity\n    /// @param tokens ERC20 tokens withdrawn\n    /// @param actualTokenAmounts Token amounts withdrawn\n    /// @param lpTokenBurned LP tokens burned from the liquidity provider\n    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IGatewayVault.sol\";\nimport \"./interfaces/IGatewayVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that combines several integration layer Vaults into one Vault.\ncontract GatewayVault is IERC721Receiver, IGatewayVault, Vault {\n    using SafeERC20 for IERC20;\n    uint256[] internal _subvaultNfts;\n    mapping(uint256 => uint256) internal _subvaultNftsIndex;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc IGatewayVault\n    function subvaultNfts() external view returns (uint256[] memory) {\n        return _subvaultNfts;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                tokenAmounts[j] += vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));\n        return vault.tvl();\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 vaultTokensLength = _vaultTokens.length;\n        tokenAmounts = new uint256[][](_subvaultNfts.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            tokenAmounts[i] = new uint256[](vaultTokensLength);\n            for (uint256 j = 0; j < vaultTokensLength; j++) {\n                tokenAmounts[i][j] = vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function hasSubvault(address vault) external view override returns (bool) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 nft_ = registry.nftForVault(vault);\n        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);\n    }\n\n    /// @inheritdoc IGatewayVault\n    function addSubvaults(uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);\n        address[] memory selfTokens = _vaultTokens;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        for (uint256 i = 0; i < nfts.length; i++) {\n            uint256 nft_ = nfts[i];\n            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n            IVault vault = IVault(registry.vaultForNft(nft_));\n            address[] memory vTokens = vault.vaultTokens();\n            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);\n            for (uint256 j = 0; j < selfTokens.length; j++) {\n                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);\n            }\n            _subvaultNfts.push(nft_);\n            _subvaultNftsIndex[nft_] = i;\n        }\n    }\n\n    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);\n        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;\n        for (uint i = 0; i < nfts.length; ++i)\n            vaultRegistry.approve(strategy, nfts[i]);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        bool optimized;\n        bytes[] memory vaultsOptions;\n        (optimized, vaultsOptions) = _parseOptions(options);\n\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(\n            address(_vaultGovernance)\n        ).delayedStrategyParams(_nft);\n        if (optimized && strategyParams.redirects.length > 0) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (strategyParams.redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            if (optimized && (strategyParams.redirects[i] != 0)) {\n                continue;\n            }\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                if (amountsByVault[i][j] > 0) {\n                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));\n                }\n            }\n            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(\n                address(this),\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n                totalTvl[j] += tvls[i][j];\n            }\n        }\n        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);\n        }\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);\n\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))\n            .delayedStrategyParams(_nft)\n            .redirects;\n\n        if (optimized && (_redirects.length > 0)) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (_redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory actualVaultTokenAmounts = vault.pull(\n                to,\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n            }\n        }\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {\n        if (options.length == 0) {\n            return (false, new bytes[](_subvaultNfts.length));\n        }\n        return abi.decode(options, (bool, bytes[]));\n    }\n\n    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);\n    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n",
        "CodeNames": [
            "LpIssuer.sol",
            "GatewayVault.sol",
            "AaveVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "updateTvl",
                    "transferAndPush",
                    "actualTokenAmounts =",
                    "updateTvls",
                    "deposit",
                    "amountToMint",
                    "tvl",
                    "_tvls"
                ],
                "Type": " AaveVault does not update TVL on deposit/withdraw",
                "Description": "\nAave uses rebasing tokens which means the token balance aToken.balanceOf(this) increases over time with the accrued interest.\n\nThe AaveVault.tvl uses a cached value that needs to be updated using a updateTvls call.\n\nThis call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share *of the old tvl*, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the *new tvl*, receiving back their initial deposit + the share of the interest.\nThis can be done risk-free in a single transaction.\n\n\n*   Imagine an Aave Vault with a single vault token, and current TVL = 1,000 aTokens\n*   Attacker calls LPIssuer.push([1000]). This loads the old, cached tvl. No updateTvl is called.\n*   The 1000 underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: aaveVault.transferAndPush([1000]). This deposists 1000 underlying tokens to the Aave lending pool and returns actualTokenAmounts = 1000]. After that the internal _tvls variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited but also the new rebased aToken amounts, the interest the vault received from supplying the tokens since last updateTvls call. _tvls = _tvls + interest + 1000\n*   The LP amount to mint amountToMint is still calculated on the old cached tvl memory variable, i.e., attacker receives amount / oldTvl = 1000/1000 = 100% of existing LP supply\n*   Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in deposit's transferAndPush call). Attacker receives 50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest.\n*   Attacker makes a profit of 0.5 * interest\n\n\nThe interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing.\nIf the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest\n\n",
                "Repair": "\nUpdate the tvl when depositing and withdrawing before doing anything else.\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/41)\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./interfaces/IDefaultAccessControl.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice This is a default access control with 2 roles -\n/// ADMIN and ADMIN_DELEGATE.\ncontract DefaultAccessControl is IDefaultAccessControl, AccessControlEnumerable {\n    bytes32 public constant ADMIN_ROLE = keccak256(\"admin\");\n    bytes32 public constant ADMIN_DELEGATE_ROLE = keccak256(\"admin_delegate\");\n\n    /// @notice Creates a new contract.\n    /// @param admin Admin of the contract\n    constructor(address admin) {\n        require(admin != address(0), ExceptionsLibrary.ADMIN_ADDRESS_ZERO);\n        _setupRole(ADMIN_ROLE, admin);\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(ADMIN_DELEGATE_ROLE, ADMIN_ROLE);\n    }\n\n    /// @notice Checks if the address is contract admin.\n    /// @param sender Adddress to check\n    /// @return `true` if sender is an admin, `false` otherwise\n    function isAdmin(address sender) public view returns (bool) {\n        return hasRole(ADMIN_ROLE, sender) || hasRole(ADMIN_DELEGATE_ROLE, sender);\n    }\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n",
        "CodeNames": [
            "DefaultAccessControl.sol",
            "AaveVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "min(",
                    "tokenAmounts"
                ],
                "Type": " User deposits don't have min. return checks",
                "Description": "\nThe LPIssuer.deposit first computes *balanced amounts* on the user's defined tokenAmounts.\nThe idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be *balanced*, meaning, the depositAmount / tvl ratio should be equal for all vault tokens.\n\nBut the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance.\nThis frontrun can happen accidentally whenever the strategist rebalances\n\n\nThere's a vault with two tokens A and B, tvls are [500, 1500]\n\n*   The user provides [500, 1500], expecting to get 50% of the share supply (is minted 100% of old total supply).\n*   The strategist rebalances to [1000, 1000]\n*   The user's balanceFactor is min(500/1000, 1500/1000) = 1/2, their balancedAmounts are thus tvl * balanceFactor = 500, 500], the 1000 excess token B are refunded. In the end, they only received 500/(1000+500) = 33.3% of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.\n\n\nUsers can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.\n\n",
                "Repair": "\nAdd minimum return amount checks.\nAccept a function parameter that can be chosen by the user indicating their *expected LP amount* for their deposit tokenAmounts, then check that the actually minted LP token amount is above this parameter.\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/46)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n",
        "CodeNames": [
            "AaveVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "tokenAmounts",
                    "updateTvls",
                    "_push",
                    "_pull",
                    "tvl"
                ],
                "Type": " Withdraw from  AaveVault  will receive less than actual share",
                "Description": "\n\nAaveVault cache tvl and update it at the end of each _push and _pull. When withdrawing from LpIssuer,  tokenAmounts is calculated using the cached tvl to be pulled from AaveVault. This will lead to user missing out their share of the accrued interest / donations to Aave since the last updateTvls.\n\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13\n\n",
                "Repair": "\nCall updateTvls at the beginning of withdraw function if the _subvault will cache tvl\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/82)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BSL-1.1\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../interfaces/IProtocolGovernance.sol\";\nimport \"./interfaces/ITrader.sol\";\nimport \"./interfaces/IChiefTrader.sol\";\nimport \"./libraries/TraderExceptionsLibrary.sol\";\n\n/// @notice Main contract that allows trading of ERC20 tokens on different Dexes\n/// @dev This contract contains several subtraders that can be used for trading ERC20 tokens.\n/// Examples of subtraders are UniswapV3, UniswapV2, SushiSwap, Curve, etc.\ncontract ChiefTrader is ERC165, IChiefTrader, ITrader {\n    address public immutable protocolGovernance;\n    address[] internal _traders;\n    mapping(address => bool) public addedTraders;\n\n    constructor(address _protocolGovernance) {\n        protocolGovernance = _protocolGovernance;\n    }\n\n    /// @inheritdoc IChiefTrader\n    function tradersCount() external view returns (uint256) {\n        return _traders.length;\n    }\n\n    function getTrader(uint256 _index) external view returns (address) {\n        return _traders[_index];\n    }\n\n    function traders() external view returns (address[] memory) {\n        return _traders;\n    }\n\n    /// @inheritdoc IChiefTrader\n    function addTrader(address traderAddress) external {\n        _requireProtocolAdmin();\n        require(traderAddress != address(this), TraderExceptionsLibrary.RECURRENCE_EXCEPTION);\n        require(!addedTraders[traderAddress], TraderExceptionsLibrary.TRADER_ALREADY_REGISTERED_EXCEPTION);\n        require(ERC165(traderAddress).supportsInterface(type(ITrader).interfaceId));\n        require(!ERC165(traderAddress).supportsInterface(type(IChiefTrader).interfaceId));\n        _traders.push(traderAddress);\n        addedTraders[traderAddress] = true;\n        emit AddedTrader(_traders.length - 1, traderAddress);\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactInput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] calldata path,\n        bytes calldata options\n    ) external returns (uint256) {\n        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n        _requireAllowedTokens(path);\n        address traderAddress = _traders[traderId];\n        address recipient = msg.sender;\n        return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactOutput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] calldata path,\n        bytes calldata options\n    ) external returns (uint256) {\n        require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n        _requireAllowedTokens(path);\n        address traderAddress = _traders[traderId];\n        address recipient = msg.sender;\n        return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return (interfaceId == this.supportsInterface.selector ||\n            interfaceId == type(ITrader).interfaceId ||\n            interfaceId == type(IChiefTrader).interfaceId);\n    }\n\n    function _requireAllowedTokens(PathItem[] memory path) internal view {\n        IProtocolGovernance pg = IProtocolGovernance(protocolGovernance);\n        for (uint256 i = 1; i < path.length; ++i)\n            require(\n                pg.isAllowedToken(path[i].token0) && pg.isAllowedToken(path[i].token1),\n                TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION\n            );\n        if (path.length > 0)\n            require(pg.isAllowedToken(path[0].token1), TraderExceptionsLibrary.TOKEN_NOT_ALLOWED_EXCEPTION);\n    }\n\n    function _requireProtocolAdmin() internal view {\n        require(\n            IProtocolGovernance(protocolGovernance).isAdmin(msg.sender),\n            TraderExceptionsLibrary.PROTOCOL_ADMIN_REQUIRED_EXCEPTION\n        );\n    }\n\n    event AddedTrader(uint256 indexed traderId, address traderAddress);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./trader/interfaces/IChiefTrader.sol\";\nimport \"./trader/interfaces/ITrader.sol\";\nimport \"./interfaces/IERC20VaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that stores ERC20 tokens.\ncontract ERC20Vault is Vault, ITrader {\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            tokenAmounts[i] = IERC20(tokens[i]).balanceOf(address(this));\n        }\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactInput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] memory path,\n        bytes memory options\n    ) external returns (uint256 amountOut) {\n        require(\n            path.length > 0  && isVaultToken(path[path.length - 1].token1), \n            ExceptionsLibrary.NOT_VAULT_TOKEN\n        );\n        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);\n        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));\n        ITrader trader = ITrader(vg.delayedProtocolParams().trader);\n        IChiefTrader chiefTrader = IChiefTrader(address(trader));\n        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));\n        return trader.swapExactInput(traderId, amount, address(0), path, options);\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactOutput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] memory path,\n        bytes calldata options\n    ) external returns (uint256 amountOut) {\n        require(\n            path.length > 0  && isVaultToken(path[path.length - 1].token1), \n            ExceptionsLibrary.NOT_VAULT_TOKEN\n        );\n        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);\n        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));\n        ITrader trader = ITrader(vg.delayedProtocolParams().trader);\n        IChiefTrader chiefTrader = IChiefTrader(address(trader));\n        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));\n        return trader.swapExactOutput(traderId, amount, address(0), path, options);\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        pure\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        // no-op, tokens are already on balance\n        return tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        for (uint256 i = 0; i < tokenAmounts.length; i++) {\n            IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(!isVaultToken(tokens[i]), ExceptionsLibrary.OTHER_VAULT_TOKENS); // vault token is part of TVL\n        }\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    function _approveERC20TokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(to, type(uint256).max);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/external/univ3/INonfungiblePositionManager.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Pool.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Factory.sol\";\nimport \"./interfaces/IUniV3VaultGovernance.sol\";\nimport \"./libraries/external/TickMath.sol\";\nimport \"./libraries/external/LiquidityAmounts.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.\ncontract UniV3Vault is IERC721Receiver, Vault {\n    struct Options {\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct Pair {\n        uint256 a0;\n        uint256 a1;\n    }\n\n    IUniswapV3Pool public immutable pool;\n\n    uint256 public uniV3Nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param fee Fee of the underlying UniV3 pool\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        uint24 fee\n    ) Vault(vaultGovernance_, vaultTokens_) {\n        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);\n        pool = IUniswapV3Pool(\n            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)\n        );\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {\n        require(msg.sender == address(_positionManager()), \"SNFT\");\n        require(_isStrategy(operator), \"STR\");\n        (\n            , ,\n            address token0,\n            address token1,\n            , , , , , , ,\n        ) = _positionManager().positions(tokenId);\n        // new position should have vault tokens\n        require(\n            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],\n            \"VT\"\n        );\n\n        if (uniV3Nft != 0) {\n            (\n                , , , , , , ,\n                uint128 liquidity,\n                , ,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            ) = _positionManager().positions(uniV3Nft);\n            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, \"TVL\");\n            // return previous uni v3 position nft\n            _positionManager().transferFrom(address(this), from, uniV3Nft);\n        }\n\n        uniV3Nft = tokenId;\n        return this.onERC721Received.selector;\n    }\n\n    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        collectedEarnings = new uint256[](2);\n        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n        collectedEarnings[0] = collectedEarnings0;\n        collectedEarnings[1] = collectedEarnings1;\n        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        if (uniV3Nft == 0)\n            return tokenAmounts;\n        (\n            , , , , , \n            int24 tickLower, \n            int24 tickUpper, \n            uint128 liquidity,\n            , , ,\n        ) = _positionManager().positions(uniV3Nft);\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            liquidity\n        );\n        tokenAmounts[0] = amount0;\n        tokenAmounts[1] = amount1;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < tokens.length; i++)\n            _allowTokenIfNecessary(tokens[i]);\n\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = Pair({\n            a0: tokenAmounts[0],\n            a1: tokenAmounts[1]\n        });\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                amount0Desired: amounts.a0,\n                amount1Desired: amounts.a1,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        actualTokenAmounts[0] = amount0;\n        actualTokenAmounts[1] = amount1;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);\n        actualTokenAmounts[0] = amounts.a0;\n        actualTokenAmounts[1] = amounts.a1;\n    }\n\n    function _pullUniV3Nft(\n        uint256[] memory tokenAmounts,\n        address to,\n        Options memory opts\n    ) internal returns (Pair memory) {\n        uint128 liquidityToPull;\n        // scope the code below to avoid stack-too-deep exception\n        {\n            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]\n            );\n            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;\n            if (liquidityToPull == 0) {\n                return Pair({a0: 0, a1: 0});\n            }\n        }\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                liquidity: liquidityToPull,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n        return Pair({a0: amount0Collected, a1: amount1Collected});\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {}\n\n    /// TODO: make a virtual function here? Or other better approach\n    function _positionManager() internal view returns (INonfungiblePositionManager) {\n        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(address(_positionManager()), type(uint256).max);\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (Options memory) {\n        if (options.length == 0)\n            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});\n\n        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);\n        return abi.decode(options, (Options));\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);\n}\n\n\n",
        "CodeNames": [
            "ChiefTrader.sol",
            "ERC20Vault.sol",
            "UniV3Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\nreturn ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);\n",
                    "//solidity\nIERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n",
                    "//solidity\nfunction swapExactOutput(\n    uint256 traderId,\n    uint256 amount,\n    address,\n    PathItem[] calldata path,\n    bytes calldata options\n) external returns (uint256) {\n    require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n    _requireAllowedTokens(path);\n    address traderAddress = _traders[traderId];\n    address recipient = msg.sender;\n    return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);\n}\n"
                ],
                "Type": "  ChiefTrader.sol  Wrong implementation of  swapExactInput()  and  swapExactOutput() ",
                "Description": "\nWhen a caller calls ChiefTrader.sol#swapExactInput(), it will call ITrader(traderAddress).swapExactInput().\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59\n\nsolidity\nreturn ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options);\n\n\nHowever, in the current implementation, inputToken is not approved to the traderAddress.\n\nFor example, in UniV3Trader.sol#_swapExactInputSingle, at L89, it tries to transfer inputToken from msg.sender (which is ChiefTrader), since it's not approved, this will revert.\n\nPlus, the inputToken should also be transferred from the caller before calling the subtrader.\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89\n\nsolidity\nIERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n\n\nThe same problem exists in swapExactOutput():\n\n<https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75\n\nsolidity\nfunction swapExactOutput(\n    uint256 traderId,\n    uint256 amount,\n    address,\n    PathItem[] calldata path,\n    bytes calldata options\n) external returns (uint256) {\n    require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);\n    _requireAllowedTokens(path);\n    address traderAddress = _traders[traderId];\n    address recipient = msg.sender;\n    return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);\n}\n\n\n",
                "Repair": "\nApprove the inputToken to the subtrader and transfer from the caller before calling ITrader.swapExactInput() and ITrader.swapExactOutput().\n\nOr maybe just remove support of swapExactInput() and swapExactOutput() in ChiefTrader.\n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/108#issuecomment-995456401):\n  In fact, tokens are approved to the trader https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L67\n The problem is that safeTransferFrom uses msg.sender which is ChiefTrader instead of recipient which is ERC20Vault.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/IProtocolGovernance.sol\";\nimport \"./DefaultAccessControl.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.\ncontract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;\n\n    EnumerableSet.AddressSet private _claimAllowlist;\n    address[] private _pendingClaimAllowlistAdd;\n    uint256 public pendingClaimAllowlistAddTimestamp;\n\n    address[] private _tokenWhitelist;\n    address[] private _pendingTokenWhitelistAdd;\n    uint256 private _numberOfValidTokens;\n    mapping(address => bool) _tokensAllowed;\n    mapping(address => bool) _tokenEverAdded;\n    uint256 public pendingTokenWhitelistAddTimestamp;\n\n    EnumerableSet.AddressSet private _vaultGovernances;\n    address[] private _pendingVaultGovernancesAdd;\n    uint256 public pendingVaultGovernancesAddTimestamp;\n\n    IProtocolGovernance.Params public params;\n    Params public pendingParams;\n\n    uint256 public pendingParamsTimestamp;\n\n    /// @notice Creates a new contract.\n    /// @param admin Initial admin of the contract\n    constructor(address admin) DefaultAccessControl(admin) {\n        _tokenWhitelist = new address[](0);\n        _numberOfValidTokens = 0;\n    }\n\n    // -------------------  PUBLIC, VIEW  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function claimAllowlist() external view returns (address[] memory) {\n        uint256 l = _claimAllowlist.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _claimAllowlist.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function tokenWhitelist() external view returns (address[] memory) {\n        uint256 l = _tokenWhitelist.length;\n        address[] memory res = new address[](_numberOfValidTokens);\n        uint256 j = 0;\n        for (uint256 i = 0; i < l; i++) {\n            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {\n                continue;\n            }\n            res[j] = _tokenWhitelist[i];\n            j += 1;\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function vaultGovernances() external view returns (address[] memory) {\n        uint256 l = _vaultGovernances.length();\n        address[] memory res = new address[](l);\n        for (uint256 i = 0; i < l; i++) {\n            res[i] = _vaultGovernances.at(i);\n        }\n        return res;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingClaimAllowlistAdd() external view returns (address[] memory) {\n        return _pendingClaimAllowlistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingTokenWhitelistAdd() external view returns (address[] memory) {\n        return _pendingTokenWhitelistAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function pendingVaultGovernancesAdd() external view returns (address[] memory) {\n        return _pendingVaultGovernancesAdd;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToClaim(address addr) external view returns (bool) {\n        return _claimAllowlist.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isAllowedToken(address addr) external view returns (bool) {\n        return _tokenEverAdded[addr] && _tokensAllowed[addr];\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function isVaultGovernance(address addr) external view returns (bool) {\n        return _vaultGovernances.contains(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function permissionless() external view returns (bool) {\n        return params.permissionless;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function maxTokensPerVault() external view returns (uint256) {\n        return params.maxTokensPerVault;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function governanceDelay() external view returns (uint256) {\n        return params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function protocolTreasury() external view returns (address) {\n        return params.protocolTreasury;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingClaimAllowlistAdd = addresses;\n        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromClaimAllowlist(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_claimAllowlist.contains(addr)) {\n            return;\n        }\n        _claimAllowlist.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _pendingTokenWhitelistAdd = addresses;\n        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromTokenWhitelist(address addr) external {\n        require(isAdmin(msg.sender), \"ADM\");\n        _tokensAllowed[addr] = false;\n        if (_tokenEverAdded[addr]) {\n            --_numberOfValidTokens;\n        }\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        _pendingVaultGovernancesAdd = addresses;\n        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function removeFromVaultGovernances(address addr) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        if (!_vaultGovernances.contains(addr)) {\n            return;\n        }\n        _vaultGovernances.remove(addr);\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function setPendingParams(IProtocolGovernance.Params memory newParams) external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);\n        pendingParams = newParams;\n        pendingParamsTimestamp = block.timestamp + params.governanceDelay;\n    }\n\n    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------\n\n    /// @inheritdoc IProtocolGovernance\n    function commitClaimAllowlistAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {\n            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);\n        }\n        delete _pendingClaimAllowlistAdd;\n        delete pendingClaimAllowlistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitTokenWhitelistAdd() external {\n        require(isAdmin(msg.sender), \"ADM\");\n        require(\n            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),\n            \"TS\"\n        );\n        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {\n            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {\n                _numberOfValidTokens += 1;\n                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);\n                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;\n            } else {\n                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {\n                    _numberOfValidTokens += 1;\n                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;\n                }\n            }\n        }\n        delete _pendingTokenWhitelistAdd;\n        delete pendingTokenWhitelistAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitVaultGovernancesAdd() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(\n            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),\n            ExceptionsLibrary.TIMESTAMP\n        );\n        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {\n            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);\n        }\n        delete _pendingVaultGovernancesAdd;\n        delete pendingVaultGovernancesAddTimestamp;\n    }\n\n    /// @inheritdoc IProtocolGovernance\n    function commitParams() external {\n        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);\n        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);\n        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params\n        params = pendingParams;\n        delete pendingParams;\n        delete pendingParamsTimestamp;\n    }\n}\n\n\n",
        "CodeNames": [
            "ProtocolGovernance.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    _tokensAllowed[addr] = false;\n    if (_tokenEverAdded[addr]) {\n        // @audit admin can repeatedly call this function and sets _numberOfValidTokens to zero. because they don't flip _tokenEverAdded[addr] here\n        --_numberOfValidTokens;\n    }\n}\n"
                ],
                "Type": " Admin can break  _numberOfValidTokens ",
                "Description": "\nThe ProtocolGovernance._numberOfValidTokens can be decreased by the admin in the ProtocolGovernance.removeFromTokenWhitelist function:\n\nsolidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    _tokensAllowed[addr] = false;\n    if (_tokenEverAdded[addr]) {\n        // @audit admin can repeatedly call this function and sets _numberOfValidTokens to zero. because they don't flip _tokenEverAdded[addr] here\n        --_numberOfValidTokens;\n    }\n}\n\n\nThis function can be called repeatedly until the _numberOfValidTokens is zero.\n\n\nThe _numberOfValidTokens is wrong and with it the tokenWhitelist().\n\n",
                "Repair": "\nIt seems that _numberOfValidTokens should only be decreased if the token was previously allowed:\n\nsolidity\nfunction removeFromTokenWhitelist(address addr) external {\n    require(isAdmin(msg.sender), \"ADM\");\n    if (_tokensAllowed[addr]) {\n        _tokensAllowed[addr] = false;\n        --_numberOfValidTokens;\n    }\n}\n\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1005680208):\n  Can you confirm if this issue is valid or not? @MihanixA\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1006252085):\n  Just realised this is a duplicate of another issue. Marking this as the primary issue\n\nMihanixA (Mellow Protocol) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/49#issuecomment-1006394949):\n  @0xleastwood Confirmed, it's a bug.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/external/univ3/ISwapRouter.sol\";\nimport \"./libraries/TraderExceptionsLibrary.sol\";\nimport \"./Trader.sol\";\n\n/// @notice Contract that can execute ERC20 swaps on Uniswap V3\ncontract UniV3Trader is Trader, ITrader {\n    using SafeERC20 for IERC20;\n\n    struct Options {\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n        uint256 deadline;\n        uint256 limitAmount;\n    }\n\n    struct PathItemOptions {\n        uint24 fee;\n    }\n\n    ISwapRouter public swapRouter;\n\n    constructor(address _swapRouter) {\n        swapRouter = ISwapRouter(_swapRouter);\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactInput(\n        uint256,\n        uint256 amount,\n        address recipient,\n        PathItem[] memory path,\n        bytes memory options\n    ) external returns (uint256) {\n        Options memory options_ = abi.decode(options, (Options));\n        if (path.length == 1) {\n            return _swapExactInputSingle(path[0].token0, path[0].token1, amount, recipient, options_);\n        } else {\n            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);\n            return _swapExactInputMultihop(amount, recipient, path, options_);\n        }\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactOutput(\n        uint256,\n        uint256 amount,\n        address recipient,\n        PathItem[] memory path,\n        bytes memory options\n    ) external returns (uint256) {\n        Options memory options_ = abi.decode(options, (Options));\n        if (path.length == 0) {\n            return _swapExactOutputSingle(path[0].token0, path[0].token1, amount, recipient, options_);\n        } else {\n            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);\n            return _swapExactOutputMultihop(amount, recipient, path, options_);\n        }\n    }\n\n    function _validatePathLinked(PathItem[] memory path) internal pure returns (bool result) {\n        if (path.length == 0) return false;\n        for (uint256 i = 0; i < path.length - 1; ++i) if (path[0].token1 != path[i + 1].token0) return false;\n        return true;\n    }\n\n    function _swapExactInputSingle(\n        address input,\n        address output,\n        uint256 amount,\n        address recipient,\n        Options memory options\n    ) internal returns (uint256 amountOut) {\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: input,\n            tokenOut: output,\n            fee: options.fee,\n            recipient: recipient,\n            deadline: options.deadline,\n            amountIn: amount,\n            amountOutMinimum: options.limitAmount,\n            sqrtPriceLimitX96: options.sqrtPriceLimitX96\n        });\n        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n        _approveERC20TokenIfNecessary(input, address(swapRouter));\n        amountOut = swapRouter.exactInputSingle(params);\n    }\n\n    function _swapExactOutputSingle(\n        address input,\n        address output,\n        uint256 amount,\n        address recipient,\n        Options memory options\n    ) internal returns (uint256 amountIn) {\n        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({\n            tokenIn: input,\n            tokenOut: output,\n            fee: options.fee,\n            recipient: recipient,\n            deadline: options.deadline,\n            amountOut: amount,\n            amountInMaximum: options.limitAmount,\n            sqrtPriceLimitX96: options.sqrtPriceLimitX96\n        });\n        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);\n        _approveERC20TokenIfNecessary(input, address(swapRouter));\n        amountIn = swapRouter.exactOutputSingle(params);\n        if (amountIn < options.limitAmount)\n            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);\n    }\n\n    function _swapExactInputMultihop(\n        uint256 amount,\n        address recipient,\n        PathItem[] memory path,\n        Options memory options\n    ) internal returns (uint256 amountOut) {\n        address input = path[0].token0;\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: _makeMultihopPath(path),\n            recipient: recipient,\n            deadline: options.deadline,\n            amountIn: amount,\n            amountOutMinimum: options.limitAmount\n        });\n        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);\n        _approveERC20TokenIfNecessary(input, address(swapRouter));\n        amountOut = swapRouter.exactInput(params);\n    }\n\n    function _swapExactOutputMultihop(\n        uint256 amount,\n        address recipient,\n        PathItem[] memory path,\n        Options memory options\n    ) internal returns (uint256 amountIn) {\n        address input = path[0].token0;\n        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({\n            path: _reverseBytes(_makeMultihopPath(path)),\n            recipient: recipient,\n            deadline: options.deadline,\n            amountOut: amount,\n            amountInMaximum: options.limitAmount\n        });\n        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);\n        _approveERC20TokenIfNecessary(input, address(swapRouter));\n        amountIn = swapRouter.exactOutput(params);\n        if (amountIn < options.limitAmount)\n            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);\n    }\n\n    function _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {\n        for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];\n    }\n\n    function _makeMultihopPath(PathItem[] memory path) internal pure returns (bytes memory) {\n        bytes memory result;\n        for (uint256 i = 0; i < path.length; ++i) {\n            PathItemOptions memory pathItemOptions = abi.decode(path[i].options, (PathItemOptions));\n            result = bytes.concat(result, abi.encodePacked(path[i].token0, abi.encodePacked(pathItemOptions.fee)));\n        }\n        result = bytes.concat(result, abi.encodePacked(path[path.length - 1].token1));\n        return result;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./trader/interfaces/IChiefTrader.sol\";\nimport \"./trader/interfaces/ITrader.sol\";\nimport \"./interfaces/IERC20VaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that stores ERC20 tokens.\ncontract ERC20Vault is Vault, ITrader {\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        tokenAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            tokenAmounts[i] = IERC20(tokens[i]).balanceOf(address(this));\n        }\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactInput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] memory path,\n        bytes memory options\n    ) external returns (uint256 amountOut) {\n        require(\n            path.length > 0  && isVaultToken(path[path.length - 1].token1), \n            ExceptionsLibrary.NOT_VAULT_TOKEN\n        );\n        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);\n        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));\n        ITrader trader = ITrader(vg.delayedProtocolParams().trader);\n        IChiefTrader chiefTrader = IChiefTrader(address(trader));\n        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));\n        return trader.swapExactInput(traderId, amount, address(0), path, options);\n    }\n\n    /// @inheritdoc ITrader\n    function swapExactOutput(\n        uint256 traderId,\n        uint256 amount,\n        address,\n        PathItem[] memory path,\n        bytes calldata options\n    ) external returns (uint256 amountOut) {\n        require(\n            path.length > 0  && isVaultToken(path[path.length - 1].token1), \n            ExceptionsLibrary.NOT_VAULT_TOKEN\n        );\n        require(_isStrategy(msg.sender), ExceptionsLibrary.NOT_STRATEGY_TREASURY);\n        IERC20VaultGovernance vg = IERC20VaultGovernance(address(_vaultGovernance));\n        ITrader trader = ITrader(vg.delayedProtocolParams().trader);\n        IChiefTrader chiefTrader = IChiefTrader(address(trader));\n        _approveERC20TokenIfNecessary(path[0].token0, chiefTrader.getTrader(traderId));\n        return trader.swapExactOutput(traderId, amount, address(0), path, options);\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory)\n        internal\n        pure\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        // no-op, tokens are already on balance\n        return tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        for (uint256 i = 0; i < tokenAmounts.length; i++) {\n            IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);\n        }\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(!isVaultToken(tokens[i]), ExceptionsLibrary.OTHER_VAULT_TOKENS); // vault token is part of TVL\n        }\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    function _approveERC20TokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(to, type(uint256).max);\n    }\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/external/univ3/INonfungiblePositionManager.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Pool.sol\";\nimport \"./interfaces/external/univ3/IUniswapV3Factory.sol\";\nimport \"./interfaces/IUniV3VaultGovernance.sol\";\nimport \"./libraries/external/TickMath.sol\";\nimport \"./libraries/external/LiquidityAmounts.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.\ncontract UniV3Vault is IERC721Receiver, Vault {\n    struct Options {\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct Pair {\n        uint256 a0;\n        uint256 a1;\n    }\n\n    IUniswapV3Pool public immutable pool;\n\n    uint256 public uniV3Nft;\n\n    /// @notice Creates a new contract.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    /// @param fee Fee of the underlying UniV3 pool\n    constructor(\n        IVaultGovernance vaultGovernance_,\n        address[] memory vaultTokens_,\n        uint24 fee\n    ) Vault(vaultGovernance_, vaultTokens_) {\n        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);\n        pool = IUniswapV3Pool(\n            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)\n        );\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {\n        require(msg.sender == address(_positionManager()), \"SNFT\");\n        require(_isStrategy(operator), \"STR\");\n        (\n            , ,\n            address token0,\n            address token1,\n            , , , , , , ,\n        ) = _positionManager().positions(tokenId);\n        // new position should have vault tokens\n        require(\n            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],\n            \"VT\"\n        );\n\n        if (uniV3Nft != 0) {\n            (\n                , , , , , , ,\n                uint128 liquidity,\n                , ,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            ) = _positionManager().positions(uniV3Nft);\n            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, \"TVL\");\n            // return previous uni v3 position nft\n            _positionManager().transferFrom(address(this), from, uniV3Nft);\n        }\n\n        uniV3Nft = tokenId;\n        return this.onERC721Received.selector;\n    }\n\n    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {\n        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        address owner = registry.ownerOf(_nft);\n        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);\n        collectedEarnings = new uint256[](2);\n        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n        collectedEarnings[0] = collectedEarnings0;\n        collectedEarnings[1] = collectedEarnings1;\n        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        if (uniV3Nft == 0)\n            return tokenAmounts;\n        (\n            , , , , , \n            int24 tickLower, \n            int24 tickUpper, \n            uint128 liquidity,\n            , , ,\n        ) = _positionManager().positions(uniV3Nft);\n        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96,\n            sqrtPriceAX96,\n            sqrtPriceBX96,\n            liquidity\n        );\n        tokenAmounts[0] = amount0;\n        tokenAmounts[1] = amount1;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < tokens.length; i++)\n            _allowTokenIfNecessary(tokens[i]);\n\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = Pair({\n            a0: tokenAmounts[0],\n            a1: tokenAmounts[1]\n        });\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                amount0Desired: amounts.a0,\n                amount1Desired: amounts.a1,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        actualTokenAmounts[0] = amount0;\n        actualTokenAmounts[1] = amount1;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        actualTokenAmounts = new uint256[](2);\n        if (uniV3Nft == 0)\n            return actualTokenAmounts;\n\n        Options memory opts = _parseOptions(options);\n        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);\n        actualTokenAmounts[0] = amounts.a0;\n        actualTokenAmounts[1] = amounts.a1;\n    }\n\n    function _pullUniV3Nft(\n        uint256[] memory tokenAmounts,\n        address to,\n        Options memory opts\n    ) internal returns (Pair memory) {\n        uint128 liquidityToPull;\n        // scope the code below to avoid stack-too-deep exception\n        {\n            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]\n            );\n            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;\n            if (liquidityToPull == 0) {\n                return Pair({a0: 0, a1: 0});\n            }\n        }\n        Pair memory minAmounts = Pair({\n            a0: opts.amount0Min,\n            a1: opts.amount1Min\n        });\n        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: uniV3Nft,\n                liquidity: liquidityToPull,\n                amount0Min: minAmounts.a0,\n                amount1Min: minAmounts.a1,\n                deadline: opts.deadline\n            })\n        );\n        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: uniV3Nft,\n                recipient: to,\n                amount0Max: uint128(amount0),\n                amount1Max: uint128(amount1)\n            })\n        );\n        return Pair({a0: amount0Collected, a1: amount1Collected});\n    }\n\n    function _postReclaimTokens(address, address[] memory tokens) internal view override {}\n\n    /// TODO: make a virtual function here? Or other better approach\n    function _positionManager() internal view returns (INonfungiblePositionManager) {\n        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)\n            IERC20(token).approve(address(_positionManager()), type(uint256).max);\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (Options memory) {\n        if (options.length == 0)\n            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});\n\n        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);\n        return abi.decode(options, (Options));\n    }\n\n    function _isStrategy(address addr) internal view returns (bool) {\n        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;\n    }\n\n    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);\n}\n\n\n",
        "CodeNames": [
            "UniV3Trader.sol",
            "ERC20Vault.sol",
            "AaveVault.sol",
            "UniV3Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nfunction _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {\n    / @audit reverses byte order? */\n    for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length 1 i];\n}\n"
                ],
                "Type": " UniswapV3's path issue for  swapExactOutput ",
                "Description": "\nUniswapV3 expects a path object like (tokenA, feeAB, tokenB, feeBC, tokenC).\nThe UniV3Trader.swapExactOutput code tries to reverse this path to get to (tokenC, feeBC, tokenB, feeAB, tokenA) but that's not what the _reverseBytes function does.\nNote that it reverts the entire encoded path byte array byte-by-byte which breaks the byte-order in a token.\nFor example, tokenA would have every single byte reversed and lead to a different token.\n\nsolidity\nfunction _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {\n    / @audit reverses byte order? */\n    for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length 1 i];\n}\n\n\n\nThe UniV3Trader.swapExactOutput function with multi-hops is broken and cannot be used.\n\n",
                "Repair": "\nDon't reverse the path byte-by-byte but element-by-element.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/50#issuecomment-1005680245):\n  Can you confirm if this issue is valid or not? @MihanixA\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/50#issuecomment-1006253424):\n  I actually agree with the warden's finding here. Leaving as is.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IGatewayVault.sol\";\nimport \"./interfaces/IGatewayVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that combines several integration layer Vaults into one Vault.\ncontract GatewayVault is IERC721Receiver, IGatewayVault, Vault {\n    using SafeERC20 for IERC20;\n    uint256[] internal _subvaultNfts;\n    mapping(uint256 => uint256) internal _subvaultNftsIndex;\n\n    /// @notice Creates a new contract.\n    /// @dev All subvault nfts must be owned by this vault before.\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {}\n\n    /// @inheritdoc IGatewayVault\n    function subvaultNfts() external view returns (uint256[] memory) {\n        return _subvaultNfts;\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override(IVault, Vault) returns (uint256[] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        tokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                tokenAmounts[j] += vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultTvl(uint256 vaultNum) public view override returns (uint256[] memory) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        IVault vault = IVault(registry.vaultForNft(_subvaultNfts[vaultNum]));\n        return vault.tvl();\n    }\n\n    /// @inheritdoc IGatewayVault\n    function subvaultsTvl() public view override returns (uint256[][] memory tokenAmounts) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 vaultTokensLength = _vaultTokens.length;\n        tokenAmounts = new uint256[][](_subvaultNfts.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory vTokenAmounts = vault.tvl();\n            tokenAmounts[i] = new uint256[](vaultTokensLength);\n            for (uint256 j = 0; j < vaultTokensLength; j++) {\n                tokenAmounts[i][j] = vTokenAmounts[j];\n            }\n        }\n    }\n\n    /// @inheritdoc IGatewayVault\n    function hasSubvault(address vault) external view override returns (bool) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256 nft_ = registry.nftForVault(vault);\n        return (_subvaultNftsIndex[nft_] > 0 || _subvaultNfts[0] == nft_);\n    }\n\n    /// @inheritdoc IGatewayVault\n    function addSubvaults(uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(_subvaultNfts.length == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);\n        require(nfts.length > 0, ExceptionsLibrary.SUB_VAULT_LENGTH);\n        address[] memory selfTokens = _vaultTokens;\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        for (uint256 i = 0; i < nfts.length; i++) {\n            uint256 nft_ = nfts[i];\n            require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);\n            IVault vault = IVault(registry.vaultForNft(nft_));\n            address[] memory vTokens = vault.vaultTokens();\n            require(selfTokens.length == vTokens.length, ExceptionsLibrary.INCONSISTENT_LENGTH);\n            for (uint256 j = 0; j < selfTokens.length; j++) {\n                require(selfTokens[j] == vTokens[j], ExceptionsLibrary.NOT_VAULT_TOKEN);\n            }\n            _subvaultNfts.push(nft_);\n            _subvaultNftsIndex[nft_] = i;\n        }\n    }\n\n    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external {\n        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);\n        require(strategy != address(0), ExceptionsLibrary.ZERO_STRATEGY_ADDRESS);\n        IVaultRegistry vaultRegistry = IVaultGovernance(_vaultGovernance).internalParams().registry;\n        for (uint i = 0; i < nfts.length; ++i)\n            vaultRegistry.approve(strategy, nfts[i]);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external nonReentrant returns (bytes4) {\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);\n        registry.lockNft(tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        bool optimized;\n        bytes[] memory vaultsOptions;\n        (optimized, vaultsOptions) = _parseOptions(options);\n\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(\n            address(_vaultGovernance)\n        ).delayedStrategyParams(_nft);\n        if (optimized && strategyParams.redirects.length > 0) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (strategyParams.redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            if (optimized && (strategyParams.redirects[i] != 0)) {\n                continue;\n            }\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                if (amountsByVault[i][j] > 0) {\n                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));\n                }\n            }\n            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(\n                address(this),\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n                totalTvl[j] += tvls[i][j];\n            }\n        }\n        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);\n        }\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory options\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);\n\n        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);\n        IVaultRegistry registry = _vaultGovernance.internalParams().registry;\n        uint256[][] memory tvls = subvaultsTvl();\n        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);\n        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))\n            .delayedStrategyParams(_nft)\n            .redirects;\n\n        if (optimized && (_redirects.length > 0)) {\n            for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n                if (_redirects[i] == 0) {\n                    continue;\n                }\n                for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];\n                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n                    amountsByVault[i][j] = 0;\n                }\n            }\n        }\n        actualTokenAmounts = new uint256[](_vaultTokens.length);\n        for (uint256 i = 0; i < _subvaultNfts.length; i++) {\n            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));\n            uint256[] memory actualVaultTokenAmounts = vault.pull(\n                to,\n                _vaultTokens,\n                amountsByVault[i],\n                vaultsOptions[i]\n            );\n            for (uint256 j = 0; j < _vaultTokens.length; j++) {\n                actualTokenAmounts[j] += actualVaultTokenAmounts[j];\n            }\n        }\n    }\n\n    function _allowTokenIfNecessary(address token, address to) internal {\n        if (IERC20(token).allowance(address(this), address(to)) < type(uint256).max / 2) {\n            IERC20(token).approve(address(to), type(uint256).max);\n        }\n    }\n\n    function _parseOptions(bytes memory options) internal view returns (bool, bytes[] memory) {\n        if (options.length == 0) {\n            return (false, new bytes[](_subvaultNfts.length));\n        }\n        return abi.decode(options, (bool, bytes[]));\n    }\n\n    event CollectProtocolFees(address protocolTreasury, address[] tokens, uint256[] amounts);\n    event CollectStrategyFees(address strategyTreasury, address[] tokens, uint256[] amounts);\n}\n\n\n// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.9;\n\nimport \"./interfaces/external/aave/ILendingPool.sol\";\nimport \"./interfaces/IAaveVaultGovernance.sol\";\nimport \"./Vault.sol\";\nimport \"./libraries/ExceptionsLibrary.sol\";\n\n/// @notice Vault that interfaces Aave protocol in the integration layer.\n/// @dev Notes:\n/// ### TVL\n///\n/// The TVL of the vault is cached and updated after each deposit withdraw.\n/// So essentially `tvl` call doesn't take into account accrued interest / donations to Aave since the\n/// last `deposit` / `withdraw`\n///\n/// ### aTokens\n/// aTokens are fixed at the token creation and addresses are taken from Aave Lending Pool.\n/// So essentially each aToken is fixed for life of the AaveVault. If the aToken is missing for some vaultToken,\n/// the AaveVault cannot be created.\n///\n/// ### Push / Pull\n/// It is assumed that any amounts of tokens can be deposited / withdrawn from Aave.\n/// The contract's vaultTokens are fully allowed to Aave Lending Pool.\ncontract AaveVault is Vault {\n    address[] internal _aTokens;\n    uint256[] internal _tvls;\n\n    /// @notice Creates a new contract.\n    /// @dev Requires that aToken exists for each vaultToken\n    /// @param vaultGovernance_ Reference to VaultGovernance for this vault\n    /// @param vaultTokens_ ERC20 tokens under Vault management\n    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)\n        Vault(vaultGovernance_, vaultTokens_)\n    {\n        _aTokens = new address[](vaultTokens_.length);\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address aToken = _getAToken(_vaultTokens[i]);\n            require(aToken != address(0), ExceptionsLibrary.ZERO_TOKEN);\n            _aTokens[i] = aToken;\n            _tvls.push(0);\n        }\n    }\n\n    /// @inheritdoc Vault\n    function tvl() public view override returns (uint256[] memory tokenAmounts) {\n        return _tvls;\n    }\n\n    /// @notice Update all tvls to current aToken balances.\n    function updateTvls() public {\n        for (uint256 i = 0; i < _tvls.length; i++) {\n            _tvls[i] = IERC20(_aTokens[i]).balanceOf(address(this));\n        }\n    }\n\n    function _push(uint256[] memory tokenAmounts, bytes memory options)\n        internal\n        override\n        returns (uint256[] memory actualTokenAmounts)\n    {\n        address[] memory tokens = _vaultTokens;\n        uint256 referralCode = 0;\n        if (options.length > 0) {\n            referralCode = abi.decode(options, (uint256));\n        }\n\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if (tokenAmounts[i] == 0) {\n                continue;\n            }\n            address token = tokens[i];\n            _allowTokenIfNecessary(token);\n            _lendingPool().deposit(tokens[i], tokenAmounts[i], address(this), uint16(referralCode));\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _pull(\n        address to,\n        uint256[] memory tokenAmounts,\n        bytes memory\n    ) internal override returns (uint256[] memory actualTokenAmounts) {\n        address[] memory tokens = _vaultTokens;\n        for (uint256 i = 0; i < _aTokens.length; i++) {\n            if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {\n                continue;\n            }\n            _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);\n        }\n        updateTvls();\n        actualTokenAmounts = tokenAmounts;\n    }\n\n    function _getAToken(address token) internal view returns (address) {\n        DataTypes.ReserveData memory data = _lendingPool().getReserveData(token);\n        return data.aTokenAddress;\n    }\n\n    function _allowTokenIfNecessary(address token) internal {\n        if (IERC20(token).allowance(address(this), address(_lendingPool())) < type(uint256).max / 2) {\n            IERC20(token).approve(address(_lendingPool()), type(uint256).max);\n        }\n    }\n\n    function _lendingPool() internal view returns (ILendingPool) {\n        return IAaveVaultGovernance(address(_vaultGovernance)).delayedProtocolParams().lendingPool;\n    }\n}\n\n\n",
        "CodeNames": [
            "GatewayVault.sol",
            "AaveVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nfor (uint256 j = 0; j < _vaultTokens.length; j++) {\n    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n    amountsByVault[i][j] = 0;\n}\n"
                ],
                "Type": " Bad redirects can make it impossible to deposit & withdraw",
                "Description": "\nThe GatewayVault._push() function gets redirects from the strategyParams.\nIf redirects[i] = j, vault index i's deposits are redirected to vault index j.\n\nNote that the deposits for vault index i are cleared, as they are redirected:\n\nsolidity\nfor (uint256 j = 0; j < _vaultTokens.length; j++) {\n    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];\n    amountsByVault[vaultIndex][j] += amountsByVault[i][j];\n    amountsByVault[i][j] = 0;\n}\n\n\n The same is true for withdrawals in the _pull function. Users might not be able to withdraw this way.\n\nIf the redirects array is misconfigured, it's possible that all amountsByVault are set to zero.\nFor example, if 0 redirects to 1 and 1 redirects to 0. Or 0 redirects to itself, etc.\nThere are many misconfigurations that can lead to not being able to deposit to the pool anymore.\n\n",
                "Repair": "\nThe redirects[i] = j matrix needs to be restricted.\nIf i is redirected to j, j may not redirect itself.\nCheck for this when setting the redirects array.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1005680123):\n  Can you confirm if this issue is valid or not? @MihanixA \n\nMihanixA (Mellow Protocol) confirmed(https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1006406574):\n  @0xleastwood Confirmed\n\nMihanixA (Mellow Protocol) commented(https://github.com/code-423n4/2021-12-mellow-findings/issues/44#issuecomment-1006407377):\n  (notice that this one is a deploy-related issue)\n\n\n"
            }
        ]
    }
]