[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IERC721.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/ILendingController.sol';\nimport './interfaces/univ3/IUniswapV3Helper.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ReentrancyGuard.sol';\nimport './external/ERC721Receivable.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {\n\n  IERC721 internal constant uniManager = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  uint    public   constant LIQ_MIN_HEALTH = 1e18;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public override supplySharesOf;\n  mapping (address => mapping (address => uint)) public debtSharesOf;\n  mapping (address => uint) public pendingSystemFees;\n  mapping (address => uint) public lastBlockAccrued;\n  mapping (address => uint) public override totalSupplyShares;\n  mapping (address => uint) public totalSupplyAmount;\n  mapping (address => uint) public totalDebtShares;\n  mapping (address => uint) public totalDebtAmount;\n  mapping (address => uint) public uniPosition;\n  mapping (address => uint) private decimals;\n  mapping (address => address) public override lpToken;\n\n  IUniswapV3Helper   private uniV3Helper;\n  ILendingController public  lendingController;\n\n  address public feeRecipient;\n  address public override tokenA;\n  address public override tokenB;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n  event CollectSystemFee(address indexed token, uint amount);\n  event DepositUniPosition(address indexed account, uint positionID);\n  event WithdrawUniPosition(uint positionID);\n\n  receive() external payable {}\n\n  modifier onlyLpToken() {\n    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, \"LendingController: caller must be LP token\");\n    _;\n  }\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n    require(_tokenA != address(0) && _tokenB != address(0), \"LendingPair: cannot be ZERO address\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= 6 && decimals[tokenB] >= 6, \"LendingPair: min 6 decimals\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n\n  // Deposit limits do not apply to Uniswap positions\n  function depositUniPosition(address _account, uint _positionID) external {\n    _checkDepositsEnabled();\n    _validateUniPosition(_positionID);\n    require(uniPosition[_account] == 0, \"LendingPair: one position per account\");\n\n    uniManager.safeTransferFrom(msg.sender, address(this), _positionID);\n    uniPosition[_account] = _positionID;\n\n    emit DepositUniPosition(_account, _positionID);\n  }\n\n  function withdrawUniPosition() external {\n    uint positionID = uniPosition[msg.sender];\n    uniManager.safeTransferFrom(address(this), msg.sender, positionID);\n\n    uniPosition[msg.sender] = 0;\n    checkAccountHealth(msg.sender);\n\n    emit WithdrawUniPosition(positionID);\n  }\n\n  // claim & mint supply from uniswap fees\n  function uniClaimDeposit() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _mintSupplyAmount(tokenA, msg.sender, amountA);\n    _mintSupplyAmount(tokenB, msg.sender, amountB);\n  }\n\n  // claim & withdraw uniswap fees\n  function uniClaimWithdraw() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _safeTransfer(tokenA, msg.sender, amountA);\n    _safeTransfer(tokenB, msg.sender, amountB);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n  }\n\n  function withdraw(address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawShares(_token, _supplyToShares(_token, _amount));\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint shares = supplySharesOf[_token][msg.sender];\n    _withdrawShares(_token, shares);\n    _safeTransfer(_token, msg.sender, _sharesToSupply(_token, shares));\n  }\n\n  function withdrawAllETH() external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint shares = supplySharesOf[address(WETH)][msg.sender];\n    _withdrawShares(address(WETH), shares);\n    _wethWithdrawTo(msg.sender, _sharesToSupply(address(WETH), shares));\n  }\n\n  function borrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _borrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token, uint _maxAmount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint amount = _repayShares(_account, _token, debtSharesOf[_token][_account]);\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account, uint _maxAmount) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint amount = _repayShares(_account, address(WETH), debtSharesOf[address(WETH)][_account]);\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n\n    _depositWeth();\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _repayShares(_account, _token, _debtToShares(_token, _amount));\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue(address _token) public {\n    if (lastBlockAccrued[_token] < block.number) {\n      uint newDebt   = _accrueDebt(_token);\n      uint newSupply = newDebt * _lpRate(_token) / 100e18;\n      totalSupplyAmount[_token] += newSupply;\n      pendingSystemFees[_token] += (newDebt - newSupply);\n      lastBlockAccrued[_token]   = block.number;\n    }\n  }\n\n  function collectSystemFee(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    pendingSystemFees[_token] -= _amount;\n    _safeTransfer(_token, feeRecipient, _amount);\n    emit CollectSystemFee(_token, _amount);\n  }\n\n  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {\n    require(debtSharesOf[_token][_to] == 0, \"LendingPair: cannot deposit borrowed token\");\n    supplySharesOf[_token][_from] -= _amount;\n    supplySharesOf[_token][_to]   += _amount;\n    checkAccountHealth(_from);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external nonReentrant {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    accrue(supplyToken);\n    accrue(_repayToken);\n\n    uint health = accountHealth(_account);\n    require(health < LIQ_MIN_HEALTH, \"LendingPair: account health < LIQ_MIN_HEALTH\");\n\n    // Fully unwrap Uni position - withdraw & mint supply\n\n    _unwrapUniPosition(_account);\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));\n    (uint repayPrice, uint supplyPrice) = lendingController.tokenPrices(_repayToken, supplyToken);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount, repayPrice, supplyPrice);\n    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));\n    pendingSystemFees[supplyToken] += systemFee;\n    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));\n\n    // Uni position unwrapping can mint supply of already borrowed tokens\n\n    _repayDebtFromSupply(_account, tokenA);\n    _repayDebtFromSupply(_account, tokenB);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {\n      return LIQ_MIN_HEALTH;\n    }\n\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    uint colFactorA = lendingController.colFactor(tokenA);\n    uint colFactorB = lendingController.colFactor(tokenB);\n\n    uint creditA   = _supplyBalanceConverted(_account, tokenA, tokenA, priceA, priceA) * colFactorA / 100e18;\n    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, priceB, priceA) * colFactorB / 100e18;\n    uint creditUni = _supplyCreditUni(_account, tokenA, priceA, priceB, colFactorA, colFactorB);\n\n    uint totalAccountSupply = creditA + creditB + creditUni;\n\n    uint totalAccountBorrow =\n      _borrowBalanceConverted(_account, tokenA, tokenA, priceA, priceA) +\n      _borrowBalanceConverted(_account, tokenB, tokenA, priceB, priceA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\n  }\n\n  function debtOf(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _debtOf(_token, _account);\n  }\n\n  function supplyOf(address _token, address _account) external view override returns(uint) {\n    _validateToken(_token);\n    return _supplyOf(_token, _account);\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);\n    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);\n  }\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view override returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);\n    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token) * _lpRate(_token) / 100e18;\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token);\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= LIQ_MIN_HEALTH, \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt          = _debtOf(_token, _account);\n    uint repayAmount   = debt > _amount ? _amount : debt;\n    uint depositAmount = _amount - repayAmount;\n\n    if (repayAmount > 0) {\n      _repayShares(_account, _token, _debtToShares(_token, repayAmount));\n    }\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount   = _supplyOf(_token, msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n    uint borrowAmount   = _amount - withdrawAmount;\n\n    if (withdrawAmount > 0) {\n      _withdrawShares(_token, _supplyToShares(_token, withdrawAmount));\n    }\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  // Uses TWAP to estimate min outputs to reduce MEV\n  // Liquidation might be temporarily unavailable due to this\n  function _unwrapUniPosition(address _account) internal {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n      (uint amount0, uint amount1) = uniV3Helper.positionAmounts(uniPosition[_account], priceA, priceB);\n      uint uniMinOutput = lendingController.uniMinOutputPct();\n\n      uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(\n        uniPosition[_account],\n        amount0 * uniMinOutput / 100e18,\n        amount1 * uniMinOutput / 100e18\n      );\n      uniPosition[_account] = 0;\n\n      _mintSupplyAmount(tokenA, _account, amountA);\n      _mintSupplyAmount(tokenB, _account, amountB);\n    }\n  }\n\n  // Ensure we never have borrow + supply balances of the same token on the same account\n  function _repayDebtFromSupply(address _account, address _token) internal {\n\n    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));\n\n    if (burnAmount > 0) {\n      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));\n      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));\n    }\n  }\n\n  function _uniCollectFees(address _account) internal returns(uint, uint) {\n    uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n    return uniV3Helper.collectFees(uniPosition[_account]);\n  }\n\n  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _supplyToShares(_token, _amount);\n      supplySharesOf[_token][_account] += shares;\n      totalSupplyShares[_token] += shares;\n      totalSupplyAmount[_token] += _amount;\n    }\n  }\n\n  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToSupply(_token, _shares);\n      supplySharesOf[_token][_account] -= _shares;\n      totalSupplyShares[_token] -= _shares;\n      totalSupplyAmount[_token] -= amount;\n    }\n  }\n\n  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _debtToShares(_token, _amount);\n      debtSharesOf[_token][_account] += shares;\n      totalDebtShares[_token] += shares;\n      totalDebtAmount[_token] += _amount;\n    }\n  }\n\n  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToDebt(_token, _shares);\n      debtSharesOf[_token][_account] -= _shares;\n      totalDebtShares[_token] -= _shares;\n      totalDebtAmount[_token] -= amount;\n    }\n  }\n\n  function _accrueDebt(address _token) internal returns(uint newDebt) {\n    if (totalDebtAmount[_token] > 0) {\n      uint blocksElapsed = block.number - lastBlockAccrued[_token];\n      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;\n      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;\n      totalDebtAmount[_token] += newDebt;\n    }\n  }\n\n  function _withdrawShares(address _token, uint _shares) internal {\n    uint amount = _burnSupplyShares(_token, msg.sender, _shares);\n    checkAccountHealth(msg.sender);\n    emit Withdraw(_token, amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(supplySharesOf[_token][msg.sender] == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebtAmount(_token, msg.sender, _amount);\n\n    _checkBorrowEnabled();\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {\n    amount = _burnDebtShares(_token, _account, _shares);\n    emit Repay(_account, _token, amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    require(debtSharesOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupplyAmount(_token, _account, _amount);\n    _checkDepositsEnabled();\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize(_underlying, address(lendingController));\n    return address(newLPToken);\n  }\n\n  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputSupply * _totalShares / _totalAmount;\n    } else {\n      return _inputSupply;\n    }\n  }\n\n  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputShares * _totalAmount / _totalShares;\n    } else {\n      return _inputShares;\n    }\n  }\n\n  function _debtToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);\n  }\n\n  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);\n  }\n\n  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);\n  }\n\n  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);\n  }\n\n  function _debtOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToDebt(_token, debtSharesOf[_token][_account]);\n  }\n\n  function _supplyOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToSupply(_token, supplySharesOf[_token][_account]);\n  }\n\n  function _interestRatePerBlock(address _token) internal view returns(uint) {\n    return _interestRateModel().interestRatePerBlock(\n      address(this),\n      _token,\n      totalSupplyAmount[_token],\n      totalDebtAmount[_token]\n    );\n  }\n\n  function _interestRateModel() internal view returns(IInterestRateModel) {\n    return IInterestRateModel(lendingController.interestRateModel());\n  }\n\n  // Get borrow balance converted to the units of _returnToken\n  function _borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken,\n    uint    _borrowPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _borrowedToken,\n      _returnToken,\n      _debtOf(_borrowedToken, _account),\n      _borrowPrice,\n      _returnPrice\n    );\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken,\n    uint    _supplyPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _suppliedToken,\n      _returnToken,\n      _supplyOf(_suppliedToken, _account),\n      _supplyPrice,\n      _returnPrice\n    );\n  }\n\n  function _supplyCreditUni(\n    address _account,\n    address _returnToken,\n    uint    _priceA,\n    uint    _priceB,\n    uint    _colFactorA,\n    uint    _colFactorB\n  ) internal view returns(uint) {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amountA, uint amountB) = uniV3Helper.positionAmounts(uniPosition[_account], _priceA, _priceB);\n\n      uint supplyA = _convertTokenValues(tokenA, _returnToken, amountA, _priceA, _priceB);\n      uint supplyB = _convertTokenValues(tokenB, _returnToken, amountB, _priceB, _priceB);\n\n      uint creditA = supplyA * _colFactorA / 100e18;\n      uint creditB = supplyB * _colFactorB / 100e18;\n\n      return (creditA + creditB);\n\n    } else {\n      return 0;\n    }\n  }\n\n  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount,\n    uint    _fromPrice,\n    uint    _toPrice\n  ) internal view returns(uint) {\n\n    uint priceFrom = _fromPrice * 1e18 / 10 ** decimals[_fromToken];\n    uint priceTo   = _toPrice   * 1e18 / 10 ** decimals[_toToken];\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _validateUniPosition(uint _positionID) internal view {\n    (address uniTokenA, address uniTokenB) = uniV3Helper.positionTokens(_positionID);\n    _validateToken(uniTokenA);\n    _validateToken(uniTokenB);\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    uint depositLimit = lendingController.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require(totalSupplyAmount[_token] <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkDepositsEnabled() internal view {\n    require(lendingController.depositsEnabled(), \"LendingPair: deposits disabled\");\n  }\n\n  function _checkBorrowEnabled() internal view {\n    require(lendingController.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    uint borrowLimit = lendingController.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebtAmount[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return _interestRateModel().lpRate(address(this), _token);\n  }\n}\n\n\n",
        "CodeNames": [
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "totalAccountSupply",
                    "accountHealth()",
                    "supplyB",
                    "_supplyCreditUni()",
                    "creditUni",
                    "_priceA",
                    "creditB",
                    "_convertTokenValues()"
                ],
                "Type": " Use of tokenB\u2019s price instead of tokenA in determining account health will lead to protocol mis-accounting and insolvency",
                "Description": "\n\nIn _supplyCreditUni(), the last argument of _convertTokenValues() on L674 being _priceB instead of _priceA in the calculation of supplyB is a typo (should be _priceA) and therefore miscalculates supplyB, creditB, creditUni and therefore totalAccountSupply in function accountHealth() which affects the health of account/protocol determination that is used across all borrows/withdrawals/transfers/liquidations in the protocol. This miscalculation significantly affects all calculations in protocol and could therefore cause protocol insolvency.\n\n\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L674\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L340\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L398-L401\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L532\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L544\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L119\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L266\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LendingPair.sol#L289\n\n\nManual Analysis\n\n",
                "Repair": "\nChange the last argument of _convertTokenValues() from _priceB to _priceA on L674.\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/70)\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "_unwrapUniPosition()",
                    "uniV",
                    "liquidateAccount()"
                ],
                "Type": " Liquidation can be escaped by depositing a Uni v3 position with 0 liquidity",
                "Description": "\nWhen the liquidator is trying to liquidate a undercolldarezed loan by calling liquidateAccount(), it calls _unwrapUniPosition() - uniV3Helper.removeLiquidity() - positionManager.decreaseLiquidity().\n\nHowever, when the Uni v3 position has 0 liquidity, positionManager.decreaseLiquidity() will fail.\n\nSee: <https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L265\n\nBased on this, a malicious user can escaped liquidation by depositing a Uni v3 position with 0 liquidity.\n\n\nUndercollateralized debts cannot be liquidated and it leads to bad debts to the protocol.\n\nA malicious user can take advantage of this by creating long positions on the collateral assets and take profit on the way up, and keep taking more debt out of the protocol, while when the price goes down, the debt can not be liquidated and the risks of bad debt are paid by the protocol.\n\n\n1.  A malicious user deposits some collateral assets and borrow the max amount of debt;\n2.  The user deposits a Uni v3 position with 0 liquidity;\n3.  When the market value of the collateral assets decreases, the liquadation will fail as positionManager.decreaseLiquidity() reverts.\n\n",
                "Repair": "\nCheck if liquidity  0 when removeLiquidity.\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/30#issuecomment-932861833):\n  Valid issue. Good catch.\n \n Severity should be lowered to 2 as it doesn't allow direct theft of funds and the loss would only occur under specific external conditions.\n \n _2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements_\n \n https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/30#issuecomment-940647789):\n  To my understanding, bad position would affect the whole protocol and a loss would have to be paid by other participans which means funds can be drained. For that reason, I'm keeping high risk.\n\n\n\n \n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "accrue",
                    "totalDebtAmount",
                    "withdrawUniPosition"
                ],
                "Type": "  LendingPair.withdrawUniPosition  should accrue debt first",
                "Description": "\nThe LendingPair.withdrawUniPosition function allows the user to withdraw their UniswapV3 pool position (NFT) again.\nAs the Uniswap position acts as collateral in the protocol, a health check is performed afterwards.\n\nHowever, it does not check the current debt of the caller as it does not accrue the debt for both tokens first.\n\n\nIn the worst case, in low-activity markets, it could happen that debt has not accrued for a long time and the current debt is significantly higher than the current *recorded* debt in totalDebtAmount.\nAn account with a de-facto negative health ratio if the debt was accrued could still withdraw their collateral NFT instead of having to repay their debt first.\n\n",
                "Repair": "\nAccrue the debt for both tokens first in LendingPair.withdrawUniPosition.\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/48)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/uniV3/IUniswapV3Pool.sol';\nimport './interfaces/uniV3/IUniswapV3Factory.sol';\nimport './interfaces/ILinkOracle.sol';\nimport './interfaces/IPriceOracle.sol';\nimport './interfaces/IUniswapPriceConverter.sol';\nimport './external/Ownable.sol';\n\ncontract UniswapV3Oracle is IPriceOracle, Ownable {\n\n  IUniswapV3Factory public constant uniFactory    = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n  ILinkOracle       public constant wethOracle    = ILinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n  address           public constant WETH          = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  uint24            public constant WETH_POOL_FEE = 3000;\n\n  struct Pool {\n    address pairToken;\n    uint24  poolFee;\n  }\n\n  uint32 public twapPeriod;\n  uint16 public minObservations;\n\n  IUniswapPriceConverter public uniPriceConverter;\n\n  mapping(address => Pool) public pools;\n\n  event PoolAdded(address indexed token);\n  event PoolRemoved(address indexed token);\n  event NewTwapPeriod(uint32 value);\n  event NewMinObservations(uint16 value);\n  event NewUniPriceConverter(IUniswapPriceConverter value);\n\n  constructor(\n    IUniswapPriceConverter _uniPriceConverter,\n    uint32 _twapPeriod,\n    uint16 _minObservations\n  ) {\n    uniPriceConverter = _uniPriceConverter;\n    twapPeriod        = _twapPeriod;\n    minObservations   = _minObservations;\n  }\n\n  function addPool(\n    address _token,\n    address _pairToken,\n    uint24  _poolFee\n  ) external onlyOwner {\n\n    _validatePool(_token, _pairToken, _poolFee);\n\n    pools[_token] = Pool({\n      pairToken: _pairToken,\n      poolFee: _poolFee\n    });\n\n    emit PoolAdded(_token);\n  }\n\n  function removePool(address _token) external onlyOwner {\n    pools[_token] = Pool(address(0), 0);\n    emit PoolRemoved(_token);\n  }\n\n  function setUniPriceConverter(IUniswapPriceConverter _value) external onlyOwner {\n    uniPriceConverter = _value;\n    emit NewUniPriceConverter(_value);\n  }\n\n  function setTwapPeriod(uint32 _value) external onlyOwner {\n    twapPeriod = _value;\n    emit NewTwapPeriod(_value);\n  }\n\n  function setMinObservations(uint16 _value) external onlyOwner {\n    minObservations = _value;\n    emit NewMinObservations(_value);\n  }\n\n  function tokenPrice(address _token) public view override returns(uint) {\n    require(pools[_token].pairToken != address(0), \"UniswapV3Oracle: token not supported\");\n    _validatePool(_token, pools[_token].pairToken, pools[_token].poolFee);\n\n    uint ethValue = uniPriceConverter.assetToAssetThruRoute(\n      _token,\n      10 ** IERC20(_token).decimals(),\n      WETH,\n      twapPeriod,\n      pools[_token].pairToken,\n      [pools[_token].poolFee, WETH_POOL_FEE]\n    );\n\n    return ethValue * ethPrice() / 1e18;\n  }\n\n  function ethPrice() public view returns(uint) {\n    uint latestAnswer = wethOracle.latestAnswer();\n    require(latestAnswer > 1, \"LinkPriceOracle: invalid oracle value\");\n    return latestAnswer * 1e10;\n  }\n\n  // Not used in any LendingPair to save gas. But useful for external usage.\n  function convertTokenValues(address _fromToken, address _toToken, uint _amount) external view override returns(uint) {\n    uint priceFrom = tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n    return _amount * priceFrom / priceTo;\n  }\n\n  function isPoolValid(address _token, address _pairToken, uint24 _poolFee) public view returns(bool) {\n    address poolAddress = uniFactory.getPool(_token, _pairToken, _poolFee);\n    if (poolAddress == address(0)) { return false; }\n\n    (, , , , uint16 observationSlots, ,) = IUniswapV3Pool(poolAddress).slot0();\n    return observationSlots >= minObservations;\n  }\n\n  function tokenSupported(address _token) external view override returns(bool) {\n    return pools[_token].pairToken != address(0);\n  }\n\n  function _validatePool(address _token, address _pairToken, uint24 _poolFee) internal view {\n    require(isPoolValid(_token, _pairToken, _poolFee), \"UniswapV3Oracle: invalid pool\");\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapV3Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "latestAnswer()"
                ],
                "Type": " Use of deprecated Chainlink API",
                "Description": "\n\nThe contract uses Chainlink\u2019s deprecated API latestAnswer(). Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs.\n\nImpact: Deprecated API stops working. Prices cannot be obtained. Protocol stops and contracts have to be redeployed.\n\nSee similar Low-severity finding L11 from OpenZeppelin's Audit of Opyn Gamma Protocol: <https://blog.openzeppelin.com/opyn-gamma-protocol-audit/\n\nThis was a Medium-severity finding even in the previous version of WildCredit contest as well: <https://github.com/code-423n4/2021-07-wildcredit-findings/issues/75 where it was reported that \"latestAnswer method will return the last value, but you won\u2019t be able to check if the data is fresh. On the other hand, calling the method latestRoundData allows you to run some extra validations.\u201d\n\n\n<https://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/UniswapV3Oracle.sol#L101\n\nSee <https://docs.chain.link/docs/deprecated-aggregatorinterface-api-reference/#latestanswer.\n\n\nManual Analysis\n\n",
                "Repair": "\nUse V3 interface functions: <https://docs.chain.link/docs/price-feeds-api-reference/\n\ntalegift (Wild Credit) acknowledged:(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/55#issuecomment-932200536):\n  We'll remove dependence on Chainlink completely.\n\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\n\ncontract InterestRateModel is IInterestRateModel, Ownable {\n\n  // InterestRateModel can be re-deployed later\n  uint private constant BLOCK_TIME = 132e17; // 13.2 seconds\n  uint private constant LP_RATE = 50e18; // 50%\n\n  // Per block\n  uint public minRate;\n  uint public lowRate;\n  uint public highRate;\n  uint public targetUtilization; // 80e18 = 80%\n\n  event NewMinRate(uint value);\n  event NewLowRate(uint value);\n  event NewHighRate(uint value);\n  event NewTargetUtilization(uint value);\n\n  constructor(\n    uint _minRate,\n    uint _lowRate,\n    uint _highRate,\n    uint _targetUtilization\n  ) {\n    minRate           = _timeRateToBlockRate(_minRate);\n    lowRate           = _timeRateToBlockRate(_lowRate);\n    highRate          = _timeRateToBlockRate(_highRate);\n    targetUtilization = _targetUtilization;\n  }\n\n  function setMinRate(uint _value) external onlyOwner {\n    require(_value < lowRate, \"InterestRateModel: _value < lowRate\");\n    minRate = _timeRateToBlockRate(_value);\n    emit NewMinRate(_value);\n  }\n\n  function setLowRate(uint _value) external onlyOwner {\n    require(_value < highRate, \"InterestRateModel: _value < lowRate\");\n    lowRate = _timeRateToBlockRate(_value);\n    emit NewLowRate(_value);\n  }\n\n  function setHighRate(uint _value) external onlyOwner {\n    highRate = _timeRateToBlockRate(_value);\n    emit NewHighRate(_value);\n  }\n\n  function setTargetUtilization(uint _value) external onlyOwner {\n    require(_value < 99e18, \"InterestRateModel: _value < 100e18\");\n    targetUtilization = _value;\n    emit NewTargetUtilization(_value);\n  }\n\n  // InterestRateModel can later be replaced for more granular fees per _pair\n  function interestRatePerBlock(\n    address _pair,\n    address _token,\n    uint    _totalSupply,\n    uint    _totalDebt\n  ) external view override returns(uint) {\n    if (_totalSupply == 0 || _totalDebt == 0) { return minRate; }\n\n    uint utilization = (_totalDebt * 100e18 / _totalSupply) * 100e18 / targetUtilization;\n\n    if (utilization < 100e18) {\n      uint rate = lowRate * utilization / 100e18;\n      return Math.max(rate, minRate);\n    } else {\n      utilization = 100e18 * ( _totalDebt - (_totalSupply * targetUtilization / 100e18) ) / (_totalSupply * (100e18 - targetUtilization) / 100e18);\n      utilization = Math.min(utilization, 100e18);\n      return lowRate + (highRate - lowRate) * utilization / 100e18;\n    }\n  }\n\n  // InterestRateModel can later be replaced for more granular fees per _pair\n  function utilizationRate(\n    address _pair,\n    address _token,\n    uint    _totalDebt,\n    uint    _totalSupply\n  ) external view returns(uint) {\n    if (_totalSupply == 0 || _totalDebt == 0) { return 0; }\n    return Math.min(_totalDebt * 100e18 / _totalSupply, 100e18);\n  }\n\n  // InterestRateModel can later be replaced for more granular fees per _pair\n  function lpRate(address _pair, address _token) external view override returns(uint) {\n    return LP_RATE;\n  }\n\n  // _uint is set as 1e18 = 1% (annual) and converted to the block rate\n  function _timeRateToBlockRate(uint _uint) private view returns(uint) {\n    return _uint / 365 / 86400 * BLOCK_TIME / 1e18;\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport \"openzeppelin/openzeppelin-contracts@3.4.1-solc-0.7-2/contracts/token/ERC721/IERC721Metadata.sol\";\nimport \"openzeppelin/openzeppelin-contracts@3.4.1-solc-0.7-2/contracts/token/ERC721/IERC721Enumerable.sol\";\n\nimport \"./IPoolInitializer.sol\";\nimport \"../IERC721Permit.sol\";\nimport \"./IPeripheryPayments.sol\";\nimport \"./IPeripheryImmutableState.sol\";\nimport \"../../external/PoolAddress.sol\";\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is\n    IPeripheryPayments,\n    IPeripheryImmutableState,\n    IERC721Metadata,\n    IERC721Enumerable,\n    IERC721Permit,\n    IPoolInitializer\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(\n        uint256 indexed tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(\n        uint256 indexed tokenId,\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(\n        uint256 indexed tokenId,\n        address recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n\n// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity 0.8.6;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IERC721.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/ILendingController.sol';\nimport './interfaces/univ3/IUniswapV3Helper.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ReentrancyGuard.sol';\nimport './external/ERC721Receivable.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {\n\n  IERC721 internal constant uniManager = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  uint    public   constant LIQ_MIN_HEALTH = 1e18;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public override supplySharesOf;\n  mapping (address => mapping (address => uint)) public debtSharesOf;\n  mapping (address => uint) public pendingSystemFees;\n  mapping (address => uint) public lastBlockAccrued;\n  mapping (address => uint) public override totalSupplyShares;\n  mapping (address => uint) public totalSupplyAmount;\n  mapping (address => uint) public totalDebtShares;\n  mapping (address => uint) public totalDebtAmount;\n  mapping (address => uint) public uniPosition;\n  mapping (address => uint) private decimals;\n  mapping (address => address) public override lpToken;\n\n  IUniswapV3Helper   private uniV3Helper;\n  ILendingController public  lendingController;\n\n  address public feeRecipient;\n  address public override tokenA;\n  address public override tokenB;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n  event CollectSystemFee(address indexed token, uint amount);\n  event DepositUniPosition(address indexed account, uint positionID);\n  event WithdrawUniPosition(uint positionID);\n\n  receive() external payable {}\n\n  modifier onlyLpToken() {\n    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, \"LendingController: caller must be LP token\");\n    _;\n  }\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n    require(_tokenA != address(0) && _tokenB != address(0), \"LendingPair: cannot be ZERO address\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= 6 && decimals[tokenB] >= 6, \"LendingPair: min 6 decimals\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n\n  // Deposit limits do not apply to Uniswap positions\n  function depositUniPosition(address _account, uint _positionID) external {\n    _checkDepositsEnabled();\n    _validateUniPosition(_positionID);\n    require(uniPosition[_account] == 0, \"LendingPair: one position per account\");\n\n    uniManager.safeTransferFrom(msg.sender, address(this), _positionID);\n    uniPosition[_account] = _positionID;\n\n    emit DepositUniPosition(_account, _positionID);\n  }\n\n  function withdrawUniPosition() external {\n    uint positionID = uniPosition[msg.sender];\n    uniManager.safeTransferFrom(address(this), msg.sender, positionID);\n\n    uniPosition[msg.sender] = 0;\n    checkAccountHealth(msg.sender);\n\n    emit WithdrawUniPosition(positionID);\n  }\n\n  // claim & mint supply from uniswap fees\n  function uniClaimDeposit() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _mintSupplyAmount(tokenA, msg.sender, amountA);\n    _mintSupplyAmount(tokenB, msg.sender, amountB);\n  }\n\n  // claim & withdraw uniswap fees\n  function uniClaimWithdraw() external {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _safeTransfer(tokenA, msg.sender, amountA);\n    _safeTransfer(tokenB, msg.sender, amountB);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n  }\n\n  function withdraw(address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawShares(_token, _supplyToShares(_token, _amount));\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint shares = supplySharesOf[_token][msg.sender];\n    _withdrawShares(_token, shares);\n    _safeTransfer(_token, msg.sender, _sharesToSupply(_token, shares));\n  }\n\n  function withdrawAllETH() external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint shares = supplySharesOf[address(WETH)][msg.sender];\n    _withdrawShares(address(WETH), shares);\n    _wethWithdrawTo(msg.sender, _sharesToSupply(address(WETH), shares));\n  }\n\n  function borrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _borrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token, uint _maxAmount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint amount = _repayShares(_account, _token, debtSharesOf[_token][_account]);\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account, uint _maxAmount) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint amount = _repayShares(_account, address(WETH), debtSharesOf[address(WETH)][_account]);\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n\n    _depositWeth();\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _repayShares(_account, _token, _debtToShares(_token, _amount));\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue(address _token) public {\n    if (lastBlockAccrued[_token] < block.number) {\n      uint newDebt   = _accrueDebt(_token);\n      uint newSupply = newDebt * _lpRate(_token) / 100e18;\n      totalSupplyAmount[_token] += newSupply;\n      pendingSystemFees[_token] += (newDebt - newSupply);\n      lastBlockAccrued[_token]   = block.number;\n    }\n  }\n\n  function collectSystemFee(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    pendingSystemFees[_token] -= _amount;\n    _safeTransfer(_token, feeRecipient, _amount);\n    emit CollectSystemFee(_token, _amount);\n  }\n\n  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {\n    require(debtSharesOf[_token][_to] == 0, \"LendingPair: cannot deposit borrowed token\");\n    supplySharesOf[_token][_from] -= _amount;\n    supplySharesOf[_token][_to]   += _amount;\n    checkAccountHealth(_from);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external nonReentrant {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    accrue(supplyToken);\n    accrue(_repayToken);\n\n    uint health = accountHealth(_account);\n    require(health < LIQ_MIN_HEALTH, \"LendingPair: account health < LIQ_MIN_HEALTH\");\n\n    // Fully unwrap Uni position - withdraw & mint supply\n\n    _unwrapUniPosition(_account);\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));\n    (uint repayPrice, uint supplyPrice) = lendingController.tokenPrices(_repayToken, supplyToken);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount, repayPrice, supplyPrice);\n    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));\n    pendingSystemFees[supplyToken] += systemFee;\n    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));\n\n    // Uni position unwrapping can mint supply of already borrowed tokens\n\n    _repayDebtFromSupply(_account, tokenA);\n    _repayDebtFromSupply(_account, tokenB);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {\n      return LIQ_MIN_HEALTH;\n    }\n\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    uint colFactorA = lendingController.colFactor(tokenA);\n    uint colFactorB = lendingController.colFactor(tokenB);\n\n    uint creditA   = _supplyBalanceConverted(_account, tokenA, tokenA, priceA, priceA) * colFactorA / 100e18;\n    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, priceB, priceA) * colFactorB / 100e18;\n    uint creditUni = _supplyCreditUni(_account, tokenA, priceA, priceB, colFactorA, colFactorB);\n\n    uint totalAccountSupply = creditA + creditB + creditUni;\n\n    uint totalAccountBorrow =\n      _borrowBalanceConverted(_account, tokenA, tokenA, priceA, priceA) +\n      _borrowBalanceConverted(_account, tokenB, tokenA, priceB, priceA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\n  }\n\n  function debtOf(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _debtOf(_token, _account);\n  }\n\n  function supplyOf(address _token, address _account) external view override returns(uint) {\n    _validateToken(_token);\n    return _supplyOf(_token, _account);\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);\n    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);\n  }\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view override returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);\n    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token) * _lpRate(_token) / 100e18;\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token);\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= LIQ_MIN_HEALTH, \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt          = _debtOf(_token, _account);\n    uint repayAmount   = debt > _amount ? _amount : debt;\n    uint depositAmount = _amount - repayAmount;\n\n    if (repayAmount > 0) {\n      _repayShares(_account, _token, _debtToShares(_token, repayAmount));\n    }\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount   = _supplyOf(_token, msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n    uint borrowAmount   = _amount - withdrawAmount;\n\n    if (withdrawAmount > 0) {\n      _withdrawShares(_token, _supplyToShares(_token, withdrawAmount));\n    }\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  // Uses TWAP to estimate min outputs to reduce MEV\n  // Liquidation might be temporarily unavailable due to this\n  function _unwrapUniPosition(address _account) internal {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n      (uint amount0, uint amount1) = uniV3Helper.positionAmounts(uniPosition[_account], priceA, priceB);\n      uint uniMinOutput = lendingController.uniMinOutputPct();\n\n      uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(\n        uniPosition[_account],\n        amount0 * uniMinOutput / 100e18,\n        amount1 * uniMinOutput / 100e18\n      );\n      uniPosition[_account] = 0;\n\n      _mintSupplyAmount(tokenA, _account, amountA);\n      _mintSupplyAmount(tokenB, _account, amountB);\n    }\n  }\n\n  // Ensure we never have borrow + supply balances of the same token on the same account\n  function _repayDebtFromSupply(address _account, address _token) internal {\n\n    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));\n\n    if (burnAmount > 0) {\n      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));\n      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));\n    }\n  }\n\n  function _uniCollectFees(address _account) internal returns(uint, uint) {\n    uniManager.approve(address(uniV3Helper), uniPosition[_account]);\n    return uniV3Helper.collectFees(uniPosition[_account]);\n  }\n\n  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _supplyToShares(_token, _amount);\n      supplySharesOf[_token][_account] += shares;\n      totalSupplyShares[_token] += shares;\n      totalSupplyAmount[_token] += _amount;\n    }\n  }\n\n  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToSupply(_token, _shares);\n      supplySharesOf[_token][_account] -= _shares;\n      totalSupplyShares[_token] -= _shares;\n      totalSupplyAmount[_token] -= amount;\n    }\n  }\n\n  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _debtToShares(_token, _amount);\n      debtSharesOf[_token][_account] += shares;\n      totalDebtShares[_token] += shares;\n      totalDebtAmount[_token] += _amount;\n    }\n  }\n\n  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      amount = _sharesToDebt(_token, _shares);\n      debtSharesOf[_token][_account] -= _shares;\n      totalDebtShares[_token] -= _shares;\n      totalDebtAmount[_token] -= amount;\n    }\n  }\n\n  function _accrueDebt(address _token) internal returns(uint newDebt) {\n    if (totalDebtAmount[_token] > 0) {\n      uint blocksElapsed = block.number - lastBlockAccrued[_token];\n      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;\n      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;\n      totalDebtAmount[_token] += newDebt;\n    }\n  }\n\n  function _withdrawShares(address _token, uint _shares) internal {\n    uint amount = _burnSupplyShares(_token, msg.sender, _shares);\n    checkAccountHealth(msg.sender);\n    emit Withdraw(_token, amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(supplySharesOf[_token][msg.sender] == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebtAmount(_token, msg.sender, _amount);\n\n    _checkBorrowEnabled();\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {\n    amount = _burnDebtShares(_token, _account, _shares);\n    emit Repay(_account, _token, amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    require(debtSharesOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupplyAmount(_token, _account, _amount);\n    _checkDepositsEnabled();\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize(_underlying, address(lendingController));\n    return address(newLPToken);\n  }\n\n  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputSupply * _totalShares / _totalAmount;\n    } else {\n      return _inputSupply;\n    }\n  }\n\n  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputShares * _totalAmount / _totalShares;\n    } else {\n      return _inputShares;\n    }\n  }\n\n  function _debtToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);\n  }\n\n  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);\n  }\n\n  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);\n  }\n\n  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);\n  }\n\n  function _debtOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToDebt(_token, debtSharesOf[_token][_account]);\n  }\n\n  function _supplyOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToSupply(_token, supplySharesOf[_token][_account]);\n  }\n\n  function _interestRatePerBlock(address _token) internal view returns(uint) {\n    return _interestRateModel().interestRatePerBlock(\n      address(this),\n      _token,\n      totalSupplyAmount[_token],\n      totalDebtAmount[_token]\n    );\n  }\n\n  function _interestRateModel() internal view returns(IInterestRateModel) {\n    return IInterestRateModel(lendingController.interestRateModel());\n  }\n\n  // Get borrow balance converted to the units of _returnToken\n  function _borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken,\n    uint    _borrowPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _borrowedToken,\n      _returnToken,\n      _debtOf(_borrowedToken, _account),\n      _borrowPrice,\n      _returnPrice\n    );\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken,\n    uint    _supplyPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _suppliedToken,\n      _returnToken,\n      _supplyOf(_suppliedToken, _account),\n      _supplyPrice,\n      _returnPrice\n    );\n  }\n\n  function _supplyCreditUni(\n    address _account,\n    address _returnToken,\n    uint    _priceA,\n    uint    _priceB,\n    uint    _colFactorA,\n    uint    _colFactorB\n  ) internal view returns(uint) {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amountA, uint amountB) = uniV3Helper.positionAmounts(uniPosition[_account], _priceA, _priceB);\n\n      uint supplyA = _convertTokenValues(tokenA, _returnToken, amountA, _priceA, _priceB);\n      uint supplyB = _convertTokenValues(tokenB, _returnToken, amountB, _priceB, _priceB);\n\n      uint creditA = supplyA * _colFactorA / 100e18;\n      uint creditB = supplyB * _colFactorB / 100e18;\n\n      return (creditA + creditB);\n\n    } else {\n      return 0;\n    }\n  }\n\n  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount,\n    uint    _fromPrice,\n    uint    _toPrice\n  ) internal view returns(uint) {\n\n    uint priceFrom = _fromPrice * 1e18 / 10 ** decimals[_fromToken];\n    uint priceTo   = _toPrice   * 1e18 / 10 ** decimals[_toToken];\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _validateUniPosition(uint _positionID) internal view {\n    (address uniTokenA, address uniTokenB) = uniV3Helper.positionTokens(_positionID);\n    _validateToken(uniTokenA);\n    _validateToken(uniTokenB);\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    uint depositLimit = lendingController.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require(totalSupplyAmount[_token] <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkDepositsEnabled() internal view {\n    require(lendingController.depositsEnabled(), \"LendingPair: deposits disabled\");\n  }\n\n  function _checkBorrowEnabled() internal view {\n    require(lendingController.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    uint borrowLimit = lendingController.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebtAmount[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return _interestRateModel().lpRate(address(this), _token);\n  }\n}\n\n\n",
        "CodeNames": [
            "InterestRateModel.sol",
            "INonFungiblePositionManager.sol",
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "accrue(token",
                    "accrue",
                    "_sharesToSupply",
                    "tokensOwed",
                    "withdraw",
                    "lpRate",
                    "uniClaimDeposit",
                    "totalSupplyAmount",
                    "UniswapV",
                    "depositUniPosition"
                ],
                "Type": " Supply part of the accrued debt can be stolen",
                "Description": "\nThe LendingPair.uniClaimDeposit function allows the user to \"collect fees\" and mint new supply shares with the collected amounts.\n\n\nHowever, the current total supply is not accrued in the function.\nThis means an attacker can:\n\n*   mint shares using uniClaimDeposit\n*   increase the totalSupplyAmount by calling accrue(token0) and accrue(token1) afterwards.\n*   call withdraw and receive *a larger amount of tokens* for the newly minted shares due to the increase in totalSupplyAmount from accrue (increasing the supply share price _sharesToSupply).\n\nThis would only lead to a small protocol loss if uniClaimDeposit would only collect the *fees*, however, combined with another flaw, one can steal almost the entire protocol lpRate each time:\n\n\nThis has to do with the way liquidity from a Uniswap V3 position (NFT) is withdrawn:\n\n*   When calling positionManager.decreaseLiquidity, the position.liquidity is removed but stored in the position as tokensOwed0/tokensOwed1(https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L281-L282). It is not transferred to the user.\n*   One needs to call positionManager.collect(params) to actually transfer out these tokens(https://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L362), setting tokensOwed0/1 to 0. (This is correctly done in UniswapV3Helper.removeLiquidity.)\n\nAn attacker can perform the following attack:\n\n*   Create a Uniswap V3 position.\n*   Get flashloans for both tokens to provide lots of liquidity for this position.\n*   Call positionManager.decreaseLiquidity such that the entire liquidity is removed and stored (but not collected yet) in the position's tokensOwed0/1 fields\n*   Deposit it to WildCredit's lending pair using depositUniPosition\n*   Call uniClaimDeposit to mint a huge amount of NFT supply shares. This huge amount will capture the protocol's debt accrual in the next steps.\n*   Call accrue on both tokens to accrue debt and pay the lpRate part of it to suppliers, increasing totalSupplyAmount and thus the value of a supply share.\n*   With the new debt added to the totalSupplyAmount, the attacker can now withdraw their minted shares again and capture most of the new debt that was accrued, making a profit.\n\n\nCombining these two issues, an attacker could steal most of the accrued lpRate in a single atomic transaction.\nThe attacker can repeat this step capturing the supplier interest for each accrual. (The longer the market hasn't been accrued, the bigger the profit per single attack transaction, but in the end, the attacker could perform this attack at every block or when it becomes profitable for the gas costs.)\n\nProviding / removing Uniswap V3 liquidity does not incur fees.\n\nThe attacker's profit is the loss of other legitimate suppliers that capture less of the newly accrued debt.\n\n",
                "Repair": "\nAccrue the debt for both tokens first in LendingPair.uniClaimDeposit.\n\nIt might also be a good idea to disallow collecting the \"parked\" liquidity in a token (that has been removed but not yet collected) by immediately collecting them when the NFT is deposited in depositUniPosition. I.e., call _uniCollectFees in depositUniPosition to withdraw any outstanding tokens and fees.\nThen mint shares with these token amounts.\n\ntalegift (Wild Credit) confirmed(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/50#issuecomment-932864980):\n  We'll implement the suggested fix.\n \n Suggest lowering severity to 2 as it doesn't allow direct theft of funds and the loss would only occur under specific external conditions long periods of not accrue interest combined with a low gas price to steal the pending interest.\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-09-wildcredit-findings/issues/50#issuecomment-940678187):\n  It seems that the attacker can steal interest that is owed to other users but deposits are safe. For that reason I agree with sponsor to make this medium risk.\n\n\n\n \n\n"
            }
        ]
    }
]